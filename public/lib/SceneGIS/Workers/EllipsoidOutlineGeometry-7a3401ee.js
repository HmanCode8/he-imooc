/**
 * @license
 * SceneGIS - https://github.com/CesiumGS/cesium
 * Version 1.97
 *
 * Copyright 2011-2022 SceneGIS Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["exports","./Transforms-38ce56dd","./Matrix3-fe947601","./ComponentDatatype-f194b981","./defaultValue-192c850d","./GeometryAttribute-440d2d6c","./GeometryAttributes-fcaeebba","./GeometryOffsetAttribute-817c59a7","./IndexDatatype-1ff811be","./Math-be2c8494"],(function(t,e,i,a,n,o,r,s,u,m){"use strict";const l=new i.Cartesian3(1,1,1),f=Math.cos,c=Math.sin;function d(t){t=n.defaultValue(t,n.defaultValue.EMPTY_OBJECT);const e=n.defaultValue(t.radii,l),a=n.defaultValue(t.innerRadii,e),o=n.defaultValue(t.minimumClock,0),r=n.defaultValue(t.maximumClock,m.CesiumMath.TWO_PI),s=n.defaultValue(t.minimumCone,0),u=n.defaultValue(t.maximumCone,m.CesiumMath.PI),f=Math.round(n.defaultValue(t.stackPartitions,10)),c=Math.round(n.defaultValue(t.slicePartitions,8)),d=Math.round(n.defaultValue(t.subdivisions,128)),C=n.defaultValue(t.planeView,!1);this._radii=i.Cartesian3.clone(e),this._innerRadii=i.Cartesian3.clone(a),this._minimumClock=o,this._maximumClock=r,this._minimumCone=s,this._maximumCone=u,this._stackPartitions=f,this._slicePartitions=c,this._subdivisions=d,this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidOutlineGeometry",this._planeView=C}d.packedLength=2*i.Cartesian3.packedLength+8,d.pack=function(t,e,a){return a=n.defaultValue(a,0),i.Cartesian3.pack(t._radii,e,a),a+=i.Cartesian3.packedLength,i.Cartesian3.pack(t._innerRadii,e,a),a+=i.Cartesian3.packedLength,e[a++]=t._minimumClock,e[a++]=t._maximumClock,e[a++]=t._minimumCone,e[a++]=t._maximumCone,e[a++]=t._stackPartitions,e[a++]=t._slicePartitions,e[a++]=t._subdivisions,e[a]=n.defaultValue(t._offsetAttribute,-1),e};const C=new i.Cartesian3,_=new i.Cartesian3,p={radii:C,innerRadii:_,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,subdivisions:void 0,offsetAttribute:void 0};d.unpack=function(t,e,a,o){e=n.defaultValue(e,0);const r=i.Cartesian3.unpack(t,e,C);e+=i.Cartesian3.packedLength;const s=i.Cartesian3.unpack(t,e,_);e+=i.Cartesian3.packedLength;const u=t[e++],m=t[e++],l=t[e++],f=t[e++],c=t[e++],h=t[e++],y=t[e++],b=t[e];return n.defined(a)?(a._radii=i.Cartesian3.clone(r,a._radii),a._innerRadii=i.Cartesian3.clone(s,a._innerRadii),a._minimumClock=u,a._maximumClock=m,a._minimumCone=l,a._maximumCone=f,a._stackPartitions=c,a._slicePartitions=h,a._subdivisions=y,a._offsetAttribute=-1===b?void 0:b,a._planeView=n.defaultValue(o,!1),a):(p.minimumClock=u,p.maximumClock=m,p.minimumCone=l,p.maximumCone=f,p.stackPartitions=c,p.slicePartitions=h,p.subdivisions=y,p.offsetAttribute=-1===b?void 0:b,p.planeView=n.defaultValue(o,!1),new d(p))},d.createGeometry=function(t){const l=t._radii;if(l.x<=0||l.y<=0||l.z<=0)return;const d=t._innerRadii;if(d.x<=0||d.y<=0||d.z<=0)return;const C=t._minimumClock,_=t._maximumClock,p=t._minimumCone,h=t._maximumCone,y=t._subdivisions,b=i.Ellipsoid.fromCartesian3(l);let k=t._slicePartitions+1,x=t._stackPartitions+1;k=Math.round(k*Math.abs(_-C)/m.CesiumMath.TWO_PI),x=Math.round(x*Math.abs(h-p)/m.CesiumMath.PI),k<2&&(k=2),x<2&&(x=2);let A=0,P=1;const V=d.x!==l.x||d.y!==l.y||d.z!==l.z;let v=!1,w=!1;V&&(P=2,p>0&&(v=!0,A+=k),h<Math.PI&&(w=!0,A+=k));const M=y*P*(x+k),g=new Float64Array(3*M),G=2*(M+A-(k+x)*P),E=u.IndexDatatype.createTypedArray(M,G);let O,D,I,T,z=0;const L=new Array(x),R=new Array(x);for(O=0;O<x;O++)T=p+O*(h-p)/(x-1),L[O]=c(T),R[O]=f(T);const N=new Array(y),B=new Array(y);for(O=0;O<y;O++)I=C+O*(_-C)/(y-1),N[O]=c(I),B[O]=f(I);for(O=0;O<x;O++)for(D=0;D<y;D++)g[z++]=l.x*L[O]*B[D],g[z++]=l.y*L[O]*N[D],g[z++]=l.z*R[O];if(V)for(O=0;O<x;O++)for(D=0;D<y;D++)g[z++]=d.x*L[O]*B[D],g[z++]=d.y*L[O]*N[D],g[z++]=d.z*R[O];for(L.length=y,R.length=y,O=0;O<y;O++)T=p+O*(h-p)/(y-1),L[O]=c(T),R[O]=f(T);for(N.length=k,B.length=k,O=0;O<k;O++)I=C+O*(_-C)/(k-1),N[O]=c(I),B[O]=f(I);for(O=0;O<y;O++)for(D=0;D<k;D++)g[z++]=l.x*L[O]*B[D],g[z++]=l.y*L[O]*N[D],g[z++]=l.z*R[O];if(V)for(O=0;O<y;O++)for(D=0;D<k;D++)g[z++]=d.x*L[O]*B[D],g[z++]=d.y*L[O]*N[D],g[z++]=d.z*R[O];for(z=0,O=0;O<x*P;O++){const t=O*y;for(D=0;D<y-1;D++)E[z++]=t+D,E[z++]=t+D+1}let S=x*y*P;for(O=0;O<k;O++)for(D=0;D<y-1;D++)E[z++]=S+O+D*k,E[z++]=S+O+(D+1)*k;if(V)for(S=x*y*P+k*y,O=0;O<k;O++)for(D=0;D<y-1;D++)E[z++]=S+O+D*k,E[z++]=S+O+(D+1)*k;if(V){let t=x*y*P,e=t+y*k;if(v)for(O=0;O<k;O++)E[z++]=t+O,E[z++]=e+O;if(w)for(t+=y*k-k,e+=y*k-k,O=0;O<k;O++)E[z++]=t+O,E[z++]=e+O}const U=new r.GeometryAttributes({position:new o.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:g})});if(n.defined(t._offsetAttribute)){const e=g.length,i=t._offsetAttribute===s.GeometryOffsetAttribute.NONE?0:1,n=new Uint8Array(e/3).fill(i);U.applyOffset=new o.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return new o.Geometry({attributes:U,indices:E,primitiveType:o.PrimitiveType.LINES,boundingSphere:e.BoundingSphere.fromEllipsoid(b),offsetAttribute:t._offsetAttribute})},t.EllipsoidOutlineGeometry=d}));
