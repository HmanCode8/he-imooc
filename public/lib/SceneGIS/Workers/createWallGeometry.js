/**
 * @license
 * SceneGIS - https://github.com/CesiumGS/cesium
 * Version 1.97
 *
 * Copyright 2011-2022 SceneGIS Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./defaultValue-192c850d","./Matrix3-a45402cf","./Transforms-c38817cd","./ComponentDatatype-f194b981","./GeometryAttribute-add8522c","./GeometryAttributes-fcaeebba","./IndexDatatype-1ff811be","./Math-be2c8494","./VertexFormat-d2271f13","./WallGeometryLibrary-0d5729d2","./Matrix2-bce7772b","./RuntimeError-ca280330","./_commonjsHelpers-f78443cf","./combine-b9b48e3c","./WebGLConstants-1bcc99d3","./arrayRemoveDuplicates-0aca867d","./PolylinePipeline-1de62483","./EllipsoidGeodesic-35356ee4","./EllipsoidRhumbLine-c951aea3","./IntersectionTests-f861e6a9","./Plane-f4b01105"],(function(e,t,n,i,a,o,r,s,l,m,c,u,p,d,f,y,g,h,C,b,x){"use strict";const _=new t.Cartesian3,A=new t.Cartesian3,w=new t.Cartesian3,E=new t.Cartesian3,v=new t.Cartesian3,F=new t.Cartesian3,V=new t.Cartesian3;function L(n){const i=(n=e.defaultValue(n,e.defaultValue.EMPTY_OBJECT)).positions,a=n.maximumHeights,o=n.minimumHeights,r=e.defaultValue(n.planeView,!1),m=e.defaultValue(n.vertexFormat,l.VertexFormat.DEFAULT),c=e.defaultValue(n.granularity,s.CesiumMath.RADIANS_PER_DEGREE),u=e.defaultValue(n.ellipsoid,t.Ellipsoid.WGS84);this._positions=i,this._minimumHeights=o,this._maximumHeights=a,this._vertexFormat=l.VertexFormat.clone(m),this._granularity=c,this._ellipsoid=t.Ellipsoid.clone(u),this._workerName="createWallGeometry",this._planeView=r;let p=1+i.length*t.Cartesian3.packedLength+2;e.defined(o)&&(p+=o.length),e.defined(a)&&(p+=a.length),this.packedLength=p+t.Ellipsoid.packedLength+l.VertexFormat.packedLength+1}L.pack=function(n,i,a){let o;a=e.defaultValue(a,0);const r=n._positions;let s=r.length;for(i[a++]=s,o=0;o<s;++o,a+=t.Cartesian3.packedLength)t.Cartesian3.pack(r[o],i,a);const m=n._minimumHeights;if(s=e.defined(m)?m.length:0,i[a++]=s,e.defined(m))for(o=0;o<s;++o)i[a++]=m[o];const c=n._maximumHeights;if(s=e.defined(c)?c.length:0,i[a++]=s,e.defined(c))for(o=0;o<s;++o)i[a++]=c[o];return t.Ellipsoid.pack(n._ellipsoid,i,a),a+=t.Ellipsoid.packedLength,l.VertexFormat.pack(n._vertexFormat,i,a),i[a+=l.VertexFormat.packedLength]=n._granularity,i};const H=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),k=new l.VertexFormat,G={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:H,vertexFormat:k,granularity:void 0};return L.unpack=function(n,i,a,o){let r;i=e.defaultValue(i,0);let s=n[i++];const m=new Array(s);for(r=0;r<s;++r,i+=t.Cartesian3.packedLength)m[r]=t.Cartesian3.unpack(n,i);let c,u;if(s=n[i++],s>0)for(c=new Array(s),r=0;r<s;++r)c[r]=n[i++];if(s=n[i++],s>0)for(u=new Array(s),r=0;r<s;++r)u[r]=n[i++];const p=t.Ellipsoid.unpack(n,i,H,o);i+=t.Ellipsoid.packedLength;const d=l.VertexFormat.unpack(n,i,k),f=n[i+=l.VertexFormat.packedLength];return e.defined(a)?(a._positions=m,a._minimumHeights=c,a._maximumHeights=u,a._ellipsoid=t.Ellipsoid.clone(p,a._ellipsoid),a._vertexFormat=l.VertexFormat.clone(d,a._vertexFormat),a._granularity=f,a._planeView=e.defaultValue(o,!1),a):(G.positions=m,G.minimumHeights=c,G.maximumHeights=u,G.granularity=f,G.planeView=o,new L(G))},L.fromConstantHeights=function(t){const n=(t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT)).positions;let i,a;const o=t.minimumHeight,r=t.maximumHeight,s=e.defined(o),l=e.defined(r);if(s||l){const e=n.length;i=s?new Array(e):void 0,a=l?new Array(e):void 0;for(let t=0;t<e;++t)s&&(i[t]=o),l&&(a[t]=r)}return new L({positions:n,maximumHeights:a,minimumHeights:i,ellipsoid:t.ellipsoid,vertexFormat:t.vertexFormat})},L.createGeometry=function(l){const c=l._positions,u=l._minimumHeights,p=l._maximumHeights,d=l._vertexFormat;let f=l._granularity;const y=l._ellipsoid,g=l._planeView;!0===g&&(f=111e3);const h=m.WallGeometryLibrary.computePositions(y,c,p,u,f,!0,g);if(!e.defined(h))return;const C=h.bottomPositions,b=h.topPositions,x=h.numCorners;let L=b.length,H=2*L;const k=d.position?new Float64Array(H):void 0,G=d.normal?new Float32Array(H):void 0,D=d.tangent?new Float32Array(H):void 0,P=d.bitangent?new Float32Array(H):void 0,T=d.st?new Float32Array(H/3*2):void 0;let z,O=0,R=0,S=0,I=0,M=0,N=V,W=F,B=v,U=!0;L/=3;let q=0;const J=1/(L-x-1);for(z=0;z<L;++z){const e=3*z,n=t.Cartesian3.fromArray(b,e,_),i=t.Cartesian3.fromArray(C,e,A);if(d.position&&(k[O++]=i.x,k[O++]=i.y,k[O++]=i.z,k[O++]=n.x,k[O++]=n.y,k[O++]=n.z),d.st&&(T[M++]=q,T[M++]=0,T[M++]=q,T[M++]=1),d.normal||d.tangent||d.bitangent){let i=t.Cartesian3.clone(t.Cartesian3.ZERO,E);const a=t.Cartesian3.subtract(n,y.geodeticSurfaceNormal(n,A),A);if(z+1<L&&(i=t.Cartesian3.fromArray(b,e+3,E)),U){const e=t.Cartesian3.subtract(i,n,w),o=t.Cartesian3.subtract(a,n,_);N=t.Cartesian3.normalize(t.Cartesian3.cross(o,e,N),N),U=!1}t.Cartesian3.equalsEpsilon(n,i,s.CesiumMath.EPSILON10)?U=!0:(q+=J,d.tangent&&(W=t.Cartesian3.normalize(t.Cartesian3.subtract(i,n,W),W)),d.bitangent&&(B=t.Cartesian3.normalize(t.Cartesian3.cross(N,W,B),B))),d.normal&&(G[R++]=N.x,G[R++]=N.y,G[R++]=N.z,G[R++]=N.x,G[R++]=N.y,G[R++]=N.z),d.tangent&&(D[I++]=W.x,D[I++]=W.y,D[I++]=W.z,D[I++]=W.x,D[I++]=W.y,D[I++]=W.z),d.bitangent&&(P[S++]=B.x,P[S++]=B.y,P[S++]=B.z,P[S++]=B.x,P[S++]=B.y,P[S++]=B.z)}}const Y=new o.GeometryAttributes;d.position&&(Y.position=new a.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:k})),d.normal&&(Y.normal=new a.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:G})),d.tangent&&(Y.tangent=new a.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:D})),d.bitangent&&(Y.bitangent=new a.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:P})),d.st&&(Y.st=new a.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:T}));const j=H/3;H-=6*(x+1);const Z=r.IndexDatatype.createTypedArray(j,H);let K=0;for(z=0;z<j-2;z+=2){const e=z,n=z+2,i=t.Cartesian3.fromArray(k,3*e,_),a=t.Cartesian3.fromArray(k,3*n,A);if(t.Cartesian3.equalsEpsilon(i,a,s.CesiumMath.EPSILON10))continue;const o=z+1,r=z+3;Z[K++]=o,Z[K++]=e,Z[K++]=r,Z[K++]=r,Z[K++]=e,Z[K++]=n}return new a.Geometry({attributes:Y,indices:Z,primitiveType:a.PrimitiveType.TRIANGLES,boundingSphere:new n.BoundingSphere.fromVertices(k)})},function(n,i,a){return e.defined(i)&&(n=L.unpack(n,i,void 0,a)),n._ellipsoid=t.Ellipsoid.clone(n._ellipsoid),L.createGeometry(n)}}));
