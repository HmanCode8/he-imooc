/**
 * @license
 * SceneGIS - https://github.com/CesiumGS/cesium
 * Version 1.97
 *
 * Copyright 2011-2022 SceneGIS Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["exports","./Matrix3-a45402cf","./Transforms-c38817cd","./defaultValue-192c850d","./Math-be2c8494"],(function(t,e,n,a,s){"use strict";function u(t,e,n,s){this.west=a.defaultValue(t,0),this.south=a.defaultValue(e,0),this.east=a.defaultValue(n,0),this.north=a.defaultValue(s,0)}Object.defineProperties(u.prototype,{width:{get:function(){return u.computeWidth(this)}},height:{get:function(){return u.computeHeight(this)}}}),u.packedLength=4,u.pack=function(t,e,n){return n=a.defaultValue(n,0),e[n++]=t.west,e[n++]=t.south,e[n++]=t.east,e[n]=t.north,e},u.unpack=function(t,e,n){return e=a.defaultValue(e,0),a.defined(n)||(n=new u),n.west=t[e++],n.south=t[e++],n.east=t[e++],n.north=t[e],n},u.computeWidth=function(t){let e=t.east;const n=t.west;return e<n&&(e+=s.CesiumMath.TWO_PI),e-n},u.computeHeight=function(t){return t.north-t.south},u.fromDegrees=function(t,e,n,i,o){return t=s.CesiumMath.toRadians(a.defaultValue(t,0)),e=s.CesiumMath.toRadians(a.defaultValue(e,0)),n=s.CesiumMath.toRadians(a.defaultValue(n,0)),i=s.CesiumMath.toRadians(a.defaultValue(i,0)),a.defined(o)?(o.west=t,o.south=e,o.east=n,o.north=i,o):new u(t,e,n,i)},u.fromRadians=function(t,e,n,s,i){return a.defined(i)?(i.west=a.defaultValue(t,0),i.south=a.defaultValue(e,0),i.east=a.defaultValue(n,0),i.north=a.defaultValue(s,0),i):new u(t,e,n,s)},u.fromCartographicArray=function(t,e){let n=Number.MAX_VALUE,i=-Number.MAX_VALUE,o=Number.MAX_VALUE,h=-Number.MAX_VALUE,r=Number.MAX_VALUE,d=-Number.MAX_VALUE;for(let e=0,a=t.length;e<a;e++){const a=t[e];n=Math.min(n,a.longitude),i=Math.max(i,a.longitude),r=Math.min(r,a.latitude),d=Math.max(d,a.latitude);const u=a.longitude>=0?a.longitude:a.longitude+s.CesiumMath.TWO_PI;o=Math.min(o,u),h=Math.max(h,u)}return i-n>h-o&&(n=o,i=h,i>s.CesiumMath.PI&&(i-=s.CesiumMath.TWO_PI),n>s.CesiumMath.PI&&(n-=s.CesiumMath.TWO_PI)),a.defined(e)?(e.west=n,e.south=r,e.east=i,e.north=d,e):new u(n,r,i,d)},u.fromCartesianArray=function(t,n,i){n=a.defaultValue(n,e.Ellipsoid.WGS84);let o=Number.MAX_VALUE,h=-Number.MAX_VALUE,r=Number.MAX_VALUE,d=-Number.MAX_VALUE,l=Number.MAX_VALUE,c=-Number.MAX_VALUE;for(let e=0,a=t.length;e<a;e++){const a=n.cartesianToCartographic(t[e]);o=Math.min(o,a.longitude),h=Math.max(h,a.longitude),l=Math.min(l,a.latitude),c=Math.max(c,a.latitude);const u=a.longitude>=0?a.longitude:a.longitude+s.CesiumMath.TWO_PI;r=Math.min(r,u),d=Math.max(d,u)}return h-o>d-r&&(o=r,h=d,h>s.CesiumMath.PI&&(h-=s.CesiumMath.TWO_PI),o>s.CesiumMath.PI&&(o-=s.CesiumMath.TWO_PI)),a.defined(i)?(i.west=o,i.south=l,i.east=h,i.north=c,i):new u(o,l,h,c)},u.clone=function(t,e){if(a.defined(t))return a.defined(e)?(e.west=t.west,e.south=t.south,e.east=t.east,e.north=t.north,e):new u(t.west,t.south,t.east,t.north)},u.equalsEpsilon=function(t,e,n){return n=a.defaultValue(n,0),t===e||a.defined(t)&&a.defined(e)&&Math.abs(t.west-e.west)<=n&&Math.abs(t.south-e.south)<=n&&Math.abs(t.east-e.east)<=n&&Math.abs(t.north-e.north)<=n},u.prototype.clone=function(t){return u.clone(this,t)},u.prototype.equals=function(t){return u.equals(this,t)},u.equals=function(t,e){return t===e||a.defined(t)&&a.defined(e)&&t.west===e.west&&t.south===e.south&&t.east===e.east&&t.north===e.north},u.prototype.equalsEpsilon=function(t,e){return u.equalsEpsilon(this,t,e)},u.validate=function(t){},u.southwest=function(t,e){return a.defined(e)?(e.x=t.west,e.y=t.south,e.height=0,e):{x:t.west,y:t.south,height:0}},u.northwest=function(t,e){return a.defined(e)?(e.longitude=t.west,e.latitude=t.north,e.height=0,e):{x:t.west,y:t.north,height:0}},u.northeast=function(t,e){return a.defined(e)?(e.longitude=t.east,e.latitude=t.north,e.height=0,e):{x:t.east,y:t.north,height:0}},u.southeast=function(t,e){return a.defined(e)?(e.longitude=t.east,e.latitude=t.south,e.height=0,e):{x:t.east,y:t.south,height:0}},u.center=function(t,s){n.Check.typeOf.object("rectangle",t);let u=t.east;const i=.5*(t.west+u),o=.5*(t.south+t.north);return a.defined(s)?(s.x=i,s.y=o,s.z=0,s):new e.Cartesian3(i,o,0)},u.intersection=function(t,e,n){let i=t.east,o=t.west,h=e.east,r=e.west;i<o&&h>0?i+=s.CesiumMath.TWO_PI:h<r&&i>0&&(h+=s.CesiumMath.TWO_PI),i<o&&r<0?r+=s.CesiumMath.TWO_PI:h<r&&o<0&&(o+=s.CesiumMath.TWO_PI);const d=s.CesiumMath.negativePiToPi(Math.max(o,r)),l=s.CesiumMath.negativePiToPi(Math.min(i,h));if((t.west<t.east||e.west<e.east)&&l<=d)return;const c=Math.max(t.south,e.south),f=Math.min(t.north,e.north);return c>=f?void 0:a.defined(n)?(n.west=d,n.south=c,n.east=l,n.north=f,n):new u(d,c,l,f)},u.intersection1=function(t,e,n){t.east,t.west,e.east,e.west;const s=Math.max(t.west,e.west),i=Math.min(t.east,e.east);if((t.west<t.east||e.west<e.east)&&i<=s)return;const o=Math.max(t.south,e.south),h=Math.min(t.north,e.north);return o>=h?void 0:a.defined(n)?(n.west=s,n.south=o,n.east=i,n.north=h,n):new u(s,o,i,h)},u.simpleIntersection=function(t,e,n){const s=Math.max(t.west,e.west),i=Math.max(t.south,e.south),o=Math.min(t.east,e.east),h=Math.min(t.north,e.north);if(!(i>=h||s>=o))return a.defined(n)?(n.west=s,n.south=i,n.east=o,n.north=h,n):new u(s,i,o,h)},u.union=function(t,e,n){a.defined(n)||(n=new u);let i=t.east,o=t.west,h=e.east,r=e.west;i<o&&h>0?i+=s.CesiumMath.TWO_PI:h<r&&i>0&&(h+=s.CesiumMath.TWO_PI),i<o&&r<0?r+=s.CesiumMath.TWO_PI:h<r&&o<0&&(o+=s.CesiumMath.TWO_PI);const d=s.CesiumMath.negativePiToPi(Math.min(o,r)),l=s.CesiumMath.negativePiToPi(Math.max(i,h));return n.west=d,n.south=Math.min(t.south,e.south),n.east=l,n.north=Math.max(t.north,e.north),n},u.expand=function(t,e,n){return a.defined(n)||(n=new u),n.west=Math.min(t.west,e.longitude),n.south=Math.min(t.south,e.latitude),n.east=Math.max(t.east,e.longitude),n.north=Math.max(t.north,e.latitude),n},u.contains=function(t,e){let n=e.x;const a=e.y,s=t.west;let u=t.east;return n>s&&n<u&&a>=t.south&&a<=t.north};const i=new e.Cartographic;u.subsample=function(t,n,o,h){n=a.defaultValue(n,e.Ellipsoid.WGS84),o=a.defaultValue(o,0),a.defined(h)||(h=[]);let r=0;const d=t.north,l=t.south,c=t.east,f=t.west,m=i;m.height=o,m.longitude=f,m.latitude=d,h[r]=n.cartographicToCartesian(m,h[r]),r++,m.longitude=c,h[r]=n.cartographicToCartesian(m,h[r]),r++,m.latitude=l,h[r]=n.cartographicToCartesian(m,h[r]),r++,m.longitude=f,h[r]=n.cartographicToCartesian(m,h[r]),r++,m.latitude=d<0?d:l>0?l:0;for(let e=1;e<8;++e)m.longitude=-Math.PI+e*s.CesiumMath.PI_OVER_TWO,u.contains(t,m)&&(h[r]=n.cartographicToCartesian(m,h[r]),r++);return 0===m.latitude&&(m.longitude=f,h[r]=n.cartographicToCartesian(m,h[r]),r++,m.longitude=c,h[r]=n.cartographicToCartesian(m,h[r]),r++),h.length=r,h},u.subsection=function(t,e,n,i,o,h){if(a.defined(h)||(h=new u),t.west<=t.east){const n=t.east-t.west;h.west=t.west+e*n,h.east=t.west+i*n}else{const n=s.CesiumMath.TWO_PI+t.east-t.west;h.west=s.CesiumMath.negativePiToPi(t.west+e*n),h.east=s.CesiumMath.negativePiToPi(t.west+i*n)}const r=t.north-t.south;return h.south=t.south+n*r,h.north=t.south+o*r,1===e&&(h.west=t.east),1===i&&(h.east=t.east),1===n&&(h.south=t.north),1===o&&(h.north=t.north),h},u.MAX_VALUE=Object.freeze(new u(-Math.PI,-s.CesiumMath.PI_OVER_TWO,Math.PI,s.CesiumMath.PI_OVER_TWO)),t.CartesianRectangle=u}));
