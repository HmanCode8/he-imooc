/**
 * @license
 * SceneGIS - https://github.com/CesiumGS/cesium
 * Version 1.97
 *
 * Copyright 2011-2022 SceneGIS Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./Matrix3-a45402cf","./LercDecode-bb83c22f","./AxisAlignedBoundingBox-e6370b82","./Transforms-c38817cd","./Matrix2-bce7772b","./defaultValue-192c850d","./TerrainEncoding-432a4214","./Math-be2c8494","./OrientedBoundingBox-d8d8ede3","./CartesianRectangle-3289fb67","./RuntimeError-ca280330","./createTaskProcessorWorker","./_commonjsHelpers-f78443cf","./combine-b9b48e3c","./AttributeCompression-cb62dc59","./ComponentDatatype-f194b981","./WebGLConstants-1bcc99d3","./EllipsoidTangentPlane-b1a9b8da","./IntersectionTests-f861e6a9","./Plane-f4b01105"],(function(e,t,i,n,a,r,o,l,s,c,d,u,m,h,g,f,T,E,p,I){"use strict";const b={};b.DEFAULT_STRUCTURE=Object.freeze({heightScale:1,heightOffset:0,elementsPerHeight:1,stride:1,elementMultiplier:256,isBigEndian:!1});const R=new e.Cartesian3,x=new a.Matrix4,C=new e.Cartesian3,N=new e.Cartesian3;b.computeVertices=function(t){const c=Math.cos,d=Math.sin,u=Math.sqrt,m=Math.atan,h=Math.exp,g=l.CesiumMath.PI_OVER_TWO,f=l.CesiumMath.toRadians,T=t.heightmap,E=t.width,p=t.height,I=t.skirtHeight,w=I>0,U=r.defaultValue(t.isGeographic,!0),V=r.defaultValue(t.ellipsoid,e.Ellipsoid.WGS84),A=1/V.maximumRadius,S=a.Rectangle.clone(t.nativeRectangle),M=a.Rectangle.clone(t.rectangle);let B,_,F,y;r.defined(M)?(B=M.west,_=M.south,F=M.east,y=M.north):U?(B=f(S.west),_=f(S.south),F=f(S.east),y=f(S.north)):(B=S.west*A,_=g-2*m(h(-S.south*A)),F=S.east*A,y=g-2*m(h(-S.north*A)));let H=t.relativeToCenter;const O=r.defined(H);H=O?H:e.Cartesian3.ZERO;const P=r.defaultValue(t.exaggeration,1),D=r.defaultValue(t.exaggerationRelativeHeight,0),L=1!==P,v=r.defaultValue(t.structure,b.DEFAULT_STRUCTURE),Y=r.defaultValue(v.heightScale,b.DEFAULT_STRUCTURE.heightScale),z=r.defaultValue(v.heightOffset,b.DEFAULT_STRUCTURE.heightOffset),G=r.defaultValue(v.elementsPerHeight,b.DEFAULT_STRUCTURE.elementsPerHeight),W=r.defaultValue(v.stride,b.DEFAULT_STRUCTURE.stride),k=r.defaultValue(v.elementMultiplier,b.DEFAULT_STRUCTURE.elementMultiplier),j=r.defaultValue(v.isBigEndian,b.DEFAULT_STRUCTURE.isBigEndian);let q=a.Rectangle.computeWidth(S),X=a.Rectangle.computeHeight(S);const Z=q/(E-1),J=X/(p-1),K=r.defaultValue(t.isCartesian,!1);K||U||(q*=A,X*=A);const Q=V.radiiSquared,$=Q.x,ee=Q.y,te=Q.z;let ie=65536,ne=-65536;const ae=n.Transforms.eastNorthUpToFixedFrame(H,V),re=a.Matrix4.inverseTransformation(ae,x),oe=C;oe.x=Number.POSITIVE_INFINITY,oe.y=Number.POSITIVE_INFINITY,oe.z=Number.POSITIVE_INFINITY;const le=N;le.x=Number.NEGATIVE_INFINITY,le.y=Number.NEGATIVE_INFINITY,le.z=Number.NEGATIVE_INFINITY;let se=Number.POSITIVE_INFINITY;const ce=E*p,de=ce+(I>0?2*E+2*p:0),ue=new Array(de),me=new Array(de),he=new Array(de),ge=[],fe=L?new Array(de):[];let Te=0,Ee=p,pe=0,Ie=E;w&&(--Te,++Ee,--pe,++Ie);const be=1e-5;for(let t=Te;t<Ee;++t){let i=t;i<0&&(i=0),i>=p&&(i=p-1);let n=S.north-J*i;K||(n=U?f(n):g-2*m(h(-n*A)));let r=(n-_)/(y-_);r=l.CesiumMath.clamp(r,0,1);const o=t===Te,s=t===Ee-1;I>0&&(o?n+=be*X:s&&(n-=be*X));const b=c(n),x=d(n),C=te*x;for(let t=pe;t<Ie;++t){let m=t;m<0&&(m=0),m>=E&&(m=E-1);const h=i*(E*W)+m*W;let g;if(1===G)g=T[h];else{let e;if(g=0,j)for(e=0;e<G;++e)g=g*k+T[h+e];else for(e=G-1;e>=0;--e)g=g*k+T[h+e]}g=g*Y+z,ne=Math.max(ne,g),ie=Math.min(ie,g);let f=S.west+Z*m,N=(f-B)/(F-B);N=l.CesiumMath.clamp(N,0,1);let w=i*E+m;if(I>0){const e=t===pe,n=t===Ie-1,a=o||s||e||n;if((o||s)&&(e||n))continue;a&&(g-=I,e?(w=ce+(p-i-1),f-=be*q):s?w=ce+p+(E-m-1):n?(w=ce+p+E+i,f+=be*q):o&&(w=ce+p+E+p+m))}const U=b*c(f),A=b*d(f),M=$*U,_=ee*A,y=1/u(M*U+_*A+C*x),H=M*y,O=_*y,P=C*y,D=new e.Cartesian3;K?(se=Math.min(se,g),D.x=f,D.y=n,D.z=g):(D.x=H+U*g,D.y=O+A*g,D.z=P+x*g,a.Matrix4.multiplyByPoint(re,D,R),e.Cartesian3.minimumByComponent(R,oe,oe),e.Cartesian3.maximumByComponent(R,le,le),se=Math.min(se,g)),ue[w]=D,he[w]=new a.Cartesian2(N,r),me[w]=g,L&&(fe[w]=V.geodeticSurfaceNormal(D))}}const Re=n.BoundingSphere.fromPoints(ue);let xe;r.defined(M)&&(xe=s.OrientedBoundingBox.fromPoints(ue),xe.center),O&&new o.EllipsoidalOccluder(V);const Ce=new i.AxisAlignedBoundingBox(oe,le,H),Ne=new o.TerrainEncoding(H,Ce,se,ne,ae,!1,!1,L,P,D,!0),we=new Float32Array(de*Ne.stride);let Ue=0;for(let e=0;e<de;++e)Ue=Ne.encode(we,Ue,ue[e],he[e],me[e],void 0,ge[e],fe[e]);return{vertices:we,maximumHeight:ne,minimumHeight:ie,encoding:Ne,boundingSphere3D:Re,orientedBoundingBox:xe,occludeePointInScaledSpace:undefined}};var w=b;return u((function(i,n){if(i.encoding===t.HeightmapEncoding.LERC){let e;try{e=t.LercDecode.decode(i.heightmap)}catch(e){throw new d.RuntimeError(e)}if(e.statistics[0].minValue===Number.MAX_VALUE)throw new d.RuntimeError("Invalid tile data");i.heightmap=e.pixels[0],i.width=e.width,i.height=e.height}i.ellipsoid=e.Ellipsoid.clone(i.ellipsoid),i.rectangle=c.CartesianRectangle.clone(i.rectangle);const a=w.computeVertices(i),r=a.vertices;return n.push(r.buffer),{vertices:r.buffer,numberOfAttributes:a.encoding.stride,minimumHeight:a.minimumHeight,maximumHeight:a.maximumHeight,gridWidth:i.width,gridHeight:i.height,boundingSphere3D:a.boundingSphere3D,orientedBoundingBox:a.orientedBoundingBox,encoding:a.encoding}}))}));
