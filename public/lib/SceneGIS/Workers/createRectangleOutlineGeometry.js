/**
 * @license
 * SceneGIS - https://github.com/CesiumGS/cesium
 * Version 1.97
 *
 * Copyright 2011-2022 SceneGIS Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./defaultValue-192c850d","./Matrix3-a45402cf","./Matrix2-bce7772b","./Transforms-c38817cd","./ComponentDatatype-f194b981","./GeometryAttribute-add8522c","./GeometryAttributes-fcaeebba","./GeometryOffsetAttribute-817c59a7","./IndexDatatype-1ff811be","./Math-be2c8494","./PolygonPipeline-2888ea37","./RectangleGeometryLibrary-4c469ae6","./RuntimeError-ca280330","./_commonjsHelpers-f78443cf","./combine-b9b48e3c","./WebGLConstants-1bcc99d3","./EllipsoidRhumbLine-c951aea3"],(function(e,t,i,n,o,a,r,l,s,u,c,p,d,f,g,h,y){"use strict";const m=new n.BoundingSphere,b=new n.BoundingSphere,_=new t.Cartesian3,E=new i.Rectangle;function A(e,t){const i=e._ellipsoid,n=t.height,l=t.width,u=t.northCap,c=t.southCap,d=e._planeView;let f=n,g=2,h=0,y=4;u&&(g-=1,f-=1,h+=1,y-=2),c&&(g-=1,f-=1,h+=1,y-=2),h+=g*l+2*f-y;const m=new Float64Array(3*h);let b,E=0,A=0;const G=_;if(u)p.RectangleGeometryLibrary.computePosition(t,i,!1,A,0,G,void 0,d),m[E++]=G.x,m[E++]=G.y,m[E++]=G.z;else for(b=0;b<l;b++)p.RectangleGeometryLibrary.computePosition(t,i,!1,A,b,G,void 0,d),m[E++]=G.x,m[E++]=G.y,m[E++]=G.z;for(b=l-1,A=1;A<n;A++)p.RectangleGeometryLibrary.computePosition(t,i,!1,A,b,G,void 0,d),m[E++]=G.x,m[E++]=G.y,m[E++]=G.z;if(A=n-1,!c)for(b=l-2;b>=0;b--)p.RectangleGeometryLibrary.computePosition(t,i,!1,A,b,G,void 0,d),m[E++]=G.x,m[E++]=G.y,m[E++]=G.z;for(b=0,A=n-2;A>0;A--)p.RectangleGeometryLibrary.computePosition(t,i,!1,A,b,G,void 0,d),m[E++]=G.x,m[E++]=G.y,m[E++]=G.z;const v=m.length/3*2,w=s.IndexDatatype.createTypedArray(m.length/3,v);let R=0;for(let e=0;e<m.length/3-1;e++)w[R++]=e,w[R++]=e+1;w[R++]=m.length/3-1,w[R++]=0;const P=new a.Geometry({attributes:new r.GeometryAttributes,primitiveType:a.PrimitiveType.LINES});return P.attributes.position=new a.GeometryAttribute({componentDatatype:o.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:m}),P.indices=w,P}function G(n){const o=(n=e.defaultValue(n,e.defaultValue.EMPTY_OBJECT)).rectangle,a=e.defaultValue(n.granularity,u.CesiumMath.RADIANS_PER_DEGREE),r=e.defaultValue(n.ellipsoid,t.Ellipsoid.WGS84),l=e.defaultValue(n.rotation,0),s=e.defaultValue(n.planeView,!1),c=e.defaultValue(n.height,0),p=e.defaultValue(n.extrudedHeight,c);this._rectangle=i.Rectangle.clone(o),this._granularity=a,this._ellipsoid=r,this._surfaceHeight=Math.max(c,p),this._rotation=l,this._extrudedHeight=Math.min(c,p),this._offsetAttribute=n.offsetAttribute,this._workerName="createRectangleOutlineGeometry",this._planeView=s}G.packedLength=i.Rectangle.packedLength+t.Ellipsoid.packedLength+5,G.pack=function(n,o,a){return a=e.defaultValue(a,0),i.Rectangle.pack(n._rectangle,o,a),a+=i.Rectangle.packedLength,t.Ellipsoid.pack(n._ellipsoid,o,a),a+=t.Ellipsoid.packedLength,o[a++]=n._granularity,o[a++]=n._surfaceHeight,o[a++]=n._rotation,o[a++]=n._extrudedHeight,o[a]=e.defaultValue(n._offsetAttribute,-1),o};const v=new i.Rectangle,w=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),R={rectangle:v,ellipsoid:w,granularity:void 0,height:void 0,rotation:void 0,extrudedHeight:void 0,offsetAttribute:void 0};G.unpack=function(n,o,a,r){o=e.defaultValue(o,0);const l=i.Rectangle.unpack(n,o,v,r);o+=i.Rectangle.packedLength;const s=t.Ellipsoid.unpack(n,o,w);o+=t.Ellipsoid.packedLength;const u=n[o++],c=n[o++],p=n[o++],d=n[o++],f=n[o];return e.defined(a)?(a._rectangle=i.Rectangle.clone(l,a._rectangle),a._ellipsoid=t.Ellipsoid.clone(s,a._ellipsoid),a._surfaceHeight=c,a._rotation=p,a._extrudedHeight=d,a._offsetAttribute=-1===f?void 0:f,a._planeView=e.defaultValue(r,!1),a):(R.granularity=u,R.height=c,R.rotation=p,R.extrudedHeight=d,R.offsetAttribute=-1===f?void 0:f,R.planeView=e.defaultValue(r,!1),new G(R))};const P=new t.Cartographic;return G.createGeometry=function(t){const i=t._rectangle,r=t._ellipsoid,d=p.RectangleGeometryLibrary.computeOptions(i,t._granularity,t._rotation,0,E,P);let f,g;if(u.CesiumMath.equalsEpsilon(i.north,i.south,u.CesiumMath.EPSILON10)||u.CesiumMath.equalsEpsilon(i.east,i.west,u.CesiumMath.EPSILON10))return;const h=t._surfaceHeight,y=t._extrudedHeight;let _;if(!u.CesiumMath.equalsEpsilon(h,y,0,u.CesiumMath.EPSILON2)){if(f=function(e,t){const i=e._surfaceHeight,n=e._extrudedHeight,o=e._ellipsoid,a=e._planeView,r=n,l=i,u=A(e,t),p=t.height,d=t.width,f=c.PolygonPipeline.scaleToGeodeticHeight(u.attributes.position.values,l,o,!1,a);let g=f.length;const h=new Float64Array(2*g);h.set(f);const y=c.PolygonPipeline.scaleToGeodeticHeight(u.attributes.position.values,r,o,void 0,a);h.set(y,g),u.attributes.position.values=h;const m=t.northCap,b=t.southCap;let _=4;m&&(_-=1),b&&(_-=1);const E=2*(h.length/3+_),G=s.IndexDatatype.createTypedArray(h.length/3,E);g=h.length/6;let v,w=0;for(let e=0;e<g-1;e++)G[w++]=e,G[w++]=e+1,G[w++]=e+g,G[w++]=e+g+1;if(G[w++]=g-1,G[w++]=0,G[w++]=g+g-1,G[w++]=g,G[w++]=0,G[w++]=g,m)v=p-1;else{const e=d-1;G[w++]=e,G[w++]=e+g,v=d+p-2}if(G[w++]=v,G[w++]=v+g,!b){const e=d+v-1;G[w++]=e,G[w]=e+g}return u.indices=G,u}(t,d),e.defined(t._offsetAttribute)){const e=f.attributes.position.values.length/3;let i=new Uint8Array(e);t._offsetAttribute===l.GeometryOffsetAttribute.TOP?i=i.fill(1,0,e/2):(_=t._offsetAttribute===l.GeometryOffsetAttribute.NONE?0:1,i=i.fill(_)),f.attributes.applyOffset=new a.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}const u=n.BoundingSphere.fromRectangle3D(i,r,h,b),p=n.BoundingSphere.fromRectangle3D(i,r,y,m);g=n.BoundingSphere.union(u,p)}else{if(f=A(t,d),f.attributes.position.values=c.PolygonPipeline.scaleToGeodeticHeight(f.attributes.position.values,h,r,!1),e.defined(t._offsetAttribute)){const e=f.attributes.position.values.length;_=t._offsetAttribute===l.GeometryOffsetAttribute.NONE?0:1;const i=new Uint8Array(e/3).fill(_);f.attributes.applyOffset=new a.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}g=n.BoundingSphere.fromRectangle3D(i,r,h)}return new a.Geometry({attributes:f.attributes,indices:f.indices,primitiveType:a.PrimitiveType.LINES,boundingSphere:g,offsetAttribute:t._offsetAttribute})},function(n,o,a){return e.defined(o)&&(n=G.unpack(n,o,void 0,a)),n._ellipsoid=t.Ellipsoid.clone(n._ellipsoid),n._rectangle=i.Rectangle.clone(n._rectangle),G.createGeometry(n)}}));
