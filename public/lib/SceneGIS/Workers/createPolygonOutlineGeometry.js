/**
 * @license
 * SceneGIS - https://github.com/CesiumGS/cesium
 * Version 1.97
 *
 * Copyright 2011-2022 SceneGIS Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./defaultValue-192c850d","./Matrix3-a45402cf","./ArcType-d7935178","./Transforms-c38817cd","./ComponentDatatype-f194b981","./EllipsoidTangentPlane-b1a9b8da","./GeometryAttribute-add8522c","./GeometryAttributes-fcaeebba","./GeometryInstance-6a82712b","./GeometryOffsetAttribute-817c59a7","./GeometryPipeline-be1ab56a","./IndexDatatype-1ff811be","./Math-be2c8494","./PolygonGeometryLibrary-34f8044c","./PolygonPipeline-2888ea37","./Matrix2-bce7772b","./RuntimeError-ca280330","./_commonjsHelpers-f78443cf","./combine-b9b48e3c","./WebGLConstants-1bcc99d3","./AxisAlignedBoundingBox-e6370b82","./IntersectionTests-f861e6a9","./Plane-f4b01105","./AttributeCompression-cb62dc59","./EncodedCartesian3-43036f0c","./arrayRemoveDuplicates-0aca867d","./EllipsoidRhumbLine-c951aea3"],(function(e,t,i,o,r,n,a,l,s,y,u,p,c,d,f,g,m,h,b,P,_,E,A,G,L,H,T){"use strict";const v=[],C=[];function x(e,t,o,y,u){const c=n.EllipsoidTangentPlane.fromPoints(t,e).projectPointsOntoPlane(t,v);let g,m;f.PolygonPipeline.computeWindingOrder2D(c)===f.WindingOrder.CLOCKWISE&&(c.reverse(),t=t.slice().reverse());let h=t.length,b=0;if(y)for(g=new Float64Array(2*h*3),m=0;m<h;m++){const e=t[m],i=t[(m+1)%h];g[b++]=e.x,g[b++]=e.y,g[b++]=e.z,g[b++]=i.x,g[b++]=i.y,g[b++]=i.z}else{let r=0;if(u===i.ArcType.GEODESIC)for(m=0;m<h;m++)r+=d.PolygonGeometryLibrary.subdivideLineCount(t[m],t[(m+1)%h],o);else if(u===i.ArcType.RHUMB)for(m=0;m<h;m++)r+=d.PolygonGeometryLibrary.subdivideRhumbLineCount(e,t[m],t[(m+1)%h],o);for(g=new Float64Array(3*r),m=0;m<h;m++){let r;u===i.ArcType.GEODESIC?r=d.PolygonGeometryLibrary.subdivideLine(t[m],t[(m+1)%h],o,C):u===i.ArcType.RHUMB&&(r=d.PolygonGeometryLibrary.subdivideRhumbLine(e,t[m],t[(m+1)%h],o,C));const n=r.length;for(let e=0;e<n;++e)g[b++]=r[e]}}h=g.length/3;const P=2*h,_=p.IndexDatatype.createTypedArray(h,P);for(b=0,m=0;m<h-1;m++)_[b++]=m,_[b++]=m+1;return _[b++]=h-1,_[b++]=0,new s.GeometryInstance({geometry:new a.Geometry({attributes:new l.GeometryAttributes({position:new a.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:g})}),indices:_,primitiveType:a.PrimitiveType.LINES})})}function O(e,t,o,y,u){const c=n.EllipsoidTangentPlane.fromPoints(t,e).projectPointsOntoPlane(t,v);let g,m;f.PolygonPipeline.computeWindingOrder2D(c)===f.WindingOrder.CLOCKWISE&&(c.reverse(),t=t.slice().reverse());let h=t.length;const b=new Array(h);let P=0;if(y)for(g=new Float64Array(2*h*3*2),m=0;m<h;++m){b[m]=P/3;const e=t[m],i=t[(m+1)%h];g[P++]=e.x,g[P++]=e.y,g[P++]=e.z,g[P++]=i.x,g[P++]=i.y,g[P++]=i.z}else{let r=0;if(u===i.ArcType.GEODESIC)for(m=0;m<h;m++)r+=d.PolygonGeometryLibrary.subdivideLineCount(t[m],t[(m+1)%h],o);else if(u===i.ArcType.RHUMB)for(m=0;m<h;m++)r+=d.PolygonGeometryLibrary.subdivideRhumbLineCount(e,t[m],t[(m+1)%h],o);for(g=new Float64Array(3*r*2),m=0;m<h;++m){let r;b[m]=P/3,u===i.ArcType.GEODESIC?r=d.PolygonGeometryLibrary.subdivideLine(t[m],t[(m+1)%h],o,C):u===i.ArcType.RHUMB&&(r=d.PolygonGeometryLibrary.subdivideRhumbLine(e,t[m],t[(m+1)%h],o,C));const n=r.length;for(let e=0;e<n;++e)g[P++]=r[e]}}h=g.length/6;const _=b.length,E=2*(2*h+_),A=p.IndexDatatype.createTypedArray(h+_,E);for(P=0,m=0;m<h;++m)A[P++]=m,A[P++]=(m+1)%h,A[P++]=m+h,A[P++]=(m+1)%h+h;for(m=0;m<_;m++){const e=b[m];A[P++]=e,A[P++]=e+h}return new s.GeometryInstance({geometry:new a.Geometry({attributes:new l.GeometryAttributes({position:new a.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:g})}),indices:A,primitiveType:a.PrimitiveType.LINES})})}function w(o){const r=o.polygonHierarchy,n=e.defaultValue(o.ellipsoid,t.Ellipsoid.WGS84),a=e.defaultValue(o.granularity,c.CesiumMath.RADIANS_PER_DEGREE),l=e.defaultValue(o.perPositionHeight,!1),s=l&&e.defined(o.extrudedHeight),y=e.defaultValue(o.arcType,i.ArcType.GEODESIC),u=e.defaultValue(o.planeView,!1);let p=e.defaultValue(o.height,0),f=e.defaultValue(o.extrudedHeight,p);if(!s){const e=Math.max(p,f);f=Math.min(p,f),p=e}this._ellipsoid=t.Ellipsoid.clone(n),this._granularity=a,this._height=p,this._extrudedHeight=f,this._arcType=y,this._polygonHierarchy=r,this._perPositionHeight=l,this._perPositionHeightExtrude=s,this._offsetAttribute=o.offsetAttribute,this._workerName="createPolygonOutlineGeometry",this._planeView=u,this.packedLength=d.PolygonGeometryLibrary.computeHierarchyPackedLength(r,t.Cartesian3)+t.Ellipsoid.packedLength+8}w.pack=function(i,o,r){return r=e.defaultValue(r,0),r=d.PolygonGeometryLibrary.packPolygonHierarchy(i._polygonHierarchy,o,r,t.Cartesian3),t.Ellipsoid.pack(i._ellipsoid,o,r),r+=t.Ellipsoid.packedLength,o[r++]=i._height,o[r++]=i._extrudedHeight,o[r++]=i._granularity,o[r++]=i._perPositionHeightExtrude?1:0,o[r++]=i._perPositionHeight?1:0,o[r++]=i._arcType,o[r++]=e.defaultValue(i._offsetAttribute,-1),o[r]=i.packedLength,o};const D=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),I={polygonHierarchy:{}};return w.unpack=function(i,o,r,n){o=e.defaultValue(o,0);const a=d.PolygonGeometryLibrary.unpackPolygonHierarchy(i,o,t.Cartesian3);o=a.startingIndex,delete a.startingIndex;const l=t.Ellipsoid.unpack(i,o,D);o+=t.Ellipsoid.packedLength;const s=i[o++],y=i[o++],u=i[o++],p=1===i[o++],c=1===i[o++],f=i[o++],g=i[o++],m=i[o];return e.defined(r)||(I.planeView=n,r=new w(I)),r._polygonHierarchy=a,r._ellipsoid=t.Ellipsoid.clone(l,r._ellipsoid),r._height=s,r._extrudedHeight=y,r._granularity=u,r._perPositionHeight=c,r._perPositionHeightExtrude=p,r._arcType=f,r._offsetAttribute=-1===g?void 0:g,r.packedLength=m,r._planeView=n,r},w.fromPositions=function(t){return new w({polygonHierarchy:{positions:(t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT)).positions},height:t.height,extrudedHeight:t.extrudedHeight,ellipsoid:t.ellipsoid,granularity:t.granularity,perPositionHeight:t.perPositionHeight,arcType:t.arcType,offsetAttribute:t.offsetAttribute})},w.createGeometry=function(t){const i=t._ellipsoid,n=t._granularity,l=t._polygonHierarchy,s=t._perPositionHeight,p=t._arcType,g=t._planeView,m=d.PolygonGeometryLibrary.polygonOutlinesFromHierarchy(l,!s,i,g);if(0===m.length)return;let h;const b=[],P=c.CesiumMath.chordLength(n,i.maximumRadius),_=t._height,E=t._extrudedHeight;let A,G;if(t._perPositionHeightExtrude||!c.CesiumMath.equalsEpsilon(_,E,0,c.CesiumMath.EPSILON2))for(G=0;G<m.length;G++){if(h=O(i,m[G],P,s,p),h.geometry=d.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(h.geometry,_,E,i,s,g),e.defined(t._offsetAttribute)){const e=h.geometry.attributes.position.values.length/3;let i=new Uint8Array(e);t._offsetAttribute===y.GeometryOffsetAttribute.TOP?i=i.fill(1,0,e/2):(A=t._offsetAttribute===y.GeometryOffsetAttribute.NONE?0:1,i=i.fill(A)),h.geometry.attributes.applyOffset=new a.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}b.push(h)}else for(G=0;G<m.length;G++){if(h=x(i,m[G],P,s,p),h.geometry.attributes.position.values=f.PolygonPipeline.scaleToGeodeticHeight(h.geometry.attributes.position.values,_,i,!s),e.defined(t._offsetAttribute)){const e=h.geometry.attributes.position.values.length;A=t._offsetAttribute===y.GeometryOffsetAttribute.NONE?0:1;const i=new Uint8Array(e/3).fill(A);h.geometry.attributes.applyOffset=new a.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}b.push(h)}const L=u.GeometryPipeline.combineInstances(b)[0],H=o.BoundingSphere.fromVertices(L.attributes.position.values);return new a.Geometry({attributes:L.attributes,indices:L.indices,primitiveType:L.primitiveType,boundingSphere:H,offsetAttribute:t._offsetAttribute})},function(i,o,r){return e.defined(o)&&(i=w.unpack(i,o,void 0,r)),i._ellipsoid=t.Ellipsoid.clone(i._ellipsoid),w.createGeometry(i)}}));
