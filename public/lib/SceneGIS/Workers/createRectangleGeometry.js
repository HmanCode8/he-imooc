/**
 * @license
 * SceneGIS - https://github.com/CesiumGS/cesium
 * Version 1.97
 *
 * Copyright 2011-2022 SceneGIS Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./defaultValue-192c850d","./Matrix3-a45402cf","./Matrix2-bce7772b","./Transforms-c38817cd","./ComponentDatatype-f194b981","./GeometryAttribute-add8522c","./GeometryAttributes-fcaeebba","./GeometryInstance-6a82712b","./GeometryOffsetAttribute-817c59a7","./GeometryPipeline-be1ab56a","./IndexDatatype-1ff811be","./Math-be2c8494","./PolygonPipeline-2888ea37","./RectangleGeometryLibrary-4c469ae6","./VertexFormat-d2271f13","./RuntimeError-ca280330","./_commonjsHelpers-f78443cf","./combine-b9b48e3c","./WebGLConstants-1bcc99d3","./AttributeCompression-cb62dc59","./EncodedCartesian3-43036f0c","./IntersectionTests-f861e6a9","./Plane-f4b01105","./EllipsoidRhumbLine-c951aea3"],(function(t,e,n,a,o,r,i,s,l,u,c,m,d,p,g,f,y,h,b,_,w,A,x,C){"use strict";const v=new e.Cartesian3,V=new e.Cartesian3,R=new e.Cartesian3,E=new e.Cartesian3,G=new n.Rectangle,F=new n.Cartesian2,P=new a.BoundingSphere,L=new a.BoundingSphere;function M(t,e){const n=new r.Geometry({attributes:new i.GeometryAttributes,primitiveType:r.PrimitiveType.TRIANGLES});return n.attributes.position=new r.GeometryAttribute({componentDatatype:o.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e.positions}),t.normal&&(n.attributes.normal=new r.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e.normals})),t.tangent&&(n.attributes.tangent=new r.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e.tangents})),t.bitangent&&(n.attributes.bitangent=new r.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e.bitangents})),n}const D=new e.Cartesian3,N=new e.Cartesian3;function T(n,a){const i=n._vertexFormat,s=n._ellipsoid,l=a.height,u=a.width,m=a.northCap,d=a.southCap,g=n._planeView;let f=0,y=l,h=l,b=0;m&&(f=1,h-=1,b+=1),d&&(y-=1,h-=1,b+=1),b+=u*h;const _=i.position?new Float64Array(3*b):void 0,w=i.st?new Float32Array(2*b):void 0;let A=0,x=0;const C=v,G=F;let P=Number.MAX_VALUE,L=Number.MAX_VALUE,D=-Number.MAX_VALUE,N=-Number.MAX_VALUE;for(let t=f;t<y;++t)for(let e=0;e<u;++e)p.RectangleGeometryLibrary.computePosition(a,s,i.st,t,e,C,G,g),_[A++]=C.x,_[A++]=C.y,_[A++]=C.z,i.st&&(w[x++]=G.x,w[x++]=G.y,P=Math.min(P,G.x),L=Math.min(L,G.y),D=Math.max(D,G.x),N=Math.max(N,G.y));if(m&&(p.RectangleGeometryLibrary.computePosition(a,s,i.st,0,0,C,G),_[A++]=C.x,_[A++]=C.y,_[A++]=C.z,i.st&&(w[x++]=G.x,w[x++]=G.y,P=G.x,L=G.y,D=G.x,N=G.y)),d&&(p.RectangleGeometryLibrary.computePosition(a,s,i.st,l-1,0,C,G),_[A++]=C.x,_[A++]=C.y,_[A]=C.z,i.st&&(w[x++]=G.x,w[x]=G.y,P=Math.min(P,G.x),L=Math.min(L,G.y),D=Math.max(D,G.x),N=Math.max(N,G.y))),i.st&&(P<0||L<0||D>1||N>1))for(let t=0;t<w.length;t+=2)w[t]=(w[t]-P)/(D-P),w[t+1]=(w[t+1]-L)/(N-L);const T=function(n,a,o,r,i){const s=n.length,l=a.normal?new Float32Array(s):void 0,u=a.tangent?new Float32Array(s):void 0,c=a.bitangent?new Float32Array(s):void 0;let m=0;const d=E,p=R;let g=V;if(a.normal||a.tangent||a.bitangent)for(let f=0;f<s;f+=3){const s=e.Cartesian3.fromArray(n,f,v),y=m+1,h=m+2;g=t.defined(i)&&!0===i?new e.Cartesian3(0,0,1):o.geodeticSurfaceNormal(s,g),(a.tangent||a.bitangent)&&(e.Cartesian3.cross(e.Cartesian3.UNIT_Z,g,p),e.Matrix3.multiplyByVector(r,p,p),e.Cartesian3.normalize(p,p),a.bitangent&&e.Cartesian3.normalize(e.Cartesian3.cross(g,p,d),d)),a.normal&&(l[m]=g.x,l[y]=g.y,l[h]=g.z),a.tangent&&(u[m]=p.x,u[y]=p.y,u[h]=p.z),a.bitangent&&(c[m]=d.x,c[y]=d.y,c[h]=d.z),m+=3}return M(a,{positions:n,normals:l,tangents:u,bitangents:c})}(_,i,s,a.tangentRotationMatrix,g);let O=6*(u-1)*(h-1);m&&(O+=3*(u-1)),d&&(O+=3*(u-1));const I=c.IndexDatatype.createTypedArray(b,O);let S,k=0,H=0;for(S=0;S<h-1;++S){for(let t=0;t<u-1;++t){const t=k,e=t+u,n=e+1,a=t+1;I[H++]=t,I[H++]=e,I[H++]=a,I[H++]=a,I[H++]=e,I[H++]=n,++k}++k}if(m||d){let t=b-1;const e=b-1;let n,a;if(m&&d&&(t=b-2),k=0,m)for(S=0;S<u-1;S++)n=k,a=n+1,I[H++]=t,I[H++]=n,I[H++]=a,++k;if(d)for(k=(h-1)*u,S=0;S<u-1;S++)n=k,a=n+1,I[H++]=n,I[H++]=e,I[H++]=a,++k}return T.indices=I,i.st&&(T.attributes.st=new r.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:w})),T}function O(t,e,n,a,o){return t[e++]=a[n],t[e++]=a[n+1],t[e++]=a[n+2],t[e++]=o[n],t[e++]=o[n+1],t[e]=o[n+2],t}function I(t,e,n,a){return t[e++]=a[n],t[e++]=a[n+1],t[e++]=a[n],t[e]=a[n+1],t}const S=new g.VertexFormat;function k(n,a){const i=n._shadowVolume,p=n._offsetAttribute,f=n._vertexFormat,y=n._extrudedHeight,h=n._surfaceHeight,b=n._ellipsoid,_=n._planeView,w=a.height,A=a.width;let x;if(i){const t=g.VertexFormat.clone(f,S);t.normal=!0,n._vertexFormat=t}const C=T(n,a);i&&(n._vertexFormat=f);let G=d.PolygonPipeline.scaleToGeodeticHeight(C.attributes.position.values,h,b,!1,_);G=new Float64Array(G);let F=G.length;const P=2*F,L=new Float64Array(P);L.set(G);const k=d.PolygonPipeline.scaleToGeodeticHeight(C.attributes.position.values,y,b,void 0,_);L.set(k,F),C.attributes.position.values=L;const H=f.normal?new Float32Array(P):void 0,U=f.tangent?new Float32Array(P):void 0,z=f.bitangent?new Float32Array(P):void 0,B=f.st?new Float32Array(P/3*2):void 0;let Y,X,q;if(f.normal){for(X=C.attributes.normal.values,H.set(X),x=0;x<F;x++)X[x]=-X[x];H.set(X,F),C.attributes.normal.values=H}if(i){X=C.attributes.normal.values,f.normal||(C.attributes.normal=void 0);const t=new Float32Array(P);for(x=0;x<F;x++)X[x]=-X[x];t.set(X,F),C.attributes.extrudeDirection=new r.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:t})}const Q=t.defined(p);if(Q){const t=F/3*2;let e=new Uint8Array(t);p===l.GeometryOffsetAttribute.TOP?e=e.fill(1,0,t/2):(q=p===l.GeometryOffsetAttribute.NONE?0:1,e=e.fill(q)),C.attributes.applyOffset=new r.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}if(f.tangent){const t=C.attributes.tangent.values;for(U.set(t),x=0;x<F;x++)t[x]=-t[x];U.set(t,F),C.attributes.tangent.values=U}if(f.bitangent){const t=C.attributes.bitangent.values;z.set(t),z.set(t,F),C.attributes.bitangent.values=z}f.st&&(Y=C.attributes.st.values,B.set(Y),B.set(Y,F/3*2),C.attributes.st.values=B);const W=C.indices,j=W.length,J=F/3,Z=c.IndexDatatype.createTypedArray(P/3,2*j);for(Z.set(W),x=0;x<j;x+=3)Z[x+j]=W[x+2]+J,Z[x+1+j]=W[x+1]+J,Z[x+2+j]=W[x]+J;C.indices=Z;const K=a.northCap,$=a.southCap;let tt=w,et=2,nt=0,at=4,ot=4;K&&(et-=1,tt-=1,nt+=1,at-=2,ot-=1),$&&(et-=1,tt-=1,nt+=1,at-=2,ot-=1),nt+=et*A+2*tt-at;const rt=2*(nt+ot);let it=new Float64Array(3*rt);const st=i?new Float32Array(3*rt):void 0;let lt=Q?new Uint8Array(rt):void 0,ut=f.st?new Float32Array(2*rt):void 0;const ct=p===l.GeometryOffsetAttribute.TOP;Q&&!ct&&(q=p===l.GeometryOffsetAttribute.ALL?1:0,lt=lt.fill(q));let mt=0,dt=0,pt=0,gt=0;const ft=A*tt;let yt;for(x=0;x<ft;x+=A)yt=3*x,it=O(it,mt,yt,G,k),mt+=6,f.st&&(ut=I(ut,dt,2*x,Y),dt+=4),i&&(pt+=3,st[pt++]=X[yt],st[pt++]=X[yt+1],st[pt++]=X[yt+2]),ct&&(lt[gt++]=1,gt+=1);if($){const t=K?ft+1:ft;for(yt=3*t,x=0;x<2;x++)it=O(it,mt,yt,G,k),mt+=6,f.st&&(ut=I(ut,dt,2*t,Y),dt+=4),i&&(pt+=3,st[pt++]=X[yt],st[pt++]=X[yt+1],st[pt++]=X[yt+2]),ct&&(lt[gt++]=1,gt+=1)}else for(x=ft-A;x<ft;x++)yt=3*x,it=O(it,mt,yt,G,k),mt+=6,f.st&&(ut=I(ut,dt,2*x,Y),dt+=4),i&&(pt+=3,st[pt++]=X[yt],st[pt++]=X[yt+1],st[pt++]=X[yt+2]),ct&&(lt[gt++]=1,gt+=1);for(x=ft-1;x>0;x-=A)yt=3*x,it=O(it,mt,yt,G,k),mt+=6,f.st&&(ut=I(ut,dt,2*x,Y),dt+=4),i&&(pt+=3,st[pt++]=X[yt],st[pt++]=X[yt+1],st[pt++]=X[yt+2]),ct&&(lt[gt++]=1,gt+=1);if(K){const t=ft;for(yt=3*t,x=0;x<2;x++)it=O(it,mt,yt,G,k),mt+=6,f.st&&(ut=I(ut,dt,2*t,Y),dt+=4),i&&(pt+=3,st[pt++]=X[yt],st[pt++]=X[yt+1],st[pt++]=X[yt+2]),ct&&(lt[gt++]=1,gt+=1)}else for(x=A-1;x>=0;x--)yt=3*x,it=O(it,mt,yt,G,k),mt+=6,f.st&&(ut=I(ut,dt,2*x,Y),dt+=4),i&&(pt+=3,st[pt++]=X[yt],st[pt++]=X[yt+1],st[pt++]=X[yt+2]),ct&&(lt[gt++]=1,gt+=1);let ht=function(t,n,a){const o=t.length,r=n.normal?new Float32Array(o):void 0,i=n.tangent?new Float32Array(o):void 0,s=n.bitangent?new Float32Array(o):void 0;let l=0,u=0,c=0,d=!0,p=E,g=R,f=V;if(n.normal||n.tangent||n.bitangent)for(let y=0;y<o;y+=6){const h=e.Cartesian3.fromArray(t,y,v),b=e.Cartesian3.fromArray(t,(y+6)%o,D);if(d){const n=e.Cartesian3.fromArray(t,(y+3)%o,N);e.Cartesian3.subtract(b,h,b),e.Cartesian3.subtract(n,h,n),f=e.Cartesian3.normalize(e.Cartesian3.cross(n,b,f),f),d=!1}e.Cartesian3.equalsEpsilon(b,h,m.CesiumMath.EPSILON10)&&(d=!0),(n.tangent||n.bitangent)&&(p=a.geodeticSurfaceNormal(h,p),n.tangent&&(g=e.Cartesian3.normalize(e.Cartesian3.cross(p,f,g),g))),n.normal&&(r[l++]=f.x,r[l++]=f.y,r[l++]=f.z,r[l++]=f.x,r[l++]=f.y,r[l++]=f.z),n.tangent&&(i[u++]=g.x,i[u++]=g.y,i[u++]=g.z,i[u++]=g.x,i[u++]=g.y,i[u++]=g.z),n.bitangent&&(s[c++]=p.x,s[c++]=p.y,s[c++]=p.z,s[c++]=p.x,s[c++]=p.y,s[c++]=p.z)}return M(n,{positions:t,normals:r,tangents:i,bitangents:s})}(it,f,b);f.st&&(ht.attributes.st=new r.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:ut})),i&&(ht.attributes.extrudeDirection=new r.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:st})),Q&&(ht.attributes.applyOffset=new r.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:lt}));const bt=c.IndexDatatype.createTypedArray(rt,6*nt);let _t,wt,At,xt;F=it.length/3;let Ct=0;for(x=0;x<F-1;x+=2){_t=x,xt=(_t+2)%F;const t=e.Cartesian3.fromArray(it,3*_t,D),n=e.Cartesian3.fromArray(it,3*xt,N);e.Cartesian3.equalsEpsilon(t,n,m.CesiumMath.EPSILON10)||(wt=(_t+1)%F,At=(wt+2)%F,bt[Ct++]=_t,bt[Ct++]=wt,bt[Ct++]=xt,bt[Ct++]=xt,bt[Ct++]=wt,bt[Ct++]=At)}return ht.indices=bt,ht=u.GeometryPipeline.combineInstances([new s.GeometryInstance({geometry:C}),new s.GeometryInstance({geometry:ht})]),ht[0]}const H=[new e.Cartesian3,new e.Cartesian3,new e.Cartesian3,new e.Cartesian3],U=new e.Cartographic,z=new e.Cartographic;function B(e,a,o,r,i,s){if(0===o)return n.Rectangle.clone(e,i);e._planeView=s;const l=p.RectangleGeometryLibrary.computeOptions(e,a,o,0,G,U),u=l.height,c=l.width,m=H;if(p.RectangleGeometryLibrary.computePosition(l,r,!1,0,0,m[0],void 0,s),p.RectangleGeometryLibrary.computePosition(l,r,!1,0,c-1,m[1],void 0,s),p.RectangleGeometryLibrary.computePosition(l,r,!1,u-1,0,m[2],void 0,s),p.RectangleGeometryLibrary.computePosition(l,r,!1,u-1,c-1,m[3],void 0,s),t.defined(s)&&!0===s){const t={west:0,east:0,south:0,north:0,width:0,height:0};let e=Number.MAX_VALUE,n=Number.MIN_VALUE,a=Number.MAX_VALUE,o=Number.MIN_VALUE;return m.forEach((t=>{e=Math.min(e,t.x),n=Math.max(n,t.x),a=Math.min(a,t.y),o=Math.max(o,t.y)})),t.west=e,t.south=a,t.east=n,t.north=o,t.width=t.east-t.west,t.height=t.north-t.south,t._planeView=!0,t}return n.Rectangle.fromCartesianArray(m,r,i)}function Y(a){const o=(a=t.defaultValue(a,t.defaultValue.EMPTY_OBJECT)).rectangle,r=t.defaultValue(a.planeView,!1),i=t.defaultValue(a.height,0),s=t.defaultValue(a.extrudedHeight,i);this._rectangle=n.Rectangle.clone(o),this._granularity=t.defaultValue(a.granularity,m.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=e.Ellipsoid.clone(t.defaultValue(a.ellipsoid,e.Ellipsoid.WGS84)),this._surfaceHeight=Math.max(i,s),this._rotation=t.defaultValue(a.rotation,0),this._stRotation=t.defaultValue(a.stRotation,0),this._vertexFormat=g.VertexFormat.clone(t.defaultValue(a.vertexFormat,g.VertexFormat.DEFAULT)),this._extrudedHeight=Math.min(i,s),this._shadowVolume=t.defaultValue(a.shadowVolume,!1),this._workerName="createRectangleGeometry",this._offsetAttribute=a.offsetAttribute,this._rotatedRectangle=void 0,this._textureCoordinateRotationPoints=void 0,this._planeView=r}Y.packedLength=n.Rectangle.packedLength+e.Ellipsoid.packedLength+g.VertexFormat.packedLength+7,Y.pack=function(a,o,r){return r=t.defaultValue(r,0),n.Rectangle.pack(a._rectangle,o,r),r+=n.Rectangle.packedLength,e.Ellipsoid.pack(a._ellipsoid,o,r),r+=e.Ellipsoid.packedLength,g.VertexFormat.pack(a._vertexFormat,o,r),r+=g.VertexFormat.packedLength,o[r++]=a._granularity,o[r++]=a._surfaceHeight,o[r++]=a._rotation,o[r++]=a._stRotation,o[r++]=a._extrudedHeight,o[r++]=a._shadowVolume?1:0,o[r]=t.defaultValue(a._offsetAttribute,-1),o};const X=new n.Rectangle,q=e.Ellipsoid.clone(e.Ellipsoid.UNIT_SPHERE),Q={rectangle:X,ellipsoid:q,vertexFormat:S,granularity:void 0,height:void 0,rotation:void 0,stRotation:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};Y.unpack=function(a,o,r,i){o=t.defaultValue(o,0);const s=n.Rectangle.unpack(a,o,X,i);o+=n.Rectangle.packedLength;const l=e.Ellipsoid.unpack(a,o,q);o+=e.Ellipsoid.packedLength;const u=g.VertexFormat.unpack(a,o,S);o+=g.VertexFormat.packedLength;const c=a[o++],m=a[o++],d=a[o++],p=a[o++],f=a[o++],y=1===a[o++],h=a[o];return t.defined(r)?(r._rectangle=n.Rectangle.clone(s,r._rectangle),r._rectangle._planeView=t.defaultValue(i,!1),r._ellipsoid=e.Ellipsoid.clone(l,r._ellipsoid),r._vertexFormat=g.VertexFormat.clone(u,r._vertexFormat),r._granularity=c,r._surfaceHeight=m,r._rotation=d,r._stRotation=p,r._extrudedHeight=f,r._shadowVolume=y,r._offsetAttribute=-1===h?void 0:h,r._planeView=t.defaultValue(i,!1),r):(Q.granularity=c,Q.height=m,Q.rotation=d,Q.stRotation=p,Q.extrudedHeight=f,Q.shadowVolume=y,Q.offsetAttribute=-1===h?void 0:h,Q.planeView=t.defaultValue(i,!1),new Y(Q))},Y.computeRectangle=function(n,a){const o=(n=t.defaultValue(n,t.defaultValue.EMPTY_OBJECT)).rectangle,r=t.defaultValue(n.granularity,m.CesiumMath.RADIANS_PER_DEGREE),i=t.defaultValue(n.ellipsoid,e.Ellipsoid.WGS84);return B(o,r,t.defaultValue(n.rotation,0),i,a,t.defaultValue(n.planeView,!1))};const W=new e.Matrix3,j=new a.Quaternion,J=new e.Cartographic;Y.createGeometry=function(i){if(m.CesiumMath.equalsEpsilon(i._rectangle.north,i._rectangle.south,m.CesiumMath.EPSILON10)||m.CesiumMath.equalsEpsilon(i._rectangle.east,i._rectangle.west,m.CesiumMath.EPSILON10))return;let s=i._rectangle;const u=i._ellipsoid,c=i._rotation,g=i._stRotation,f=i._vertexFormat,y=i._planeView,h=p.RectangleGeometryLibrary.computeOptions(s,i._granularity,c,g,G,U,z),b=W;if(0!==g||0!==c){const o=n.Rectangle.center(s,J);let r;r=t.defined(y)&&!0===y?new e.Cartesian3(0,0,1):u.geodeticSurfaceNormalCartographic(o,D),a.Quaternion.fromAxisAngle(r,-g,j),e.Matrix3.fromQuaternion(j,b)}else e.Matrix3.clone(e.Matrix3.IDENTITY,b);const _=i._surfaceHeight,w=i._extrudedHeight,A=!m.CesiumMath.equalsEpsilon(_,w,0,m.CesiumMath.EPSILON2);let x,C;if(h.lonScalar=1/i._rectangle.width,h.latScalar=1/i._rectangle.height,h.tangentRotationMatrix=b,s=i._rectangle,A){x=k(i,h);const t=a.BoundingSphere.fromRectangle3D(s,u,_,L),e=a.BoundingSphere.fromRectangle3D(s,u,w,P);C=a.BoundingSphere.union(t,e)}else{if(x=T(i,h),x.attributes.position.values=d.PolygonPipeline.scaleToGeodeticHeight(x.attributes.position.values,_,u,!1,y),t.defined(i._offsetAttribute)){const t=x.attributes.position.values.length,e=i._offsetAttribute===l.GeometryOffsetAttribute.NONE?0:1,n=new Uint8Array(t/3).fill(e);x.attributes.applyOffset=new r.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}C=a.BoundingSphere.fromRectangle3D(s,u,_)}return f.position||delete x.attributes.position,new r.Geometry({attributes:x.attributes,indices:x.indices,primitiveType:x.primitiveType,boundingSphere:C,offsetAttribute:i._offsetAttribute})},Y.createShadowVolume=function(t,e,n){const a=t._granularity,o=t._ellipsoid,r=e(a,o),i=n(a,o);return new Y({rectangle:t._rectangle,rotation:t._rotation,ellipsoid:o,stRotation:t._stRotation,granularity:a,extrudedHeight:i,height:r,vertexFormat:g.VertexFormat.POSITION_ONLY,shadowVolume:!0})};const Z=new n.Rectangle,K=[new n.Cartesian2,new n.Cartesian2,new n.Cartesian2],$=new n.Matrix2,tt=new e.Cartographic;return Object.defineProperties(Y.prototype,{rectangle:{get:function(){return t.defined(this._rotatedRectangle)||(this._rotatedRectangle=B(this._rectangle,this._granularity,this._rotation,this._ellipsoid,void 0,this._planeView)),this._rotatedRectangle}},textureCoordinateRotationPoints:{get:function(){return t.defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(t){if(0===t._stRotation)return[0,0,0,1,1,0];const e=n.Rectangle.clone(t._rectangle,Z),a=t._granularity,o=t._ellipsoid,r=t._rotation-t._stRotation,i=t._planeView,s=B(e,a,r,o,Z,i),l=K;l[0].x=s.west,l[0].y=s.south,l[1].x=s.west,l[1].y=s.north,l[2].x=s.east,l[2].y=s.south;const u=t.rectangle,c=n.Matrix2.fromRotation(t._stRotation,$),m=n.Rectangle.center(u,tt);for(let t=0;t<3;++t){const e=l[t];e.x-=m.longitude,e.y-=m.latitude,n.Matrix2.multiplyByVector(c,e,e),e.x+=m.longitude,e.y+=m.latitude,e.x=(e.x-u.west)/u.width,e.y=(e.y-u.south)/u.height}const d=l[0],p=l[1],g=l[2],f=new Array(6);return n.Cartesian2.pack(d,f),n.Cartesian2.pack(p,f,2),n.Cartesian2.pack(g,f,4),f}(this)),this._textureCoordinateRotationPoints}}}),function(a,o,r){return t.defined(o)&&(a=Y.unpack(a,o,void 0,r)),a._ellipsoid=e.Ellipsoid.clone(a._ellipsoid),a._rectangle=n.Rectangle.clone(a._rectangle),Y.createGeometry(a)}}));
