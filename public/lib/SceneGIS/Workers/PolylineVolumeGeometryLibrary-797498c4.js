/**
 * @license
 * SceneGIS - https://github.com/CesiumGS/cesium
 * Version 1.97
 *
 * Copyright 2011-2022 SceneGIS Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["exports","./Matrix2-bce7772b","./Matrix3-a45402cf","./EllipsoidTangentPlane-b1a9b8da","./Math-be2c8494","./PolylinePipeline-1de62483","./Transforms-c38817cd","./defaultValue-192c850d"],(function(e,a,t,n,r,i,s,o){"use strict";var l=Object.freeze({ROUNDED:0,MITERED:1,BEVELED:2});const c={};function C(e,a){o.defined(c[e])||(c[e]=!0,console.warn(o.defaultValue(a,e)))}C.geometryOutlines="Entity geometry outlines are unsupported on terrain. Outlines will be disabled. To enable outlines, disable geometry terrain clamping by explicitly setting height to 0.",C.geometryZIndex="Entity geometry with zIndex are unsupported when height or extrudedHeight are defined.  zIndex will be ignored",C.geometryHeightReference="Entity corridor, ellipse, polygon or rectangle with heightReference must also have a defined height.  heightReference will be ignored",C.geometryExtrudedHeightReference="Entity corridor, ellipse, polygon or rectangle with extrudedHeightReference must also have a defined extrudedHeight.  extrudedHeightReference will be ignored";const u=[new t.Cartesian3,new t.Cartesian3],d=new t.Cartesian3,g=new t.Cartesian3,y=new t.Cartesian3,f=new t.Cartesian3,h=new t.Cartesian3,m=new t.Cartesian3,p=new t.Cartesian3,w=new t.Cartesian3,x=new t.Cartesian3,E=new t.Cartesian3,P=new t.Cartesian3,b={};let M=new t.Cartographic;function T(e,a,n,r){const i=e[0],s=e[1],o=t.Cartesian3.angleBetween(i,s),l=Math.ceil(o/r),c=new Array(l);let C;if(a===n){for(C=0;C<l;C++)c[C]=a;return c.push(n),c}const u=(n-a)/l;for(C=1;C<l;C++){const e=a+C*u;c[C]=e}return c[0]=a,c.push(n),c}const z=new t.Cartesian3,B=new t.Cartesian3;const S=new t.Cartesian3(-1,0,0);let A=new a.Matrix4;const D=new a.Matrix4;let R=new t.Matrix3;const O=t.Matrix3.IDENTITY.clone(),V=new t.Cartesian3,I=new a.Cartesian4,v=new t.Cartesian3;function N(e,r,i,o,l,c,C,u){let d=V,g=I;A=s.Transforms.eastNorthUpToFixedFrame(e,l,A),d=a.Matrix4.multiplyByPointAsVector(A,S,d),d=t.Cartesian3.normalize(d,d);const y=function(e,r,i,s){const o=new n.EllipsoidTangentPlane(i,s),l=o.projectPointOntoPlane(t.Cartesian3.add(i,e,z),z),c=o.projectPointOntoPlane(t.Cartesian3.add(i,r,B),B),C=a.Cartesian2.angleBetween(l,c);return c.x*l.y-c.y*l.x>=0?-C:C}(d,r,e,l);R=t.Matrix3.fromRotationZ(y,R),v.z=c,A=a.Matrix4.multiplyTransformation(A,a.Matrix4.fromRotationTranslation(R,v,D),A);const f=O;f[0]=C;for(let e=0;e<u;e++)for(let e=0;e<i.length;e+=3)g=t.Cartesian3.fromArray(i,e,g),g=t.Matrix3.multiplyByVector(f,g,g),g=a.Matrix4.multiplyByPoint(A,g,g),o.push(g.x,g.y,g.z);return o}const G=new t.Cartesian3;function H(e,a,n,r,i,s,o){for(let l=0;l<e.length;l+=3){r=N(t.Cartesian3.fromArray(e,l,G),a,n,r,i,s[l/3],o,1)}return r}function L(e,a){const t=e.length,n=new Array(3*t);let r=0;const i=a.x+a.width/2,s=a.y+a.height/2;for(let a=0;a<t;a++)n[r++]=e[a].x-i,n[r++]=0,n[r++]=e[a].y-s;return n}const j=new s.Quaternion,Q=new t.Cartesian3,q=new t.Matrix3;function F(e,a,n,i,o,c,C,u,d,g){const y=t.Cartesian3.angleBetween(t.Cartesian3.subtract(a,e,E),t.Cartesian3.subtract(n,e,P)),f=i===l.BEVELED?0:Math.ceil(y/r.CesiumMath.toRadians(5));let h,m,p;if(h=o?t.Matrix3.fromQuaternion(s.Quaternion.fromAxisAngle(t.Cartesian3.negate(e,E),y/(f+1),j),q):t.Matrix3.fromQuaternion(s.Quaternion.fromAxisAngle(e,y/(f+1),j),q),a=t.Cartesian3.clone(a,Q),f>0){const n=g?2:1;for(let r=0;r<f;r++)a=t.Matrix3.multiplyByVector(h,a,a),m=t.Cartesian3.subtract(a,e,E),m=t.Cartesian3.normalize(m,m),o||(m=t.Cartesian3.negate(m,m)),p=c.scaleToGeodeticSurface(a,P),C=N(p,m,u,C,c,d,1,n)}else m=t.Cartesian3.subtract(a,e,E),m=t.Cartesian3.normalize(m,m),o||(m=t.Cartesian3.negate(m,m)),p=c.scaleToGeodeticSurface(a,P),C=N(p,m,u,C,c,d,1,1),n=t.Cartesian3.clone(n,Q),m=t.Cartesian3.subtract(n,e,E),m=t.Cartesian3.normalize(m,m),o||(m=t.Cartesian3.negate(m,m)),p=c.scaleToGeodeticSurface(n,P),C=N(p,m,u,C,c,d,1,1);return C}b.removeDuplicatesFromShape=function(e){const t=e.length,n=[];for(let r=t-1,i=0;i<t;r=i++){const t=e[r],s=e[i];a.Cartesian2.equals(t,s)||n.push(s)}return n},b.angleIsGreaterThanPi=function(e,a,r,i,s){if(!0===(s=o.defaultValue(s,!1))){const n=new t.Cartesian3;if(t.Cartesian3.cross(e,a,n),n.z>=0)return!1;if(n.z<0)return!0}const l=new n.EllipsoidTangentPlane(r,i),c=l.projectPointOntoPlane(t.Cartesian3.add(r,e,z),z),C=l.projectPointOntoPlane(t.Cartesian3.add(r,a,B),B);return C.x*c.y-C.y*c.x>=0};const U=new t.Cartesian3,_=new t.Cartesian3;b.computePositions=function(e,a,n,s,o){const c=s._ellipsoid,P=function(e,a){const t=new Array(e.length);for(let n=0;n<e.length;n++){const r=e[n];M=a.cartesianToCartographic(r,M),t[n]=M.height,e[n]=a.scaleToGeodeticSurface(r,r)}return t}(e,c),z=s._granularity,B=s._cornerType,S=o?function(e,a){const t=e.length,n=new Array(6*t);let r=0;const i=a.x+a.width/2,s=a.y+a.height/2;let o=e[0];n[r++]=o.x-i,n[r++]=0,n[r++]=o.y-s;for(let a=1;a<t;a++){o=e[a];const t=o.x-i,l=o.y-s;n[r++]=t,n[r++]=0,n[r++]=l,n[r++]=t,n[r++]=0,n[r++]=l}return o=e[0],n[r++]=o.x-i,n[r++]=0,n[r++]=o.y-s,n}(a,n):L(a,n),A=o?L(a,n):void 0,D=n.height/2,R=n.width/2;let O=e.length,V=[],I=o?[]:void 0,v=d,G=g,j=y,Q=f,q=h,Z=m,W=p,Y=w,k=x,J=e[0],K=e[1];Q=c.geodeticSurfaceNormal(J,Q),v=t.Cartesian3.subtract(K,J,v),v=t.Cartesian3.normalize(v,v),Y=t.Cartesian3.cross(Q,v,Y),Y=t.Cartesian3.normalize(Y,Y);let X,$,ee=P[0],ae=P[1];o&&(I=N(J,Y,A,I,c,ee+D,1,1)),k=t.Cartesian3.clone(J,k),J=K,G=t.Cartesian3.negate(v,G);for(let a=1;a<O-1;a++){const n=o?2:1;if(K=e[a+1],J.equals(K)){C("Positions are too close and are considered equivalent with rounding error.");continue}v=t.Cartesian3.subtract(K,J,v),v=t.Cartesian3.normalize(v,v),j=t.Cartesian3.add(v,G,j),j=t.Cartesian3.normalize(j,j),Q=c.geodeticSurfaceNormal(J,Q);const s=t.Cartesian3.multiplyByScalar(Q,t.Cartesian3.dot(v,Q),U);t.Cartesian3.subtract(v,s,s),t.Cartesian3.normalize(s,s);const d=t.Cartesian3.multiplyByScalar(Q,t.Cartesian3.dot(G,Q),_);t.Cartesian3.subtract(G,d,d),t.Cartesian3.normalize(d,d);if(!r.CesiumMath.equalsEpsilon(Math.abs(t.Cartesian3.dot(s,d)),1,r.CesiumMath.EPSILON7)){j=t.Cartesian3.cross(j,Q,j),j=t.Cartesian3.cross(Q,j,j),j=t.Cartesian3.normalize(j,j);const e=1/Math.max(.25,t.Cartesian3.magnitude(t.Cartesian3.cross(j,G,E))),a=b.angleIsGreaterThanPi(v,G,J,c);a?(q=t.Cartesian3.add(J,t.Cartesian3.multiplyByScalar(j,e*R,j),q),Z=t.Cartesian3.add(q,t.Cartesian3.multiplyByScalar(Y,R,Z),Z),u[0]=t.Cartesian3.clone(k,u[0]),u[1]=t.Cartesian3.clone(Z,u[1]),X=T(u,ee+D,ae+D,z),$=i.PolylinePipeline.generateArc({positions:u,granularity:z,ellipsoid:c}),V=H($,Y,S,V,c,X,1),Y=t.Cartesian3.cross(Q,v,Y),Y=t.Cartesian3.normalize(Y,Y),W=t.Cartesian3.add(q,t.Cartesian3.multiplyByScalar(Y,R,W),W),B===l.ROUNDED||B===l.BEVELED?F(q,Z,W,B,a,c,V,S,ae+D,o):(j=t.Cartesian3.negate(j,j),V=N(J,j,S,V,c,ae+D,e,n)),k=t.Cartesian3.clone(W,k)):(q=t.Cartesian3.add(J,t.Cartesian3.multiplyByScalar(j,e*R,j),q),Z=t.Cartesian3.add(q,t.Cartesian3.multiplyByScalar(Y,-R,Z),Z),u[0]=t.Cartesian3.clone(k,u[0]),u[1]=t.Cartesian3.clone(Z,u[1]),X=T(u,ee+D,ae+D,z),$=i.PolylinePipeline.generateArc({positions:u,granularity:z,ellipsoid:c}),V=H($,Y,S,V,c,X,1),Y=t.Cartesian3.cross(Q,v,Y),Y=t.Cartesian3.normalize(Y,Y),W=t.Cartesian3.add(q,t.Cartesian3.multiplyByScalar(Y,-R,W),W),B===l.ROUNDED||B===l.BEVELED?F(q,Z,W,B,a,c,V,S,ae+D,o):V=N(J,j,S,V,c,ae+D,e,n),k=t.Cartesian3.clone(W,k)),G=t.Cartesian3.negate(v,G)}else V=N(k,Y,S,V,c,ee+D,1,1),k=J;ee=ae,ae=P[a+1],J=K}u[0]=t.Cartesian3.clone(k,u[0]),u[1]=t.Cartesian3.clone(J,u[1]),X=T(u,ee+D,ae+D,z),$=i.PolylinePipeline.generateArc({positions:u,granularity:z,ellipsoid:c}),V=H($,Y,S,V,c,X,1),o&&(I=N(J,Y,A,I,c,ae+D,1,1)),O=V.length;const te=o?O+I.length:O,ne=new Float64Array(te);return ne.set(V),o&&ne.set(I,O),ne};var Z=b;e.CornerType=l,e.PolylineVolumeGeometryLibrary=Z,e.oneTimeWarning=C}));
