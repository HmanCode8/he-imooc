/**
 * @license
 * SceneGIS - https://github.com/CesiumGS/cesium
 * Version 1.97
 *
 * Copyright 2011-2022 SceneGIS Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./AttributeCompression-cb62dc59","./Matrix3-a45402cf","./Color-7a84f104","./defaultValue-192c850d","./IndexDatatype-1ff811be","./Math-be2c8494","./OrientedBoundingBox-d8d8ede3","./Matrix2-bce7772b","./createTaskProcessorWorker","./ComponentDatatype-f194b981","./WebGLConstants-1bcc99d3","./Transforms-c38817cd","./_commonjsHelpers-f78443cf","./combine-b9b48e3c","./RuntimeError-ca280330","./EllipsoidTangentPlane-b1a9b8da","./AxisAlignedBoundingBox-e6370b82","./IntersectionTests-f861e6a9","./Plane-f4b01105","./CartesianRectangle-3289fb67"],(function(e,t,n,a,r,o,s,i,c,f,d,l,u,h,g,p,b,m,y,C){"use strict";const I=new t.Cartesian3,x=new t.Ellipsoid,w=new i.Rectangle,A={min:void 0,max:void 0,indexBytesPerElement:void 0};function E(e,t,a){const r=t.length,o=2+r*s.OrientedBoundingBox.packedLength+1+function(e){const t=e.length;let a=0;for(let r=0;r<t;++r)a+=n.Color.packedLength+3+e[r].batchIds.length;return a}(a),i=new Float64Array(o);let c=0;i[c++]=e,i[c++]=r;for(let e=0;e<r;++e)s.OrientedBoundingBox.pack(t[e],i,c),c+=s.OrientedBoundingBox.packedLength;const f=a.length;i[c++]=f;for(let e=0;e<f;++e){const t=a[e];n.Color.pack(t.color,i,c),c+=n.Color.packedLength,i[c++]=t.offset,i[c++]=t.count;const r=t.batchIds,o=r.length;i[c++]=o;for(let e=0;e<o;++e)i[c++]=r[e]}return i}const N=new t.Cartesian3,T=new t.Cartesian3,B=new t.Cartesian3,k=new t.Cartesian3,L=new t.Cartesian3,O=new t.Cartographic,U=new i.Rectangle;return c((function(c,f){let d;!function(e){const n=new Float64Array(e);let a=0;A.indexBytesPerElement=n[a++],A.min=n[a++],A.max=n[a++],t.Cartesian3.unpack(n,a,I),a+=t.Cartesian3.packedLength,t.Ellipsoid.unpack(n,a,x),a+=t.Ellipsoid.packedLength,i.Rectangle.unpack(n,a,w)}(c.packedBuffer),d=2===A.indexBytesPerElement?new Uint16Array(c.indices):new Uint32Array(c.indices);const l=new Uint16Array(c.positions),u=new Uint32Array(c.counts),h=new Uint32Array(c.indexCounts),g=new Uint32Array(c.batchIds),p=new Uint32Array(c.batchTableColors),b=new Array(u.length),m=I,y=x;let C=w;const P=A.min,F=A.max;let M,R,S,D=c.minimumHeights,_=c.maximumHeights;a.defined(D)&&a.defined(_)&&(D=new Float32Array(D),_=new Float32Array(_));const G=l.length/2,V=l.subarray(0,G),Y=l.subarray(G,2*G);e.AttributeCompression.zigZagDeltaDecode(V,Y);const H=new Float64Array(3*G);for(M=0;M<G;++M){const e=V[M],n=Y[M],a=o.CesiumMath.lerp(C.west,C.east,e/32767),r=o.CesiumMath.lerp(C.south,C.north,n/32767),s=t.Cartographic.fromRadians(a,r,0,O),i=y.cartographicToCartesian(s,N);t.Cartesian3.pack(i,H,3*M)}const v=u.length,W=new Array(v),j=new Array(v);let z=0,Z=0;for(M=0;M<v;++M)W[M]=z,j[M]=Z,z+=u[M],Z+=h[M];const q=new Float32Array(3*G*2),J=new Uint16Array(2*G),K=new Uint32Array(j.length),Q=new Uint32Array(h.length);let X=[];const $={};for(M=0;M<v;++M)S=p[M],a.defined($[S])?($[S].positionLength+=u[M],$[S].indexLength+=h[M],$[S].batchIds.push(M)):$[S]={positionLength:u[M],indexLength:h[M],offset:0,indexOffset:0,batchIds:[M]};let ee,te=0,ne=0;for(S in $)if($.hasOwnProperty(S)){ee=$[S],ee.offset=te,ee.indexOffset=ne;const e=2*ee.positionLength,t=2*ee.indexLength+6*ee.positionLength;te+=e,ne+=t,ee.indexLength=t}const ae=[];for(S in $)$.hasOwnProperty(S)&&(ee=$[S],ae.push({color:n.Color.fromRgba(parseInt(S)),offset:ee.indexOffset,count:ee.indexLength,batchIds:ee.batchIds}));for(M=0;M<v;++M){S=p[M],ee=$[S];const e=ee.offset;let n=3*e,r=e;const o=W[M],i=u[M],c=g[M];let f=P,l=F;a.defined(D)&&a.defined(_)&&(f=D[M],l=_[M]);let I=Number.POSITIVE_INFINITY,x=Number.NEGATIVE_INFINITY,w=Number.POSITIVE_INFINITY,A=Number.NEGATIVE_INFINITY;for(R=0;R<i;++R){const e=t.Cartesian3.unpack(H,3*o+3*R,N);y.scaleToGeodeticSurface(e,e);const a=y.cartesianToCartographic(e,O),s=a.latitude,i=a.longitude;I=Math.min(s,I),x=Math.max(s,x),w=Math.min(i,w),A=Math.max(i,A);const d=y.geodeticSurfaceNormal(e,T);let u=t.Cartesian3.multiplyByScalar(d,f,B);const h=t.Cartesian3.add(e,u,k);u=t.Cartesian3.multiplyByScalar(d,l,u);const g=t.Cartesian3.add(e,u,L);t.Cartesian3.subtract(g,m,g),t.Cartesian3.subtract(h,m,h),t.Cartesian3.pack(g,q,n),t.Cartesian3.pack(h,q,n+3),J[r]=c,J[r+1]=c,n+=6,r+=2}C=U,C.west=w,C.east=A,C.south=I,C.north=x,b[M]=s.OrientedBoundingBox.fromRectangle(C,P,F,y);let E=ee.indexOffset;const G=j[M],V=h[M];for(K[M]=E,R=0;R<V;R+=3){const t=d[G+R]-o,n=d[G+R+1]-o,a=d[G+R+2]-o;X[E++]=2*t+e,X[E++]=2*n+e,X[E++]=2*a+e,X[E++]=2*a+1+e,X[E++]=2*n+1+e,X[E++]=2*t+1+e}for(R=0;R<i;++R){const t=R,n=(R+1)%i;X[E++]=2*t+1+e,X[E++]=2*n+e,X[E++]=2*t+e,X[E++]=2*t+1+e,X[E++]=2*n+1+e,X[E++]=2*n+e}ee.offset+=2*i,ee.indexOffset=E,Q[M]=E-K[M]}X=r.IndexDatatype.createTypedArray(q.length/3,X);const re=ae.length;for(let e=0;e<re;++e){const t=ae[e].batchIds;let n=0;const a=t.length;for(let e=0;e<a;++e)n+=Q[t[e]];ae[e].count=n}const oe=E(2===X.BYTES_PER_ELEMENT?r.IndexDatatype.UNSIGNED_SHORT:r.IndexDatatype.UNSIGNED_INT,b,ae);return f.push(q.buffer,X.buffer,K.buffer,Q.buffer,J.buffer,oe.buffer),{positions:q.buffer,indices:X.buffer,indexOffsets:K.buffer,indexCounts:Q.buffer,batchIds:J.buffer,packedBuffer:oe.buffer}}))}));
