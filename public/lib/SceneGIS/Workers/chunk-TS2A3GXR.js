/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.114
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

import{a as Pt}from"./chunk-H3IXAINZ.js";import{a as k}from"./chunk-SCJI2CER.js";import{a as wt}from"./chunk-Y3QWB4WF.js";import{a as kt}from"./chunk-KJJSAVM5.js";import{b as dt,c as Ct,d as g}from"./chunk-5JJAXZP5.js";import{d as _t}from"./chunk-XIY2HUS2.js";import{a as R}from"./chunk-PF7ABWYW.js";import{a as s,c as ht,d as mt}from"./chunk-KXWBEOUA.js";import{a as N}from"./chunk-4BEFMW7D.js";import{a as l}from"./chunk-2F4MHS2T.js";import{a as D}from"./chunk-3Z2AZRQC.js";import{e as M}from"./chunk-A5XXOFX2.js";var Et=new s,At=new s,Mt=new s,Nt=new s,Rt=new s,gt=new s(1,1,1),bt=Math.cos,xt=Math.sin;function O(e){e=l(e,l.EMPTY_OBJECT);let m=l(e.radii,gt),i=l(e.innerRadii,m),w=l(e.minimumClock,0),T=l(e.maximumClock,N.TWO_PI),A=l(e.minimumCone,0),F=l(e.maximumCone,N.PI),a=Math.round(l(e.stackPartitions,64)),y=Math.round(l(e.slicePartitions,64)),p=l(e.vertexFormat,k.DEFAULT),h=l(e.planeView,!1);if(y<3)throw new D("options.slicePartitions cannot be less than three.");if(a<3)throw new D("options.stackPartitions cannot be less than three.");this._radii=s.clone(m),this._innerRadii=s.clone(i),this._minimumClock=w,this._maximumClock=T,this._minimumCone=A,this._maximumCone=F,this._stackPartitions=a,this._slicePartitions=y,this._vertexFormat=k.clone(p),this._offsetAttribute=e.offsetAttribute,this._workerName="createEllipsoidGeometry",this._planeView=h}O.packedLength=2*s.packedLength+k.packedLength+7;O.pack=function(e,m,i){if(!M(e))throw new D("value is required");if(!M(m))throw new D("array is required");return i=l(i,0),s.pack(e._radii,m,i),i+=s.packedLength,s.pack(e._innerRadii,m,i),i+=s.packedLength,k.pack(e._vertexFormat,m,i),i+=k.packedLength,m[i++]=e._minimumClock,m[i++]=e._maximumClock,m[i++]=e._minimumCone,m[i++]=e._maximumCone,m[i++]=e._stackPartitions,m[i++]=e._slicePartitions,m[i]=l(e._offsetAttribute,-1),m};var Ot=new s,Tt=new s,Ft=new k,x={radii:Ot,innerRadii:Tt,vertexFormat:Ft,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,offsetAttribute:void 0};O.unpack=function(e,m,i,w){if(!M(e))throw new D("array is required");m=l(m,0);let T=s.unpack(e,m,Ot);m+=s.packedLength;let A=s.unpack(e,m,Tt);m+=s.packedLength;let F=k.unpack(e,m,Ft);m+=k.packedLength;let a=e[m++],y=e[m++],p=e[m++],h=e[m++],t=e[m++],o=e[m++],n=e[m];return M(i)?(i._radii=s.clone(T,i._radii),i._innerRadii=s.clone(A,i._innerRadii),i._vertexFormat=k.clone(F,i._vertexFormat),i._minimumClock=a,i._maximumClock=y,i._minimumCone=p,i._maximumCone=h,i._stackPartitions=t,i._slicePartitions=o,i._offsetAttribute=n===-1?void 0:n,i._planeView=w,i):(x.minimumClock=a,x.maximumClock=y,x.minimumCone=p,x.maximumCone=h,x.stackPartitions=t,x.slicePartitions=o,x.offsetAttribute=n===-1?void 0:n,x.planeView=w,new O(x))};O.createGeometry=function(e){let m=e._radii;if(m.x<=0||m.y<=0||m.z<=0)return;let i=e._innerRadii;if(i.x<=0||i.y<=0||i.z<=0)return;let w=e._minimumClock,T=e._maximumClock,A=e._minimumCone,F=e._maximumCone,a=e._vertexFormat,y=e._planeView,p=e._slicePartitions+1,h=e._stackPartitions+1;p=Math.round(p*Math.abs(T-w)/N.TWO_PI),h=Math.round(h*Math.abs(F-A)/N.PI),p<2&&(p=2),h<2&&(h=2);let t,o,n=0,V=[A],S=[w];for(t=0;t<h;t++)V.push(A+t*(F-A)/(h-1));for(V.push(F),o=0;o<p;o++)S.push(w+o*(T-w)/(p-1));S.push(T);let f=V.length,r=S.length,U=0,B=1,Y=i.x!==m.x||i.y!==m.y||i.z!==m.z,X=!1,rt=!1,st=!1;Y&&(B=2,A>0&&(X=!0,U+=p-1),F<Math.PI&&(rt=!0,U+=p-1),(T-w)%N.TWO_PI?(st=!0,U+=(h-1)*2+1):U+=1);let P=r*f*B,b=new Float64Array(P*3),Z=new Array(P).fill(!1),at=new Array(P).fill(!1),ft=p*h*B,Lt=6*(ft+U+1-(p+h)*B),c=wt.createTypedArray(ft,Lt),j=a.normal?new Float32Array(P*3):void 0,H=a.tangent?new Float32Array(P*3):void 0,J=a.bitangent?new Float32Array(P*3):void 0,K=a.st?new Float32Array(P*2):void 0,W=new Array(f),Q=new Array(f);for(t=0;t<f;t++)W[t]=xt(V[t]),Q[t]=bt(V[t]);let $=new Array(r),G=new Array(r);for(o=0;o<r;o++)G[o]=bt(S[o]),$[o]=xt(S[o]);for(t=0;t<f;t++)for(o=0;o<r;o++)b[n++]=m.x*W[t]*G[o],b[n++]=m.y*W[t]*$[o],b[n++]=m.z*Q[t];let I=P/2;if(Y)for(t=0;t<f;t++)for(o=0;o<r;o++)b[n++]=i.x*W[t]*G[o],b[n++]=i.y*W[t]*$[o],b[n++]=i.z*Q[t],Z[I]=!0,t>0&&t!==f-1&&o!==0&&o!==r-1&&(at[I]=!0),I++;n=0;let L,v;for(t=1;t<f-2;t++)for(L=t*r,v=(t+1)*r,o=1;o<r-2;o++)c[n++]=v+o,c[n++]=v+o+1,c[n++]=L+o+1,c[n++]=v+o,c[n++]=L+o+1,c[n++]=L+o;if(Y){let z=f*r;for(t=1;t<f-2;t++)for(L=z+t*r,v=z+(t+1)*r,o=1;o<r-2;o++)c[n++]=v+o,c[n++]=L+o,c[n++]=L+o+1,c[n++]=v+o,c[n++]=L+o+1,c[n++]=v+o+1}let d,u;if(Y){if(X)for(u=f*r,t=1;t<r-2;t++)c[n++]=t,c[n++]=t+1,c[n++]=u+t+1,c[n++]=t,c[n++]=u+t+1,c[n++]=u+t;if(rt)for(d=f*r-r,u=f*r*B-r,t=1;t<r-2;t++)c[n++]=d+t+1,c[n++]=d+t,c[n++]=u+t,c[n++]=d+t+1,c[n++]=u+t,c[n++]=u+t+1}if(st){for(t=1;t<f-2;t++)u=r*f+r*t,d=r*t,c[n++]=u,c[n++]=d+r,c[n++]=d,c[n++]=u,c[n++]=u+r,c[n++]=d+r;for(t=1;t<f-2;t++)u=r*f+r*(t+1)-1,d=r*(t+1)-1,c[n++]=d+r,c[n++]=u,c[n++]=d,c[n++]=d+r,c[n++]=u+r,c[n++]=u}let E=new kt;a.position&&(E.position=new g({componentDatatype:R.DOUBLE,componentsPerAttribute:3,values:b}));let ut=0,tt=0,et=0,nt=0,vt=P/2,lt,pt=mt.fromCartesian3(m),yt=mt.fromCartesian3(i);if(a.st||a.normal||a.tangent||a.bitangent){for(t=0;t<P;t++){lt=Z[t]?yt:pt;let z=s.fromArray(b,t*3,Et),_;if(y===!0?(_=new s(0,0,1),_.clone(At)):_=lt.geodeticSurfaceNormal(z,At),at[t]&&s.negate(_,_),a.st){let C=ht.negate(_,Rt);K[ut++]=Math.atan2(C.y,C.x)/N.TWO_PI+.5,K[ut++]=Math.asin(_.z)/Math.PI+.5}if(a.normal&&(j[tt++]=_.x,j[tt++]=_.y,j[tt++]=_.z),a.tangent||a.bitangent){let C=Mt,it=0,ot;if(Z[t]&&(it=vt),!X&&t>=it&&t<it+r*2?ot=s.UNIT_X:ot=s.UNIT_Z,s.cross(ot,_,C),s.normalize(C,C),a.tangent&&(H[et++]=C.x,H[et++]=C.y,H[et++]=C.z),a.bitangent){let q=s.cross(_,C,Nt);s.normalize(q,q),J[nt++]=q.x,J[nt++]=q.y,J[nt++]=q.z}}}a.st&&(E.st=new g({componentDatatype:R.FLOAT,componentsPerAttribute:2,values:K})),a.normal&&(E.normal=new g({componentDatatype:R.FLOAT,componentsPerAttribute:3,values:j})),a.tangent&&(E.tangent=new g({componentDatatype:R.FLOAT,componentsPerAttribute:3,values:H})),a.bitangent&&(E.bitangent=new g({componentDatatype:R.FLOAT,componentsPerAttribute:3,values:J}))}if(M(e._offsetAttribute)){let z=b.length,_=e._offsetAttribute===Pt.NONE?0:1,C=new Uint8Array(z/3).fill(_);E.applyOffset=new g({componentDatatype:R.UNSIGNED_BYTE,componentsPerAttribute:1,values:C})}return new Ct({attributes:E,indices:c,primitiveType:dt.TRIANGLES,boundingSphere:_t.fromEllipsoid(pt),offsetAttribute:e._offsetAttribute})};var ct;O.getUnitEllipsoid=function(){return M(ct)||(ct=O.createGeometry(new O({radii:new s(1,1,1),vertexFormat:k.POSITION_ONLY}))),ct};var $t=O;export{$t as a};
