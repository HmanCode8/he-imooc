/**
 * @license
 * SceneGIS - https://github.com/CesiumGS/cesium
 * Version 1.97
 *
 * Copyright 2011-2022 SceneGIS Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./arrayRemoveDuplicates-0aca867d","./Transforms-c38817cd","./Matrix3-a45402cf","./ComponentDatatype-f194b981","./PolylineVolumeGeometryLibrary-797498c4","./CorridorGeometryLibrary-7cb9a15a","./defaultValue-192c850d","./GeometryAttribute-add8522c","./GeometryAttributes-fcaeebba","./GeometryOffsetAttribute-817c59a7","./IndexDatatype-1ff811be","./Math-be2c8494","./PolygonPipeline-2888ea37","./Matrix2-bce7772b","./VertexFormat-d2271f13","./_commonjsHelpers-f78443cf","./combine-b9b48e3c","./RuntimeError-ca280330","./WebGLConstants-1bcc99d3","./EllipsoidTangentPlane-b1a9b8da","./AxisAlignedBoundingBox-e6370b82","./IntersectionTests-f861e6a9","./Plane-f4b01105","./PolylinePipeline-1de62483","./EllipsoidGeodesic-35356ee4","./EllipsoidRhumbLine-c951aea3"],(function(t,e,r,a,i,o,n,s,l,d,u,c,m,f,y,p,h,g,b,C,A,_,w,v,V,T){"use strict";const G=new r.Cartesian3,E=new r.Cartesian3,x=new r.Cartesian3,P=new r.Cartesian3,L=new r.Cartesian3,F=new r.Cartesian3,N=new r.Cartesian3,M=new r.Cartesian3;function D(t,e){for(let r=0;r<t.length;r++)t[r]=e.scaleToGeodeticSurface(t[r],t[r]);return t}function O(t,e,a,i,n,s){const l=t.normals,d=t.tangents,u=t.bitangents,c=r.Cartesian3.normalize(r.Cartesian3.cross(a,e,N),N);s.normal&&o.CorridorGeometryLibrary.addAttribute(l,e,i,n),s.tangent&&o.CorridorGeometryLibrary.addAttribute(d,c,i,n),s.bitangent&&o.CorridorGeometryLibrary.addAttribute(u,a,i,n)}function I(t,e,i,d){const m=t.positions,f=t.corners,y=t.endPositions,p=t.lefts,h=t.normals;d=n.defaultValue(d,!1);const g=new l.GeometryAttributes;let b,C,A,_=0,w=0,v=0;for(C=0;C<m.length;C+=2)A=m[C].length-3,_+=A,v+=2*A,w+=m[C+1].length-3;for(_+=3,w+=3,C=0;C<f.length;C++){b=f[C];const t=f[C].leftPositions;n.defined(t)?(A=t.length,_+=A,v+=A):(A=f[C].rightPositions.length,w+=A,v+=A)}const V=n.defined(y);let T;V&&(T=y[0].length-3,_+=T,w+=T,T/=3,v+=6*T);const L=_+w,D=new Float64Array(L),I={normals:e.normal?new Float32Array(L):void 0,tangents:e.tangent?new Float32Array(L):void 0,bitangents:e.bitangent?new Float32Array(L):void 0};let S,R,k,z,H,B,U=0,Y=L-1,W=G,q=E;const j=T/2,J=u.IndexDatatype.createTypedArray(L/3,v);let K=0;if(V){B=x,H=P;const t=y[0];for(W=r.Cartesian3.fromArray(h,0,W),q=r.Cartesian3.fromArray(p,0,q),C=0;C<j;C++)B=r.Cartesian3.fromArray(t,3*(j-1-C),B),H=r.Cartesian3.fromArray(t,3*(j+C),H),o.CorridorGeometryLibrary.addAttribute(D,H,U),o.CorridorGeometryLibrary.addAttribute(D,B,void 0,Y),O(I,W,q,U,Y,e),R=U/3,z=R+1,S=(Y-2)/3,k=S-1,J[K++]=S,J[K++]=R,J[K++]=k,J[K++]=k,J[K++]=R,J[K++]=z,U+=3,Y-=3}let Q,X,Z=0,$=0,tt=m[Z++],et=m[Z++];for(D.set(tt,U),D.set(et,Y-et.length+1),q=r.Cartesian3.fromArray(p,$,q),A=et.length-3,C=0;C<A;C+=3)!0===d?(X=Q=new r.Cartesian3(0,0,1),Q.clone(N),X.clone(M)):(Q=i.geodeticSurfaceNormal(r.Cartesian3.fromArray(tt,C,N),N),X=i.geodeticSurfaceNormal(r.Cartesian3.fromArray(et,A-C,M),M)),W=r.Cartesian3.normalize(r.Cartesian3.add(Q,X,W),W),O(I,W,q,U,Y,e),R=U/3,z=R+1,S=(Y-2)/3,k=S-1,J[K++]=S,J[K++]=R,J[K++]=k,J[K++]=k,J[K++]=R,J[K++]=z,U+=3,Y-=3;for(!0===d?(X=Q=new r.Cartesian3(0,0,1),Q.clone(N),X.clone(M)):(Q=i.geodeticSurfaceNormal(r.Cartesian3.fromArray(tt,A,N),N),X=i.geodeticSurfaceNormal(r.Cartesian3.fromArray(et,A,M),M)),W=r.Cartesian3.normalize(r.Cartesian3.add(Q,X,W),W),$+=3,C=0;C<f.length;C++){let t;b=f[C];const a=b.leftPositions,s=b.rightPositions;let l,u,c=F,y=x,g=P;if(W=r.Cartesian3.fromArray(h,$,W),n.defined(a)){for(O(I,W,q,void 0,Y,e),Y-=3,l=z,u=k,t=0;t<a.length/3;t++)c=r.Cartesian3.fromArray(a,3*t,c),J[K++]=l,J[K++]=u-t-1,J[K++]=u-t,o.CorridorGeometryLibrary.addAttribute(D,c,void 0,Y),y=r.Cartesian3.fromArray(D,3*(u-t-1),y),g=r.Cartesian3.fromArray(D,3*l,g),q=r.Cartesian3.normalize(r.Cartesian3.subtract(y,g,q),q),O(I,W,q,void 0,Y,e),Y-=3;c=r.Cartesian3.fromArray(D,3*l,c),y=r.Cartesian3.subtract(r.Cartesian3.fromArray(D,3*u,y),c,y),g=r.Cartesian3.subtract(r.Cartesian3.fromArray(D,3*(u-t),g),c,g),q=r.Cartesian3.normalize(r.Cartesian3.add(y,g,q),q),O(I,W,q,U,void 0,e),U+=3}else{for(O(I,W,q,U,void 0,e),U+=3,l=k,u=z,t=0;t<s.length/3;t++)c=r.Cartesian3.fromArray(s,3*t,c),J[K++]=l,J[K++]=u+t,J[K++]=u+t+1,o.CorridorGeometryLibrary.addAttribute(D,c,U),y=r.Cartesian3.fromArray(D,3*l,y),g=r.Cartesian3.fromArray(D,3*(u+t),g),q=r.Cartesian3.normalize(r.Cartesian3.subtract(y,g,q),q),O(I,W,q,U,void 0,e),U+=3;c=r.Cartesian3.fromArray(D,3*l,c),y=r.Cartesian3.subtract(r.Cartesian3.fromArray(D,3*(u+t),y),c,y),g=r.Cartesian3.subtract(r.Cartesian3.fromArray(D,3*u,g),c,g),q=r.Cartesian3.normalize(r.Cartesian3.negate(r.Cartesian3.add(g,y,q),q),q),O(I,W,q,void 0,Y,e),Y-=3}for(tt=m[Z++],et=m[Z++],tt.splice(0,3),et.splice(et.length-3,3),D.set(tt,U),D.set(et,Y-et.length+1),A=et.length-3,$+=3,q=r.Cartesian3.fromArray(p,$,q),t=0;t<et.length;t+=3)!0===d?(X=Q=new r.Cartesian3(0,0,1),Q.clone(N),X.clone(M)):(Q=i.geodeticSurfaceNormal(r.Cartesian3.fromArray(tt,t,N),N),X=i.geodeticSurfaceNormal(r.Cartesian3.fromArray(et,A-t,M),M)),W=r.Cartesian3.normalize(r.Cartesian3.add(Q,X,W),W),O(I,W,q,U,Y,e),z=U/3,R=z-1,k=(Y-2)/3,S=k+1,J[K++]=S,J[K++]=R,J[K++]=k,J[K++]=k,J[K++]=R,J[K++]=z,U+=3,Y-=3;U-=3,Y+=3}if(W=r.Cartesian3.fromArray(h,h.length-3,W),O(I,W,q,U,Y,e),V){U+=3,Y-=3,B=x,H=P;const t=y[1];for(C=0;C<j;C++)B=r.Cartesian3.fromArray(t,3*(T-C-1),B),H=r.Cartesian3.fromArray(t,3*C,H),o.CorridorGeometryLibrary.addAttribute(D,B,void 0,Y),o.CorridorGeometryLibrary.addAttribute(D,H,U),O(I,W,q,U,Y,e),z=U/3,R=z-1,k=(Y-2)/3,S=k+1,J[K++]=S,J[K++]=R,J[K++]=k,J[K++]=k,J[K++]=R,J[K++]=z,U+=3,Y-=3}if(g.position=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:D}),e.st){const t=new Float32Array(L/3*2);let e,r,i=0;if(V){_/=3,w/=3;const a=Math.PI/(T+1);let o;r=1/(_-T+1),e=1/(w-T+1);const n=T/2;for(C=n+1;C<T+1;C++)o=c.CesiumMath.PI_OVER_TWO+a*C,t[i++]=e*(1+Math.cos(o)),t[i++]=.5*(1+Math.sin(o));for(C=1;C<w-T+1;C++)t[i++]=C*e,t[i++]=0;for(C=T;C>n;C--)o=c.CesiumMath.PI_OVER_TWO-C*a,t[i++]=1-e*(1+Math.cos(o)),t[i++]=.5*(1+Math.sin(o));for(C=n;C>0;C--)o=c.CesiumMath.PI_OVER_TWO-a*C,t[i++]=1-r*(1+Math.cos(o)),t[i++]=.5*(1+Math.sin(o));for(C=_-T;C>0;C--)t[i++]=C*r,t[i++]=1;for(C=1;C<n+1;C++)o=c.CesiumMath.PI_OVER_TWO+a*C,t[i++]=r*(1+Math.cos(o)),t[i++]=.5*(1+Math.sin(o))}else{for(_/=3,w/=3,r=1/(_-1),e=1/(w-1),C=0;C<w;C++)t[i++]=C*e,t[i++]=0;for(C=_;C>0;C--)t[i++]=(C-1)*r,t[i++]=1}g.st=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:t})}return e.normal&&(g.normal=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:I.normals})),e.tangent&&(g.tangent=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:I.tangents})),e.bitangent&&(g.bitangent=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:I.bitangents})),{attributes:g,indices:J}}function S(t,e,r){r[e++]=t[0],r[e++]=t[1],r[e++]=t[2];for(let a=3;a<t.length;a+=3){const i=t[a],o=t[a+1],n=t[a+2];r[e++]=i,r[e++]=o,r[e++]=n,r[e++]=i,r[e++]=o,r[e++]=n}return r[e++]=t[0],r[e++]=t[1],r[e++]=t[2],r}function R(t,e){const i=new y.VertexFormat({position:e.position,normal:e.normal||e.bitangent||t.shadowVolume,tangent:e.tangent,bitangent:e.normal||e.bitangent,st:e.st}),l=t.ellipsoid,c=o.CorridorGeometryLibrary.computePositions(t),f=t.planeView,p=I(c,i,l,f),h=t.height,g=t.extrudedHeight;let b=p.attributes;const C=p.indices;let A=b.position.values,_=A.length;const w=new Float64Array(6*_);let v=new Float64Array(_);v.set(A);let V,T=new Float64Array(4*_);A=m.PolygonPipeline.scaleToGeodeticHeight(A,h,l,void 0,f),T=S(A,0,T),v=m.PolygonPipeline.scaleToGeodeticHeight(v,g,l,void 0,f),T=S(v,2*_,T),w.set(A),w.set(v,_),w.set(T,2*_),b.position.values=w,b=function(t,e){if(!(e.normal||e.tangent||e.bitangent||e.st))return t;const a=t.position.values;let i,n;(e.normal||e.bitangent)&&(i=t.normal.values,n=t.bitangent.values);const s=t.position.values.length/18,l=3*s,d=2*s,u=2*l;let c;if(e.normal||e.bitangent||e.tangent){const s=e.normal?new Float32Array(6*l):void 0,d=e.tangent?new Float32Array(6*l):void 0,m=e.bitangent?new Float32Array(6*l):void 0;let f=G,y=E,p=x,h=P,g=L,b=F,C=u;for(c=0;c<l;c+=3){const t=C+u;f=r.Cartesian3.fromArray(a,c,f),y=r.Cartesian3.fromArray(a,c+l,y),p=r.Cartesian3.fromArray(a,(c+3)%l,p),y=r.Cartesian3.subtract(y,f,y),p=r.Cartesian3.subtract(p,f,p),h=r.Cartesian3.normalize(r.Cartesian3.cross(y,p,h),h),e.normal&&(o.CorridorGeometryLibrary.addAttribute(s,h,t),o.CorridorGeometryLibrary.addAttribute(s,h,t+3),o.CorridorGeometryLibrary.addAttribute(s,h,C),o.CorridorGeometryLibrary.addAttribute(s,h,C+3)),(e.tangent||e.bitangent)&&(b=r.Cartesian3.fromArray(i,c,b),e.bitangent&&(o.CorridorGeometryLibrary.addAttribute(m,b,t),o.CorridorGeometryLibrary.addAttribute(m,b,t+3),o.CorridorGeometryLibrary.addAttribute(m,b,C),o.CorridorGeometryLibrary.addAttribute(m,b,C+3)),e.tangent&&(g=r.Cartesian3.normalize(r.Cartesian3.cross(b,h,g),g),o.CorridorGeometryLibrary.addAttribute(d,g,t),o.CorridorGeometryLibrary.addAttribute(d,g,t+3),o.CorridorGeometryLibrary.addAttribute(d,g,C),o.CorridorGeometryLibrary.addAttribute(d,g,C+3))),C+=6}if(e.normal){for(s.set(i),c=0;c<l;c+=3)s[c+l]=-i[c],s[c+l+1]=-i[c+1],s[c+l+2]=-i[c+2];t.normal.values=s}else t.normal=void 0;if(e.bitangent?(m.set(n),m.set(n,l),t.bitangent.values=m):t.bitangent=void 0,e.tangent){const e=t.tangent.values;d.set(e),d.set(e,l),t.tangent.values=d}}if(e.st){const e=t.st.values,r=new Float32Array(6*d);r.set(e),r.set(e,d);let a=2*d;for(let t=0;t<2;t++){for(r[a++]=e[0],r[a++]=e[1],c=2;c<d;c+=2){const t=e[c],i=e[c+1];r[a++]=t,r[a++]=i,r[a++]=t,r[a++]=i}r[a++]=e[0],r[a++]=e[1]}t.st.values=r}return t}(b,e);const N=_/3;if(t.shadowVolume){const t=b.normal.values;_=t.length;let r=new Float32Array(6*_);for(V=0;V<_;V++)t[V]=-t[V];r.set(t,_),r=S(t,4*_,r),b.extrudeDirection=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:r}),e.normal||(b.normal=void 0)}if(n.defined(t.offsetAttribute)){let e=new Uint8Array(6*N);if(t.offsetAttribute===d.GeometryOffsetAttribute.TOP)e=e.fill(1,0,N).fill(1,2*N,4*N);else{const r=t.offsetAttribute===d.GeometryOffsetAttribute.NONE?0:1;e=e.fill(r)}b.applyOffset=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}const M=C.length,D=N+N,O=u.IndexDatatype.createTypedArray(w.length/3,2*M+3*D);O.set(C);let R,k,z,H,B=M;for(V=0;V<M;V+=3){const t=C[V],e=C[V+1],r=C[V+2];O[B++]=r+N,O[B++]=e+N,O[B++]=t+N}for(V=0;V<D;V+=2)R=V+D,k=R+D,z=R+1,H=k+1,O[B++]=R,O[B++]=k,O[B++]=z,O[B++]=z,O[B++]=k,O[B++]=H;return{attributes:b,indices:O}}const k=new r.Cartesian3,z=new r.Cartesian3,H=new r.Cartographic;function B(t,e,a,i,o,s,l){l=n.defaultValue(l,!1);const d=r.Cartesian3.subtract(e,t,k);r.Cartesian3.normalize(d,d);let u=z;!0===l?(u=new r.Cartesian3(0,0,1),u.clone(z)):u=a.geodeticSurfaceNormal(t,z);const c=r.Cartesian3.cross(d,u,k);r.Cartesian3.multiplyByScalar(c,i,c);let m=o.latitude,f=o.longitude,y=s.latitude,p=s.longitude;r.Cartesian3.add(t,c,z),!0===l?(H.longitude=z.x,H.latitude=z.y,H.height=z.z):a.cartesianToCartographic(z,H);let h=H.latitude,g=H.longitude;m=Math.min(m,h),f=Math.min(f,g),y=Math.max(y,h),p=Math.max(p,g),r.Cartesian3.subtract(t,c,z),!0===l?(H.longitude=z.x,H.latitude=z.y,H.height=z.z):a.cartesianToCartographic(z,H),h=H.latitude,g=H.longitude,m=Math.min(m,h),f=Math.min(f,g),y=Math.max(y,h),p=Math.max(p,g),o.latitude=m,o.longitude=f,s.latitude=y,s.longitude=p}const U=new r.Cartesian3,Y=new r.Cartesian3,W=new r.Cartographic,q=new r.Cartographic;function j(e,a,o,s,l,d){!1===(d=n.defaultValue(d,!1))&&(e=D(e,a));const u=t.arrayRemoveDuplicates(e,r.Cartesian3.equalsEpsilon),c=u.length;if(c<2||o<=0)return new f.Rectangle;const m=.5*o;let y,p;if(W.latitude=Number.POSITIVE_INFINITY,W.longitude=Number.POSITIVE_INFINITY,q.latitude=Number.NEGATIVE_INFINITY,q.longitude=Number.NEGATIVE_INFINITY,s===i.CornerType.ROUNDED){const t=u[0];r.Cartesian3.subtract(t,u[1],U),r.Cartesian3.normalize(U,U),r.Cartesian3.multiplyByScalar(U,m,U),r.Cartesian3.add(t,U,Y),!0===d?(H.longitude=Y.x,H.latitude=Y.y,H.height=Y.z):a.cartesianToCartographic(Y,H),y=H.latitude,p=H.longitude,W.latitude=Math.min(W.latitude,y),W.longitude=Math.min(W.longitude,p),q.latitude=Math.max(q.latitude,y),q.longitude=Math.max(q.longitude,p)}for(let t=0;t<c-1;++t)B(u[t],u[t+1],a,m,W,q,d);const h=u[c-1];r.Cartesian3.subtract(h,u[c-2],U),r.Cartesian3.normalize(U,U),r.Cartesian3.multiplyByScalar(U,m,U),r.Cartesian3.add(h,U,Y),B(h,Y,a,m,W,q,d),s===i.CornerType.ROUNDED&&(!0===d?(H.longitude=Y.x,H.latitude=Y.y,H.height=Y.z):a.cartesianToCartographic(Y,H),y=H.latitude,p=H.longitude,W.latitude=Math.min(W.latitude,y),W.longitude=Math.min(W.longitude,p),q.latitude=Math.max(q.latitude,y),q.longitude=Math.max(q.longitude,p));const g=n.defined(l)?l:new f.Rectangle;return g.north=q.latitude,g.south=W.latitude,g.east=q.longitude,g.west=W.longitude,!0===d&&(g.north+=1e3,g.south-=1e3,g.east+=1e3,g.west-=1e3),g._planeView=d,g}function J(t){const e=(t=n.defaultValue(t,n.defaultValue.EMPTY_OBJECT)).positions,a=t.width,o=n.defaultValue(t.planeView,!1),s=n.defaultValue(t.height,0),l=n.defaultValue(t.extrudedHeight,s);this._positions=e,this._ellipsoid=r.Ellipsoid.clone(n.defaultValue(t.ellipsoid,r.Ellipsoid.WGS84)),this._vertexFormat=y.VertexFormat.clone(n.defaultValue(t.vertexFormat,y.VertexFormat.DEFAULT)),this._width=a,this._height=Math.max(s,l),this._extrudedHeight=Math.min(s,l),this._cornerType=n.defaultValue(t.cornerType,i.CornerType.ROUNDED),this._granularity=n.defaultValue(t.granularity,c.CesiumMath.RADIANS_PER_DEGREE),this._shadowVolume=n.defaultValue(t.shadowVolume,!1),this._workerName="createCorridorGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this._planeView=o,this._totalPositions=void 0,this._leftPositions=void 0,this.packedLength=1+e.length*r.Cartesian3.packedLength+r.Ellipsoid.packedLength+y.VertexFormat.packedLength+7}J.pack=function(t,e,a){a=n.defaultValue(a,0);const i=t._positions,o=i.length;e[a++]=o;for(let t=0;t<o;++t,a+=r.Cartesian3.packedLength)r.Cartesian3.pack(i[t],e,a);return r.Ellipsoid.pack(t._ellipsoid,e,a),a+=r.Ellipsoid.packedLength,y.VertexFormat.pack(t._vertexFormat,e,a),a+=y.VertexFormat.packedLength,e[a++]=t._width,e[a++]=t._height,e[a++]=t._extrudedHeight,e[a++]=t._cornerType,e[a++]=t._granularity,e[a++]=t._shadowVolume?1:0,e[a]=n.defaultValue(t._offsetAttribute,-1),e};const K=r.Ellipsoid.clone(r.Ellipsoid.UNIT_SPHERE),Q=new y.VertexFormat,X={positions:void 0,ellipsoid:K,vertexFormat:Q,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};return J.unpack=function(t,e,a,i){e=n.defaultValue(e,0);const o=t[e++],s=new Array(o);for(let a=0;a<o;++a,e+=r.Cartesian3.packedLength)s[a]=r.Cartesian3.unpack(t,e);const l=r.Ellipsoid.unpack(t,e,K);e+=r.Ellipsoid.packedLength;const d=y.VertexFormat.unpack(t,e,Q);e+=y.VertexFormat.packedLength;const u=t[e++],c=t[e++],m=t[e++],f=t[e++],p=t[e++],h=1===t[e++],g=t[e];return n.defined(a)?(a._positions=s,a._ellipsoid=r.Ellipsoid.clone(l,a._ellipsoid),a._vertexFormat=y.VertexFormat.clone(d,a._vertexFormat),a._width=u,a._height=c,a._extrudedHeight=m,a._cornerType=f,a._granularity=p,a._shadowVolume=h,a._offsetAttribute=-1===g?void 0:g,a._planeView=n.defaultValue(i,!1),a):(X.positions=s,X.width=u,X.height=c,X.extrudedHeight=m,X.cornerType=f,X.granularity=p,X.shadowVolume=h,X.offsetAttribute=-1===g?void 0:g,X.planeView=i,new J(X))},J.computeRectangle=function(t,e){const a=(t=n.defaultValue(t,n.defaultValue.EMPTY_OBJECT)).positions,o=t.width;return j(a,n.defaultValue(t.ellipsoid,r.Ellipsoid.WGS84),o,n.defaultValue(t.cornerType,i.CornerType.ROUNDED),e,n.defaultValue(t.planeView,!1))},J.createGeometry=function(i){let l=i._positions;const u=i._width,f=i._ellipsoid,y=i._planeView;!1===y&&(l=D(l,f));const p=t.arrayRemoveDuplicates(l,r.Cartesian3.equalsEpsilon);if(p.length<2||u<=0)return;const h=i._height,g=i._extrudedHeight,b=!c.CesiumMath.equalsEpsilon(h,g,0,c.CesiumMath.EPSILON2),C=i._vertexFormat,A={ellipsoid:f,positions:p,width:u,cornerType:i._cornerType,granularity:i._granularity,saveAttributes:!0};let _;if(b)A.height=h,A.extrudedHeight=g,A.shadowVolume=i._shadowVolume,A.offsetAttribute=i._offsetAttribute,A.planeView=y,_=R(A,C);else{A.planeView=y;const t=o.CorridorGeometryLibrary.computePositions(A);if(i._leftPositions=t.lefts,_=I(t,C,f),_.attributes.position.values=m.PolygonPipeline.scaleToGeodeticHeight(_.attributes.position.values,h,f,void 0,y),n.defined(i._offsetAttribute)){const t=i._offsetAttribute===d.GeometryOffsetAttribute.NONE?0:1,e=_.attributes.position.values.length,r=new Uint8Array(e/3).fill(t);_.attributes.applyOffset=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}}const w=_.attributes,v=e.BoundingSphere.fromVertices(w.position.values,void 0,3);return i._totalPositions=_.attributes.position.values.slice(),C.position||(_.attributes.position.values=void 0),new s.Geometry({attributes:w,indices:_.indices,primitiveType:s.PrimitiveType.TRIANGLES,boundingSphere:v,offsetAttribute:i._offsetAttribute})},J.createShadowVolume=function(t,e,r,a){const i=t._granularity,o=t._ellipsoid,n=e(i,o),s=r(i,o);return new J({positions:t._positions,width:t._width,cornerType:t._cornerType,ellipsoid:o,granularity:i,extrudedHeight:n,height:s,vertexFormat:y.VertexFormat.POSITION_ONLY,shadowVolume:!0,planeView:a})},Object.defineProperties(J.prototype,{rectangle:{get:function(){return n.defined(this._rectangle)||(this._rectangle=j(this._positions,this._ellipsoid,this._width,this._cornerType,void 0,this._planeView)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}}),function(t,e,a){return n.defined(e)&&(t=J.unpack(t,e,void 0,a)),t._ellipsoid=r.Ellipsoid.clone(t._ellipsoid),J.createGeometry(t)}}));
