/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.114
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

import{a as W}from"./chunk-H3IXAINZ.js";import{a as Z}from"./chunk-Y3QWB4WF.js";import{a as X}from"./chunk-KJJSAVM5.js";import{b as K,c as Q,d as U}from"./chunk-5JJAXZP5.js";import{d as H}from"./chunk-XIY2HUS2.js";import{a as y}from"./chunk-PF7ABWYW.js";import{a as u,d as J}from"./chunk-KXWBEOUA.js";import{a as V}from"./chunk-4BEFMW7D.js";import{a as r}from"./chunk-2F4MHS2T.js";import{a as w}from"./chunk-3Z2AZRQC.js";import{e as E}from"./chunk-A5XXOFX2.js";var ii=new u(1,1,1),B=Math.cos,S=Math.sin;function L(t){t=r(t,r.EMPTY_OBJECT);let n=r(t.radii,ii),o=r(t.innerRadii,n),_=r(t.minimumClock,0),A=r(t.maximumClock,V.TWO_PI),l=r(t.minimumCone,0),b=r(t.maximumCone,V.PI),s=Math.round(r(t.stackPartitions,10)),O=Math.round(r(t.slicePartitions,8)),m=Math.round(r(t.subdivisions,128)),f=r(t.planeView,!1);if(s<1)throw new w("options.stackPartitions cannot be less than 1");if(O<0)throw new w("options.slicePartitions cannot be less than 0");if(m<0)throw new w("options.subdivisions must be greater than or equal to zero.");if(E(t.offsetAttribute)&&t.offsetAttribute===W.TOP)throw new w("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._radii=u.clone(n),this._innerRadii=u.clone(o),this._minimumClock=_,this._maximumClock=A,this._minimumCone=l,this._maximumCone=b,this._stackPartitions=s,this._slicePartitions=O,this._subdivisions=m,this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidOutlineGeometry",this._planeView=f}L.packedLength=2*u.packedLength+8;L.pack=function(t,n,o){if(!E(t))throw new w("value is required");if(!E(n))throw new w("array is required");return o=r(o,0),u.pack(t._radii,n,o),o+=u.packedLength,u.pack(t._innerRadii,n,o),o+=u.packedLength,n[o++]=t._minimumClock,n[o++]=t._maximumClock,n[o++]=t._minimumCone,n[o++]=t._maximumCone,n[o++]=t._stackPartitions,n[o++]=t._slicePartitions,n[o++]=t._subdivisions,n[o]=r(t._offsetAttribute,-1),n};var $=new u,G=new u,k={radii:$,innerRadii:G,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,subdivisions:void 0,offsetAttribute:void 0};L.unpack=function(t,n,o,_){if(!E(t))throw new w("array is required");n=r(n,0);let A=u.unpack(t,n,$);n+=u.packedLength;let l=u.unpack(t,n,G);n+=u.packedLength;let b=t[n++],s=t[n++],O=t[n++],m=t[n++],f=t[n++],v=t[n++],p=t[n++],C=t[n];return E(o)?(o._radii=u.clone(A,o._radii),o._innerRadii=u.clone(l,o._innerRadii),o._minimumClock=b,o._maximumClock=s,o._minimumCone=O,o._maximumCone=m,o._stackPartitions=f,o._slicePartitions=v,o._subdivisions=p,o._offsetAttribute=C===-1?void 0:C,o._planeView=r(_,!1),o):(k.minimumClock=b,k.maximumClock=s,k.minimumCone=O,k.maximumCone=m,k.stackPartitions=f,k.slicePartitions=v,k.subdivisions=p,k.offsetAttribute=C===-1?void 0:C,k.planeView=r(_,!1),new L(k))};L.createGeometry=function(t){let n=t._radii;if(n.x<=0||n.y<=0||n.z<=0)return;let o=t._innerRadii;if(o.x<=0||o.y<=0||o.z<=0)return;let _=t._minimumClock,A=t._maximumClock,l=t._minimumCone,b=t._maximumCone,s=t._subdivisions,O=J.fromCartesian3(n),m=t._slicePartitions+1,f=t._stackPartitions+1;m=Math.round(m*Math.abs(A-_)/V.TWO_PI),f=Math.round(f*Math.abs(b-l)/V.PI),m<2&&(m=2),f<2&&(f=2);let v=0,p=1,C=o.x!==n.x||o.y!==n.y||o.z!==n.z,Y=!1,j=!1;C&&(p=2,l>0&&(Y=!0,v+=m),b<Math.PI&&(j=!0,v+=m));let q=s*p*(f+m),a=new Float64Array(q*3),g=2*(q+v-(m+f)*p),h=Z.createTypedArray(q,g),i,e,z,x,c=0,d=new Array(f),M=new Array(f);for(i=0;i<f;i++)x=l+i*(b-l)/(f-1),d[i]=S(x),M[i]=B(x);let R=new Array(s),T=new Array(s);for(i=0;i<s;i++)z=_+i*(A-_)/(s-1),R[i]=S(z),T[i]=B(z);for(i=0;i<f;i++)for(e=0;e<s;e++)a[c++]=n.x*d[i]*T[e],a[c++]=n.y*d[i]*R[e],a[c++]=n.z*M[i];if(C)for(i=0;i<f;i++)for(e=0;e<s;e++)a[c++]=o.x*d[i]*T[e],a[c++]=o.y*d[i]*R[e],a[c++]=o.z*M[i];for(d.length=s,M.length=s,i=0;i<s;i++)x=l+i*(b-l)/(s-1),d[i]=S(x),M[i]=B(x);for(R.length=m,T.length=m,i=0;i<m;i++)z=_+i*(A-_)/(m-1),R[i]=S(z),T[i]=B(z);for(i=0;i<s;i++)for(e=0;e<m;e++)a[c++]=n.x*d[i]*T[e],a[c++]=n.y*d[i]*R[e],a[c++]=n.z*M[i];if(C)for(i=0;i<s;i++)for(e=0;e<m;e++)a[c++]=o.x*d[i]*T[e],a[c++]=o.y*d[i]*R[e],a[c++]=o.z*M[i];for(c=0,i=0;i<f*p;i++){let P=i*s;for(e=0;e<s-1;e++)h[c++]=P+e,h[c++]=P+e+1}let D=f*s*p;for(i=0;i<m;i++)for(e=0;e<s-1;e++)h[c++]=D+i+e*m,h[c++]=D+i+(e+1)*m;if(C)for(D=f*s*p+m*s,i=0;i<m;i++)for(e=0;e<s-1;e++)h[c++]=D+i+e*m,h[c++]=D+i+(e+1)*m;if(C){let P=f*s*p,N=P+s*m;if(Y)for(i=0;i<m;i++)h[c++]=P+i,h[c++]=N+i;if(j)for(P+=s*m-m,N+=s*m-m,i=0;i<m;i++)h[c++]=P+i,h[c++]=N+i}let F=new X({position:new U({componentDatatype:y.DOUBLE,componentsPerAttribute:3,values:a})});if(E(t._offsetAttribute)){let P=a.length,N=t._offsetAttribute===W.NONE?0:1,I=new Uint8Array(P/3).fill(N);F.applyOffset=new U({componentDatatype:y.UNSIGNED_BYTE,componentsPerAttribute:1,values:I})}return new Q({attributes:F,indices:h,primitiveType:K.LINES,boundingSphere:H.fromEllipsoid(O),offsetAttribute:t._offsetAttribute})};var li=L;export{li as a};
