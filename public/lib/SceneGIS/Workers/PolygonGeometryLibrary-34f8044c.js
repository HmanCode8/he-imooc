/**
 * @license
 * SceneGIS - https://github.com/CesiumGS/cesium
 * Version 1.97
 *
 * Copyright 2011-2022 SceneGIS Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["exports","./ArcType-d7935178","./arrayRemoveDuplicates-0aca867d","./Matrix2-bce7772b","./Matrix3-a45402cf","./ComponentDatatype-f194b981","./defaultValue-192c850d","./EllipsoidRhumbLine-c951aea3","./GeometryAttribute-add8522c","./GeometryAttributes-fcaeebba","./GeometryPipeline-be1ab56a","./IndexDatatype-1ff811be","./Math-be2c8494","./PolygonPipeline-2888ea37","./Transforms-c38817cd"],(function(e,t,n,i,o,r,a,s,c,l,u,h,f,d,p){"use strict";function y(){this._array=[],this._offset=0,this._length=0}Object.defineProperties(y.prototype,{length:{get:function(){return this._length}}}),y.prototype.enqueue=function(e){this._array.push(e),this._length++},y.prototype.dequeue=function(){if(0===this._length)return;const e=this._array;let t=this._offset;const n=e[t];return e[t]=void 0,t++,t>10&&2*t>e.length&&(this._array=e.slice(t),t=0),this._offset=t,this._length--,n},y.prototype.peek=function(){if(0!==this._length)return this._array[this._offset]},y.prototype.contains=function(e){return-1!==this._array.indexOf(e)},y.prototype.clear=function(){this._array.length=this._offset=this._length=0},y.prototype.sort=function(e){this._offset>0&&(this._array=this._array.slice(this._offset),this._offset=0),this._array.sort(e)};const g={computeHierarchyPackedLength:function(e,t){let n=0;const i=[e];for(;i.length>0;){const e=i.pop();if(!a.defined(e))continue;n+=2;const o=e.positions,r=e.holes;if(a.defined(o)&&o.length>0&&(n+=o.length*t.packedLength),a.defined(r)){const e=r.length;for(let t=0;t<e;++t)i.push(r[t])}}return n},packPolygonHierarchy:function(e,t,n,i){const o=[e];for(;o.length>0;){const e=o.pop();if(!a.defined(e))continue;const r=e.positions,s=e.holes;if(t[n++]=a.defined(r)?r.length:0,t[n++]=a.defined(s)?s.length:0,a.defined(r)){const e=r.length;for(let o=0;o<e;++o,n+=i.packedLength)i.pack(r[o],t,n)}if(a.defined(s)){const e=s.length;for(let t=0;t<e;++t)o.push(s[t])}}return n},unpackPolygonHierarchy:function(e,t,n){const i=e[t++],o=e[t++],r=new Array(i),a=o>0?new Array(o):void 0;for(let o=0;o<i;++o,t+=n.packedLength)r[o]=n.unpack(e,t);for(let i=0;i<o;++i)a[i]=g.unpackPolygonHierarchy(e,t,n),t=a[i].startingIndex,delete a[i].startingIndex;return{positions:r,holes:a,startingIndex:t}}},m=new i.Cartesian2;function C(e,t,n,o){return i.Cartesian2.subtract(t,e,m),i.Cartesian2.multiplyByScalar(m,n/o,m),i.Cartesian2.add(e,m,m),[m.x,m.y]}const b=new o.Cartesian3;function x(e,t,n,i){return o.Cartesian3.subtract(t,e,b),o.Cartesian3.multiplyByScalar(b,n/i,b),o.Cartesian3.add(e,b,b),[b.x,b.y,b.z]}g.subdivideLineCount=function(e,t,n){const i=o.Cartesian3.distance(e,t)/n,r=Math.max(0,Math.ceil(f.CesiumMath.log2(i)));return Math.pow(2,r)};const w=new o.Cartographic,T=new o.Cartographic,v=new o.Cartographic,A=new o.Cartesian3,L=new s.EllipsoidRhumbLine;g.subdivideRhumbLineCount=function(e,t,n,i){const o=e.cartesianToCartographic(t,w),r=e.cartesianToCartographic(n,T),a=new s.EllipsoidRhumbLine(o,r,e).surfaceDistance/i,c=Math.max(0,Math.ceil(f.CesiumMath.log2(a)));return Math.pow(2,c)},g.subdivideTexcoordLine=function(e,t,n,o,r,a){const s=g.subdivideLineCount(n,o,r),c=i.Cartesian2.distance(e,t),l=c/s,u=a;u.length=2*s;let h=0;for(let n=0;n<s;n++){const i=C(e,t,n*l,c);u[h++]=i[0],u[h++]=i[1]}return u},g.subdivideLine=function(e,t,n,i){const r=g.subdivideLineCount(e,t,n),s=o.Cartesian3.distance(e,t),c=s/r;a.defined(i)||(i=[]);const l=i;l.length=3*r;let u=0;for(let n=0;n<r;n++){const i=x(e,t,n*c,s);l[u++]=i[0],l[u++]=i[1],l[u++]=i[2]}return l},g.subdivideTexcoordRhumbLine=function(e,t,n,o,r,a,s){const c=n.cartesianToCartographic(o,w),l=n.cartesianToCartographic(r,T);L.setEndPoints(c,l);const u=L.surfaceDistance/a,h=Math.max(0,Math.ceil(f.CesiumMath.log2(u))),d=Math.pow(2,h),p=i.Cartesian2.distance(e,t),y=p/d,g=s;g.length=2*d;let m=0;for(let n=0;n<d;n++){const i=C(e,t,n*y,p);g[m++]=i[0],g[m++]=i[1]}return g},g.subdivideRhumbLine=function(e,t,n,i,o){const r=e.cartesianToCartographic(t,w),c=e.cartesianToCartographic(n,T),l=new s.EllipsoidRhumbLine(r,c,e),u=l.surfaceDistance/i,h=Math.max(0,Math.ceil(f.CesiumMath.log2(u))),d=Math.pow(2,h),p=l.surfaceDistance/d;a.defined(o)||(o=[]);const y=o;y.length=3*d;let g=0;for(let t=0;t<d;t++){const n=l.interpolateUsingSurfaceDistance(t*p,v),i=e.cartographicToCartesian(n,A);y[g++]=i.x,y[g++]=i.y,y[g++]=i.z}return y};const E=new o.Cartesian3,I=new o.Cartesian3,M=new o.Cartesian3,P=new o.Cartesian3;g.scaleToGeodeticHeightExtruded=function(e,t,n,i,r,s){i=a.defaultValue(i,o.Ellipsoid.WGS84);const c=E;let l=I;const u=M;let h=P;if(a.defined(e)&&a.defined(e.attributes)&&a.defined(e.attributes.position)){const f=e.attributes.position.values,d=f.length/2;for(let e=0;e<d;e+=3){if(o.Cartesian3.fromArray(f,e,u),a.defined(s)&&!0===s){new o.Cartesian3(0,0,1).clone(c),u.clone(h),h.z=0,l=o.Cartesian3.multiplyByScalar(c,n,l),l=o.Cartesian3.add(h,l,l)}else i.geodeticSurfaceNormal(u,c),h=i.scaleToGeodeticSurface(u,h),l=o.Cartesian3.multiplyByScalar(c,n,l),l=o.Cartesian3.add(h,l,l);f[e+d]=l.x,f[e+1+d]=l.y,f[e+2+d]=l.z,r&&(h=o.Cartesian3.clone(u,h)),l=o.Cartesian3.multiplyByScalar(c,t,l),l=a.defined(s)&&!0===s?o.Cartesian3.add(u,l,l):o.Cartesian3.add(h,l,l),f[e]=l.x,f[e+1]=l.y,f[e+2]=l.z}}return e},g.polygonOutlinesFromHierarchy=function(e,t,i,r){r=a.defaultValue(r,!1);const s=[],c=new y;let l,u,h;for(c.enqueue(e);0!==c.length;){const e=c.dequeue();let f=e.positions;if(t)for(h=f.length,l=0;l<h;l++)!1===r?i.scaleToGeodeticSurface(f[l],f[l]):f[l].z=0;if(f=n.arrayRemoveDuplicates(f,o.Cartesian3.equalsEpsilon,!0),f.length<3)continue;const d=e.holes?e.holes.length:0;for(l=0;l<d;l++){const f=e.holes[l];let d=f.positions;if(t)for(h=d.length,u=0;u<h;++u)!1===r?i.scaleToGeodeticSurface(d[u],d[u]):d[u].z=0;if(d=n.arrayRemoveDuplicates(d,o.Cartesian3.equalsEpsilon,!0),d.length<3)continue;s.push(d);let p=0;for(a.defined(f.holes)&&(p=f.holes.length),u=0;u<p;u++)c.enqueue(f.holes[u])}s.push(f)}return s},g.polygonsFromHierarchy=function(e,t,r,s,c,l){l=a.defaultValue(l,!1);const u=[],h=[],f=new y;for(f.enqueue(e);0!==f.length;){const e=f.dequeue();let p=e.positions;const y=e.holes;let g,m;if(s)for(m=p.length,g=0;g<m;g++)a.defined(l)&&!1!==l?p[g].z=0:c.scaleToGeodeticSurface(p[g],p[g]);if(t||(p=n.arrayRemoveDuplicates(p,o.Cartesian3.equalsEpsilon,!0)),p.length<3)continue;let C=[];if(!0===l){const e=new i.Cartesian2;for(const t of p)e.x+=t.x,e.y+=t.y;e.x=e.x/p.length,e.y=e.y/p.length;for(const t of p){const n=i.Cartesian2.fromCartesian3(t);n.x-=e.x,n.y-=e.y,C.push(n)}}else C=r(p);if(!a.defined(C))continue;const b=[];let x=d.PolygonPipeline.computeWindingOrder2D(C);x===d.WindingOrder.CLOCKWISE&&(C.reverse(),p=p.slice().reverse());let w=p.slice();const T=a.defined(y)?y.length:0,v=[];let A;for(g=0;g<T;g++){const e=y[g];let u=e.positions;if(s)for(m=u.length,A=0;A<m;++A)a.defined(l)&&!1!==l?u[A].z=0:c.scaleToGeodeticSurface(u[A],u[A]);if(t||(u=n.arrayRemoveDuplicates(u,o.Cartesian3.equalsEpsilon,!0)),u.length<3)continue;let h=[];if(!0===l){const e=new i.Cartesian2;for(const t of u)e.x+=t.x,e.y+=t.y;e.x=e.x/u.length,e.y=e.y/u.length;for(const t of u){const n=i.Cartesian2.fromCartesian3(t);n.x-=e.x,n.y-=e.y,h.push(n)}}else h=r(u);if(!a.defined(h))continue;x=d.PolygonPipeline.computeWindingOrder2D(h),x===d.WindingOrder.CLOCKWISE&&(h.reverse(),u=u.slice().reverse()),v.push(u),b.push(w.length),w=w.concat(u),C=C.concat(h);let p=0;for(a.defined(e.holes)&&(p=e.holes.length),A=0;A<p;A++)f.enqueue(e.holes[A])}u.push({outerRing:p,holes:v}),h.push({positions:w,positions2D:C,holes:b})}return{hierarchy:u,polygons:h}};const D=new i.Cartesian2,_=new o.Cartesian3,G=new p.Quaternion,S=new o.Matrix3;g.computeBoundingRectangle=function(e,t,n,r,s,c){c=a.defaultValue(c,!1);const l=p.Quaternion.fromAxisAngle(e,r,G),u=o.Matrix3.fromQuaternion(l,S);let h=Number.POSITIVE_INFINITY,f=Number.NEGATIVE_INFINITY,d=Number.POSITIVE_INFINITY,y=Number.NEGATIVE_INFINITY;const g=n.length;for(let e=0;e<g;++e){const r=o.Cartesian3.clone(n[e],_);o.Matrix3.multiplyByVector(u,r,r);let s=D;s=!0===c?i.Cartesian2.fromCartesian3(r,D):t(r,D),a.defined(s)&&(h=Math.min(h,s.x),f=Math.max(f,s.x),d=Math.min(d,s.y),y=Math.max(y,s.y))}return s.x=h,s.y=d,s.width=f-h,s.height=y-d,s},g.createGeometryFromPositions=function(e,n,o,s,l,h,f,p){let y=d.PolygonPipeline.triangulate(n.positions2D,n.holes);y.length<3&&(y=[0,1,2]);const g=n.positions,m=a.defined(o),C=m?o.positions:void 0;if(l){const e=g.length,t=new Array(3*e);let n=0;for(let i=0;i<e;i++){const e=g[i];t[n++]=e.x,t[n++]=e.y,t[n++]=e.z}const o={attributes:{position:new c.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:t})},indices:y,primitiveType:c.PrimitiveType.TRIANGLES};m&&(o.attributes.st=new c.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:i.Cartesian2.packArray(C)}));const a=new c.Geometry(o);return h.normal?u.GeometryPipeline.computeNormal(a):a}return f===t.ArcType.GEODESIC?d.PolygonPipeline.computeSubdivision(e,g,y,C,s,p):f===t.ArcType.RHUMB?d.PolygonPipeline.computeRhumbLineSubdivision(e,g,y,C,s):void 0};const R=[],N=[],O=new o.Cartesian3,z=new o.Cartesian3;g.computeWallGeometry=function(e,n,i,s,u,d){let p,y,m,C,b,x,w,T,v,A=e.length,L=0,E=0;const I=a.defined(n),M=I?n.positions:void 0;if(u)for(y=3*A*2,p=new Array(2*y),I&&(v=2*A*2,T=new Array(2*v)),m=0;m<A;m++)C=e[m],b=e[(m+1)%A],p[L]=p[L+y]=C.x,++L,p[L]=p[L+y]=C.y,++L,p[L]=p[L+y]=C.z,++L,p[L]=p[L+y]=b.x,++L,p[L]=p[L+y]=b.y,++L,p[L]=p[L+y]=b.z,++L,I&&(x=M[m],w=M[(m+1)%A],T[E]=T[E+v]=x.x,++E,T[E]=T[E+v]=x.y,++E,T[E]=T[E+v]=w.x,++E,T[E]=T[E+v]=w.y,++E);else{const n=f.CesiumMath.chordLength(s,i.maximumRadius);let o=0;if(d===t.ArcType.GEODESIC)for(m=0;m<A;m++)o+=g.subdivideLineCount(e[m],e[(m+1)%A],n);else if(d===t.ArcType.RHUMB)for(m=0;m<A;m++)o+=g.subdivideRhumbLineCount(i,e[m],e[(m+1)%A],n);for(y=3*(o+A),p=new Array(2*y),I&&(v=2*(o+A),T=new Array(2*v)),m=0;m<A;m++){let o,r;C=e[m],b=e[(m+1)%A],I&&(x=M[m],w=M[(m+1)%A]),d===t.ArcType.GEODESIC?(o=g.subdivideLine(C,b,n,N),I&&(r=g.subdivideTexcoordLine(x,w,C,b,n,R))):d===t.ArcType.RHUMB&&(o=g.subdivideRhumbLine(i,C,b,n,N),I&&(r=g.subdivideTexcoordRhumbLine(x,w,i,C,b,n,R)));const a=o.length;for(let e=0;e<a;++e,++L)p[L]=o[e],p[L+y]=o[e];if(p[L]=b.x,p[L+y]=b.x,++L,p[L]=b.y,p[L+y]=b.y,++L,p[L]=b.z,p[L+y]=b.z,++L,I){const e=r.length;for(let t=0;t<e;++t,++E)T[E]=r[t],T[E+v]=r[t];T[E]=w.x,T[E+v]=w.x,++E,T[E]=w.y,T[E+v]=w.y,++E}}}A=p.length;const P=h.IndexDatatype.createTypedArray(A/3,A-6*e.length);let D=0;for(A/=6,m=0;m<A;m++){const e=m,t=e+1,n=e+A,i=n+1;C=o.Cartesian3.fromArray(p,3*e,O),b=o.Cartesian3.fromArray(p,3*t,z),o.Cartesian3.equalsEpsilon(C,b,f.CesiumMath.EPSILON10,f.CesiumMath.EPSILON10)||(P[D++]=e,P[D++]=n,P[D++]=t,P[D++]=t,P[D++]=n,P[D++]=i)}const _={attributes:new l.GeometryAttributes({position:new c.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:p})}),indices:P,primitiveType:c.PrimitiveType.TRIANGLES};I&&(_.attributes.st=new c.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:T}));return new c.Geometry(_)};var q=g;e.PolygonGeometryLibrary=q}));
