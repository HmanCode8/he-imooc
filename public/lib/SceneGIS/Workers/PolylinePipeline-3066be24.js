/**
 * @license
 * SceneGIS - https://github.com/CesiumGS/cesium
 * Version 1.97
 *
 * Copyright 2011-2022 SceneGIS Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["exports","./Matrix3-fe947601","./defaultValue-192c850d","./EllipsoidGeodesic-738f7df1","./EllipsoidRhumbLine-e5543179","./IntersectionTests-35826260","./Math-be2c8494","./Matrix2-dca1b63d","./Plane-d57be61c"],(function(e,t,a,n,i,r,o,s,c){"use strict";const l={numberOfPoints:function(e,a,n){const i=t.Cartesian3.distance(e,a);return Math.ceil(i/n)},numberOfPointsRhumbLine:function(e,t,a){const n=Math.pow(e.longitude-t.longitude,2)+Math.pow(e.latitude-t.latitude,2);return Math.max(1,Math.ceil(Math.sqrt(n/(a*a))))}},u=new t.Cartographic;l.extractHeights=function(e,t,n){const i=e.length,r=new Array(i);for(let o=0;o<i;o++){const i=e[o];a.defined(n)&&!0===n?r[o]=i.z:r[o]=t.cartesianToCartographic(i,u).height}return r};const h=new s.Matrix4,d=new t.Cartesian3,f=new t.Cartesian3,g=new c.Plane(t.Cartesian3.UNIT_X,0),C=new t.Cartesian3,p=new c.Plane(t.Cartesian3.UNIT_X,0),m=new t.Cartesian3,w=new t.Cartesian3,y=[];function P(e,t,a){const n=y;let i;if(n.length=e,t===a){for(i=0;i<e;i++)n[i]=t;return n}const r=(a-t)/e;for(i=0;i<e;i++){const e=t+i*r;n[i]=e}return n}const T=new t.Cartographic,A=new t.Cartographic,E=new t.Cartesian3,b=new t.Cartesian3,M=new t.Cartesian3,x=new n.EllipsoidGeodesic;let R=new i.EllipsoidRhumbLine;function S(e,n,i,r,o,s,c,u,h){let d,f,g=new t.Cartographic,C=new t.Cartographic;a.defined(h)&&!0===h?(d=e.clone(b),f=n.clone(M),g.longitude=d.x,g.latitude=d.y,g.height=d.z,C.longitude=f.x,C.latitude=f.y,C.height=f.z):(d=r.scaleToGeodeticSurface(e,b),f=r.scaleToGeodeticSurface(n,M),g=r.cartesianToCartographic(d,T),C=r.cartesianToCartographic(f,A));const p=l.numberOfPoints(e,n,i),m=P(p,o,s);x.setEndPoints(g,C);const w=x.surfaceDistance/p;let y,R=u;g.height=o,a.defined(h)&&!0===h?(y=d.clone(E),y.z=o):y=r.cartographicToCartesian(g,E),t.Cartesian3.pack(y,c,R),R+=3;for(let e=1;e<p;e++){const a=x.interpolateUsingSurfaceDistance(e*w,A);a.height=m[e],!0===h?(y.x=a.longitude,y.y=a.latitude,y.z=a.height):y=r.cartographicToCartesian(a,E),t.Cartesian3.pack(y,c,R),R+=3}return R}function D(e,a,n,r,o,s,c,u){const h=r.cartesianToCartographic(e,T),d=r.cartesianToCartographic(a,A),f=l.numberOfPointsRhumbLine(h,d,n);h.height=0,d.height=0;const g=P(f,o,s);R.ellipsoid.equals(r)||(R=new i.EllipsoidRhumbLine(void 0,void 0,r)),R.setEndPoints(h,d);const C=R.surfaceDistance/f;let p=u;h.height=o;let m=r.cartographicToCartesian(h,E);t.Cartesian3.pack(m,c,p),p+=3;for(let e=1;e<f;e++){const a=R.interpolateUsingSurfaceDistance(e*C,A);a.height=g[e],m=r.cartographicToCartesian(a,E),t.Cartesian3.pack(m,c,p),p+=3}return p}l.wrapLongitude=function(e,n){const i=[],o=[];if(a.defined(e)&&e.length>0){n=a.defaultValue(n,s.Matrix4.IDENTITY);const l=s.Matrix4.inverseTransformation(n,h),u=s.Matrix4.multiplyByPoint(l,t.Cartesian3.ZERO,d),y=t.Cartesian3.normalize(s.Matrix4.multiplyByPointAsVector(l,t.Cartesian3.UNIT_Y,f),f),P=c.Plane.fromPointNormal(u,y,g),T=t.Cartesian3.normalize(s.Matrix4.multiplyByPointAsVector(l,t.Cartesian3.UNIT_X,C),C),A=c.Plane.fromPointNormal(u,T,p);let E=1;i.push(t.Cartesian3.clone(e[0]));let b=i[0];const M=e.length;for(let n=1;n<M;++n){const s=e[n];if(c.Plane.getPointDistance(A,b)<0||c.Plane.getPointDistance(A,s)<0){const e=r.IntersectionTests.lineSegmentPlane(b,s,P,m);if(a.defined(e)){const a=t.Cartesian3.multiplyByScalar(y,5e-9,w);c.Plane.getPointDistance(P,b)<0&&t.Cartesian3.negate(a,a),i.push(t.Cartesian3.add(e,a,new t.Cartesian3)),o.push(E+1),t.Cartesian3.negate(a,a),i.push(t.Cartesian3.add(e,a,new t.Cartesian3)),E=1}}i.push(t.Cartesian3.clone(e[n])),E++,b=s}o.push(E)}return{positions:i,lengths:o}},l.generateArc=function(e){a.defined(e)||(e={});const n=e.positions,i=a.defaultValue(e.planeView,!1),r=n.length,s=a.defaultValue(e.ellipsoid,t.Ellipsoid.WGS84);let c=a.defaultValue(e.height,0);const u=Array.isArray(c);if(r<1)return[];if(1===r){let e;if(e=!0===i?n[0].clone(b):s.scaleToGeodeticSurface(n[0],b),c=u?c[0]:c,0!==c){let a;!0===i?(a=new t.Cartesian3(0,0,1),a.clone(E)):a=s.geodeticSurfaceNormal(e,E),t.Cartesian3.multiplyByScalar(a,c,a),t.Cartesian3.add(e,a,e)}return[e.x,e.y,e.z]}let h=e.minDistance;if(!a.defined(h)){const t=a.defaultValue(e.granularity,o.CesiumMath.RADIANS_PER_DEGREE);h=o.CesiumMath.chordLength(t,s.maximumRadius)}let d,f=0;for(d=0;d<r-1;d++)f+=l.numberOfPoints(n[d],n[d+1],h);const g=3*(f+1),C=new Array(g);let p=0;for(d=0;d<r-1;d++){p=S(n[d],n[d+1],h,s,u?c[d]:c,u?c[d+1]:c,C,p,i)}y.length=0;const m=n[r-1];let w;if(a.defined(i)&&!0===i)w=m.clone(E),w.z=u?c[r-1]:c;else{const e=s.cartesianToCartographic(m,T);e.height=u?c[r-1]:c,w=s.cartographicToCartesian(e,E)}return t.Cartesian3.pack(w,C,g-3),C};const V=new t.Cartographic,N=new t.Cartographic;l.generateRhumbArc=function(e){a.defined(e)||(e={});const n=e.positions,i=n.length,r=a.defaultValue(e.ellipsoid,t.Ellipsoid.WGS84);let s=a.defaultValue(e.height,0);const c=Array.isArray(s);if(i<1)return[];if(1===i){const e=r.scaleToGeodeticSurface(n[0],b);if(s=c?s[0]:s,0!==s){const a=r.geodeticSurfaceNormal(e,E);t.Cartesian3.multiplyByScalar(a,s,a),t.Cartesian3.add(e,a,e)}return[e.x,e.y,e.z]}const u=a.defaultValue(e.granularity,o.CesiumMath.RADIANS_PER_DEGREE);let h,d,f=0,g=r.cartesianToCartographic(n[0],V);for(h=0;h<i-1;h++)d=r.cartesianToCartographic(n[h+1],N),f+=l.numberOfPointsRhumbLine(g,d,u),g=t.Cartographic.clone(d,V);const C=3*(f+1),p=new Array(C);let m=0;for(h=0;h<i-1;h++){m=D(n[h],n[h+1],u,r,c?s[h]:s,c?s[h+1]:s,p,m)}y.length=0;const w=n[i-1],P=r.cartesianToCartographic(w,T);P.height=c?s[i-1]:s;const A=r.cartographicToCartesian(P,E);return t.Cartesian3.pack(A,p,C-3),p},l.generateCartesianArc=function(e){const a=l.generateArc(e),n=a.length/3,i=new Array(n);for(let e=0;e<n;e++)i[e]=t.Cartesian3.unpack(a,3*e);return i},l.generateCartesianRhumbArc=function(e){const a=l.generateRhumbArc(e),n=a.length/3,i=new Array(n);for(let e=0;e<n;e++)i[e]=t.Cartesian3.unpack(a,3*e);return i};var z=l;e.PolylinePipeline=z}));
