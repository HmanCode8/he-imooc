/**
 * @license
 * SceneGIS - https://github.com/CesiumGS/cesium
 * Version 1.97
 *
 * Copyright 2011-2022 SceneGIS Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["exports","./Transforms-c38817cd","./Matrix2-bce7772b","./Matrix3-a45402cf","./ComponentDatatype-f194b981","./defaultValue-192c850d","./GeometryAttribute-add8522c","./GeometryAttributes-fcaeebba","./GeometryOffsetAttribute-817c59a7","./IndexDatatype-1ff811be","./Math-be2c8494","./VertexFormat-d2271f13"],(function(t,e,a,n,i,r,o,s,m,u,l,c){"use strict";const f=new n.Cartesian3,d=new n.Cartesian3,p=new n.Cartesian3,C=new n.Cartesian3,y=new n.Cartesian3,_=new n.Cartesian3(1,1,1),h=Math.cos,x=Math.sin;function A(t){t=r.defaultValue(t,r.defaultValue.EMPTY_OBJECT);const e=r.defaultValue(t.radii,_),a=r.defaultValue(t.innerRadii,e),i=r.defaultValue(t.minimumClock,0),o=r.defaultValue(t.maximumClock,l.CesiumMath.TWO_PI),s=r.defaultValue(t.minimumCone,0),m=r.defaultValue(t.maximumCone,l.CesiumMath.PI),u=Math.round(r.defaultValue(t.stackPartitions,64)),f=Math.round(r.defaultValue(t.slicePartitions,64)),d=r.defaultValue(t.vertexFormat,c.VertexFormat.DEFAULT),p=r.defaultValue(t.planeView,!1);this._radii=n.Cartesian3.clone(e),this._innerRadii=n.Cartesian3.clone(a),this._minimumClock=i,this._maximumClock=o,this._minimumCone=s,this._maximumCone=m,this._stackPartitions=u,this._slicePartitions=f,this._vertexFormat=c.VertexFormat.clone(d),this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidGeometry",this._planeView=p}A.packedLength=2*n.Cartesian3.packedLength+c.VertexFormat.packedLength+7,A.pack=function(t,e,a){return a=r.defaultValue(a,0),n.Cartesian3.pack(t._radii,e,a),a+=n.Cartesian3.packedLength,n.Cartesian3.pack(t._innerRadii,e,a),a+=n.Cartesian3.packedLength,c.VertexFormat.pack(t._vertexFormat,e,a),a+=c.VertexFormat.packedLength,e[a++]=t._minimumClock,e[a++]=t._maximumClock,e[a++]=t._minimumCone,e[a++]=t._maximumCone,e[a++]=t._stackPartitions,e[a++]=t._slicePartitions,e[a]=r.defaultValue(t._offsetAttribute,-1),e};const b=new n.Cartesian3,k=new n.Cartesian3,w=new c.VertexFormat,V={radii:b,innerRadii:k,vertexFormat:w,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,offsetAttribute:void 0};let P;A.unpack=function(t,e,a,i){e=r.defaultValue(e,0);const o=n.Cartesian3.unpack(t,e,b);e+=n.Cartesian3.packedLength;const s=n.Cartesian3.unpack(t,e,k);e+=n.Cartesian3.packedLength;const m=c.VertexFormat.unpack(t,e,w);e+=c.VertexFormat.packedLength;const u=t[e++],l=t[e++],f=t[e++],d=t[e++],p=t[e++],C=t[e++],y=t[e];return r.defined(a)?(a._radii=n.Cartesian3.clone(o,a._radii),a._innerRadii=n.Cartesian3.clone(s,a._innerRadii),a._vertexFormat=c.VertexFormat.clone(m,a._vertexFormat),a._minimumClock=u,a._maximumClock=l,a._minimumCone=f,a._maximumCone=d,a._stackPartitions=p,a._slicePartitions=C,a._offsetAttribute=-1===y?void 0:y,a._planeView=i,a):(V.minimumClock=u,V.maximumClock=l,V.minimumCone=f,V.maximumCone=d,V.stackPartitions=p,V.slicePartitions=C,V.offsetAttribute=-1===y?void 0:y,V.planeView=i,new A(V))},A.createGeometry=function(t){const c=t._radii;if(c.x<=0||c.y<=0||c.z<=0)return;const _=t._innerRadii;if(_.x<=0||_.y<=0||_.z<=0)return;const A=t._minimumClock,b=t._maximumClock,k=t._minimumCone,w=t._maximumCone,V=t._vertexFormat,P=t._planeView;let g,v,F=t._slicePartitions+1,M=t._stackPartitions+1;F=Math.round(F*Math.abs(b-A)/l.CesiumMath.TWO_PI),M=Math.round(M*Math.abs(w-k)/l.CesiumMath.PI),F<2&&(F=2),M<2&&(M=2);let T=0;const D=[k],G=[A];for(g=0;g<M;g++)D.push(k+g*(w-k)/(M-1));for(D.push(w),v=0;v<F;v++)G.push(A+v*(b-A)/(F-1));G.push(b);const L=D.length,O=G.length;let I=0,E=1;const z=_.x!==c.x||_.y!==c.y||_.z!==c.z;let N=!1,R=!1,U=!1;z&&(E=2,k>0&&(N=!0,I+=F-1),w<Math.PI&&(R=!0,I+=F-1),(b-A)%l.CesiumMath.TWO_PI?(U=!0,I+=2*(M-1)+1):I+=1);const S=O*L*E,B=new Float64Array(3*S),W=new Array(S).fill(!1),Y=new Array(S).fill(!1),J=F*M*E,X=6*(J+I+1-(F+M)*E),Z=u.IndexDatatype.createTypedArray(J,X),j=V.normal?new Float32Array(3*S):void 0,q=V.tangent?new Float32Array(3*S):void 0,H=V.bitangent?new Float32Array(3*S):void 0,K=V.st?new Float32Array(2*S):void 0,Q=new Array(L),$=new Array(L);for(g=0;g<L;g++)Q[g]=x(D[g]),$[g]=h(D[g]);const tt=new Array(O),et=new Array(O);for(v=0;v<O;v++)et[v]=h(G[v]),tt[v]=x(G[v]);for(g=0;g<L;g++)for(v=0;v<O;v++)B[T++]=c.x*Q[g]*et[v],B[T++]=c.y*Q[g]*tt[v],B[T++]=c.z*$[g];let at,nt,it,rt,ot=S/2;if(z)for(g=0;g<L;g++)for(v=0;v<O;v++)B[T++]=_.x*Q[g]*et[v],B[T++]=_.y*Q[g]*tt[v],B[T++]=_.z*$[g],W[ot]=!0,g>0&&g!==L-1&&0!==v&&v!==O-1&&(Y[ot]=!0),ot++;for(T=0,g=1;g<L-2;g++)for(at=g*O,nt=(g+1)*O,v=1;v<O-2;v++)Z[T++]=nt+v,Z[T++]=nt+v+1,Z[T++]=at+v+1,Z[T++]=nt+v,Z[T++]=at+v+1,Z[T++]=at+v;if(z){const t=L*O;for(g=1;g<L-2;g++)for(at=t+g*O,nt=t+(g+1)*O,v=1;v<O-2;v++)Z[T++]=nt+v,Z[T++]=at+v,Z[T++]=at+v+1,Z[T++]=nt+v,Z[T++]=at+v+1,Z[T++]=nt+v+1}if(z){if(N)for(rt=L*O,g=1;g<O-2;g++)Z[T++]=g,Z[T++]=g+1,Z[T++]=rt+g+1,Z[T++]=g,Z[T++]=rt+g+1,Z[T++]=rt+g;if(R)for(it=L*O-O,rt=L*O*E-O,g=1;g<O-2;g++)Z[T++]=it+g+1,Z[T++]=it+g,Z[T++]=rt+g,Z[T++]=it+g+1,Z[T++]=rt+g,Z[T++]=rt+g+1}if(U){for(g=1;g<L-2;g++)rt=O*L+O*g,it=O*g,Z[T++]=rt,Z[T++]=it+O,Z[T++]=it,Z[T++]=rt,Z[T++]=rt+O,Z[T++]=it+O;for(g=1;g<L-2;g++)rt=O*L+O*(g+1)-1,it=O*(g+1)-1,Z[T++]=it+O,Z[T++]=rt,Z[T++]=it,Z[T++]=it+O,Z[T++]=rt+O,Z[T++]=rt}const st=new s.GeometryAttributes;V.position&&(st.position=new o.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:B}));let mt=0,ut=0,lt=0,ct=0;const ft=S/2;let dt;const pt=n.Ellipsoid.fromCartesian3(c),Ct=n.Ellipsoid.fromCartesian3(_);if(V.st||V.normal||V.tangent||V.bitangent){for(g=0;g<S;g++){dt=W[g]?Ct:pt;const t=n.Cartesian3.fromArray(B,3*g,f);let e;if(!0===P?(e=new n.Cartesian3(0,0,1),e.clone(d)):e=dt.geodeticSurfaceNormal(t,d),Y[g]&&n.Cartesian3.negate(e,e),V.st){const t=a.Cartesian2.negate(e,y);K[mt++]=Math.atan2(t.y,t.x)/l.CesiumMath.TWO_PI+.5,K[mt++]=Math.asin(e.z)/Math.PI+.5}if(V.normal&&(j[ut++]=e.x,j[ut++]=e.y,j[ut++]=e.z),V.tangent||V.bitangent){const t=p;let a,i=0;if(W[g]&&(i=ft),a=!N&&g>=i&&g<i+2*O?n.Cartesian3.UNIT_X:n.Cartesian3.UNIT_Z,n.Cartesian3.cross(a,e,t),n.Cartesian3.normalize(t,t),V.tangent&&(q[lt++]=t.x,q[lt++]=t.y,q[lt++]=t.z),V.bitangent){const a=n.Cartesian3.cross(e,t,C);n.Cartesian3.normalize(a,a),H[ct++]=a.x,H[ct++]=a.y,H[ct++]=a.z}}}V.st&&(st.st=new o.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:K})),V.normal&&(st.normal=new o.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:j})),V.tangent&&(st.tangent=new o.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:q})),V.bitangent&&(st.bitangent=new o.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:H}))}if(r.defined(t._offsetAttribute)){const e=B.length,a=t._offsetAttribute===m.GeometryOffsetAttribute.NONE?0:1,n=new Uint8Array(e/3).fill(a);st.applyOffset=new o.GeometryAttribute({componentDatatype:i.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return new o.Geometry({attributes:st,indices:Z,primitiveType:o.PrimitiveType.TRIANGLES,boundingSphere:e.BoundingSphere.fromEllipsoid(pt),offsetAttribute:t._offsetAttribute})},A.getUnitEllipsoid=function(){return r.defined(P)||(P=A.createGeometry(new A({radii:new n.Cartesian3(1,1,1),vertexFormat:c.VertexFormat.POSITION_ONLY}))),P},t.EllipsoidGeometry=A}));
