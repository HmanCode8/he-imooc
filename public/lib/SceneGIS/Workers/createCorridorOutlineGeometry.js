/**
 * @license
 * SceneGIS - https://github.com/CesiumGS/cesium
 * Version 1.97
 *
 * Copyright 2011-2022 SceneGIS Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./arrayRemoveDuplicates-0aca867d","./Transforms-c38817cd","./Matrix3-a45402cf","./ComponentDatatype-f194b981","./PolylineVolumeGeometryLibrary-797498c4","./CorridorGeometryLibrary-7cb9a15a","./defaultValue-192c850d","./GeometryAttribute-add8522c","./GeometryAttributes-fcaeebba","./GeometryOffsetAttribute-817c59a7","./IndexDatatype-1ff811be","./Math-be2c8494","./PolygonPipeline-2888ea37","./Matrix2-bce7772b","./RuntimeError-ca280330","./_commonjsHelpers-f78443cf","./combine-b9b48e3c","./WebGLConstants-1bcc99d3","./EllipsoidTangentPlane-b1a9b8da","./AxisAlignedBoundingBox-e6370b82","./IntersectionTests-f861e6a9","./Plane-f4b01105","./PolylinePipeline-1de62483","./EllipsoidGeodesic-35356ee4","./EllipsoidRhumbLine-c951aea3"],(function(e,t,i,r,o,n,a,s,l,d,u,p,c,f,h,y,g,b,m,A,_,E,C,G,w){"use strict";const v=new i.Cartesian3,T=new i.Cartesian3,P=new i.Cartesian3;function V(e,t){const d=[],p=e.positions,c=e.corners,f=e.endPositions,h=new l.GeometryAttributes;let y,g,b,m=0,A=0,_=0;for(g=0;g<p.length;g+=2)b=p[g].length-3,m+=b,_+=b/3*4,A+=p[g+1].length-3;for(m+=3,A+=3,g=0;g<c.length;g++){y=c[g];const e=c[g].leftPositions;a.defined(e)?(b=e.length,m+=b,_+=b/3*2):(b=c[g].rightPositions.length,A+=b,_+=b/3*2)}const E=a.defined(f);let C;E&&(C=f[0].length-3,m+=C,A+=C,C/=3,_+=4*C);const G=m+A,w=new Float64Array(G);let V,L,D,x,k,H,N=0,O=G-1;const I=C/2,M=u.IndexDatatype.createTypedArray(G/3,_+4);let S=0;if(M[S++]=N/3,M[S++]=(O-2)/3,E){d.push(N/3),H=v,k=T;const e=f[0];for(g=0;g<I;g++)H=i.Cartesian3.fromArray(e,3*(I-1-g),H),k=i.Cartesian3.fromArray(e,3*(I+g),k),n.CorridorGeometryLibrary.addAttribute(w,k,N),n.CorridorGeometryLibrary.addAttribute(w,H,void 0,O),L=N/3,x=L+1,V=(O-2)/3,D=V-1,M[S++]=V,M[S++]=D,M[S++]=L,M[S++]=x,N+=3,O-=3}let B=0,R=p[B++],U=p[B++];for(w.set(R,N),w.set(U,O-U.length+1),b=U.length-3,d.push(N/3,(O-2)/3),g=0;g<b;g+=3)L=N/3,x=L+1,V=(O-2)/3,D=V-1,M[S++]=V,M[S++]=D,M[S++]=L,M[S++]=x,N+=3,O-=3;for(g=0;g<c.length;g++){let e;y=c[g];const r=y.leftPositions,s=y.rightPositions;let l,u=P;if(a.defined(r)){for(O-=3,l=D,d.push(x),e=0;e<r.length/3;e++)u=i.Cartesian3.fromArray(r,3*e,u),M[S++]=l-e-1,M[S++]=l-e,n.CorridorGeometryLibrary.addAttribute(w,u,void 0,O),O-=3;d.push(l-Math.floor(r.length/6)),t===o.CornerType.BEVELED&&d.push((O-2)/3+1),N+=3}else{for(N+=3,l=x,d.push(D),e=0;e<s.length/3;e++)u=i.Cartesian3.fromArray(s,3*e,u),M[S++]=l+e,M[S++]=l+e+1,n.CorridorGeometryLibrary.addAttribute(w,u,N),N+=3;d.push(l+Math.floor(s.length/6)),t===o.CornerType.BEVELED&&d.push(N/3-1),O-=3}for(R=p[B++],U=p[B++],R.splice(0,3),U.splice(U.length-3,3),w.set(R,N),w.set(U,O-U.length+1),b=U.length-3,e=0;e<U.length;e+=3)x=N/3,L=x-1,D=(O-2)/3,V=D+1,M[S++]=V,M[S++]=D,M[S++]=L,M[S++]=x,N+=3,O-=3;N-=3,O+=3,d.push(N/3,(O-2)/3)}if(E){N+=3,O-=3,H=v,k=T;const e=f[1];for(g=0;g<I;g++)H=i.Cartesian3.fromArray(e,3*(C-g-1),H),k=i.Cartesian3.fromArray(e,3*g,k),n.CorridorGeometryLibrary.addAttribute(w,H,void 0,O),n.CorridorGeometryLibrary.addAttribute(w,k,N),x=N/3,L=x-1,D=(O-2)/3,V=D+1,M[S++]=V,M[S++]=D,M[S++]=L,M[S++]=x,N+=3,O-=3;d.push(N/3)}else d.push(N/3,(O-2)/3);return M[S++]=N/3,M[S++]=(O-2)/3,h.position=new s.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:w}),{attributes:h,indices:M,wallIndices:d}}function L(e){const t=(e=a.defaultValue(e,a.defaultValue.EMPTY_OBJECT)).positions,r=e.width,n=a.defaultValue(e.planeView,!1),s=a.defaultValue(e.height,0),l=a.defaultValue(e.extrudedHeight,s);this._positions=t,this._ellipsoid=i.Ellipsoid.clone(a.defaultValue(e.ellipsoid,i.Ellipsoid.WGS84)),this._width=r,this._height=Math.max(s,l),this._extrudedHeight=Math.min(s,l),this._cornerType=a.defaultValue(e.cornerType,o.CornerType.ROUNDED),this._granularity=a.defaultValue(e.granularity,p.CesiumMath.RADIANS_PER_DEGREE),this._offsetAttribute=e.offsetAttribute,this._workerName="createCorridorOutlineGeometry",this._planeView=n,this.packedLength=1+t.length*i.Cartesian3.packedLength+i.Ellipsoid.packedLength+6}L.pack=function(e,t,r){r=a.defaultValue(r,0);const o=e._positions,n=o.length;t[r++]=n;for(let e=0;e<n;++e,r+=i.Cartesian3.packedLength)i.Cartesian3.pack(o[e],t,r);return i.Ellipsoid.pack(e._ellipsoid,t,r),r+=i.Ellipsoid.packedLength,t[r++]=e._width,t[r++]=e._height,t[r++]=e._extrudedHeight,t[r++]=e._cornerType,t[r++]=e._granularity,t[r]=a.defaultValue(e._offsetAttribute,-1),t};const D=i.Ellipsoid.clone(i.Ellipsoid.UNIT_SPHERE),x={positions:void 0,ellipsoid:D,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,offsetAttribute:void 0};return L.unpack=function(e,t,r,o){t=a.defaultValue(t,0);const n=e[t++],s=new Array(n);o=a.defaultValue(o,!1);for(let r=0;r<n;++r,t+=i.Cartesian3.packedLength)s[r]=i.Cartesian3.unpack(e,t);const l=i.Ellipsoid.unpack(e,t,D);t+=i.Ellipsoid.packedLength;const d=e[t++],u=e[t++],p=e[t++],c=e[t++],f=e[t++],h=e[t];return a.defined(r)?(r._positions=s,r._ellipsoid=i.Ellipsoid.clone(l,r._ellipsoid),r._width=d,r._height=u,r._extrudedHeight=p,r._cornerType=c,r._granularity=f,r._offsetAttribute=-1===h?void 0:h,r._planeView=o,r):(x.positions=s,x.width=d,x.height=u,x.extrudedHeight=p,x.cornerType=c,x.granularity=f,x.offsetAttribute=-1===h?void 0:h,x.planeView=o,new L(x))},L.createGeometry=function(o){let l=o._positions;const f=o._width,h=o._ellipsoid,y=o._planeView;!1===y&&(l=function(e,t){for(let i=0;i<e.length;i++)e[i]=t.scaleToGeodeticSurface(e[i],e[i]);return e}(l,h));const g=e.arrayRemoveDuplicates(l,i.Cartesian3.equalsEpsilon);if(g.length<2||f<=0)return;const b=o._height,m=o._extrudedHeight,A=!p.CesiumMath.equalsEpsilon(b,m,0,p.CesiumMath.EPSILON2),_={ellipsoid:h,positions:g,width:f,cornerType:o._cornerType,granularity:o._granularity,saveAttributes:!1,planeView:y};let E;if(A)_.height=b,_.extrudedHeight=m,_.offsetAttribute=o._offsetAttribute,E=function(e){const t=e.ellipsoid,i=V(n.CorridorGeometryLibrary.computePositions(e),e.cornerType),o=i.wallIndices,l=e.height,p=e.extrudedHeight,f=a.defaultValue(e.planeView,!1),h=i.attributes,y=i.indices;let g=h.position.values,b=g.length,m=new Float64Array(b);m.set(g);const A=new Float64Array(2*b);if(g=c.PolygonPipeline.scaleToGeodeticHeight(g,l,t,void 0,f),m=c.PolygonPipeline.scaleToGeodeticHeight(m,p,t,void 0,f),A.set(g),A.set(m,b),h.position.values=A,b/=3,a.defined(e.offsetAttribute)){let t=new Uint8Array(2*b);if(e.offsetAttribute===d.GeometryOffsetAttribute.TOP)t=t.fill(1,0,b);else{const i=e.offsetAttribute===d.GeometryOffsetAttribute.NONE?0:1;t=t.fill(i)}h.applyOffset=new s.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}let _;const E=y.length,C=u.IndexDatatype.createTypedArray(A.length/3,2*(E+o.length));C.set(y);let G,w,v=E;for(_=0;_<E;_+=2){const e=y[_],t=y[_+1];C[v++]=e+b,C[v++]=t+b}for(_=0;_<o.length;_++)G=o[_],w=G+b,C[v++]=G,C[v++]=w;return{attributes:h,indices:C}}(_);else{if(E=V(n.CorridorGeometryLibrary.computePositions(_),_.cornerType),E.attributes.position.values=c.PolygonPipeline.scaleToGeodeticHeight(E.attributes.position.values,b,h,void 0,y),a.defined(o._offsetAttribute)){const e=E.attributes.position.values.length,t=o._offsetAttribute===d.GeometryOffsetAttribute.NONE?0:1,i=new Uint8Array(e/3).fill(t);E.attributes.applyOffset=new s.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}}const C=E.attributes,G=t.BoundingSphere.fromVertices(C.position.values,void 0,3);return new s.Geometry({attributes:C,indices:E.indices,primitiveType:s.PrimitiveType.LINES,boundingSphere:G,offsetAttribute:o._offsetAttribute})},function(e,t,r){return a.defined(t)&&(e=L.unpack(e,t,void 0,r)),e._ellipsoid=i.Ellipsoid.clone(e._ellipsoid),L.createGeometry(e)}}));
