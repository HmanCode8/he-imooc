/**
 * @license
 * SceneGIS - https://github.com/CesiumGS/cesium
 * Version 1.97
 *
 * Copyright 2011-2022 SceneGIS Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./defaultValue-192c850d","./Matrix3-a45402cf","./ArcType-d7935178","./arrayRemoveDuplicates-0aca867d","./Transforms-c38817cd","./Color-7a84f104","./ComponentDatatype-f194b981","./GeometryAttribute-add8522c","./GeometryAttributes-fcaeebba","./IndexDatatype-1ff811be","./Math-be2c8494","./PolylinePipeline-1de62483","./VertexFormat-d2271f13","./Matrix2-bce7772b","./RuntimeError-ca280330","./_commonjsHelpers-f78443cf","./combine-b9b48e3c","./WebGLConstants-1bcc99d3","./EllipsoidGeodesic-35356ee4","./EllipsoidRhumbLine-c951aea3","./IntersectionTests-f861e6a9","./Plane-f4b01105"],(function(e,t,o,n,r,a,i,l,s,c,p,d,u,y,m,f,h,C,_,g,b,A){"use strict";const E=[];function w(e,t,o,n,r){const i=E;let l;i.length=r;const s=o.red,c=o.green,p=o.blue,d=o.alpha,u=n.red,y=n.green,m=n.blue,f=n.alpha;if(a.Color.equals(o,n)){for(l=0;l<r;l++)i[l]=a.Color.clone(o);return i}const h=(u-s)/r,C=(y-c)/r,_=(m-p)/r,g=(f-d)/r;for(l=0;l<r;l++)i[l]=new a.Color(s+l*h,c+l*C,p+l*_,d+l*g);return i}function P(n){const r=(n=e.defaultValue(n,e.defaultValue.EMPTY_OBJECT)).positions,i=n.colors,l=e.defaultValue(n.width,1),s=e.defaultValue(n.colorsPerVertex,!1),c=e.defaultValue(n.planeView,!1);this._positions=r,this._colors=i,this._width=l,this._colorsPerVertex=s,this._vertexFormat=u.VertexFormat.clone(e.defaultValue(n.vertexFormat,u.VertexFormat.DEFAULT)),this._arcType=e.defaultValue(n.arcType,o.ArcType.GEODESIC),this._granularity=e.defaultValue(n.granularity,p.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=t.Ellipsoid.clone(e.defaultValue(n.ellipsoid,t.Ellipsoid.WGS84)),this._workerName="createPolylineGeometry",this._planeView=c;let d=1+r.length*t.Cartesian3.packedLength;d+=e.defined(i)?1+i.length*a.Color.packedLength:1,this.packedLength=d+t.Ellipsoid.packedLength+u.VertexFormat.packedLength+4}P.pack=function(o,n,r){let i;r=e.defaultValue(r,0);const l=o._positions;let s=l.length;for(n[r++]=s,i=0;i<s;++i,r+=t.Cartesian3.packedLength)t.Cartesian3.pack(l[i],n,r);const c=o._colors;for(s=e.defined(c)?c.length:0,n[r++]=s,i=0;i<s;++i,r+=a.Color.packedLength)a.Color.pack(c[i],n,r);return t.Ellipsoid.pack(o._ellipsoid,n,r),r+=t.Ellipsoid.packedLength,u.VertexFormat.pack(o._vertexFormat,n,r),r+=u.VertexFormat.packedLength,n[r++]=o._width,n[r++]=o._colorsPerVertex?1:0,n[r++]=o._arcType,n[r]=o._granularity,n};const V=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),x=new u.VertexFormat,T={positions:void 0,colors:void 0,ellipsoid:V,vertexFormat:x,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};P.unpack=function(o,n,r,i){let l;n=e.defaultValue(n,0);let s=o[n++];const c=new Array(s);for(l=0;l<s;++l,n+=t.Cartesian3.packedLength)c[l]=t.Cartesian3.unpack(o,n);s=o[n++];const p=s>0?new Array(s):void 0;for(l=0;l<s;++l,n+=a.Color.packedLength)p[l]=a.Color.unpack(o,n);const d=t.Ellipsoid.unpack(o,n,V);n+=t.Ellipsoid.packedLength;const y=u.VertexFormat.unpack(o,n,x);n+=u.VertexFormat.packedLength;const m=o[n++],f=1===o[n++],h=o[n++],C=o[n];return e.defined(r)?(r._positions=c,r._colors=p,r._ellipsoid=t.Ellipsoid.clone(d,r._ellipsoid),r._vertexFormat=u.VertexFormat.clone(y,r._vertexFormat),r._width=m,r._colorsPerVertex=f,r._arcType=h,r._granularity=C,r._planeView=i,r):(T.positions=c,T.colors=p,T.width=m,T.colorsPerVertex=f,T.arcType=h,T.granularity=C,T.planeView=i,new P(T))};const D=new t.Cartesian3,k=new t.Cartesian3,v=new t.Cartesian3,L=new t.Cartesian3;return P.createGeometry=function(u){const y=u._width,m=u._vertexFormat;let f=u._colors;const h=u._colorsPerVertex,C=u._arcType,_=u._granularity,g=u._ellipsoid,b=u._planeView;let A,P,V;const x=[];let T=n.arrayRemoveDuplicates(u._positions,t.Cartesian3.equalsEpsilon,!1,x);if(e.defined(f)&&x.length>0){let e=0,t=x[0];f=f.filter((function(o,n){let r=!1;return r=h?n===t||0===n&&1===t:n+1===t,!r||(e++,t=x[e],!1)}))}let F=T.length;if(F<2||y<=0)return;if(C===o.ArcType.GEODESIC||C===o.ArcType.RHUMB){let t,n;C===o.ArcType.GEODESIC?(t=p.CesiumMath.chordLength(_,g.maximumRadius),n=d.PolylinePipeline.numberOfPoints):(t=_,n=d.PolylinePipeline.numberOfPointsRhumbLine);const r=d.PolylinePipeline.extractHeights(T,g,b);if(e.defined(f)){let e=1;for(A=0;A<F-1;++A)e+=n(T[A],T[A+1],t);const o=new Array(e);let r=0;for(A=0;A<F-1;++A){const i=T[A],l=T[A+1],s=f[A],c=n(i,l,t);if(h&&A<e){const e=w(0,0,s,f[A+1],c),t=e.length;for(P=0;P<t;++P)o[r++]=e[P]}else for(P=0;P<c;++P)o[r++]=a.Color.clone(s)}o[r]=a.Color.clone(f[f.length-1]),f=o,E.length=0}T=C===o.ArcType.GEODESIC?d.PolylinePipeline.generateCartesianArc({positions:T,minDistance:t,ellipsoid:g,height:r,planeView:b}):d.PolylinePipeline.generateCartesianRhumbArc({positions:T,granularity:t,ellipsoid:g,height:r})}F=T.length;const G=4*F-4,O=new Float64Array(3*G),R=new Float64Array(3*G),I=new Float64Array(3*G),S=new Float32Array(2*G),B=m.st?new Float32Array(2*G):void 0,M=e.defined(f)?new Uint8Array(4*G):void 0;let U,N=0,H=0,W=0,Y=0;for(P=0;P<F;++P){let o,n;0===P?(U=D,t.Cartesian3.subtract(T[0],T[1],U),t.Cartesian3.add(T[0],U,U)):U=T[P-1],t.Cartesian3.clone(U,v),t.Cartesian3.clone(T[P],k),P===F-1?(U=D,t.Cartesian3.subtract(T[F-1],T[F-2],U),t.Cartesian3.add(T[F-1],U,U)):U=T[P+1],t.Cartesian3.clone(U,L),e.defined(M)&&(o=0===P||h?f[P]:f[P-1],P!==F-1&&(n=f[P]));const r=P===F-1?2:4;for(V=0===P?2:0;V<r;++V){t.Cartesian3.pack(k,O,N),t.Cartesian3.pack(v,R,N),t.Cartesian3.pack(L,I,N),N+=3;const r=V-2<0?-1:1;if(S[H++]=V%2*2-1,S[H++]=r*y,m.st&&(B[W++]=P/(F-1),B[W++]=Math.max(S[H-2],0)),e.defined(M)){const e=V<2?o:n;M[Y++]=a.Color.floatToByte(e.red),M[Y++]=a.Color.floatToByte(e.green),M[Y++]=a.Color.floatToByte(e.blue),M[Y++]=a.Color.floatToByte(e.alpha)}}}const q=new s.GeometryAttributes;q.position=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:O}),q.prevPosition=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:R}),q.nextPosition=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:I}),q.expandAndWidth=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:S}),m.st&&(q.st=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:B})),e.defined(M)&&(q.color=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:M,normalize:!0}));const j=c.IndexDatatype.createTypedArray(G,6*F-6);let z=0,J=0;const K=F-1;for(P=0;P<K;++P)j[J++]=z,j[J++]=z+2,j[J++]=z+1,j[J++]=z+1,j[J++]=z+2,j[J++]=z+3,z+=4;return new l.Geometry({attributes:q,indices:j,primitiveType:l.PrimitiveType.TRIANGLES,boundingSphere:r.BoundingSphere.fromPoints(T),geometryType:l.GeometryType.POLYLINES})},function(o,n,r){return e.defined(n)&&(o=P.unpack(o,n,void 0,r)),o._ellipsoid=t.Ellipsoid.clone(o._ellipsoid),P.createGeometry(o)}}));
