var SceneGISEX = (function (exports) {
	'use strict';

	/* Copyright (c) 2017 Environmental Systems Research Institute, Inc.
	 * Apache-2.0 */
	var DEFAULT_VERSION = '4.17';
	var NEXT = 'next';
	function parseVersion(version) {
		if (version.toLowerCase() === NEXT) {
			return NEXT;
		}
		var match = version && version.match(/^(\d)\.(\d+)/);
		return match && {
			major: parseInt(match[1], 10),
			minor: parseInt(match[2], 10)
		};
	}
	/**
	 * Get the CDN url for a given version
	 *
	 * @param version Ex: '4.17' or '3.34'. Defaults to the latest 4.x version.
	 */
	function getCdnUrl(version) {
		if (version === void 0) { version = DEFAULT_VERSION; }
		return "https://js.arcgis.com/" + version + "/";
	}
	/**
	 * Get the CDN url for a the CSS for a given version and/or theme
	 *
	 * @param version Ex: '4.17', '3.34', or 'next'. Defaults to the latest 4.x version.
	 */
	function getCdnCssUrl(version) {
		if (version === void 0) { version = DEFAULT_VERSION; }
		var baseUrl = getCdnUrl(version);
		var parsedVersion = parseVersion(version);
		if (parsedVersion !== NEXT && parsedVersion.major === 3) {
			// NOTE: at 3.11 the CSS moved from the /js folder to the root
			var path = parsedVersion.minor <= 10 ? 'js/' : '';
			return "" + baseUrl + path + "esri/css/esri.css";
		}
		else {
			// assume 4.x
			return baseUrl + "esri/themes/light/main.css";
		}
	}

	/* Copyright (c) 2017 Environmental Systems Research Institute, Inc.
	 * Apache-2.0 */
	function createStylesheetLink(href) {
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.href = href;
		return link;
	}
	function insertLink(link, before) {
		if (before) {
			// the link should be inserted before a specific node
			var beforeNode = document.querySelector(before);
			beforeNode.parentNode.insertBefore(link, beforeNode);
		}
		else {
			// append the link to then end of the head tag
			document.head.appendChild(link);
		}
	}
	// check if the css url has been injected or added manually
	function getCss(url) {
		return document.querySelector("link[href*=\"" + url + "\"]");
	}
	function getCssUrl(urlOrVersion) {
		return !urlOrVersion || parseVersion(urlOrVersion)
			// if it's a valid version string return the CDN URL
			? getCdnCssUrl(urlOrVersion)
			// otherwise assume it's a URL and return that
			: urlOrVersion;
	}
	// lazy load the CSS needed for the ArcGIS API
	function loadCss(urlOrVersion, before) {
		var url = getCssUrl(urlOrVersion);
		var link = getCss(url);
		if (!link) {
			// create & load the css link
			link = createStylesheetLink(url);
			insertLink(link, before);
		}
		return link;
	}

	/* Copyright (c) 2017 Environmental Systems Research Institute, Inc.
	 * Apache-2.0 */
	var isBrowser = typeof window !== 'undefined';
	// allow consuming libraries to provide their own Promise implementations
	var utils = {
		Promise: isBrowser ? window['Promise'] : undefined
	};

	/* Copyright (c) 2017 Environmental Systems Research Institute, Inc.
	 * Apache-2.0 */
	var defaultOptions = {};
	function createScript(url) {
		var script = document.createElement('script');
		script.type = 'text/javascript';
		script.src = url;
		script.setAttribute('data-esri-loader', 'loading');
		return script;
	}
	// add a one-time load handler to script
	// and optionally add a one time error handler as well
	function handleScriptLoad(script, callback, errback) {
		var onScriptError;
		if (errback) {
			// set up an error handler as well
			onScriptError = handleScriptError(script, errback);
		}
		var onScriptLoad = function () {
			// pass the script to the callback
			callback(script);
			// remove this event listener
			script.removeEventListener('load', onScriptLoad, false);
			if (onScriptError) {
				// remove the error listener as well
				script.removeEventListener('error', onScriptError, false);
			}
		};
		script.addEventListener('load', onScriptLoad, false);
	}
	// add a one-time error handler to the script
	function handleScriptError(script, callback) {
		var onScriptError = function (e) {
			// reject the promise and remove this event listener
			callback(e.error || new Error("There was an error attempting to load " + script.src));
			// remove this event listener
			script.removeEventListener('error', onScriptError, false);
		};
		script.addEventListener('error', onScriptError, false);
		return onScriptError;
	}
	// get the script injected by this library
	function getScript() {
		return document.querySelector('script[data-esri-loader]');
	}
	// has ArcGIS API been loaded on the page yet?
	function isLoaded() {
		var globalRequire = window['require'];
		// .on() ensures that it's Dojo's AMD loader
		return globalRequire && globalRequire.on;
	}
	// load the ArcGIS API on the page
	function loadScript(options) {
		if (options === void 0) { options = {}; }
		// we would have liked to use spread like { ...defaultOptions, ...options }
		// but TS would inject a polyfill that would require use to configure rollup w content: 'window'
		// if we have another occasion to use spread, let'd do that and replace this for...in
		var opts = {};
		[defaultOptions, options].forEach(function (obj) {
			for (var prop in obj) {
				if (Object.prototype.hasOwnProperty.call(obj, prop)) {
					opts[prop] = obj[prop];
				}
			}
		});
		// URL to load
		var version = opts.version;
		var url = opts.url || getCdnUrl(version);
		return new utils.Promise(function (resolve, reject) {
			var script = getScript();
			if (script) {
				// the API is already loaded or in the process of loading...
				// NOTE: have to test against scr attribute value, not script.src
				// b/c the latter will return the full url for relative paths
				var src = script.getAttribute('src');
				if (src !== url) {
					// potentially trying to load a different version of the API
					reject(new Error("The ArcGIS API for JavaScript is already loaded (" + src + ")."));
				}
				else {
					if (isLoaded()) {
						// the script has already successfully loaded
						resolve(script);
					}
					else {
						// wait for the script to load and then resolve
						handleScriptLoad(script, resolve, reject);
					}
				}
			}
			else {
				if (isLoaded()) {
					// the API has been loaded by some other means
					// potentially trying to load a different version of the API
					reject(new Error("The ArcGIS API for JavaScript is already loaded."));
				}
				else {
					// this is the first time attempting to load the API
					var css = opts.css;
					if (css) {
						var useVersion = css === true;
						// load the css before loading the script
						loadCss(useVersion ? version : css, opts.insertCssBefore);
					}
					if (opts.dojoConfig) {
						// set dojo configuration parameters before loading the script
						window['dojoConfig'] = opts.dojoConfig;
					}
					// create a script object whose source points to the API
					script = createScript(url);
					// _currentUrl = url;
					// once the script is loaded...
					handleScriptLoad(script, function () {
						// update the status of the script
						script.setAttribute('data-esri-loader', 'loaded');
						// return the script
						resolve(script);
					}, reject);
					// load the script
					document.body.appendChild(script);
				}
			}
		});
	}

	/* Copyright (c) 2017 Environmental Systems Research Institute, Inc.
	 * Apache-2.0 */
	// wrap Dojo's require() in a promise
	function requireModules(modules) {
		return new utils.Promise(function (resolve, reject) {
			// If something goes wrong loading the esri/dojo scripts, reject with the error.
			var errorHandler = window['require'].on('error', reject);
			window['require'](modules, function () {
				var args = [];
				for (var _i = 0; _i < arguments.length; _i++) {
					args[_i] = arguments[_i];
				}
				// remove error handler
				errorHandler.remove();
				// Resolve with the parameters from dojo require as an array.
				resolve(args);
			});
		});
	}
	// returns a promise that resolves with an array of the required modules
	// also will attempt to lazy load the ArcGIS API if it has not already been loaded
	function loadModules(modules, loadScriptOptions) {
		if (loadScriptOptions === void 0) { loadScriptOptions = {}; }
		if (!isLoaded()) {
			// script is not yet loaded, is it in the process of loading?
			var script = getScript();
			var src = script && script.getAttribute('src');
			if (!loadScriptOptions.url && src) {
				// script is still loading and user did not specify a URL
				// in this case we want to default to the URL that's being loaded
				// instead of defaulting to the latest 4.x URL
				loadScriptOptions.url = src;
			}
			// attempt to load the script then load the modules
			return loadScript(loadScriptOptions).then(function () { return requireModules(modules); });
		}
		else {
			// script is already loaded, just load the modules
			return requireModules(modules);
		}
	}

	class CameraEX {
		/**
	   * This object takes care of additional 3d-specific properties of the view and
	   * ensures proper synchronization with the underlying raw SceneGIS.Camera object.
	   * @param {!SceneGIS.Scene} scene
	   * @param {!ol.Map} map
	   * @api
	   */
		constructor(scene, map) {
			/**
			 * @type {!SceneGIS.Scene}
			 * @private
			 */
			this.scene_ = scene;

			/**
			 * @type {!SceneGIS.Camera}
			 * @private
			 */
			this.cam_ = scene.camera;

			/**
			 * @type {!ol.Map}
			 * @private
			 */
			this.map_ = map;

			// this.map_.on('change:view', (e) => {
			//   this.setView_(this.map_.getView());
			// });
			// this.setView_(this.map_.getView());
		}
		/**
	   * Calculates the values of the properties from the current SceneGIS.Camera state.
	   * Modifies the center, resolution and rotation properties of the view.
	   * @api
	   */
		updateView() {
			this.viewUpdateInProgress_ = true;
			var self = this;
			// target & distance
			const ellipsoid = SceneGIS.Ellipsoid.WGS84;
			const scene = this.scene_;
			const map = this.map_;
			const target = CoreEX.olcsCore.pickCenterPoint(scene);

			let bestTarget = target;
			if (!bestTarget) {
				//TODO: how to handle this properly ?
				const globe = scene.globe;
				const carto = this.cam_.positionCartographic.clone();
				const height = globe.getHeight(carto);
				carto.height = height || 0;
				bestTarget = SceneGIS.Ellipsoid.WGS84.cartographicToCartesian(carto);
			}
			this.distance_ = SceneGIS.Cartesian3.distance(bestTarget, this.cam_.position);
			const bestTargetCartographic = ellipsoid.cartesianToCartographic(bestTarget);

			function toDegrees(angleInRadians) {
				return angleInRadians * 180 / Math.PI;
			}

			loadModules([
				"esri/map",
				"esri/SpatialReference",
				"esri/geometry/Point",
				"esri/symbols/SimpleMarkerSymbol",
				"esri/symbols/SimpleLineSymbol",
				"esri/symbols/SimpleFillSymbol",
				"esri/Color",
				"esri/graphic",
				"esri/layers/GraphicsLayer",
				"dojo/on",
				"dojo/dom",
				"dojo/dom-attr",
				"dojo/_base/lang"
			], {}).then(([Map, SpatialReference, Point, SimpleMarkerSymbol, SimpleLineSymbol, SimpleFillSymbol, Color,
				Graphic, GraphicsLayer, on, dom, domAttr, lang]) => {
				var point = new Point(toDegrees(bestTargetCartographic.longitude), toDegrees(bestTargetCartographic.latitude), new SpatialReference({
					wkid: 4326
				}));
				//addGraphicsToMap(point,null,false,true,false,null);
				var resolution = self.calcResolutionForDistance(self.distance_ + 5000,
					bestTargetCartographic ? bestTargetCartographic.latitude : 0);
				var scale = CoreEX.olcsCore.calcScaleFromResolution(resolution);
				console.log("point:", point, " scale:", scale);
				map.resize(true);
				//map.centerAt(point);
				//map.centerAndZoom(point, 15);
				map.setScale(scale);
				map.centerAt(point);
			});
			return;
		}

		/**
	  * Calculates the values of the properties from the current ol.View state.
	  * @api
	  */
		readFromView() {
			if (!this.map_) {
				return;
			}
			const center = this.map_.geographicExtent.getCenter();
			console.log("oyyx center:", center);
			if (center === undefined || center === null) {
				return;
			}
			// const ll = this.toLonLat_(center);
			// console.assert(ll);


			const scale = this.map_.getScale();
			const resolution = CoreEX.olcsCore.calcResolutionFromScale(scale);
			this.distance_ = this.calcDistanceForResolution(
				resolution || 0, center.y);

			this.updateCamera_();
		}

		/**
	 * Updates the state of the underlying SceneGIS.Camera
	 * according to the current values of the properties.
	 * @private
	 */
		updateCamera_() {

			function toRadians(angleInDegrees) {
				return angleInDegrees * Math.PI / 180;
			}

			if (!this.map_) {
				return;
			}
			const center = this.map_.geographicExtent.getCenter();
			if (!center) {
				return;
			}
			//const ll = this.toLonLat_(center);
			//console.assert(ll);

			// const carto = new SceneGIS.Cartographic(CoreEX.toRadians(ll[0]),
			//     CoreEX.toRadians(ll[1]));

			const carto = new SceneGIS.Cartographic(toRadians(center.x),
				toRadians(center.y));

			if (this.scene_.globe) {
				const height = this.scene_.globe.getHeight(carto);
				carto.height = height || 0;
			}

			const destination = SceneGIS.Ellipsoid.WGS84.cartographicToCartesian(carto);

			/** @type {SceneGIS.optionsOrientation} */
			const orientation = {
				pitch: -1.75,// this.tilt_ - SceneGIS.Math.PI_OVER_TWO,
				heading: 0,
				roll: 0
			};
			this.cam_.setView({
				destination,
				orientation
			});

			this.cam_.moveBackward(this.distance_);

			//this.checkCameraChange(true);
		}
		/**
	   * calculate the resolution based on a distance(camera to position) and latitude value
	   * @param {number} distance
	   * @param {number} latitude
	   * @return {number} The calculated resolution.
	   * @api
	   */
		calcResolutionForDistance(distance, latitude) {
			return CoreEX.olcsCore.calcResolutionForDistance(distance, latitude, this.scene_);//, this.map_.getProjection());
		}
		/**
		 * calculate the distance between camera and centerpoint based on the resolution and latitude value
		 * @param {number} resolution Number of map units per pixel.
		 * @param {number} latitude Latitude in radians.
		 * @return {number} The calculated distance.
		 * @api
		 */
		calcDistanceForResolution(resolution, latitude) {
			return CoreEX.olcsCore.calcDistanceForResolution(resolution, latitude, this.scene_);
		}
		/**
		 * Check if the underlying camera state has changed and ensure synchronization.
		 * @param {boolean=} opt_dontSync Do not synchronize the view.
		 */
		checkCameraChange(opt_dontSync) {
			const old = this.lastCameraViewMatrix_;
			const current = this.cam_.viewMatrix;

			if (!old || !SceneGIS.Matrix4.equalsEpsilon(old, current, 1e-5)) {
				this.lastCameraViewMatrix_ = current.clone();
				if (opt_dontSync !== true) {
					this.updateView();
				}
			}
		}
	}

	const CheckEX = {};

	function getFailedTypeErrorMessage(actual, expected, name) {
		return `${name}要求${expected}类型，但现在是${actual}类型`;
	}

	function getFailedClassErrorMessage(name) {
		return `${name}的类型错误`;
	}

	CheckEX.typeOf = function (name, test, type) {
		if (SceneGIS.defined(test) && typeof test !== type) {
			throw getFailedTypeErrorMessage(typeof test, type, name);
		}
	};

	function getSysErrorMessage(sys, name) {
		return `当前在${sys}坐标系，不支持${name}类型的图层`;
	}

	CheckEX.SysOf = function (sys, name) {
		if (sys == true) {
			if (name.indexOf("cartesian") == -1) {
				throw getSysErrorMessage("平面", name);
			}
		}
		else {
			if (name.indexOf("cartesian") > -1) {
				throw getSysErrorMessage("球面", name);
			}
		}
	};

	function getValueErrorMessage(name, value) {
		return `对象的${name}值必须是${value}`;
	}

	CheckEX.ValueOf = function (obj, propname, value) {
		if (obj[propname] !== value) {
			throw getValueErrorMessage(propname, value);
		}


	};

	CheckEX.instanceOf = function (name, test, calss) {
		if (SceneGIS.defined(test) && (test instanceof calss) !== true) {
			throw getFailedClassErrorMessage(name);
		}
	};

	function DefaultValueEX$1(a, b) {
		if (a !== undefined && a !== null) {
			return a;
		}
		return b;
	}
	DefaultValueEX$1.EMPTY_OBJECT = Object.freeze({});

	/**
	 * A 3D Cartesian point的扩展
	 * @alias Cartesian3EX
	 * @constructor
	 *
	 * @param {Number} [x=0.0] The X component.
	 * @param {Number} [y=0.0] The Y component.
	 * @param {Number} [z=0.0] The Z component.
	 */
	function Cartesian3EX(x, y, z) {
		/**
		 * The X component.
		 * @type {Number}
		 * @default 0.0
		 */
		this.x = DefaultValueEX$1(x, 0.0);

		/**
		 * The Y component.
		 * @type {Number}
		 * @default 0.0
		 */
		this.y = DefaultValueEX$1(y, 0.0);

		/**
		 * The Z component.
		 * @type {Number}
		 * @default 0.0
		 */
		this.z = DefaultValueEX$1(z, 0.0);
	}
	/**
	 * 转成Cartesian3 数组
	 * @param {Array} array 
	 * @param {Boolean} isDgree 
	 */
	Cartesian3EX.fromArrayHeights = function (coordinates, isDgree, result) {
		//>>includeStart('debug', pragmas.debug);
		SceneGIS.Check.defined("coordinates", coordinates);
		if (coordinates.length < 3 || coordinates.length % 3 !== 0) {
			throw new SceneGIS.DeveloperError(
				"the number of coordinates must be a multiple of 3 and at least 3"
			);
		}
		//>>includeEnd('debug');

		const length = coordinates.length;
		if (!SceneGIS.defined(result)) {
			result = new Array(length / 3);
		} else {
			result.length = length / 3;
		}

		for (let i = 0; i < length; i += 3) {
			const longitude = coordinates[i];
			const latitude = coordinates[i + 1];
			const height = coordinates[i + 2];
			const index = i / 3;
			if (isDgree) {
				result[index] = SceneGIS.Cartesian3.fromDegrees(
					longitude,
					latitude,
					height

				);
			}
			else {
				result[index] = new SceneGIS.Cartesian3(longitude, latitude, height);
			}

		}

		return result;
	};

	/**
	 * CommanDraw模式
	 * @readonly
	 * @enum {string}
	 */
	const CommanDrawModeEX = {
		/**
		 * 点模式
		 * @type {string}
		 * @constant
		 */
		POINT: "point",
		/**
		 * 折线模式
		 * @type {string}
		 * @constant
		 */
		LINE: "line",
		/**
		 * 线段模式
		 * @type {string}
		 * @constant
		 */
		STRAIGHTLINE: "straight_line",
		/**
		 * 矩形模式
		 */
		RECTANGLE: "rectangle",
		/**
		 * 面模式
		 * @type {string}
		 * @constant
		 */
		POLYGON: "polygon"
	};

	var CommanDrawModeEX$1 = Object.freeze(CommanDrawModeEX);

	/**
	 * 通用绘图类
	 * @class CommanDrawEX
	 * @param {Object} options 
	 * @param {Function} options.callback 回调函数，参数为{type:绘制类型,position:笛卡尔坐标的点,entity:图元}
	 * @param {Boolean} options.ground 是否贴地
	 * @param {Boolean} options.drawComplete 是否在选定点位后绘制
	 * @param {SceneGIS.Color} options.completeColor 绘制的颜色
	 * @param {SceneGIS.Viewer} viewer 
	 */
	function CommanDrawEX(options, viewer) {
		this._viewer = viewer;
		this._handle = new SceneGIS.ScreenSpaceEventHandler(viewer.scene.canvas);
		this._callback = options.callback instanceof Function ? options.callback : undefined;
		this._customDataSource = new SceneGIS.CustomDataSource("commanDrawDataSource");
		viewer.dataSources.add(this._customDataSource);

		this._tempPoint = null;
		this._tempPosition = new SceneGIS.Cartesian3(0, 0, 0);
		this._tempEntity = null;

		this._tempLinePoints = [];
		this._tempStraightLinePoints = [];
		this._tempPolygonPoints = [];
		this._tempRectanglePoints = [];
		this._tempRectanglePoint = undefined;
		this._tempRectanglePointWGS = undefined;
		this._tempScreenPoints = [];
		this._tempWGSPoints = [];

		this._points = [];
		this._lines = [];
		this._linePoints = [];
		this._straightLines = [];
		this._straightLinePoints = [];
		this._polygons = [];
		this._polygonPoints = [];
		this._rectangles = [];
		this._rectanglesPoints = [];

		this._mode = CommanDrawModeEX$1.POINT;
		this._pause = true;
		this._ground = SceneGIS.defined(options.ground) ? options.ground : true;
		this._tempColor = SceneGIS.defined(options.tempColor) ? options.tempColor : SceneGIS.Color.YELLOW;
		this._completeColor = SceneGIS.defined(options.completeColor) ? options.completeColor : SceneGIS.Color.GREEN.withAlpha(0.0);//todo
		this._drawCompletePoints = SceneGIS.defined(options.drawCompletePoints) ? options.drawCompletePoints : true;
		this._drawComplete = SceneGIS.defined(options.drawComplete) ? options.drawComplete : true;
		this._drawing = false;
		this._destroyed = false;
		bindEvent$2.bind(this)();
	}

	Object.defineProperties(CommanDrawEX.prototype, {
		/**
		 * 是否暂停绘制
		 * @memberof CommanDrawEX.prototype
		 * 
		 * @type {Boolean}
		 */
		pause: {
			get: function () {
				return this._pause;
			},
			set: function (bool) {
				this._pause = bool;
			}
		},
		/**
		 * 是否贴地
		 * @memberof CommanDrawEX.prototype
		 * 
		 * @type {Boolean}
		 */
		ground: {
			get: function () {
				return this._ground;
			},
			set: function (bool) {
				this._ground = bool;
			}
		},
		/**
		 * 是否在选定点位后绘制
		 * @memberof CommanDrawEX.prototype
		 * 
		 * @type {Boolean}
		 */
		drawComplete: {
			get: function () {
				return this._drawComplete;
			},
			set: function (bool) {
				this._drawComplete = bool;
			}
		},
		/**
		 * 绘制的颜色
		 * @memberof CommanDrawEX.prototype
		 * 
		 * @type {SceneGIS.Color}
		 */
		completeColor: {
			get: function () {
				return this._completeColor;
			},
			set: function (color) {
				// eslint-disable-next-line no-undef
				if (color instanceof Ceisum.Color) {
					this._completeColor = color;
				}
			}
		},
		/**
		 * 动态绘制面的颜色
		 */
		tempColor: {
			get: function () {
				return this._tempColor;
			},
			set: function (color) {
				if (color instanceof Ceisum.Color) {
					this._tempColor = color;
				}
			}
		}
	});

	/**
	 * 设定绘制模式
	 * @param {String} mode 绘制模式{@link CommanDrawModeEX}
	 */
	CommanDrawEX.prototype.setMode = function (mode) {
		this._mode = mode;//_mode初始值是CommanDrawMode.POINT:"point"
	};

	/**
	 * 暂停
	 */
	CommanDrawEX.prototype.pause = function () {
		this._pause = true;
	};

	/**
	 * 继续
	 */
	CommanDrawEX.prototype.start = function () {
		this._pause = false;
	};

	/**
	 * 移除最后绘制的点
	 * @returns 是否成功移除
	 */
	CommanDrawEX.prototype.removeLastPoint = function () {
		let point = this._points.pop();
		if (point) {
			if (point instanceof SceneGIS.Entity) {
				this._customDataSource.entities.remove(point);
			}
			return true;
		}
		return false;
	};

	/**
	 * 移除最后绘制的折线
	 * @returns 是否成功移除
	 */
	CommanDrawEX.prototype.removeLastLine = function () {
		let polyline = this._lines.pop();
		let points = this._linePoints.pop();
		if (polyline) {
			if (polyline instanceof SceneGIS.Entity) {
				this._customDataSource.entities.remove(polyline);
			}
			for (let point of points) {
				this._customDataSource.entities.remove(point);
			}
			return true;
		}
		return false;
	};

	/**
	 * 移除最后绘制的直线
	 * @returns 是否成功移除
	 */
	CommanDrawEX.prototype.removeLastStraightLine = function () {
		let polyline = this._straightLines.pop();
		let points = this._straightLinePoints.pop();
		if (polyline) {
			if (polyline instanceof SceneGIS.Entity) {
				this._customDataSource.entities.remove(polyline);
			}
			if (points) {
				for (let point of points) {
					this._customDataSource.entities.remove(point);
				}
			}
			return true;
		}
		return false;
	};

	/**
	 * 移除最后绘制的矩形
	 * @returns 是否成功移除
	 */
	CommanDrawEX.prototype.removeLastRectangle = function () {
		let rectangle = this._rectangles.pop();
		let points = this._rectanglesPoints.pop();
		if (rectangle) {
			if (rectangle instanceof SceneGIS.Entity) {
				this._customDataSource.entities.remove(rectangle);
			}
			for (let point of points) {
				this._customDataSource.entities.remove(point);
			}
			return true;
		}
		return false;
	};

	/**
	 * 移除最后绘制的面
	 * @returns 是否成功移除
	 */
	CommanDrawEX.prototype.removeLastPolygon = function () {
		let polygon = this._polygons.pop();
		let points = this._polygonPoints.pop();
		if (polygon) {
			if (polygon instanceof SceneGIS.Entity) {
				this._customDataSource.entities.remove(polygon);
			}
			if (points) {
				for (let point of points) {
					this._customDataSource.entities.remove(point);
				}
			}
			return true;
		}
		return false;
	};

	/**
	 * 移除最后绘制的图形
	 * @returns 是否成功移除
	 */
	CommanDrawEX.prototype.removeLast = function () {
		switch (this._mode) {
			case CommanDrawModeEX$1.POINT:
				{
					this.removeLastPoint();
					break;
				}
			case CommanDrawModeEX$1.LINE:
				{
					this.removeLastLine();
					break;
				}
			case CommanDrawModeEX$1.STRAIGHTLINE:
				{
					this.removeLastStraightLine();
					break;
				}
			case CommanDrawModeEX$1.POLYGON:
				{
					this.removeLastPolygon();
					break;
				}
		}
	};

	/**
	 * 移除所有图形
	 */
	CommanDrawEX.prototype.removeAll = function () {
		let flag = true;
		while (flag) {
			flag = this.removeLastPoint();
		}
		flag = true;
		while (flag) {
			flag = this.removeLastLine();
		}
		flag = true;
		while (flag) {
			flag = this.removeLastStraightLine();
		}
		flag = true;
		while (flag) {
			flag = this.removeLastRectangle();
		}
		flag = true;
		while (flag) {
			flag = this.removeLastPolygon();
		}
	};

	function bindEvent$2() {
		this._handle.setInputAction(mouseMove$4.bind(this), SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
		this._handle.setInputAction(leftClick$2.bind(this), SceneGIS.ScreenSpaceEventType.LEFT_CLICK);
		this._handle.setInputAction(rightClick$2.bind(this), SceneGIS.ScreenSpaceEventType.RIGHT_CLICK);
		let that = this;
		this._tempPoint = this._customDataSource.entities.add({
			position: new SceneGIS.CallbackProperty(function () {
				return that._tempPosition;
			}, false),
			point: {
				show: new SceneGIS.CallbackProperty(function () {
					return !that._pause;
				}, false),
				pixelSize: 10,
				// heightReference:SceneGIS.HeightReference.CLAMP_TO_GROUND,
				outlineColor: SceneGIS.Color.YELLOW,
				outlineWidth: 3
			}
		});
	}

	function mouseMove$4(movement) {
		if (this._pause) {
			return;
		}
		let position = this._viewer.scene.pickPosition(movement.endPosition);
		if (SceneGIS.defined(position)) {
			this._tempPosition = position;
			switch (this._mode) {
				case CommanDrawModeEX$1.LINE:
					{
						if (this._tempLinePoints.length != 0) {
							this._tempLinePoints[this._tempLinePoints.length - 1] = position;
						}
						break;
					}
				case CommanDrawModeEX$1.STRAIGHTLINE:
					{
						if (this._tempStraightLinePoints.length != 0) {
							this._tempStraightLinePoints[this._tempStraightLinePoints.length - 1] = position;
						}
						break;
					}
				case CommanDrawModeEX$1.RECTANGLE:
					{
						if (this._tempRectanglePoint) {
							this._tempRectanglePoints = [];
							let wgs84Position = transformCartesianToWGS84$2(position, false);
							let minLng = Math.min(this._tempRectanglePointWGS.lng, wgs84Position.lng);
							let maxLng = Math.max(this._tempRectanglePointWGS.lng, wgs84Position.lng);
							let minLat = Math.min(this._tempRectanglePointWGS.lat, wgs84Position.lat);
							let maxLat = Math.max(this._tempRectanglePointWGS.lat, wgs84Position.lat);
							this._tempRectanglePoints.push(SceneGIS.Cartesian3.fromDegrees(minLng, minLat));
							this._tempRectanglePoints.push(SceneGIS.Cartesian3.fromDegrees(maxLng, minLat));
							this._tempRectanglePoints.push(SceneGIS.Cartesian3.fromDegrees(maxLng, maxLat));
							this._tempRectanglePoints.push(SceneGIS.Cartesian3.fromDegrees(minLng, maxLat));
							if (!this._tempEntity) {
								let that = this;
								this._tempEntity = this._customDataSource.entities.add({
									polygon: {
										hierarchy: new SceneGIS.CallbackProperty(function () {
											let res = new SceneGIS.PolygonHierarchy(that._tempRectanglePoints);
											return res;
										}, false),
										perPositionHeight: !this._ground,
										material: this._tempColor,
									}
								});
							}
						}
					}
				case CommanDrawModeEX$1.POLYGON:
					{
						if (this._tempPolygonPoints.length != 0) {
							this._tempPolygonPoints[this._tempPolygonPoints.length - 1] = position;
						}
						break;
					}
			}
		}
	}

	function leftClick$2(mouse) {
		if (this._pause) {
			return;
		}
		this._tempScreenPoints.push(mouse.position.clone());
		let position = this._viewer.scene.pickPosition(mouse.position);
		if (!position) {
			return;
		}
		switch (this._mode) {
			case CommanDrawModeEX$1.POINT:
				{
					let point = "nodata";
					if (this._drawComplete) {
						point = this._customDataSource.entities.add({
							position: position,
							point: {
								pixelSize: 10,
								outlineColor: this._completeColor,
								outlineWidth: 3
							}
						});
					}
					this._points.push(point);
					let data = {
						type: "point",
						eventType: "leftClick",
						position: this._tempPosition,
						entity: point
					};
					if (this._callback) {
						this._callback(data);
					}
					break;
				}
			case CommanDrawModeEX$1.LINE:
				{
					this._tempLinePoints.pop();
					this._tempLinePoints.push(position.clone());
					let point = this._customDataSource.entities.add({
						position: position,
						point: {
							pixelSize: 10,
							outlineColor: SceneGIS.Color.GREEN,
							outlineWidth: 3
						}
					});
					this._tempLinePoints.push(position);
					if (!this._tempEntity) {
						let that = this;
						this._tempEntity = this._customDataSource.entities.add({
							polyline: {
								positions: new SceneGIS.CallbackProperty(function () {
									return that._tempLinePoints;
								}, false),
								width: 3,
								clampToGround: this._ground,
								material: SceneGIS.Color.YELLOW,
							}
						});
						this._linePoints.push([]);
						this._drawing = true;
					}
					this._linePoints[this._linePoints.length - 1].push(point);

					let data = {
						type: "line",
						eventType: "leftClick",
						position: this._tempLinePoints,
						entity: point
					};
					if (this._callback) {
						this._callback(data);
					}

					break;
				}
			case CommanDrawModeEX$1.STRAIGHTLINE:
				{
					this._tempStraightLinePoints.pop();
					this._tempStraightLinePoints.push(position.clone());
					let point = this._customDataSource.entities.add({
						position: position,
						point: {
							pixelSize: 10,
							outlineColor: SceneGIS.Color.GREEN,
							outlineWidth: 3
						}
					});
					this._tempStraightLinePoints.push(position);
					if (!this._tempEntity) {
						let that = this;
						this._tempEntity = this._customDataSource.entities.add({
							polyline: {
								positions: new SceneGIS.CallbackProperty(function () {
									return that._tempStraightLinePoints;
								}, false),
								width: 3,
								clampToGround: this._ground,
								material: SceneGIS.Color.YELLOW,
							}
						});
						this._straightLinePoints.push([]);
						this._drawing = true;
					}
					this._straightLinePoints[this._straightLinePoints.length - 1].push(point);
					if (this._straightLinePoints[this._straightLinePoints.length - 1].length == 2) {
						//有两个点就完成
						this._customDataSource.entities.remove(this._tempEntity);
						this._tempEntity = null;
						let polyline = "nodata";
						this._tempStraightLinePoints.pop();
						if (this._drawComplete) {
							polyline = this._customDataSource.entities.add({
								polyline: {
									positions: this._tempStraightLinePoints,
									width: 3,
									clampToGround: this._ground,
									material: this._completeColor,
								}
							});
						}
						if (!this._drawCompletePoints) {
							for (let point of this._straightLinePoints[this._straightLinePoints.length - 1]) {
								this._customDataSource.entities.remove(point);
							}
						}
						let data = {
							type: "straight_line",
							eventType: "leftClick",
							position: this._tempStraightLinePoints,
							entity: polyline
						};
						this._straightLines.push(polyline);
						this._tempStraightLinePoints = [];
						if (this._callback) {
							this._callback(data);
						}
						this._drawing = false;
					}
					break;
				}
			case CommanDrawModeEX$1.RECTANGLE:
				{
					this._tempRectanglePoints = [];
					if (!this._tempRectanglePoint) {
						this._tempRectanglePoint = position.clone();
						this._tempRectanglePointWGS = transformCartesianToWGS84$2(this._tempRectanglePoint, false);
						this._rectanglesPoints.push([]);
						let point = this._customDataSource.entities.add({
							position: position,
							point: {
								pixelSize: 10,
								outlineColor: SceneGIS.Color.GREEN,
								outlineWidth: 3
							}
						});
						this._rectanglesPoints[this._rectanglesPoints.length - 1].push(point);
						this._drawing = true;
					} else {
						//两个点完成
						this._customDataSource.entities.remove(this._tempEntity);
						this._tempEntity = null;
						let rectangle = "nodata";
						this._tempRectanglePoints = [];
						let wgs84Position = transformCartesianToWGS84$2(position, false);
						let minLng = Math.min(this._tempRectanglePointWGS.lng, wgs84Position.lng);
						let maxLng = Math.max(this._tempRectanglePointWGS.lng, wgs84Position.lng);
						let minLat = Math.min(this._tempRectanglePointWGS.lat, wgs84Position.lat);
						let maxLat = Math.max(this._tempRectanglePointWGS.lat, wgs84Position.lat);
						this._tempRectanglePoint = undefined;
						this._tempRectanglePointWGS = undefined;
						this._tempRectanglePoints.push(SceneGIS.Cartesian3.fromDegrees(minLng, minLat));
						this._tempRectanglePoints.push(SceneGIS.Cartesian3.fromDegrees(maxLng, minLat));
						this._tempRectanglePoints.push(SceneGIS.Cartesian3.fromDegrees(maxLng, maxLat));
						this._tempRectanglePoints.push(SceneGIS.Cartesian3.fromDegrees(minLng, maxLat));
						if (this._drawComplete) {
							rectangle = this._customDataSource.entities.add({
								polygon: {
									hierarchy: new SceneGIS.PolygonHierarchy(this._tempRectanglePoints),
									perPositionHeight: !this._ground,
									material: this._completeColor,
								}
							});
						}
						if (!this._drawCompletePoints) {
							for (let point of this._rectanglesPoints[this._rectanglesPoints.length - 1]) {
								this._customDataSource.entities.remove(point);
							}
						}
						let data = {
							type: "rectangle",
							eventType: "leftClick",
							position: {
								minLng: minLng,
								maxLng: maxLng,
								minLat: minLat,
								maxLat: maxLat
							},
							entity: rectangle
						};
						this._rectangles.push(rectangle);
						this._tempRectanglePoints = [];
						if (this._callback) {
							this._callback(data);
						}
						this._drawing = false;
					}

					break;
				}
			case CommanDrawModeEX$1.POLYGON:
				{
					this._tempPolygonPoints.pop();
					this._tempPolygonPoints.push(position.clone());
					let point = this._customDataSource.entities.add({
						position: position,
						point: {
							pixelSize: 10,
							outlineColor: SceneGIS.Color.GREEN,
							outlineWidth: 3
						}
					});
					this._tempPolygonPoints.push(position);
					let temp = transformCartesianToWGS84$2(position, true);
					console.log("temp:", temp);
					this._tempWGSPoints.push(temp);
					//一般点数组的长度比面数组长1
					if (this._polygons.length == this._polygonPoints.length) {
						this._polygonPoints.push([]);
						this._drawing = true;
					}
					if (!this._tempEntity && this._tempPolygonPoints.length == 3) {
						let that = this;
						this._tempEntity = this._customDataSource.entities.add({
							polygon: {
								hierarchy: new SceneGIS.CallbackProperty(function () {
									let res = new SceneGIS.PolygonHierarchy(that._tempPolygonPoints);
									return res;
								}, false),
								perPositionHeight: !this._ground,
								material: this._tempColor,

							},

						});
					}
					this._polygonPoints[this._polygonPoints.length - 1].push(point);

					let data = {
						type: "polygon",
						eventType: "leftClick",
						position: this._tempPolygonPoints,
						entity: point
					};
					if (this._callback) {
						this._callback(data);
					}
					break;
				}
		}
	}

	function rightClick$2() {
		if (this._pause) {
			return;
		}
		switch (this._mode) {
			case CommanDrawModeEX$1.LINE:
				{
					if (this._tempEntity) {
						this._customDataSource.entities.remove(this._tempEntity);
						this._tempEntity = null;
						if (this._tempLinePoints.length > 2) {
							this._tempLinePoints.pop();
							let polyline = "nodata";
							if (this._drawComplete) {
								polyline = this._customDataSource.entities.add({
									polyline: {
										positions: this._tempLinePoints,
										width: 3,
										clampToGround: this._ground,
										material: this._completeColor,
									}
								});
							}
							if (!this._drawCompletePoints) {
								for (let point of this._linePoints[this._linePoints.length - 1]) {
									this._customDataSource.entities.remove(point);
								}
							}
							let data = {
								type: "line",
								eventType: "rightClick",
								position: this._tempLinePoints,
								screenPoints: this._tempScreenPoints,
								entity: polyline
							};
							this._lines.push(polyline);
							this._tempLinePoints = [];
							this._tempScreenPoints = [];
							if (this._callback) {
								this._callback(data);
							}
						} else {
							//算上浮动的点只有两个点
							this._tempLinePoints = [];
							this._tempScreenPoints = [];
							for (let point of this._linePoints[this._linePoints.length - 1]) {
								this._customDataSource.entities.remove(point);
							}
							this._linePoints.pop();
						}
					} else {
						this._tempLinePoints = [];
						if (this._linePoints.length != 0) {
							for (let point of this._linePoints[this._linePoints.length - 1]) {
								this._customDataSource.entities.remove(point);
							}
							this._linePoints.pop();
						}
					}
					break;
				}
			case CommanDrawModeEX$1.STRAIGHTLINE:
				{
					if (this._tempEntity) {
						this._customDataSource.entities.remove(this._tempEntity);
						this._tempEntity = null;
					}
					//算上浮动的点只有两个点
					this._tempStraightLinePoints = [];
					if (this._straightLinePoints.length != 0) {
						for (let point of this._straightLinePoints[this._straightLinePoints.length - 1]) {
							this._customDataSource.entities.remove(point);
						}
						this._straightLinePoints.pop();
					}
					break;
				}
			case CommanDrawModeEX$1.RECTANGLE:
				{
					if (this._tempEntity) {
						this._customDataSource.entities.remove(this._tempEntity);
						this._tempEntity = null;
						this._tempRectanglePoint = undefined;
						this._tempRectanglePointWGS = undefined;
					}
					//算上浮动的点只有两个点
					this._tempRectanglePoints = [];
					if (this._rectanglesPoints.length != 0) {
						for (let point of this._rectanglesPoints[this._rectanglesPoints.length - 1]) {
							this._customDataSource.entities.remove(point);
						}
						this._rectanglesPoints.pop();
					}
					break;
				}
			case CommanDrawModeEX$1.POLYGON:
				{
					if (this._tempEntity) {
						this._customDataSource.entities.remove(this._tempEntity);
						this._tempEntity = null;
						if (this._tempPolygonPoints.length > 3) {
							this._tempPolygonPoints.pop();
							let polygon = "nodata";
							if (this._drawComplete) {
								polygon = this._customDataSource.entities.add({
									polygon: {
										hierarchy: new SceneGIS.PolygonHierarchy(this._tempPolygonPoints),
										perPositionHeight: !this._ground,
										material: this._completeColor,

									},

								});
							}
							if (!this._drawCompletePoints) {
								for (let point of this._polygonPoints[this._polygonPoints.length - 1]) {
									this._customDataSource.entities.remove(point);
								}
							}
							let data = {
								type: "polygon",
								eventType: "rightClick",
								position: this._tempPolygonPoints,
								screenPoints: this._tempScreenPoints,
								WGSPoints: this._tempWGSPoints,
								entity: polygon
							};
							this._tempPolygonPoints = [];
							this._tempScreenPoints = [];
							this._tempWGSPoints = [];
							this._polygons.push(polygon);
							if (this._callback) {
								this._callback(data);
							}
						} else {
							this._tempPolygonPoints = [];
							this._tempScreenPoints = [];
							this._tempWGSPoints = [];
							for (let point of this._polygonPoints[this._polygonPoints.length - 1]) {
								this._customDataSource.entities.remove(point);
							}
							this._polygonPoints.pop();
						}
					} else {
						this._tempPolygonPoints = [];
						this._tempScreenPoints = [];
						this._tempWGSPoints = [];
						if (this._polygonPoints.length != 0) {
							for (let point of this._polygonPoints[this._polygonPoints.length - 1]) {
								this._customDataSource.entities.remove(point);
							}
							this._polygonPoints.pop();
						}
					}
					break;
				}
		}
		this._drawing = false;
	}

	function unbindEvent$2() {
		this._handle.removeInputAction(SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
		this._handle.removeInputAction(SceneGIS.ScreenSpaceEventType.LEFT_CLICK);
		this._handle.removeInputAction(SceneGIS.ScreenSpaceEventType.RIGHT_CLICK);
	}

	/**
	 * 销毁资源
	 */
	CommanDrawEX.prototype.destroy = function () {
		if (this._destroyed) {
			return;
		}
		if (this._drawing) {
			rightClick$2.bind(this)();//结束创建图形
		}
		unbindEvent$2.bind(this)();
		if (this._tempPoint) {
			this._customDataSource.entities.remove(this._tempPoint);
		}
		this.removeAll();
		this._viewer.dataSources.remove(this._customDataSource, true);
		this._destroyed = true;
	};

	function transformCartesianToWGS84$2(cartesian, hasHeight) {
		if (cartesian && !hasHeight) {
			var ellipsoid = SceneGIS.Ellipsoid.WGS84;
			var cartographic = ellipsoid.cartesianToCartographic(cartesian);
			return {
				lng: SceneGIS.Math.toDegrees(cartographic.longitude),
				lat: SceneGIS.Math.toDegrees(cartographic.latitude),
				//alt: cartographic.height
			}
		} else if (cartesian && hasHeight) {
			var ellipsoid = SceneGIS.Ellipsoid.WGS84;
			var cartographic = ellipsoid.cartesianToCartographic(cartesian);
			return {
				lng: SceneGIS.Math.toDegrees(cartographic.longitude),
				lat: SceneGIS.Math.toDegrees(cartographic.latitude),
				alt: cartographic.height
			}
		}
	}

	/**
	 * from https://github.com/wandergis/coordTransform
	 * 提供了百度坐标（BD09）、国测局坐标（火星坐标，GCJ02）、和WGS84坐标系之间的转换
	 */
	//定义一些常量
	// import {
	//     SceneGIS.Cartesian3,
	//     SceneGIS.Matrix4,
	//     SceneGIS.Cartographic,
	//     Math as SceneGIS.Math
	// } from "cesium/Cesium";
	const x_PI = 3.14159265358979324 * 3000.0 / 180.0;
	const PI = 3.1415926535897932384626;
	const a = 6378245.0;
	const ee = 0.00669342162296594323;
	/**
	 * 坐标转换类
	 * 
	 * @alias CoordTransform
	 */
	class CoordTransform {
		constructor() {

		}
		/**
		 * WGS84转GCj02
		 * @param {Number} lng 经度 （单位 度）
		 * @param {Number} lat 纬度
		 * @returns {SceneGIS.Cartographic}
		 */
		wgs84togcj02(lng, lat) {
			var lat = +lat;
			var lng = +lng;
			if (this.out_of_china(lng, lat)) {
				//return [lng, lat]
				return SceneGIS.Cartographic.fromDegrees(lng, lat, 0, new SceneGIS.Cartographic());
			} else {
				var dlat = this.transformlat(lng - 105.0, lat - 35.0);
				var dlng = this.transformlng(lng - 105.0, lat - 35.0);
				var radlat = lat / 180.0 * PI;
				var magic = Math.sin(radlat);
				magic = 1 - ee * magic * magic;
				var sqrtmagic = Math.sqrt(magic);
				dlat = (dlat * 180.0) / ((a * (1 - ee)) / (magic * sqrtmagic) * PI);
				dlng = (dlng * 180.0) / (a / sqrtmagic * Math.cos(radlat) * PI);
				var mglat = lat + dlat;
				var mglng = lng + dlng;
				this.mglat = mglat;
				this.mglng = mglng;
				return SceneGIS.Cartographic.fromDegrees(mglng, mglat, 0, new SceneGIS.Cartographic());
			}
		};
		/**
		 * GCJ02 转换为 WGS84
		 * @param {Number} lng 经度 （单位 度）
		 * @param {Number} lat 纬度
		 * @returns {SceneGIS.Cartographic}
		 */
		gcj02towgs84(lng, lat) {
			var lat = +lat;
			var lng = +lng;
			if (this.out_of_china(lng, lat)) {
				//return [lng, lat]
				return SceneGIS.Cartographic.fromDegrees(lng, lat, 0, new SceneGIS.Cartographic());
			} else {
				var dlat = this.transformlat(lng - 105.0, lat - 35.0);
				var dlng = this.transformlng(lng - 105.0, lat - 35.0);
				var radlat = lat / 180.0 * PI;
				var magic = Math.sin(radlat);
				magic = 1 - ee * magic * magic;
				var sqrtmagic = Math.sqrt(magic);
				dlat = (dlat * 180.0) / ((a * (1 - ee)) / (magic * sqrtmagic) * PI);
				dlng = (dlng * 180.0) / (a / sqrtmagic * Math.cos(radlat) * PI);
				var mglat = lat + dlat;
				var mglng = lng + dlng;
				return SceneGIS.Cartographic.fromDegrees(lng * 2 - mglng, lat * 2 - mglat, 0, new SceneGIS.Cartographic());
			}
		};
		/**
		 * 百度坐标系 (BD-09) 与 火星坐标系 (GCJ-02)的转换
		 * 即 百度 转 谷歌、高德
		 * @param {Number} bd_lon 经度
		 * @param {Number} bd_lat 纬度
		 * @returns {SceneGIS.Cartographic}
		 */
		bd09togcj02(bd_lon, bd_lat) {
			var bd_lon = +bd_lon;
			var bd_lat = +bd_lat;
			var x = bd_lon - 0.0065;
			var y = bd_lat - 0.006;
			var z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * x_PI);
			var theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * x_PI);
			var gg_lng = z * Math.cos(theta);
			var gg_lat = z * Math.sin(theta);
			//return [gg_lng, gg_lat]
			return SceneGIS.Cartographic.fromDegrees(gg_lng, gg_lat, 0, new SceneGIS.Cartographic());
		};
		/**
		 * 火星坐标系 (GCJ-02) 与百度坐标系 (BD-09) 的转换
		 * 即谷歌、高德 转 百度
		 * @param {Number} lng 经度
		 * @param {Number} lat 纬度
		 * @returns {SceneGIS.Cartographic}
		 */
		gcj02tobd09(lng, lat) {
			var lat = +lat;
			var lng = +lng;
			var z = Math.sqrt(lng * lng + lat * lat) + 0.00002 * Math.sin(lat * x_PI);
			var theta = Math.atan2(lat, lng) + 0.000003 * Math.cos(lng * x_PI);
			var bd_lng = z * Math.cos(theta) + 0.0065;
			var bd_lat = z * Math.sin(theta) + 0.006;
			return SceneGIS.Cartographic.fromDegrees(bd_lng, bd_lat, 0, new SceneGIS.Cartographic());
			//return [bd_lng, bd_lat]
		};

		transformlat(lng, lat) {
			var lat = +lat;
			var lng = +lng;
			var ret = -100.0 + 2.0 * lng + 3.0 * lat + 0.2 * lat * lat + 0.1 * lng * lat + 0.2 * Math.sqrt(Math.abs(lng));
			ret += (20.0 * Math.sin(6.0 * lng * PI) + 20.0 * Math.sin(2.0 * lng * PI)) * 2.0 / 3.0;
			ret += (20.0 * Math.sin(lat * PI) + 40.0 * Math.sin(lat / 3.0 * PI)) * 2.0 / 3.0;
			ret += (160.0 * Math.sin(lat / 12.0 * PI) + 320 * Math.sin(lat * PI / 30.0)) * 2.0 / 3.0;
			return ret
		};

		transformlng(lng, lat) {
			var lat = +lat;
			var lng = +lng;
			var ret = 300.0 + lng + 2.0 * lat + 0.1 * lng * lng + 0.1 * lng * lat + 0.1 * Math.sqrt(Math.abs(lng));
			ret += (20.0 * Math.sin(6.0 * lng * PI) + 20.0 * Math.sin(2.0 * lng * PI)) * 2.0 / 3.0;
			ret += (20.0 * Math.sin(lng * PI) + 40.0 * Math.sin(lng / 3.0 * PI)) * 2.0 / 3.0;
			ret += (150.0 * Math.sin(lng / 12.0 * PI) + 300.0 * Math.sin(lng / 30.0 * PI)) * 2.0 / 3.0;
			return ret
		};
		/**
		 * 判断是否在国内，不在国内则不做偏移
		 * @param {Number} lng 经度
		 * @param {Number} lat 纬度
		 * @returns {Boolean}
		 */
		out_of_china(lng, lat) {
			var lat = +lat;
			var lng = +lng;
			// 纬度3.86~53.55,经度73.66~135.05 
			return !(lng > 73.66 && lng < 135.05 && lat > 3.86 && lat < 53.55);
		};
		transformLayer(type, tileset, height, options = {}) {
			if (!tileset) {
				return null;
			}

			const _height = height || 0;
			const boundingSphere = tileset.boundingSphere;
			let cartographic = SceneGIS.Cartographic.fromCartesian(boundingSphere.center);
			const surface = SceneGIS.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, 0);
			let offset = SceneGIS.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, _height);

			// 坐标转换偏移
			if (type === 'wgs84togcj02') {
				cartographic = this.wgs84togcj02(SceneGIS.Math.toDegrees(cartographic.longitude), SceneGIS.Math.toDegrees(cartographic.latitude));
				offset = SceneGIS.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, _height);
			}

			// 经纬度偏移
			if (options && options.offset) {
				let diflng = SceneGIS.Math.toRadians(options.offset[0]);
				let diflat = SceneGIS.Math.toRadians(options.offset[1]);
				offset = SceneGIS.Cartesian3.fromRadians(cartographic.longitude - diflng, cartographic.latitude - diflat, _height);
			}

			// 拾取点偏移
			if (options && options.originPosition && options.targetPosition) {
				let diflng = SceneGIS.Math.toRadians(options.originPosition[0] - options.targetPosition[0]);
				let diflat = SceneGIS.Math.toRadians(options.originPosition[1] - options.targetPosition[1]);
				offset = SceneGIS.Cartesian3.fromRadians(cartographic.longitude - diflng, cartographic.latitude - diflat, _height);
			}
			const translation = SceneGIS.Cartesian3.subtract(offset, surface, new SceneGIS.Cartesian3());
			tileset.modelMatrix = SceneGIS.Matrix4.fromTranslation(translation);

			// 旋转
			if (options && options.rotateAngle) {
				const mz = SceneGIS.Matrix3.fromRotationZ(SceneGIS.Math.toRadians(options.rotateAngle));
				const rotationZ = SceneGIS.SceneGIS.Matrix4.fromRotationTranslation(mz);
				tileset._root.transform = SceneGIS.SceneGIS.Matrix4.multiply(tileset._root.transform, rotationZ, new SceneGIS.SceneGIS.Matrix4());
			}
		}
	}

	function createProperty$1(
		name,
		privateName,
		subscriptionName,
		configurable,
		createPropertyCallback
	) {
		return {
			configurable: configurable,
			get: function () {
				return this[privateName];
			},
			set: function (value) {

				var oldValue = this[privateName];
				var subscription = this[subscriptionName];
				if (SceneGIS.defined(subscription)) {
					subscription();
					this[subscriptionName] = undefined;
				}

				var hasValue = value !== undefined;
				if (
					hasValue &&
					(!SceneGIS.defined(value) || !SceneGIS.defined(value.getValue)) &&
					SceneGIS.defined(createPropertyCallback)
				) {
					value = createPropertyCallback(value);
				}

				if (oldValue !== value) {
					this[privateName] = value;
					this._definitionChanged.raiseEvent(this, name, value, oldValue);
				}

				if (SceneGIS.defined(value) && SceneGIS.defined(value.definitionChanged)) {
					this[subscriptionName] = value.definitionChanged.addEventListener(
						function () {
							this._definitionChanged.raiseEvent(this, name, value, value);
						},
						this
					);
				}
			},
		};
	}

	function createConstantProperty(value) {
		return new SceneGIS.ConstantProperty(value);
	}

	/**
	 * Used to consistently define all DataSources graphics objects.
	 * This is broken into two functions because the Chrome profiler does a better
	 * job of optimizing lookups if it notices that the string is constant throughout the function.
	 * @private
	 */
	function createPropertyDescriptor$1(name, configurable, createPropertyCallback) {
		//Safari 8.0.3 has a JavaScript bug that causes it to confuse two variables and treat them as the same.
		//The two extra toString calls work around the issue.
		return createProperty$1(
			name,
			"_" + name.toString(),
			"_" + name.toString() + "Subscription",
			SceneGIS.defaultValue(configurable, false),
			SceneGIS.defaultValue(createPropertyCallback, createConstantProperty)
		);
	}

	function createPropertyTypeDescriptor(name, Type) {
		return createPropertyDescriptor(name, undefined, function (viewer, value) {
			if (value instanceof Type) {
				return value;
			}
			return new Type(viewer, value, name);
		});
	}
	function createPropertyDescriptor(name, configurable, createPropertyCallback) {
		//Safari 8.0.3 has a JavaScript bug that causes it to confuse two variables and treat them as the same.
		//The two extra toString calls work around the issue.
		return createProperty(
			name,
			"_" + name.toString(),
			"_" + name.toString() + "Subscription",
			SceneGIS.defaultValue(configurable, false),
			SceneGIS.defaultValue(createPropertyCallback, undefined)
		);
	}
	function createProperty(
		name,
		privateName,
		subscriptionName,
		configurable,
		createPropertyCallback
	) {
		return {
			configurable: configurable,
			get: function () {
				return this[privateName];
			},
			set: function (value) {
				var oldValue = this[privateName];

				var hasValue = value !== undefined;
				if (
					hasValue &&
					(!SceneGIS.defined(value) || !SceneGIS.defined(value.getValue)) &&
					SceneGIS.defined(createPropertyCallback)
				) {
					value = createPropertyCallback(this.viewer, value);
				}

				if (oldValue !== value) {
					this[privateName] = value;
					if (this[privateName]) {
						this[privateName].owner = this;//把Entity绑定到具体EntityEx对象上
					}

				}
			},
		};
	}

	let CustomShadersEX = {};

	let customShaders = {
		verticalGradient: function (option, tileset) {
			let upAxisIndex = 0;
			switch (option.upAxis) {
				case 'x':
					upAxisIndex = 0;
					break;
				case 'y':
					upAxisIndex = 1;
					break;
				case 'z':
					upAxisIndex = 2;
					break;
			}
			let customShader = new SceneGIS.CustomShader({
				uniforms: {
					u_height: {
						type: SceneGIS.UniformType.FLOAT,
						value: SceneGIS.defaultValue(option.height, 10)
					},
					u_color: {
						type: SceneGIS.UniformType.VEC3,
						value: SceneGIS.defaultValue(SceneGIS.Color.fromCssColorString(option.color), SceneGIS.Color.CYAN)
					},
					u_upIndex: {
						type: SceneGIS.UniformType.INT,
						value: upAxisIndex
					}
				},
				varyings: {
					v_modelHeight: SceneGIS.VaryingType.FLOAT
				},
				vertexShaderText: `
                void vertexMain(VertexInput vsInput, inout czm_modelVertexOutput vsOutput, inout ProcessedAttributes attributes) {
                    v_modelHeight=vsInput.attributes.positionMC[u_upIndex];
                }
            `,
				fragmentShaderText: `
                void fragmentMain(FragmentInput fsInput, inout czm_modelMaterial material) {
                    material.diffuse = u_color*v_modelHeight/u_height;
                }
            `
			});
			return customShader;
		},
		ribbon: function (option, tileset) {
			let upAxisIndex = 0;
			switch (option.upAxis) {
				case 'x':
					upAxisIndex = 0;
					break;
				case 'y':
					upAxisIndex = 1;
					break;
				case 'z':
					upAxisIndex = 2;
					break;
			}
			let customShader = new SceneGIS.CustomShader({
				uniforms: {
					u_height: {
						type: SceneGIS.UniformType.FLOAT,
						value: SceneGIS.defaultValue(option.height, 50)
					},
					u_color: {
						type: SceneGIS.UniformType.VEC3,
						value: SceneGIS.defaultValue(SceneGIS.Color.fromCssColorString(option.color), SceneGIS.Color.CYAN)
					},
					u_ribbonColor: {
						type: SceneGIS.UniformType.VEC3,
						value: SceneGIS.defaultValue(SceneGIS.Color.fromCssColorString(option.ribbonColor), SceneGIS.Color.GREEN)
					},
					u_speed: {
						type: SceneGIS.UniformType.FLOAT,
						value: SceneGIS.defaultValue(option.speed, 0.5)
					},
					u_upIndex: {
						type: SceneGIS.UniformType.INT,
						value: upAxisIndex
					}
				},
				varyings: {
					v_modelHeight: SceneGIS.VaryingType.FLOAT,
					v_modelNormal: SceneGIS.VaryingType.VEC3
				},
				vertexShaderText: `
                void vertexMain(VertexInput vsInput, inout czm_modelVertexOutput vsOutput, inout ProcessedAttributes attributes) {
                    v_modelHeight=vsInput.attributes.positionMC[u_upIndex];
                    v_modelNormal=vsInput.attributes.normalMC;
                }
            `,
				fragmentShaderText: `
                void fragmentMain(FragmentInput fsInput, inout czm_modelMaterial material) {
                    float weight=abs(v_modelHeight/u_height);
                    weight=fract(weight);
    
                    if(1.0-dot(v_modelNormal,vec3(.0,.0,1.0))<0.01){
                        material.diffuse=u_color;
                        return;
                    }
                
                    float line = fract(czm_frameNumber * u_speed / 360.0);
                    line=abs(line-0.5)*2.0;
                    if(abs(weight-line)<0.015){
                        material.diffuse=u_ribbonColor;
                    }else{
                        material.diffuse=u_color;
                    }
                }
            `
			});
			return customShader;
		},
		scan: function (option, tileset) {
			let center = tileset.root.boundingSphere.center;
			let radius = tileset.root.boundingSphere.radius;

			let customShader = new SceneGIS.CustomShader({
				uniforms: {
					u_color: {
						type: SceneGIS.UniformType.VEC3,
						value: SceneGIS.defaultValue(SceneGIS.Color.fromCssColorString(option.color), SceneGIS.Color.CYAN)
					},
					u_center: {
						type: SceneGIS.UniformType.VEC3,
						arrayNum: 1,
						value: [center]
					},
					u_circleLength: {
						type: SceneGIS.UniformType.INT,
						value: 1
					},
					u_radius: {
						type: SceneGIS.UniformType.FLOAT,
						value: SceneGIS.defaultValue(option.radius, radius)
					}
				},
				varyings: {
					v_modelPosition: SceneGIS.VaryingType.VEC3,
					v_modelNormal: SceneGIS.VaryingType.VEC3
				},
				vertexShaderText: `
                void vertexMain(VertexInput vsInput, inout czm_modelVertexOutput vsOutput, inout ProcessedAttributes attributes) {
                    v_modelPosition=vsInput.attributes.positionMC;
                    v_modelNormal=vsInput.attributes.normalMC;
                }
            `,
				fragmentShaderText: `
            float isPointOnLine(float position, float differentialLength) {
                float fractionPartOfPosition = position - floor(position + 0.5); // fract part around unit [-0.5; 0.5]
                fractionPartOfPosition /= differentialLength; // adapt to the screen space size it takes
                fractionPartOfPosition = clamp(fractionPartOfPosition, -1., 1.);
                
                float result = 0.5 + 0.5 * cos(fractionPartOfPosition * 3.14159); // Convert to 0-1 for antialiasing.
                return result;    
            }
    
            float getVisibility(float position) {
                // Major grid line every Frequency defined in material.
                float majorGridFrequency = 5.;
                if (floor(position + 0.5) == floor(position / majorGridFrequency + 0.5) * majorGridFrequency)
                {
                    return 1.0;
                }  
            
                return 0.3;
            }
    
            float getAnisotropicAttenuation(float differentialLength) {
                const float maxNumberOfLines = 10.0;
                return clamp(1.0 / (differentialLength + 1.0) - 1.0 / maxNumberOfLines, 0.0, 1.0);
            }
    
            float normalImpactOnAxis(float x) {
                float normalImpact = clamp(1.0 - 3.0 * abs(x * x * x), 0.0, 1.0);
                return normalImpact;
            }
    
            float contributionOnAxis(float position) {
                float differentialLength = length(vec2(dFdx(position), dFdy(position)));
                differentialLength *= 1.41421356;  // Multiply by SQRT2 for diagonal length
                
                // Is the point on the line.
                float result = isPointOnLine(position, differentialLength);
            
                //控制一部分线的粗细的
                // Add dynamic visibility.
                // float visibility = getVisibility(position);
                // result *= visibility;
                
                // Anisotropic filtering.
                float anisotropicAttenuation = getAnisotropicAttenuation(differentialLength);
                result *= anisotropicAttenuation;
                
                return result;
            }
    
            void fragmentMain(FragmentInput fsInput, inout czm_modelMaterial material) {
                float gridRatio = 5.0;//密度
                vec3 gridPos = v_modelPosition / gridRatio;
                float x = contributionOnAxis(gridPos.x);
                float y = contributionOnAxis(gridPos.y);
                float z = contributionOnAxis(gridPos.z);
                vec3 normal2 = czm_inverseNormal * v_modelNormal;
                x *= normalImpactOnAxis(normal2.x);
                y *= normalImpactOnAxis(normal2.y);
                z *= normalImpactOnAxis(normal2.z);
                float grid = clamp(x + y + z, 0., 1.);
                vec3 lineColor =u_color; 
                vec3 gridColor = mix(material.diffuse, lineColor, grid);
    
                float cantrol = fract(czm_frameNumber / 360.0);
    
                for(int i=0;i<u_circleLength;i++){
                    vec4 center=vec4(u_center[i],1.0);
                    center=czm_view*center;
                    if(distance(fsInput.attributes.positionEC,center.xyz)<u_radius*cantrol){
                        material.diffuse=gridColor;
                    }
                }
            }
            `
			});

			return customShader;
		},
		grow: function (option, tileset) {
			let upAxisIndex = 0;
			switch (option.upAxis) {
				case 'x':
					upAxisIndex = 0;
					break;
				case 'y':
					upAxisIndex = 1;
					break;
				case 'z':
					upAxisIndex = 2;
					break;
			}
			let customShader = new SceneGIS.CustomShader({
				uniforms: {
					u_upIndex: {
						type: SceneGIS.UniformType.INT,
						value: upAxisIndex
					}
				},
				vertexShaderText: `
                void vertexMain(VertexInput vsInput, inout czm_modelVertexOutput vsOutput, inout ProcessedAttributes attributes) {
                    vsOutput.positionMC[u_upIndex] = clamp(czm_planNumber,u_positionMin[u_upIndex],vsInput.attributes.positionMC[u_upIndex]);
                }
            `,
			});

			return customShader;
		}
	};

	CustomShadersEX.createCustomShader = function (symbol, tileset) {
		if (customShaders[symbol.name]) {
			return customShaders[symbol.name](symbol.option, tileset);
		}
		console.error("错误的symbol.name");
		return undefined;
	};

	CustomShadersEX.update = function (oldsymble, symbol, tileset) {
		if (!symbol) {
			tileset.customShader = undefined;
			return;
		}
		if (!oldsymble || oldsymble.name != symbol.name) {
			let customShader = CustomShadersEX.createCustomShader(symbol, tileset);
			tileset.customShader = customShader;
		} else {
			let uniforms = tileset.customShader.uniforms;
			let option = symbol.option;
			switch (symbol.name) {
				case 'verticalGradient':
					uniforms.u_height.value = SceneGIS.defaultValue(option.height, uniforms.u_height.value);
					uniforms.u_color.value = SceneGIS.defaultValue(SceneGIS.Color.fromCssColorString(option.color), uniforms.u_color.value);
					break;
				case 'ribbon':
					uniforms.u_height.value = SceneGIS.defaultValue(option.height, uniforms.u_height.value);
					uniforms.u_color.value = SceneGIS.defaultValue(SceneGIS.Color.fromCssColorString(option.color), uniforms.u_color.value);
					uniforms.u_ribbonColor.value = SceneGIS.defaultValue(SceneGIS.Color.fromCssColorString(option.ribbonColor), uniforms.u_ribbonColor.value);
					uniforms.u_speed.value = SceneGIS.defaultValue(option.speed, uniforms.u_speed.value);
					break;
				case 'scan':
					uniforms.u_color.value = SceneGIS.defaultValue(SceneGIS.Color.fromCssColorString(option.color), uniforms.u_color.value);
					uniforms.u_radius.value = SceneGIS.defaultValue(option.radius, uniforms.u_radius.value);
					break;
				case 'grow':
					let upAxisIndex = 0;
					switch (option.upAxis) {
						case 'x':
							upAxisIndex = 0;
							break;
						case 'y':
							upAxisIndex = 1;
							break;
						case 'z':
							upAxisIndex = 2;
							break;
					}
					uniforms.u_upIndex.value = SceneGIS.defaultValue(upAxisIndex, uniforms.u_upIndex.value);
					break;
			}
		}
	};

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	var lodashExports = {};
	var lodash = {
		get exports() { return lodashExports; },
		set exports(v) { lodashExports = v; },
	};

	/**
	 * @license
	 * Lodash <https://lodash.com/>
	 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	(function (module, exports) {
		(function () {

			/** Used as a safe reference for `undefined` in pre-ES5 environments. */
			var undefined$1;

			/** Used as the semantic version number. */
			var VERSION = '4.17.21';

			/** Used as the size to enable large array optimizations. */
			var LARGE_ARRAY_SIZE = 200;

			/** Error message constants. */
			var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
				FUNC_ERROR_TEXT = 'Expected a function',
				INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

			/** Used to stand-in for `undefined` hash values. */
			var HASH_UNDEFINED = '__lodash_hash_undefined__';

			/** Used as the maximum memoize cache size. */
			var MAX_MEMOIZE_SIZE = 500;

			/** Used as the internal argument placeholder. */
			var PLACEHOLDER = '__lodash_placeholder__';

			/** Used to compose bitmasks for cloning. */
			var CLONE_DEEP_FLAG = 1,
				CLONE_FLAT_FLAG = 2,
				CLONE_SYMBOLS_FLAG = 4;

			/** Used to compose bitmasks for value comparisons. */
			var COMPARE_PARTIAL_FLAG = 1,
				COMPARE_UNORDERED_FLAG = 2;

			/** Used to compose bitmasks for function metadata. */
			var WRAP_BIND_FLAG = 1,
				WRAP_BIND_KEY_FLAG = 2,
				WRAP_CURRY_BOUND_FLAG = 4,
				WRAP_CURRY_FLAG = 8,
				WRAP_CURRY_RIGHT_FLAG = 16,
				WRAP_PARTIAL_FLAG = 32,
				WRAP_PARTIAL_RIGHT_FLAG = 64,
				WRAP_ARY_FLAG = 128,
				WRAP_REARG_FLAG = 256,
				WRAP_FLIP_FLAG = 512;

			/** Used as default options for `_.truncate`. */
			var DEFAULT_TRUNC_LENGTH = 30,
				DEFAULT_TRUNC_OMISSION = '...';

			/** Used to detect hot functions by number of calls within a span of milliseconds. */
			var HOT_COUNT = 800,
				HOT_SPAN = 16;

			/** Used to indicate the type of lazy iteratees. */
			var LAZY_FILTER_FLAG = 1,
				LAZY_MAP_FLAG = 2,
				LAZY_WHILE_FLAG = 3;

			/** Used as references for various `Number` constants. */
			var INFINITY = 1 / 0,
				MAX_SAFE_INTEGER = 9007199254740991,
				MAX_INTEGER = 1.7976931348623157e+308,
				NAN = 0 / 0;

			/** Used as references for the maximum length and index of an array. */
			var MAX_ARRAY_LENGTH = 4294967295,
				MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
				HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

			/** Used to associate wrap methods with their bit flags. */
			var wrapFlags = [
				['ary', WRAP_ARY_FLAG],
				['bind', WRAP_BIND_FLAG],
				['bindKey', WRAP_BIND_KEY_FLAG],
				['curry', WRAP_CURRY_FLAG],
				['curryRight', WRAP_CURRY_RIGHT_FLAG],
				['flip', WRAP_FLIP_FLAG],
				['partial', WRAP_PARTIAL_FLAG],
				['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
				['rearg', WRAP_REARG_FLAG]
			];

			/** `Object#toString` result references. */
			var argsTag = '[object Arguments]',
				arrayTag = '[object Array]',
				asyncTag = '[object AsyncFunction]',
				boolTag = '[object Boolean]',
				dateTag = '[object Date]',
				domExcTag = '[object DOMException]',
				errorTag = '[object Error]',
				funcTag = '[object Function]',
				genTag = '[object GeneratorFunction]',
				mapTag = '[object Map]',
				numberTag = '[object Number]',
				nullTag = '[object Null]',
				objectTag = '[object Object]',
				promiseTag = '[object Promise]',
				proxyTag = '[object Proxy]',
				regexpTag = '[object RegExp]',
				setTag = '[object Set]',
				stringTag = '[object String]',
				symbolTag = '[object Symbol]',
				undefinedTag = '[object Undefined]',
				weakMapTag = '[object WeakMap]',
				weakSetTag = '[object WeakSet]';

			var arrayBufferTag = '[object ArrayBuffer]',
				dataViewTag = '[object DataView]',
				float32Tag = '[object Float32Array]',
				float64Tag = '[object Float64Array]',
				int8Tag = '[object Int8Array]',
				int16Tag = '[object Int16Array]',
				int32Tag = '[object Int32Array]',
				uint8Tag = '[object Uint8Array]',
				uint8ClampedTag = '[object Uint8ClampedArray]',
				uint16Tag = '[object Uint16Array]',
				uint32Tag = '[object Uint32Array]';

			/** Used to match empty string literals in compiled template source. */
			var reEmptyStringLeading = /\b__p \+= '';/g,
				reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
				reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

			/** Used to match HTML entities and HTML characters. */
			var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
				reUnescapedHtml = /[&<>"']/g,
				reHasEscapedHtml = RegExp(reEscapedHtml.source),
				reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

			/** Used to match template delimiters. */
			var reEscape = /<%-([\s\S]+?)%>/g,
				reEvaluate = /<%([\s\S]+?)%>/g,
				reInterpolate = /<%=([\s\S]+?)%>/g;

			/** Used to match property names within property paths. */
			var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
				reIsPlainProp = /^\w*$/,
				rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

			/**
			 * Used to match `RegExp`
			 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
			 */
			var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
				reHasRegExpChar = RegExp(reRegExpChar.source);

			/** Used to match leading whitespace. */
			var reTrimStart = /^\s+/;

			/** Used to match a single whitespace character. */
			var reWhitespace = /\s/;

			/** Used to match wrap detail comments. */
			var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
				reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
				reSplitDetails = /,? & /;

			/** Used to match words composed of alphanumeric characters. */
			var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

			/**
			 * Used to validate the `validate` option in `_.template` variable.
			 *
			 * Forbids characters which could potentially change the meaning of the function argument definition:
			 * - "()," (modification of function parameters)
			 * - "=" (default value)
			 * - "[]{}" (destructuring of function parameters)
			 * - "/" (beginning of a comment)
			 * - whitespace
			 */
			var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

			/** Used to match backslashes in property paths. */
			var reEscapeChar = /\\(\\)?/g;

			/**
			 * Used to match
			 * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
			 */
			var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

			/** Used to match `RegExp` flags from their coerced string values. */
			var reFlags = /\w*$/;

			/** Used to detect bad signed hexadecimal string values. */
			var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

			/** Used to detect binary string values. */
			var reIsBinary = /^0b[01]+$/i;

			/** Used to detect host constructors (Safari). */
			var reIsHostCtor = /^\[object .+?Constructor\]$/;

			/** Used to detect octal string values. */
			var reIsOctal = /^0o[0-7]+$/i;

			/** Used to detect unsigned integer values. */
			var reIsUint = /^(?:0|[1-9]\d*)$/;

			/** Used to match Latin Unicode letters (excluding mathematical operators). */
			var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

			/** Used to ensure capturing order of template delimiters. */
			var reNoMatch = /($^)/;

			/** Used to match unescaped characters in compiled string literals. */
			var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

			/** Used to compose unicode character classes. */
			var rsAstralRange = '\\ud800-\\udfff',
				rsComboMarksRange = '\\u0300-\\u036f',
				reComboHalfMarksRange = '\\ufe20-\\ufe2f',
				rsComboSymbolsRange = '\\u20d0-\\u20ff',
				rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
				rsDingbatRange = '\\u2700-\\u27bf',
				rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
				rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
				rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
				rsPunctuationRange = '\\u2000-\\u206f',
				rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
				rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
				rsVarRange = '\\ufe0e\\ufe0f',
				rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

			/** Used to compose unicode capture groups. */
			var rsApos = "['\u2019]",
				rsAstral = '[' + rsAstralRange + ']',
				rsBreak = '[' + rsBreakRange + ']',
				rsCombo = '[' + rsComboRange + ']',
				rsDigits = '\\d+',
				rsDingbat = '[' + rsDingbatRange + ']',
				rsLower = '[' + rsLowerRange + ']',
				rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
				rsFitz = '\\ud83c[\\udffb-\\udfff]',
				rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
				rsNonAstral = '[^' + rsAstralRange + ']',
				rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
				rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
				rsUpper = '[' + rsUpperRange + ']',
				rsZWJ = '\\u200d';

			/** Used to compose unicode regexes. */
			var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
				rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
				rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
				rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
				reOptMod = rsModifier + '?',
				rsOptVar = '[' + rsVarRange + ']?',
				rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
				rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
				rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
				rsSeq = rsOptVar + reOptMod + rsOptJoin,
				rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
				rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

			/** Used to match apostrophes. */
			var reApos = RegExp(rsApos, 'g');

			/**
			 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
			 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
			 */
			var reComboMark = RegExp(rsCombo, 'g');

			/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
			var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

			/** Used to match complex or compound words. */
			var reUnicodeWord = RegExp([
				rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
				rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
				rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
				rsUpper + '+' + rsOptContrUpper,
				rsOrdUpper,
				rsOrdLower,
				rsDigits,
				rsEmoji
			].join('|'), 'g');

			/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
			var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');

			/** Used to detect strings that need a more robust regexp to match words. */
			var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

			/** Used to assign default `context` object properties. */
			var contextProps = [
				'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
				'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
				'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
				'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
				'_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
			];

			/** Used to make template sourceURLs easier to identify. */
			var templateCounter = -1;

			/** Used to identify `toStringTag` values of typed arrays. */
			var typedArrayTags = {};
			typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
				typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
				typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
				typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
				typedArrayTags[uint32Tag] = true;
			typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
				typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
				typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
				typedArrayTags[errorTag] = typedArrayTags[funcTag] =
				typedArrayTags[mapTag] = typedArrayTags[numberTag] =
				typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
				typedArrayTags[setTag] = typedArrayTags[stringTag] =
				typedArrayTags[weakMapTag] = false;

			/** Used to identify `toStringTag` values supported by `_.clone`. */
			var cloneableTags = {};
			cloneableTags[argsTag] = cloneableTags[arrayTag] =
				cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
				cloneableTags[boolTag] = cloneableTags[dateTag] =
				cloneableTags[float32Tag] = cloneableTags[float64Tag] =
				cloneableTags[int8Tag] = cloneableTags[int16Tag] =
				cloneableTags[int32Tag] = cloneableTags[mapTag] =
				cloneableTags[numberTag] = cloneableTags[objectTag] =
				cloneableTags[regexpTag] = cloneableTags[setTag] =
				cloneableTags[stringTag] = cloneableTags[symbolTag] =
				cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
				cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
			cloneableTags[errorTag] = cloneableTags[funcTag] =
				cloneableTags[weakMapTag] = false;

			/** Used to map Latin Unicode letters to basic Latin letters. */
			var deburredLetters = {
				// Latin-1 Supplement block.
				'\xc0': 'A', '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
				'\xe0': 'a', '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
				'\xc7': 'C', '\xe7': 'c',
				'\xd0': 'D', '\xf0': 'd',
				'\xc8': 'E', '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
				'\xe8': 'e', '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
				'\xcc': 'I', '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
				'\xec': 'i', '\xed': 'i', '\xee': 'i', '\xef': 'i',
				'\xd1': 'N', '\xf1': 'n',
				'\xd2': 'O', '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
				'\xf2': 'o', '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
				'\xd9': 'U', '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
				'\xf9': 'u', '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
				'\xdd': 'Y', '\xfd': 'y', '\xff': 'y',
				'\xc6': 'Ae', '\xe6': 'ae',
				'\xde': 'Th', '\xfe': 'th',
				'\xdf': 'ss',
				// Latin Extended-A block.
				'\u0100': 'A', '\u0102': 'A', '\u0104': 'A',
				'\u0101': 'a', '\u0103': 'a', '\u0105': 'a',
				'\u0106': 'C', '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
				'\u0107': 'c', '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
				'\u010e': 'D', '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
				'\u0112': 'E', '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
				'\u0113': 'e', '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
				'\u011c': 'G', '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
				'\u011d': 'g', '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
				'\u0124': 'H', '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
				'\u0128': 'I', '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
				'\u0129': 'i', '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
				'\u0134': 'J', '\u0135': 'j',
				'\u0136': 'K', '\u0137': 'k', '\u0138': 'k',
				'\u0139': 'L', '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
				'\u013a': 'l', '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
				'\u0143': 'N', '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
				'\u0144': 'n', '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
				'\u014c': 'O', '\u014e': 'O', '\u0150': 'O',
				'\u014d': 'o', '\u014f': 'o', '\u0151': 'o',
				'\u0154': 'R', '\u0156': 'R', '\u0158': 'R',
				'\u0155': 'r', '\u0157': 'r', '\u0159': 'r',
				'\u015a': 'S', '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
				'\u015b': 's', '\u015d': 's', '\u015f': 's', '\u0161': 's',
				'\u0162': 'T', '\u0164': 'T', '\u0166': 'T',
				'\u0163': 't', '\u0165': 't', '\u0167': 't',
				'\u0168': 'U', '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
				'\u0169': 'u', '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
				'\u0174': 'W', '\u0175': 'w',
				'\u0176': 'Y', '\u0177': 'y', '\u0178': 'Y',
				'\u0179': 'Z', '\u017b': 'Z', '\u017d': 'Z',
				'\u017a': 'z', '\u017c': 'z', '\u017e': 'z',
				'\u0132': 'IJ', '\u0133': 'ij',
				'\u0152': 'Oe', '\u0153': 'oe',
				'\u0149': "'n", '\u017f': 's'
			};

			/** Used to map characters to HTML entities. */
			var htmlEscapes = {
				'&': '&amp;',
				'<': '&lt;',
				'>': '&gt;',
				'"': '&quot;',
				"'": '&#39;'
			};

			/** Used to map HTML entities to characters. */
			var htmlUnescapes = {
				'&amp;': '&',
				'&lt;': '<',
				'&gt;': '>',
				'&quot;': '"',
				'&#39;': "'"
			};

			/** Used to escape characters for inclusion in compiled string literals. */
			var stringEscapes = {
				'\\': '\\',
				"'": "'",
				'\n': 'n',
				'\r': 'r',
				'\u2028': 'u2028',
				'\u2029': 'u2029'
			};

			/** Built-in method references without a dependency on `root`. */
			var freeParseFloat = parseFloat,
				freeParseInt = parseInt;

			/** Detect free variable `global` from Node.js. */
			var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

			/** Detect free variable `self`. */
			var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

			/** Used as a reference to the global object. */
			var root = freeGlobal || freeSelf || Function('return this')();

			/** Detect free variable `exports`. */
			var freeExports = exports && !exports.nodeType && exports;

			/** Detect free variable `module`. */
			var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

			/** Detect the popular CommonJS extension `module.exports`. */
			var moduleExports = freeModule && freeModule.exports === freeExports;

			/** Detect free variable `process` from Node.js. */
			var freeProcess = moduleExports && freeGlobal.process;

			/** Used to access faster Node.js helpers. */
			var nodeUtil = (function () {
				try {
					// Use `util.types` for Node.js 10+.
					var types = freeModule && freeModule.require && freeModule.require('util').types;

					if (types) {
						return types;
					}

					// Legacy `process.binding('util')` for Node.js < 10.
					return freeProcess && freeProcess.binding && freeProcess.binding('util');
				} catch (e) { }
			}());

			/* Node.js helper references. */
			var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
				nodeIsDate = nodeUtil && nodeUtil.isDate,
				nodeIsMap = nodeUtil && nodeUtil.isMap,
				nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
				nodeIsSet = nodeUtil && nodeUtil.isSet,
				nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

			/*--------------------------------------------------------------------------*/

			/**
			 * A faster alternative to `Function#apply`, this function invokes `func`
			 * with the `this` binding of `thisArg` and the arguments of `args`.
			 *
			 * @private
			 * @param {Function} func The function to invoke.
			 * @param {*} thisArg The `this` binding of `func`.
			 * @param {Array} args The arguments to invoke `func` with.
			 * @returns {*} Returns the result of `func`.
			 */
			function apply(func, thisArg, args) {
				switch (args.length) {
					case 0: return func.call(thisArg);
					case 1: return func.call(thisArg, args[0]);
					case 2: return func.call(thisArg, args[0], args[1]);
					case 3: return func.call(thisArg, args[0], args[1], args[2]);
				}
				return func.apply(thisArg, args);
			}

			/**
			 * A specialized version of `baseAggregator` for arrays.
			 *
			 * @private
			 * @param {Array} [array] The array to iterate over.
			 * @param {Function} setter The function to set `accumulator` values.
			 * @param {Function} iteratee The iteratee to transform keys.
			 * @param {Object} accumulator The initial aggregated object.
			 * @returns {Function} Returns `accumulator`.
			 */
			function arrayAggregator(array, setter, iteratee, accumulator) {
				var index = -1,
					length = array == null ? 0 : array.length;

				while (++index < length) {
					var value = array[index];
					setter(accumulator, value, iteratee(value), array);
				}
				return accumulator;
			}

			/**
			 * A specialized version of `_.forEach` for arrays without support for
			 * iteratee shorthands.
			 *
			 * @private
			 * @param {Array} [array] The array to iterate over.
			 * @param {Function} iteratee The function invoked per iteration.
			 * @returns {Array} Returns `array`.
			 */
			function arrayEach(array, iteratee) {
				var index = -1,
					length = array == null ? 0 : array.length;

				while (++index < length) {
					if (iteratee(array[index], index, array) === false) {
						break;
					}
				}
				return array;
			}

			/**
			 * A specialized version of `_.forEachRight` for arrays without support for
			 * iteratee shorthands.
			 *
			 * @private
			 * @param {Array} [array] The array to iterate over.
			 * @param {Function} iteratee The function invoked per iteration.
			 * @returns {Array} Returns `array`.
			 */
			function arrayEachRight(array, iteratee) {
				var length = array == null ? 0 : array.length;

				while (length--) {
					if (iteratee(array[length], length, array) === false) {
						break;
					}
				}
				return array;
			}

			/**
			 * A specialized version of `_.every` for arrays without support for
			 * iteratee shorthands.
			 *
			 * @private
			 * @param {Array} [array] The array to iterate over.
			 * @param {Function} predicate The function invoked per iteration.
			 * @returns {boolean} Returns `true` if all elements pass the predicate check,
			 *  else `false`.
			 */
			function arrayEvery(array, predicate) {
				var index = -1,
					length = array == null ? 0 : array.length;

				while (++index < length) {
					if (!predicate(array[index], index, array)) {
						return false;
					}
				}
				return true;
			}

			/**
			 * A specialized version of `_.filter` for arrays without support for
			 * iteratee shorthands.
			 *
			 * @private
			 * @param {Array} [array] The array to iterate over.
			 * @param {Function} predicate The function invoked per iteration.
			 * @returns {Array} Returns the new filtered array.
			 */
			function arrayFilter(array, predicate) {
				var index = -1,
					length = array == null ? 0 : array.length,
					resIndex = 0,
					result = [];

				while (++index < length) {
					var value = array[index];
					if (predicate(value, index, array)) {
						result[resIndex++] = value;
					}
				}
				return result;
			}

			/**
			 * A specialized version of `_.includes` for arrays without support for
			 * specifying an index to search from.
			 *
			 * @private
			 * @param {Array} [array] The array to inspect.
			 * @param {*} target The value to search for.
			 * @returns {boolean} Returns `true` if `target` is found, else `false`.
			 */
			function arrayIncludes(array, value) {
				var length = array == null ? 0 : array.length;
				return !!length && baseIndexOf(array, value, 0) > -1;
			}

			/**
			 * This function is like `arrayIncludes` except that it accepts a comparator.
			 *
			 * @private
			 * @param {Array} [array] The array to inspect.
			 * @param {*} target The value to search for.
			 * @param {Function} comparator The comparator invoked per element.
			 * @returns {boolean} Returns `true` if `target` is found, else `false`.
			 */
			function arrayIncludesWith(array, value, comparator) {
				var index = -1,
					length = array == null ? 0 : array.length;

				while (++index < length) {
					if (comparator(value, array[index])) {
						return true;
					}
				}
				return false;
			}

			/**
			 * A specialized version of `_.map` for arrays without support for iteratee
			 * shorthands.
			 *
			 * @private
			 * @param {Array} [array] The array to iterate over.
			 * @param {Function} iteratee The function invoked per iteration.
			 * @returns {Array} Returns the new mapped array.
			 */
			function arrayMap(array, iteratee) {
				var index = -1,
					length = array == null ? 0 : array.length,
					result = Array(length);

				while (++index < length) {
					result[index] = iteratee(array[index], index, array);
				}
				return result;
			}

			/**
			 * Appends the elements of `values` to `array`.
			 *
			 * @private
			 * @param {Array} array The array to modify.
			 * @param {Array} values The values to append.
			 * @returns {Array} Returns `array`.
			 */
			function arrayPush(array, values) {
				var index = -1,
					length = values.length,
					offset = array.length;

				while (++index < length) {
					array[offset + index] = values[index];
				}
				return array;
			}

			/**
			 * A specialized version of `_.reduce` for arrays without support for
			 * iteratee shorthands.
			 *
			 * @private
			 * @param {Array} [array] The array to iterate over.
			 * @param {Function} iteratee The function invoked per iteration.
			 * @param {*} [accumulator] The initial value.
			 * @param {boolean} [initAccum] Specify using the first element of `array` as
			 *  the initial value.
			 * @returns {*} Returns the accumulated value.
			 */
			function arrayReduce(array, iteratee, accumulator, initAccum) {
				var index = -1,
					length = array == null ? 0 : array.length;

				if (initAccum && length) {
					accumulator = array[++index];
				}
				while (++index < length) {
					accumulator = iteratee(accumulator, array[index], index, array);
				}
				return accumulator;
			}

			/**
			 * A specialized version of `_.reduceRight` for arrays without support for
			 * iteratee shorthands.
			 *
			 * @private
			 * @param {Array} [array] The array to iterate over.
			 * @param {Function} iteratee The function invoked per iteration.
			 * @param {*} [accumulator] The initial value.
			 * @param {boolean} [initAccum] Specify using the last element of `array` as
			 *  the initial value.
			 * @returns {*} Returns the accumulated value.
			 */
			function arrayReduceRight(array, iteratee, accumulator, initAccum) {
				var length = array == null ? 0 : array.length;
				if (initAccum && length) {
					accumulator = array[--length];
				}
				while (length--) {
					accumulator = iteratee(accumulator, array[length], length, array);
				}
				return accumulator;
			}

			/**
			 * A specialized version of `_.some` for arrays without support for iteratee
			 * shorthands.
			 *
			 * @private
			 * @param {Array} [array] The array to iterate over.
			 * @param {Function} predicate The function invoked per iteration.
			 * @returns {boolean} Returns `true` if any element passes the predicate check,
			 *  else `false`.
			 */
			function arraySome(array, predicate) {
				var index = -1,
					length = array == null ? 0 : array.length;

				while (++index < length) {
					if (predicate(array[index], index, array)) {
						return true;
					}
				}
				return false;
			}

			/**
			 * Gets the size of an ASCII `string`.
			 *
			 * @private
			 * @param {string} string The string inspect.
			 * @returns {number} Returns the string size.
			 */
			var asciiSize = baseProperty('length');

			/**
			 * Converts an ASCII `string` to an array.
			 *
			 * @private
			 * @param {string} string The string to convert.
			 * @returns {Array} Returns the converted array.
			 */
			function asciiToArray(string) {
				return string.split('');
			}

			/**
			 * Splits an ASCII `string` into an array of its words.
			 *
			 * @private
			 * @param {string} The string to inspect.
			 * @returns {Array} Returns the words of `string`.
			 */
			function asciiWords(string) {
				return string.match(reAsciiWord) || [];
			}

			/**
			 * The base implementation of methods like `_.findKey` and `_.findLastKey`,
			 * without support for iteratee shorthands, which iterates over `collection`
			 * using `eachFunc`.
			 *
			 * @private
			 * @param {Array|Object} collection The collection to inspect.
			 * @param {Function} predicate The function invoked per iteration.
			 * @param {Function} eachFunc The function to iterate over `collection`.
			 * @returns {*} Returns the found element or its key, else `undefined`.
			 */
			function baseFindKey(collection, predicate, eachFunc) {
				var result;
				eachFunc(collection, function (value, key, collection) {
					if (predicate(value, key, collection)) {
						result = key;
						return false;
					}
				});
				return result;
			}

			/**
			 * The base implementation of `_.findIndex` and `_.findLastIndex` without
			 * support for iteratee shorthands.
			 *
			 * @private
			 * @param {Array} array The array to inspect.
			 * @param {Function} predicate The function invoked per iteration.
			 * @param {number} fromIndex The index to search from.
			 * @param {boolean} [fromRight] Specify iterating from right to left.
			 * @returns {number} Returns the index of the matched value, else `-1`.
			 */
			function baseFindIndex(array, predicate, fromIndex, fromRight) {
				var length = array.length,
					index = fromIndex + (fromRight ? 1 : -1);

				while ((fromRight ? index-- : ++index < length)) {
					if (predicate(array[index], index, array)) {
						return index;
					}
				}
				return -1;
			}

			/**
			 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
			 *
			 * @private
			 * @param {Array} array The array to inspect.
			 * @param {*} value The value to search for.
			 * @param {number} fromIndex The index to search from.
			 * @returns {number} Returns the index of the matched value, else `-1`.
			 */
			function baseIndexOf(array, value, fromIndex) {
				return value === value
					? strictIndexOf(array, value, fromIndex)
					: baseFindIndex(array, baseIsNaN, fromIndex);
			}

			/**
			 * This function is like `baseIndexOf` except that it accepts a comparator.
			 *
			 * @private
			 * @param {Array} array The array to inspect.
			 * @param {*} value The value to search for.
			 * @param {number} fromIndex The index to search from.
			 * @param {Function} comparator The comparator invoked per element.
			 * @returns {number} Returns the index of the matched value, else `-1`.
			 */
			function baseIndexOfWith(array, value, fromIndex, comparator) {
				var index = fromIndex - 1,
					length = array.length;

				while (++index < length) {
					if (comparator(array[index], value)) {
						return index;
					}
				}
				return -1;
			}

			/**
			 * The base implementation of `_.isNaN` without support for number objects.
			 *
			 * @private
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
			 */
			function baseIsNaN(value) {
				return value !== value;
			}

			/**
			 * The base implementation of `_.mean` and `_.meanBy` without support for
			 * iteratee shorthands.
			 *
			 * @private
			 * @param {Array} array The array to iterate over.
			 * @param {Function} iteratee The function invoked per iteration.
			 * @returns {number} Returns the mean.
			 */
			function baseMean(array, iteratee) {
				var length = array == null ? 0 : array.length;
				return length ? (baseSum(array, iteratee) / length) : NAN;
			}

			/**
			 * The base implementation of `_.property` without support for deep paths.
			 *
			 * @private
			 * @param {string} key The key of the property to get.
			 * @returns {Function} Returns the new accessor function.
			 */
			function baseProperty(key) {
				return function (object) {
					return object == null ? undefined$1 : object[key];
				};
			}

			/**
			 * The base implementation of `_.propertyOf` without support for deep paths.
			 *
			 * @private
			 * @param {Object} object The object to query.
			 * @returns {Function} Returns the new accessor function.
			 */
			function basePropertyOf(object) {
				return function (key) {
					return object == null ? undefined$1 : object[key];
				};
			}

			/**
			 * The base implementation of `_.reduce` and `_.reduceRight`, without support
			 * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
			 *
			 * @private
			 * @param {Array|Object} collection The collection to iterate over.
			 * @param {Function} iteratee The function invoked per iteration.
			 * @param {*} accumulator The initial value.
			 * @param {boolean} initAccum Specify using the first or last element of
			 *  `collection` as the initial value.
			 * @param {Function} eachFunc The function to iterate over `collection`.
			 * @returns {*} Returns the accumulated value.
			 */
			function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
				eachFunc(collection, function (value, index, collection) {
					accumulator = initAccum
						? (initAccum = false, value)
						: iteratee(accumulator, value, index, collection);
				});
				return accumulator;
			}

			/**
			 * The base implementation of `_.sortBy` which uses `comparer` to define the
			 * sort order of `array` and replaces criteria objects with their corresponding
			 * values.
			 *
			 * @private
			 * @param {Array} array The array to sort.
			 * @param {Function} comparer The function to define sort order.
			 * @returns {Array} Returns `array`.
			 */
			function baseSortBy(array, comparer) {
				var length = array.length;

				array.sort(comparer);
				while (length--) {
					array[length] = array[length].value;
				}
				return array;
			}

			/**
			 * The base implementation of `_.sum` and `_.sumBy` without support for
			 * iteratee shorthands.
			 *
			 * @private
			 * @param {Array} array The array to iterate over.
			 * @param {Function} iteratee The function invoked per iteration.
			 * @returns {number} Returns the sum.
			 */
			function baseSum(array, iteratee) {
				var result,
					index = -1,
					length = array.length;

				while (++index < length) {
					var current = iteratee(array[index]);
					if (current !== undefined$1) {
						result = result === undefined$1 ? current : (result + current);
					}
				}
				return result;
			}

			/**
			 * The base implementation of `_.times` without support for iteratee shorthands
			 * or max array length checks.
			 *
			 * @private
			 * @param {number} n The number of times to invoke `iteratee`.
			 * @param {Function} iteratee The function invoked per iteration.
			 * @returns {Array} Returns the array of results.
			 */
			function baseTimes(n, iteratee) {
				var index = -1,
					result = Array(n);

				while (++index < n) {
					result[index] = iteratee(index);
				}
				return result;
			}

			/**
			 * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
			 * of key-value pairs for `object` corresponding to the property names of `props`.
			 *
			 * @private
			 * @param {Object} object The object to query.
			 * @param {Array} props The property names to get values for.
			 * @returns {Object} Returns the key-value pairs.
			 */
			function baseToPairs(object, props) {
				return arrayMap(props, function (key) {
					return [key, object[key]];
				});
			}

			/**
			 * The base implementation of `_.trim`.
			 *
			 * @private
			 * @param {string} string The string to trim.
			 * @returns {string} Returns the trimmed string.
			 */
			function baseTrim(string) {
				return string
					? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
					: string;
			}

			/**
			 * The base implementation of `_.unary` without support for storing metadata.
			 *
			 * @private
			 * @param {Function} func The function to cap arguments for.
			 * @returns {Function} Returns the new capped function.
			 */
			function baseUnary(func) {
				return function (value) {
					return func(value);
				};
			}

			/**
			 * The base implementation of `_.values` and `_.valuesIn` which creates an
			 * array of `object` property values corresponding to the property names
			 * of `props`.
			 *
			 * @private
			 * @param {Object} object The object to query.
			 * @param {Array} props The property names to get values for.
			 * @returns {Object} Returns the array of property values.
			 */
			function baseValues(object, props) {
				return arrayMap(props, function (key) {
					return object[key];
				});
			}

			/**
			 * Checks if a `cache` value for `key` exists.
			 *
			 * @private
			 * @param {Object} cache The cache to query.
			 * @param {string} key The key of the entry to check.
			 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
			 */
			function cacheHas(cache, key) {
				return cache.has(key);
			}

			/**
			 * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
			 * that is not found in the character symbols.
			 *
			 * @private
			 * @param {Array} strSymbols The string symbols to inspect.
			 * @param {Array} chrSymbols The character symbols to find.
			 * @returns {number} Returns the index of the first unmatched string symbol.
			 */
			function charsStartIndex(strSymbols, chrSymbols) {
				var index = -1,
					length = strSymbols.length;

				while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) { }
				return index;
			}

			/**
			 * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
			 * that is not found in the character symbols.
			 *
			 * @private
			 * @param {Array} strSymbols The string symbols to inspect.
			 * @param {Array} chrSymbols The character symbols to find.
			 * @returns {number} Returns the index of the last unmatched string symbol.
			 */
			function charsEndIndex(strSymbols, chrSymbols) {
				var index = strSymbols.length;

				while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) { }
				return index;
			}

			/**
			 * Gets the number of `placeholder` occurrences in `array`.
			 *
			 * @private
			 * @param {Array} array The array to inspect.
			 * @param {*} placeholder The placeholder to search for.
			 * @returns {number} Returns the placeholder count.
			 */
			function countHolders(array, placeholder) {
				var length = array.length,
					result = 0;

				while (length--) {
					if (array[length] === placeholder) {
						++result;
					}
				}
				return result;
			}

			/**
			 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
			 * letters to basic Latin letters.
			 *
			 * @private
			 * @param {string} letter The matched letter to deburr.
			 * @returns {string} Returns the deburred letter.
			 */
			var deburrLetter = basePropertyOf(deburredLetters);

			/**
			 * Used by `_.escape` to convert characters to HTML entities.
			 *
			 * @private
			 * @param {string} chr The matched character to escape.
			 * @returns {string} Returns the escaped character.
			 */
			var escapeHtmlChar = basePropertyOf(htmlEscapes);

			/**
			 * Used by `_.template` to escape characters for inclusion in compiled string literals.
			 *
			 * @private
			 * @param {string} chr The matched character to escape.
			 * @returns {string} Returns the escaped character.
			 */
			function escapeStringChar(chr) {
				return '\\' + stringEscapes[chr];
			}

			/**
			 * Gets the value at `key` of `object`.
			 *
			 * @private
			 * @param {Object} [object] The object to query.
			 * @param {string} key The key of the property to get.
			 * @returns {*} Returns the property value.
			 */
			function getValue(object, key) {
				return object == null ? undefined$1 : object[key];
			}

			/**
			 * Checks if `string` contains Unicode symbols.
			 *
			 * @private
			 * @param {string} string The string to inspect.
			 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
			 */
			function hasUnicode(string) {
				return reHasUnicode.test(string);
			}

			/**
			 * Checks if `string` contains a word composed of Unicode symbols.
			 *
			 * @private
			 * @param {string} string The string to inspect.
			 * @returns {boolean} Returns `true` if a word is found, else `false`.
			 */
			function hasUnicodeWord(string) {
				return reHasUnicodeWord.test(string);
			}

			/**
			 * Converts `iterator` to an array.
			 *
			 * @private
			 * @param {Object} iterator The iterator to convert.
			 * @returns {Array} Returns the converted array.
			 */
			function iteratorToArray(iterator) {
				var data,
					result = [];

				while (!(data = iterator.next()).done) {
					result.push(data.value);
				}
				return result;
			}

			/**
			 * Converts `map` to its key-value pairs.
			 *
			 * @private
			 * @param {Object} map The map to convert.
			 * @returns {Array} Returns the key-value pairs.
			 */
			function mapToArray(map) {
				var index = -1,
					result = Array(map.size);

				map.forEach(function (value, key) {
					result[++index] = [key, value];
				});
				return result;
			}

			/**
			 * Creates a unary function that invokes `func` with its argument transformed.
			 *
			 * @private
			 * @param {Function} func The function to wrap.
			 * @param {Function} transform The argument transform.
			 * @returns {Function} Returns the new function.
			 */
			function overArg(func, transform) {
				return function (arg) {
					return func(transform(arg));
				};
			}

			/**
			 * Replaces all `placeholder` elements in `array` with an internal placeholder
			 * and returns an array of their indexes.
			 *
			 * @private
			 * @param {Array} array The array to modify.
			 * @param {*} placeholder The placeholder to replace.
			 * @returns {Array} Returns the new array of placeholder indexes.
			 */
			function replaceHolders(array, placeholder) {
				var index = -1,
					length = array.length,
					resIndex = 0,
					result = [];

				while (++index < length) {
					var value = array[index];
					if (value === placeholder || value === PLACEHOLDER) {
						array[index] = PLACEHOLDER;
						result[resIndex++] = index;
					}
				}
				return result;
			}

			/**
			 * Converts `set` to an array of its values.
			 *
			 * @private
			 * @param {Object} set The set to convert.
			 * @returns {Array} Returns the values.
			 */
			function setToArray(set) {
				var index = -1,
					result = Array(set.size);

				set.forEach(function (value) {
					result[++index] = value;
				});
				return result;
			}

			/**
			 * Converts `set` to its value-value pairs.
			 *
			 * @private
			 * @param {Object} set The set to convert.
			 * @returns {Array} Returns the value-value pairs.
			 */
			function setToPairs(set) {
				var index = -1,
					result = Array(set.size);

				set.forEach(function (value) {
					result[++index] = [value, value];
				});
				return result;
			}

			/**
			 * A specialized version of `_.indexOf` which performs strict equality
			 * comparisons of values, i.e. `===`.
			 *
			 * @private
			 * @param {Array} array The array to inspect.
			 * @param {*} value The value to search for.
			 * @param {number} fromIndex The index to search from.
			 * @returns {number} Returns the index of the matched value, else `-1`.
			 */
			function strictIndexOf(array, value, fromIndex) {
				var index = fromIndex - 1,
					length = array.length;

				while (++index < length) {
					if (array[index] === value) {
						return index;
					}
				}
				return -1;
			}

			/**
			 * A specialized version of `_.lastIndexOf` which performs strict equality
			 * comparisons of values, i.e. `===`.
			 *
			 * @private
			 * @param {Array} array The array to inspect.
			 * @param {*} value The value to search for.
			 * @param {number} fromIndex The index to search from.
			 * @returns {number} Returns the index of the matched value, else `-1`.
			 */
			function strictLastIndexOf(array, value, fromIndex) {
				var index = fromIndex + 1;
				while (index--) {
					if (array[index] === value) {
						return index;
					}
				}
				return index;
			}

			/**
			 * Gets the number of symbols in `string`.
			 *
			 * @private
			 * @param {string} string The string to inspect.
			 * @returns {number} Returns the string size.
			 */
			function stringSize(string) {
				return hasUnicode(string)
					? unicodeSize(string)
					: asciiSize(string);
			}

			/**
			 * Converts `string` to an array.
			 *
			 * @private
			 * @param {string} string The string to convert.
			 * @returns {Array} Returns the converted array.
			 */
			function stringToArray(string) {
				return hasUnicode(string)
					? unicodeToArray(string)
					: asciiToArray(string);
			}

			/**
			 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
			 * character of `string`.
			 *
			 * @private
			 * @param {string} string The string to inspect.
			 * @returns {number} Returns the index of the last non-whitespace character.
			 */
			function trimmedEndIndex(string) {
				var index = string.length;

				while (index-- && reWhitespace.test(string.charAt(index))) { }
				return index;
			}

			/**
			 * Used by `_.unescape` to convert HTML entities to characters.
			 *
			 * @private
			 * @param {string} chr The matched character to unescape.
			 * @returns {string} Returns the unescaped character.
			 */
			var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

			/**
			 * Gets the size of a Unicode `string`.
			 *
			 * @private
			 * @param {string} string The string inspect.
			 * @returns {number} Returns the string size.
			 */
			function unicodeSize(string) {
				var result = reUnicode.lastIndex = 0;
				while (reUnicode.test(string)) {
					++result;
				}
				return result;
			}

			/**
			 * Converts a Unicode `string` to an array.
			 *
			 * @private
			 * @param {string} string The string to convert.
			 * @returns {Array} Returns the converted array.
			 */
			function unicodeToArray(string) {
				return string.match(reUnicode) || [];
			}

			/**
			 * Splits a Unicode `string` into an array of its words.
			 *
			 * @private
			 * @param {string} The string to inspect.
			 * @returns {Array} Returns the words of `string`.
			 */
			function unicodeWords(string) {
				return string.match(reUnicodeWord) || [];
			}

			/*--------------------------------------------------------------------------*/

			/**
			 * Create a new pristine `lodash` function using the `context` object.
			 *
			 * @static
			 * @memberOf _
			 * @since 1.1.0
			 * @category Util
			 * @param {Object} [context=root] The context object.
			 * @returns {Function} Returns a new `lodash` function.
			 * @example
			 *
			 * _.mixin({ 'foo': _.constant('foo') });
			 *
			 * var lodash = _.runInContext();
			 * lodash.mixin({ 'bar': lodash.constant('bar') });
			 *
			 * _.isFunction(_.foo);
			 * // => true
			 * _.isFunction(_.bar);
			 * // => false
			 *
			 * lodash.isFunction(lodash.foo);
			 * // => false
			 * lodash.isFunction(lodash.bar);
			 * // => true
			 *
			 * // Create a suped-up `defer` in Node.js.
			 * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
			 */
			var runInContext = (function runInContext(context) {
				context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

				/** Built-in constructor references. */
				var Array = context.Array,
					Date = context.Date,
					Error = context.Error,
					Function = context.Function,
					Math = context.Math,
					Object = context.Object,
					RegExp = context.RegExp,
					String = context.String,
					TypeError = context.TypeError;

				/** Used for built-in method references. */
				var arrayProto = Array.prototype,
					funcProto = Function.prototype,
					objectProto = Object.prototype;

				/** Used to detect overreaching core-js shims. */
				var coreJsData = context['__core-js_shared__'];

				/** Used to resolve the decompiled source of functions. */
				var funcToString = funcProto.toString;

				/** Used to check objects for own properties. */
				var hasOwnProperty = objectProto.hasOwnProperty;

				/** Used to generate unique IDs. */
				var idCounter = 0;

				/** Used to detect methods masquerading as native. */
				var maskSrcKey = (function () {
					var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
					return uid ? ('Symbol(src)_1.' + uid) : '';
				}());

				/**
				 * Used to resolve the
				 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
				 * of values.
				 */
				var nativeObjectToString = objectProto.toString;

				/** Used to infer the `Object` constructor. */
				var objectCtorString = funcToString.call(Object);

				/** Used to restore the original `_` reference in `_.noConflict`. */
				var oldDash = root._;

				/** Used to detect if a method is native. */
				var reIsNative = RegExp('^' +
					funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
						.replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
				);

				/** Built-in value references. */
				var Buffer = moduleExports ? context.Buffer : undefined$1,
					Symbol = context.Symbol,
					Uint8Array = context.Uint8Array,
					allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1,
					getPrototype = overArg(Object.getPrototypeOf, Object),
					objectCreate = Object.create,
					propertyIsEnumerable = objectProto.propertyIsEnumerable,
					splice = arrayProto.splice,
					spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined$1,
					symIterator = Symbol ? Symbol.iterator : undefined$1,
					symToStringTag = Symbol ? Symbol.toStringTag : undefined$1;

				var defineProperty = (function () {
					try {
						var func = getNative(Object, 'defineProperty');
						func({}, '', {});
						return func;
					} catch (e) { }
				}());

				/** Mocked built-ins. */
				var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
					ctxNow = Date && Date.now !== root.Date.now && Date.now,
					ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

				/* Built-in method references for those with the same name as other `lodash` methods. */
				var nativeCeil = Math.ceil,
					nativeFloor = Math.floor,
					nativeGetSymbols = Object.getOwnPropertySymbols,
					nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1,
					nativeIsFinite = context.isFinite,
					nativeJoin = arrayProto.join,
					nativeKeys = overArg(Object.keys, Object),
					nativeMax = Math.max,
					nativeMin = Math.min,
					nativeNow = Date.now,
					nativeParseInt = context.parseInt,
					nativeRandom = Math.random,
					nativeReverse = arrayProto.reverse;

				/* Built-in method references that are verified to be native. */
				var DataView = getNative(context, 'DataView'),
					Map = getNative(context, 'Map'),
					Promise = getNative(context, 'Promise'),
					Set = getNative(context, 'Set'),
					WeakMap = getNative(context, 'WeakMap'),
					nativeCreate = getNative(Object, 'create');

				/** Used to store function metadata. */
				var metaMap = WeakMap && new WeakMap;

				/** Used to lookup unminified function names. */
				var realNames = {};

				/** Used to detect maps, sets, and weakmaps. */
				var dataViewCtorString = toSource(DataView),
					mapCtorString = toSource(Map),
					promiseCtorString = toSource(Promise),
					setCtorString = toSource(Set),
					weakMapCtorString = toSource(WeakMap);

				/** Used to convert symbols to primitives and strings. */
				var symbolProto = Symbol ? Symbol.prototype : undefined$1,
					symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1,
					symbolToString = symbolProto ? symbolProto.toString : undefined$1;

				/*------------------------------------------------------------------------*/

				/**
				 * Creates a `lodash` object which wraps `value` to enable implicit method
				 * chain sequences. Methods that operate on and return arrays, collections,
				 * and functions can be chained together. Methods that retrieve a single value
				 * or may return a primitive value will automatically end the chain sequence
				 * and return the unwrapped value. Otherwise, the value must be unwrapped
				 * with `_#value`.
				 *
				 * Explicit chain sequences, which must be unwrapped with `_#value`, may be
				 * enabled using `_.chain`.
				 *
				 * The execution of chained methods is lazy, that is, it's deferred until
				 * `_#value` is implicitly or explicitly called.
				 *
				 * Lazy evaluation allows several methods to support shortcut fusion.
				 * Shortcut fusion is an optimization to merge iteratee calls; this avoids
				 * the creation of intermediate arrays and can greatly reduce the number of
				 * iteratee executions. Sections of a chain sequence qualify for shortcut
				 * fusion if the section is applied to an array and iteratees accept only
				 * one argument. The heuristic for whether a section qualifies for shortcut
				 * fusion is subject to change.
				 *
				 * Chaining is supported in custom builds as long as the `_#value` method is
				 * directly or indirectly included in the build.
				 *
				 * In addition to lodash methods, wrappers have `Array` and `String` methods.
				 *
				 * The wrapper `Array` methods are:
				 * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
				 *
				 * The wrapper `String` methods are:
				 * `replace` and `split`
				 *
				 * The wrapper methods that support shortcut fusion are:
				 * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
				 * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
				 * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
				 *
				 * The chainable wrapper methods are:
				 * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
				 * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
				 * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
				 * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
				 * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
				 * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
				 * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
				 * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
				 * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
				 * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
				 * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
				 * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
				 * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
				 * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
				 * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
				 * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
				 * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
				 * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
				 * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
				 * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
				 * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
				 * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
				 * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
				 * `zipObject`, `zipObjectDeep`, and `zipWith`
				 *
				 * The wrapper methods that are **not** chainable by default are:
				 * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
				 * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
				 * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
				 * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
				 * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
				 * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
				 * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
				 * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
				 * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
				 * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
				 * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
				 * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
				 * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
				 * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
				 * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
				 * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
				 * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
				 * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
				 * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
				 * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
				 * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
				 * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
				 * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
				 * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
				 * `upperFirst`, `value`, and `words`
				 *
				 * @name _
				 * @constructor
				 * @category Seq
				 * @param {*} value The value to wrap in a `lodash` instance.
				 * @returns {Object} Returns the new `lodash` wrapper instance.
				 * @example
				 *
				 * function square(n) {
				 *   return n * n;
				 * }
				 *
				 * var wrapped = _([1, 2, 3]);
				 *
				 * // Returns an unwrapped value.
				 * wrapped.reduce(_.add);
				 * // => 6
				 *
				 * // Returns a wrapped value.
				 * var squares = wrapped.map(square);
				 *
				 * _.isArray(squares);
				 * // => false
				 *
				 * _.isArray(squares.value());
				 * // => true
				 */
				function lodash(value) {
					if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
						if (value instanceof LodashWrapper) {
							return value;
						}
						if (hasOwnProperty.call(value, '__wrapped__')) {
							return wrapperClone(value);
						}
					}
					return new LodashWrapper(value);
				}

				/**
				 * The base implementation of `_.create` without support for assigning
				 * properties to the created object.
				 *
				 * @private
				 * @param {Object} proto The object to inherit from.
				 * @returns {Object} Returns the new object.
				 */
				var baseCreate = (function () {
					function object() { }
					return function (proto) {
						if (!isObject(proto)) {
							return {};
						}
						if (objectCreate) {
							return objectCreate(proto);
						}
						object.prototype = proto;
						var result = new object;
						object.prototype = undefined$1;
						return result;
					};
				}());

				/**
				 * The function whose prototype chain sequence wrappers inherit from.
				 *
				 * @private
				 */
				function baseLodash() {
					// No operation performed.
				}

				/**
				 * The base constructor for creating `lodash` wrapper objects.
				 *
				 * @private
				 * @param {*} value The value to wrap.
				 * @param {boolean} [chainAll] Enable explicit method chain sequences.
				 */
				function LodashWrapper(value, chainAll) {
					this.__wrapped__ = value;
					this.__actions__ = [];
					this.__chain__ = !!chainAll;
					this.__index__ = 0;
					this.__values__ = undefined$1;
				}

				/**
				 * By default, the template delimiters used by lodash are like those in
				 * embedded Ruby (ERB) as well as ES2015 template strings. Change the
				 * following template settings to use alternative delimiters.
				 *
				 * @static
				 * @memberOf _
				 * @type {Object}
				 */
				lodash.templateSettings = {

					/**
					 * Used to detect `data` property values to be HTML-escaped.
					 *
					 * @memberOf _.templateSettings
					 * @type {RegExp}
					 */
					'escape': reEscape,

					/**
					 * Used to detect code to be evaluated.
					 *
					 * @memberOf _.templateSettings
					 * @type {RegExp}
					 */
					'evaluate': reEvaluate,

					/**
					 * Used to detect `data` property values to inject.
					 *
					 * @memberOf _.templateSettings
					 * @type {RegExp}
					 */
					'interpolate': reInterpolate,

					/**
					 * Used to reference the data object in the template text.
					 *
					 * @memberOf _.templateSettings
					 * @type {string}
					 */
					'variable': '',

					/**
					 * Used to import variables into the compiled template.
					 *
					 * @memberOf _.templateSettings
					 * @type {Object}
					 */
					'imports': {

						/**
						 * A reference to the `lodash` function.
						 *
						 * @memberOf _.templateSettings.imports
						 * @type {Function}
						 */
						'_': lodash
					}
				};

				// Ensure wrappers are instances of `baseLodash`.
				lodash.prototype = baseLodash.prototype;
				lodash.prototype.constructor = lodash;

				LodashWrapper.prototype = baseCreate(baseLodash.prototype);
				LodashWrapper.prototype.constructor = LodashWrapper;

				/*------------------------------------------------------------------------*/

				/**
				 * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
				 *
				 * @private
				 * @constructor
				 * @param {*} value The value to wrap.
				 */
				function LazyWrapper(value) {
					this.__wrapped__ = value;
					this.__actions__ = [];
					this.__dir__ = 1;
					this.__filtered__ = false;
					this.__iteratees__ = [];
					this.__takeCount__ = MAX_ARRAY_LENGTH;
					this.__views__ = [];
				}

				/**
				 * Creates a clone of the lazy wrapper object.
				 *
				 * @private
				 * @name clone
				 * @memberOf LazyWrapper
				 * @returns {Object} Returns the cloned `LazyWrapper` object.
				 */
				function lazyClone() {
					var result = new LazyWrapper(this.__wrapped__);
					result.__actions__ = copyArray(this.__actions__);
					result.__dir__ = this.__dir__;
					result.__filtered__ = this.__filtered__;
					result.__iteratees__ = copyArray(this.__iteratees__);
					result.__takeCount__ = this.__takeCount__;
					result.__views__ = copyArray(this.__views__);
					return result;
				}

				/**
				 * Reverses the direction of lazy iteration.
				 *
				 * @private
				 * @name reverse
				 * @memberOf LazyWrapper
				 * @returns {Object} Returns the new reversed `LazyWrapper` object.
				 */
				function lazyReverse() {
					if (this.__filtered__) {
						var result = new LazyWrapper(this);
						result.__dir__ = -1;
						result.__filtered__ = true;
					} else {
						result = this.clone();
						result.__dir__ *= -1;
					}
					return result;
				}

				/**
				 * Extracts the unwrapped value from its lazy wrapper.
				 *
				 * @private
				 * @name value
				 * @memberOf LazyWrapper
				 * @returns {*} Returns the unwrapped value.
				 */
				function lazyValue() {
					var array = this.__wrapped__.value(),
						dir = this.__dir__,
						isArr = isArray(array),
						isRight = dir < 0,
						arrLength = isArr ? array.length : 0,
						view = getView(0, arrLength, this.__views__),
						start = view.start,
						end = view.end,
						length = end - start,
						index = isRight ? end : (start - 1),
						iteratees = this.__iteratees__,
						iterLength = iteratees.length,
						resIndex = 0,
						takeCount = nativeMin(length, this.__takeCount__);

					if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
						return baseWrapperValue(array, this.__actions__);
					}
					var result = [];

					outer:
					while (length-- && resIndex < takeCount) {
						index += dir;

						var iterIndex = -1,
							value = array[index];

						while (++iterIndex < iterLength) {
							var data = iteratees[iterIndex],
								iteratee = data.iteratee,
								type = data.type,
								computed = iteratee(value);

							if (type == LAZY_MAP_FLAG) {
								value = computed;
							} else if (!computed) {
								if (type == LAZY_FILTER_FLAG) {
									continue outer;
								} else {
									break outer;
								}
							}
						}
						result[resIndex++] = value;
					}
					return result;
				}

				// Ensure `LazyWrapper` is an instance of `baseLodash`.
				LazyWrapper.prototype = baseCreate(baseLodash.prototype);
				LazyWrapper.prototype.constructor = LazyWrapper;

				/*------------------------------------------------------------------------*/

				/**
				 * Creates a hash object.
				 *
				 * @private
				 * @constructor
				 * @param {Array} [entries] The key-value pairs to cache.
				 */
				function Hash(entries) {
					var index = -1,
						length = entries == null ? 0 : entries.length;

					this.clear();
					while (++index < length) {
						var entry = entries[index];
						this.set(entry[0], entry[1]);
					}
				}

				/**
				 * Removes all key-value entries from the hash.
				 *
				 * @private
				 * @name clear
				 * @memberOf Hash
				 */
				function hashClear() {
					this.__data__ = nativeCreate ? nativeCreate(null) : {};
					this.size = 0;
				}

				/**
				 * Removes `key` and its value from the hash.
				 *
				 * @private
				 * @name delete
				 * @memberOf Hash
				 * @param {Object} hash The hash to modify.
				 * @param {string} key The key of the value to remove.
				 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
				 */
				function hashDelete(key) {
					var result = this.has(key) && delete this.__data__[key];
					this.size -= result ? 1 : 0;
					return result;
				}

				/**
				 * Gets the hash value for `key`.
				 *
				 * @private
				 * @name get
				 * @memberOf Hash
				 * @param {string} key The key of the value to get.
				 * @returns {*} Returns the entry value.
				 */
				function hashGet(key) {
					var data = this.__data__;
					if (nativeCreate) {
						var result = data[key];
						return result === HASH_UNDEFINED ? undefined$1 : result;
					}
					return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
				}

				/**
				 * Checks if a hash value for `key` exists.
				 *
				 * @private
				 * @name has
				 * @memberOf Hash
				 * @param {string} key The key of the entry to check.
				 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
				 */
				function hashHas(key) {
					var data = this.__data__;
					return nativeCreate ? (data[key] !== undefined$1) : hasOwnProperty.call(data, key);
				}

				/**
				 * Sets the hash `key` to `value`.
				 *
				 * @private
				 * @name set
				 * @memberOf Hash
				 * @param {string} key The key of the value to set.
				 * @param {*} value The value to set.
				 * @returns {Object} Returns the hash instance.
				 */
				function hashSet(key, value) {
					var data = this.__data__;
					this.size += this.has(key) ? 0 : 1;
					data[key] = (nativeCreate && value === undefined$1) ? HASH_UNDEFINED : value;
					return this;
				}

				// Add methods to `Hash`.
				Hash.prototype.clear = hashClear;
				Hash.prototype['delete'] = hashDelete;
				Hash.prototype.get = hashGet;
				Hash.prototype.has = hashHas;
				Hash.prototype.set = hashSet;

				/*------------------------------------------------------------------------*/

				/**
				 * Creates an list cache object.
				 *
				 * @private
				 * @constructor
				 * @param {Array} [entries] The key-value pairs to cache.
				 */
				function ListCache(entries) {
					var index = -1,
						length = entries == null ? 0 : entries.length;

					this.clear();
					while (++index < length) {
						var entry = entries[index];
						this.set(entry[0], entry[1]);
					}
				}

				/**
				 * Removes all key-value entries from the list cache.
				 *
				 * @private
				 * @name clear
				 * @memberOf ListCache
				 */
				function listCacheClear() {
					this.__data__ = [];
					this.size = 0;
				}

				/**
				 * Removes `key` and its value from the list cache.
				 *
				 * @private
				 * @name delete
				 * @memberOf ListCache
				 * @param {string} key The key of the value to remove.
				 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
				 */
				function listCacheDelete(key) {
					var data = this.__data__,
						index = assocIndexOf(data, key);

					if (index < 0) {
						return false;
					}
					var lastIndex = data.length - 1;
					if (index == lastIndex) {
						data.pop();
					} else {
						splice.call(data, index, 1);
					}
					--this.size;
					return true;
				}

				/**
				 * Gets the list cache value for `key`.
				 *
				 * @private
				 * @name get
				 * @memberOf ListCache
				 * @param {string} key The key of the value to get.
				 * @returns {*} Returns the entry value.
				 */
				function listCacheGet(key) {
					var data = this.__data__,
						index = assocIndexOf(data, key);

					return index < 0 ? undefined$1 : data[index][1];
				}

				/**
				 * Checks if a list cache value for `key` exists.
				 *
				 * @private
				 * @name has
				 * @memberOf ListCache
				 * @param {string} key The key of the entry to check.
				 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
				 */
				function listCacheHas(key) {
					return assocIndexOf(this.__data__, key) > -1;
				}

				/**
				 * Sets the list cache `key` to `value`.
				 *
				 * @private
				 * @name set
				 * @memberOf ListCache
				 * @param {string} key The key of the value to set.
				 * @param {*} value The value to set.
				 * @returns {Object} Returns the list cache instance.
				 */
				function listCacheSet(key, value) {
					var data = this.__data__,
						index = assocIndexOf(data, key);

					if (index < 0) {
						++this.size;
						data.push([key, value]);
					} else {
						data[index][1] = value;
					}
					return this;
				}

				// Add methods to `ListCache`.
				ListCache.prototype.clear = listCacheClear;
				ListCache.prototype['delete'] = listCacheDelete;
				ListCache.prototype.get = listCacheGet;
				ListCache.prototype.has = listCacheHas;
				ListCache.prototype.set = listCacheSet;

				/*------------------------------------------------------------------------*/

				/**
				 * Creates a map cache object to store key-value pairs.
				 *
				 * @private
				 * @constructor
				 * @param {Array} [entries] The key-value pairs to cache.
				 */
				function MapCache(entries) {
					var index = -1,
						length = entries == null ? 0 : entries.length;

					this.clear();
					while (++index < length) {
						var entry = entries[index];
						this.set(entry[0], entry[1]);
					}
				}

				/**
				 * Removes all key-value entries from the map.
				 *
				 * @private
				 * @name clear
				 * @memberOf MapCache
				 */
				function mapCacheClear() {
					this.size = 0;
					this.__data__ = {
						'hash': new Hash,
						'map': new (Map || ListCache),
						'string': new Hash
					};
				}

				/**
				 * Removes `key` and its value from the map.
				 *
				 * @private
				 * @name delete
				 * @memberOf MapCache
				 * @param {string} key The key of the value to remove.
				 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
				 */
				function mapCacheDelete(key) {
					var result = getMapData(this, key)['delete'](key);
					this.size -= result ? 1 : 0;
					return result;
				}

				/**
				 * Gets the map value for `key`.
				 *
				 * @private
				 * @name get
				 * @memberOf MapCache
				 * @param {string} key The key of the value to get.
				 * @returns {*} Returns the entry value.
				 */
				function mapCacheGet(key) {
					return getMapData(this, key).get(key);
				}

				/**
				 * Checks if a map value for `key` exists.
				 *
				 * @private
				 * @name has
				 * @memberOf MapCache
				 * @param {string} key The key of the entry to check.
				 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
				 */
				function mapCacheHas(key) {
					return getMapData(this, key).has(key);
				}

				/**
				 * Sets the map `key` to `value`.
				 *
				 * @private
				 * @name set
				 * @memberOf MapCache
				 * @param {string} key The key of the value to set.
				 * @param {*} value The value to set.
				 * @returns {Object} Returns the map cache instance.
				 */
				function mapCacheSet(key, value) {
					var data = getMapData(this, key),
						size = data.size;

					data.set(key, value);
					this.size += data.size == size ? 0 : 1;
					return this;
				}

				// Add methods to `MapCache`.
				MapCache.prototype.clear = mapCacheClear;
				MapCache.prototype['delete'] = mapCacheDelete;
				MapCache.prototype.get = mapCacheGet;
				MapCache.prototype.has = mapCacheHas;
				MapCache.prototype.set = mapCacheSet;

				/*------------------------------------------------------------------------*/

				/**
				 *
				 * Creates an array cache object to store unique values.
				 *
				 * @private
				 * @constructor
				 * @param {Array} [values] The values to cache.
				 */
				function SetCache(values) {
					var index = -1,
						length = values == null ? 0 : values.length;

					this.__data__ = new MapCache;
					while (++index < length) {
						this.add(values[index]);
					}
				}

				/**
				 * Adds `value` to the array cache.
				 *
				 * @private
				 * @name add
				 * @memberOf SetCache
				 * @alias push
				 * @param {*} value The value to cache.
				 * @returns {Object} Returns the cache instance.
				 */
				function setCacheAdd(value) {
					this.__data__.set(value, HASH_UNDEFINED);
					return this;
				}

				/**
				 * Checks if `value` is in the array cache.
				 *
				 * @private
				 * @name has
				 * @memberOf SetCache
				 * @param {*} value The value to search for.
				 * @returns {number} Returns `true` if `value` is found, else `false`.
				 */
				function setCacheHas(value) {
					return this.__data__.has(value);
				}

				// Add methods to `SetCache`.
				SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
				SetCache.prototype.has = setCacheHas;

				/*------------------------------------------------------------------------*/

				/**
				 * Creates a stack cache object to store key-value pairs.
				 *
				 * @private
				 * @constructor
				 * @param {Array} [entries] The key-value pairs to cache.
				 */
				function Stack(entries) {
					var data = this.__data__ = new ListCache(entries);
					this.size = data.size;
				}

				/**
				 * Removes all key-value entries from the stack.
				 *
				 * @private
				 * @name clear
				 * @memberOf Stack
				 */
				function stackClear() {
					this.__data__ = new ListCache;
					this.size = 0;
				}

				/**
				 * Removes `key` and its value from the stack.
				 *
				 * @private
				 * @name delete
				 * @memberOf Stack
				 * @param {string} key The key of the value to remove.
				 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
				 */
				function stackDelete(key) {
					var data = this.__data__,
						result = data['delete'](key);

					this.size = data.size;
					return result;
				}

				/**
				 * Gets the stack value for `key`.
				 *
				 * @private
				 * @name get
				 * @memberOf Stack
				 * @param {string} key The key of the value to get.
				 * @returns {*} Returns the entry value.
				 */
				function stackGet(key) {
					return this.__data__.get(key);
				}

				/**
				 * Checks if a stack value for `key` exists.
				 *
				 * @private
				 * @name has
				 * @memberOf Stack
				 * @param {string} key The key of the entry to check.
				 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
				 */
				function stackHas(key) {
					return this.__data__.has(key);
				}

				/**
				 * Sets the stack `key` to `value`.
				 *
				 * @private
				 * @name set
				 * @memberOf Stack
				 * @param {string} key The key of the value to set.
				 * @param {*} value The value to set.
				 * @returns {Object} Returns the stack cache instance.
				 */
				function stackSet(key, value) {
					var data = this.__data__;
					if (data instanceof ListCache) {
						var pairs = data.__data__;
						if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
							pairs.push([key, value]);
							this.size = ++data.size;
							return this;
						}
						data = this.__data__ = new MapCache(pairs);
					}
					data.set(key, value);
					this.size = data.size;
					return this;
				}

				// Add methods to `Stack`.
				Stack.prototype.clear = stackClear;
				Stack.prototype['delete'] = stackDelete;
				Stack.prototype.get = stackGet;
				Stack.prototype.has = stackHas;
				Stack.prototype.set = stackSet;

				/*------------------------------------------------------------------------*/

				/**
				 * Creates an array of the enumerable property names of the array-like `value`.
				 *
				 * @private
				 * @param {*} value The value to query.
				 * @param {boolean} inherited Specify returning inherited property names.
				 * @returns {Array} Returns the array of property names.
				 */
				function arrayLikeKeys(value, inherited) {
					var isArr = isArray(value),
						isArg = !isArr && isArguments(value),
						isBuff = !isArr && !isArg && isBuffer(value),
						isType = !isArr && !isArg && !isBuff && isTypedArray(value),
						skipIndexes = isArr || isArg || isBuff || isType,
						result = skipIndexes ? baseTimes(value.length, String) : [],
						length = result.length;

					for (var key in value) {
						if ((inherited || hasOwnProperty.call(value, key)) &&
							!(skipIndexes && (
								// Safari 9 has enumerable `arguments.length` in strict mode.
								key == 'length' ||
								// Node.js 0.10 has enumerable non-index properties on buffers.
								(isBuff && (key == 'offset' || key == 'parent')) ||
								// PhantomJS 2 has enumerable non-index properties on typed arrays.
								(isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
								// Skip index properties.
								isIndex(key, length)
							))) {
							result.push(key);
						}
					}
					return result;
				}

				/**
				 * A specialized version of `_.sample` for arrays.
				 *
				 * @private
				 * @param {Array} array The array to sample.
				 * @returns {*} Returns the random element.
				 */
				function arraySample(array) {
					var length = array.length;
					return length ? array[baseRandom(0, length - 1)] : undefined$1;
				}

				/**
				 * A specialized version of `_.sampleSize` for arrays.
				 *
				 * @private
				 * @param {Array} array The array to sample.
				 * @param {number} n The number of elements to sample.
				 * @returns {Array} Returns the random elements.
				 */
				function arraySampleSize(array, n) {
					return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
				}

				/**
				 * A specialized version of `_.shuffle` for arrays.
				 *
				 * @private
				 * @param {Array} array The array to shuffle.
				 * @returns {Array} Returns the new shuffled array.
				 */
				function arrayShuffle(array) {
					return shuffleSelf(copyArray(array));
				}

				/**
				 * This function is like `assignValue` except that it doesn't assign
				 * `undefined` values.
				 *
				 * @private
				 * @param {Object} object The object to modify.
				 * @param {string} key The key of the property to assign.
				 * @param {*} value The value to assign.
				 */
				function assignMergeValue(object, key, value) {
					if ((value !== undefined$1 && !eq(object[key], value)) ||
						(value === undefined$1 && !(key in object))) {
						baseAssignValue(object, key, value);
					}
				}

				/**
				 * Assigns `value` to `key` of `object` if the existing value is not equivalent
				 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
				 * for equality comparisons.
				 *
				 * @private
				 * @param {Object} object The object to modify.
				 * @param {string} key The key of the property to assign.
				 * @param {*} value The value to assign.
				 */
				function assignValue(object, key, value) {
					var objValue = object[key];
					if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
						(value === undefined$1 && !(key in object))) {
						baseAssignValue(object, key, value);
					}
				}

				/**
				 * Gets the index at which the `key` is found in `array` of key-value pairs.
				 *
				 * @private
				 * @param {Array} array The array to inspect.
				 * @param {*} key The key to search for.
				 * @returns {number} Returns the index of the matched value, else `-1`.
				 */
				function assocIndexOf(array, key) {
					var length = array.length;
					while (length--) {
						if (eq(array[length][0], key)) {
							return length;
						}
					}
					return -1;
				}

				/**
				 * Aggregates elements of `collection` on `accumulator` with keys transformed
				 * by `iteratee` and values set by `setter`.
				 *
				 * @private
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Function} setter The function to set `accumulator` values.
				 * @param {Function} iteratee The iteratee to transform keys.
				 * @param {Object} accumulator The initial aggregated object.
				 * @returns {Function} Returns `accumulator`.
				 */
				function baseAggregator(collection, setter, iteratee, accumulator) {
					baseEach(collection, function (value, key, collection) {
						setter(accumulator, value, iteratee(value), collection);
					});
					return accumulator;
				}

				/**
				 * The base implementation of `_.assign` without support for multiple sources
				 * or `customizer` functions.
				 *
				 * @private
				 * @param {Object} object The destination object.
				 * @param {Object} source The source object.
				 * @returns {Object} Returns `object`.
				 */
				function baseAssign(object, source) {
					return object && copyObject(source, keys(source), object);
				}

				/**
				 * The base implementation of `_.assignIn` without support for multiple sources
				 * or `customizer` functions.
				 *
				 * @private
				 * @param {Object} object The destination object.
				 * @param {Object} source The source object.
				 * @returns {Object} Returns `object`.
				 */
				function baseAssignIn(object, source) {
					return object && copyObject(source, keysIn(source), object);
				}

				/**
				 * The base implementation of `assignValue` and `assignMergeValue` without
				 * value checks.
				 *
				 * @private
				 * @param {Object} object The object to modify.
				 * @param {string} key The key of the property to assign.
				 * @param {*} value The value to assign.
				 */
				function baseAssignValue(object, key, value) {
					if (key == '__proto__' && defineProperty) {
						defineProperty(object, key, {
							'configurable': true,
							'enumerable': true,
							'value': value,
							'writable': true
						});
					} else {
						object[key] = value;
					}
				}

				/**
				 * The base implementation of `_.at` without support for individual paths.
				 *
				 * @private
				 * @param {Object} object The object to iterate over.
				 * @param {string[]} paths The property paths to pick.
				 * @returns {Array} Returns the picked elements.
				 */
				function baseAt(object, paths) {
					var index = -1,
						length = paths.length,
						result = Array(length),
						skip = object == null;

					while (++index < length) {
						result[index] = skip ? undefined$1 : get(object, paths[index]);
					}
					return result;
				}

				/**
				 * The base implementation of `_.clamp` which doesn't coerce arguments.
				 *
				 * @private
				 * @param {number} number The number to clamp.
				 * @param {number} [lower] The lower bound.
				 * @param {number} upper The upper bound.
				 * @returns {number} Returns the clamped number.
				 */
				function baseClamp(number, lower, upper) {
					if (number === number) {
						if (upper !== undefined$1) {
							number = number <= upper ? number : upper;
						}
						if (lower !== undefined$1) {
							number = number >= lower ? number : lower;
						}
					}
					return number;
				}

				/**
				 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
				 * traversed objects.
				 *
				 * @private
				 * @param {*} value The value to clone.
				 * @param {boolean} bitmask The bitmask flags.
				 *  1 - Deep clone
				 *  2 - Flatten inherited properties
				 *  4 - Clone symbols
				 * @param {Function} [customizer] The function to customize cloning.
				 * @param {string} [key] The key of `value`.
				 * @param {Object} [object] The parent object of `value`.
				 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
				 * @returns {*} Returns the cloned value.
				 */
				function baseClone(value, bitmask, customizer, key, object, stack) {
					var result,
						isDeep = bitmask & CLONE_DEEP_FLAG,
						isFlat = bitmask & CLONE_FLAT_FLAG,
						isFull = bitmask & CLONE_SYMBOLS_FLAG;

					if (customizer) {
						result = object ? customizer(value, key, object, stack) : customizer(value);
					}
					if (result !== undefined$1) {
						return result;
					}
					if (!isObject(value)) {
						return value;
					}
					var isArr = isArray(value);
					if (isArr) {
						result = initCloneArray(value);
						if (!isDeep) {
							return copyArray(value, result);
						}
					} else {
						var tag = getTag(value),
							isFunc = tag == funcTag || tag == genTag;

						if (isBuffer(value)) {
							return cloneBuffer(value, isDeep);
						}
						if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
							result = (isFlat || isFunc) ? {} : initCloneObject(value);
							if (!isDeep) {
								return isFlat
									? copySymbolsIn(value, baseAssignIn(result, value))
									: copySymbols(value, baseAssign(result, value));
							}
						} else {
							if (!cloneableTags[tag]) {
								return object ? value : {};
							}
							result = initCloneByTag(value, tag, isDeep);
						}
					}
					// Check for circular references and return its corresponding clone.
					stack || (stack = new Stack);
					var stacked = stack.get(value);
					if (stacked) {
						return stacked;
					}
					stack.set(value, result);

					if (isSet(value)) {
						value.forEach(function (subValue) {
							result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
						});
					} else if (isMap(value)) {
						value.forEach(function (subValue, key) {
							result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
						});
					}

					var keysFunc = isFull
						? (isFlat ? getAllKeysIn : getAllKeys)
						: (isFlat ? keysIn : keys);

					var props = isArr ? undefined$1 : keysFunc(value);
					arrayEach(props || value, function (subValue, key) {
						if (props) {
							key = subValue;
							subValue = value[key];
						}
						// Recursively populate clone (susceptible to call stack limits).
						assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
					});
					return result;
				}

				/**
				 * The base implementation of `_.conforms` which doesn't clone `source`.
				 *
				 * @private
				 * @param {Object} source The object of property predicates to conform to.
				 * @returns {Function} Returns the new spec function.
				 */
				function baseConforms(source) {
					var props = keys(source);
					return function (object) {
						return baseConformsTo(object, source, props);
					};
				}

				/**
				 * The base implementation of `_.conformsTo` which accepts `props` to check.
				 *
				 * @private
				 * @param {Object} object The object to inspect.
				 * @param {Object} source The object of property predicates to conform to.
				 * @returns {boolean} Returns `true` if `object` conforms, else `false`.
				 */
				function baseConformsTo(object, source, props) {
					var length = props.length;
					if (object == null) {
						return !length;
					}
					object = Object(object);
					while (length--) {
						var key = props[length],
							predicate = source[key],
							value = object[key];

						if ((value === undefined$1 && !(key in object)) || !predicate(value)) {
							return false;
						}
					}
					return true;
				}

				/**
				 * The base implementation of `_.delay` and `_.defer` which accepts `args`
				 * to provide to `func`.
				 *
				 * @private
				 * @param {Function} func The function to delay.
				 * @param {number} wait The number of milliseconds to delay invocation.
				 * @param {Array} args The arguments to provide to `func`.
				 * @returns {number|Object} Returns the timer id or timeout object.
				 */
				function baseDelay(func, wait, args) {
					if (typeof func != 'function') {
						throw new TypeError(FUNC_ERROR_TEXT);
					}
					return setTimeout(function () { func.apply(undefined$1, args); }, wait);
				}

				/**
				 * The base implementation of methods like `_.difference` without support
				 * for excluding multiple arrays or iteratee shorthands.
				 *
				 * @private
				 * @param {Array} array The array to inspect.
				 * @param {Array} values The values to exclude.
				 * @param {Function} [iteratee] The iteratee invoked per element.
				 * @param {Function} [comparator] The comparator invoked per element.
				 * @returns {Array} Returns the new array of filtered values.
				 */
				function baseDifference(array, values, iteratee, comparator) {
					var index = -1,
						includes = arrayIncludes,
						isCommon = true,
						length = array.length,
						result = [],
						valuesLength = values.length;

					if (!length) {
						return result;
					}
					if (iteratee) {
						values = arrayMap(values, baseUnary(iteratee));
					}
					if (comparator) {
						includes = arrayIncludesWith;
						isCommon = false;
					}
					else if (values.length >= LARGE_ARRAY_SIZE) {
						includes = cacheHas;
						isCommon = false;
						values = new SetCache(values);
					}
					outer:
					while (++index < length) {
						var value = array[index],
							computed = iteratee == null ? value : iteratee(value);

						value = (comparator || value !== 0) ? value : 0;
						if (isCommon && computed === computed) {
							var valuesIndex = valuesLength;
							while (valuesIndex--) {
								if (values[valuesIndex] === computed) {
									continue outer;
								}
							}
							result.push(value);
						}
						else if (!includes(values, computed, comparator)) {
							result.push(value);
						}
					}
					return result;
				}

				/**
				 * The base implementation of `_.forEach` without support for iteratee shorthands.
				 *
				 * @private
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Function} iteratee The function invoked per iteration.
				 * @returns {Array|Object} Returns `collection`.
				 */
				var baseEach = createBaseEach(baseForOwn);

				/**
				 * The base implementation of `_.forEachRight` without support for iteratee shorthands.
				 *
				 * @private
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Function} iteratee The function invoked per iteration.
				 * @returns {Array|Object} Returns `collection`.
				 */
				var baseEachRight = createBaseEach(baseForOwnRight, true);

				/**
				 * The base implementation of `_.every` without support for iteratee shorthands.
				 *
				 * @private
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Function} predicate The function invoked per iteration.
				 * @returns {boolean} Returns `true` if all elements pass the predicate check,
				 *  else `false`
				 */
				function baseEvery(collection, predicate) {
					var result = true;
					baseEach(collection, function (value, index, collection) {
						result = !!predicate(value, index, collection);
						return result;
					});
					return result;
				}

				/**
				 * The base implementation of methods like `_.max` and `_.min` which accepts a
				 * `comparator` to determine the extremum value.
				 *
				 * @private
				 * @param {Array} array The array to iterate over.
				 * @param {Function} iteratee The iteratee invoked per iteration.
				 * @param {Function} comparator The comparator used to compare values.
				 * @returns {*} Returns the extremum value.
				 */
				function baseExtremum(array, iteratee, comparator) {
					var index = -1,
						length = array.length;

					while (++index < length) {
						var value = array[index],
							current = iteratee(value);

						if (current != null && (computed === undefined$1
							? (current === current && !isSymbol(current))
							: comparator(current, computed)
						)) {
							var computed = current,
								result = value;
						}
					}
					return result;
				}

				/**
				 * The base implementation of `_.fill` without an iteratee call guard.
				 *
				 * @private
				 * @param {Array} array The array to fill.
				 * @param {*} value The value to fill `array` with.
				 * @param {number} [start=0] The start position.
				 * @param {number} [end=array.length] The end position.
				 * @returns {Array} Returns `array`.
				 */
				function baseFill(array, value, start, end) {
					var length = array.length;

					start = toInteger(start);
					if (start < 0) {
						start = -start > length ? 0 : (length + start);
					}
					end = (end === undefined$1 || end > length) ? length : toInteger(end);
					if (end < 0) {
						end += length;
					}
					end = start > end ? 0 : toLength(end);
					while (start < end) {
						array[start++] = value;
					}
					return array;
				}

				/**
				 * The base implementation of `_.filter` without support for iteratee shorthands.
				 *
				 * @private
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Function} predicate The function invoked per iteration.
				 * @returns {Array} Returns the new filtered array.
				 */
				function baseFilter(collection, predicate) {
					var result = [];
					baseEach(collection, function (value, index, collection) {
						if (predicate(value, index, collection)) {
							result.push(value);
						}
					});
					return result;
				}

				/**
				 * The base implementation of `_.flatten` with support for restricting flattening.
				 *
				 * @private
				 * @param {Array} array The array to flatten.
				 * @param {number} depth The maximum recursion depth.
				 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
				 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
				 * @param {Array} [result=[]] The initial result value.
				 * @returns {Array} Returns the new flattened array.
				 */
				function baseFlatten(array, depth, predicate, isStrict, result) {
					var index = -1,
						length = array.length;

					predicate || (predicate = isFlattenable);
					result || (result = []);

					while (++index < length) {
						var value = array[index];
						if (depth > 0 && predicate(value)) {
							if (depth > 1) {
								// Recursively flatten arrays (susceptible to call stack limits).
								baseFlatten(value, depth - 1, predicate, isStrict, result);
							} else {
								arrayPush(result, value);
							}
						} else if (!isStrict) {
							result[result.length] = value;
						}
					}
					return result;
				}

				/**
				 * The base implementation of `baseForOwn` which iterates over `object`
				 * properties returned by `keysFunc` and invokes `iteratee` for each property.
				 * Iteratee functions may exit iteration early by explicitly returning `false`.
				 *
				 * @private
				 * @param {Object} object The object to iterate over.
				 * @param {Function} iteratee The function invoked per iteration.
				 * @param {Function} keysFunc The function to get the keys of `object`.
				 * @returns {Object} Returns `object`.
				 */
				var baseFor = createBaseFor();

				/**
				 * This function is like `baseFor` except that it iterates over properties
				 * in the opposite order.
				 *
				 * @private
				 * @param {Object} object The object to iterate over.
				 * @param {Function} iteratee The function invoked per iteration.
				 * @param {Function} keysFunc The function to get the keys of `object`.
				 * @returns {Object} Returns `object`.
				 */
				var baseForRight = createBaseFor(true);

				/**
				 * The base implementation of `_.forOwn` without support for iteratee shorthands.
				 *
				 * @private
				 * @param {Object} object The object to iterate over.
				 * @param {Function} iteratee The function invoked per iteration.
				 * @returns {Object} Returns `object`.
				 */
				function baseForOwn(object, iteratee) {
					return object && baseFor(object, iteratee, keys);
				}

				/**
				 * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
				 *
				 * @private
				 * @param {Object} object The object to iterate over.
				 * @param {Function} iteratee The function invoked per iteration.
				 * @returns {Object} Returns `object`.
				 */
				function baseForOwnRight(object, iteratee) {
					return object && baseForRight(object, iteratee, keys);
				}

				/**
				 * The base implementation of `_.functions` which creates an array of
				 * `object` function property names filtered from `props`.
				 *
				 * @private
				 * @param {Object} object The object to inspect.
				 * @param {Array} props The property names to filter.
				 * @returns {Array} Returns the function names.
				 */
				function baseFunctions(object, props) {
					return arrayFilter(props, function (key) {
						return isFunction(object[key]);
					});
				}

				/**
				 * The base implementation of `_.get` without support for default values.
				 *
				 * @private
				 * @param {Object} object The object to query.
				 * @param {Array|string} path The path of the property to get.
				 * @returns {*} Returns the resolved value.
				 */
				function baseGet(object, path) {
					path = castPath(path, object);

					var index = 0,
						length = path.length;

					while (object != null && index < length) {
						object = object[toKey(path[index++])];
					}
					return (index && index == length) ? object : undefined$1;
				}

				/**
				 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
				 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
				 * symbols of `object`.
				 *
				 * @private
				 * @param {Object} object The object to query.
				 * @param {Function} keysFunc The function to get the keys of `object`.
				 * @param {Function} symbolsFunc The function to get the symbols of `object`.
				 * @returns {Array} Returns the array of property names and symbols.
				 */
				function baseGetAllKeys(object, keysFunc, symbolsFunc) {
					var result = keysFunc(object);
					return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
				}

				/**
				 * The base implementation of `getTag` without fallbacks for buggy environments.
				 *
				 * @private
				 * @param {*} value The value to query.
				 * @returns {string} Returns the `toStringTag`.
				 */
				function baseGetTag(value) {
					if (value == null) {
						return value === undefined$1 ? undefinedTag : nullTag;
					}
					return (symToStringTag && symToStringTag in Object(value))
						? getRawTag(value)
						: objectToString(value);
				}

				/**
				 * The base implementation of `_.gt` which doesn't coerce arguments.
				 *
				 * @private
				 * @param {*} value The value to compare.
				 * @param {*} other The other value to compare.
				 * @returns {boolean} Returns `true` if `value` is greater than `other`,
				 *  else `false`.
				 */
				function baseGt(value, other) {
					return value > other;
				}

				/**
				 * The base implementation of `_.has` without support for deep paths.
				 *
				 * @private
				 * @param {Object} [object] The object to query.
				 * @param {Array|string} key The key to check.
				 * @returns {boolean} Returns `true` if `key` exists, else `false`.
				 */
				function baseHas(object, key) {
					return object != null && hasOwnProperty.call(object, key);
				}

				/**
				 * The base implementation of `_.hasIn` without support for deep paths.
				 *
				 * @private
				 * @param {Object} [object] The object to query.
				 * @param {Array|string} key The key to check.
				 * @returns {boolean} Returns `true` if `key` exists, else `false`.
				 */
				function baseHasIn(object, key) {
					return object != null && key in Object(object);
				}

				/**
				 * The base implementation of `_.inRange` which doesn't coerce arguments.
				 *
				 * @private
				 * @param {number} number The number to check.
				 * @param {number} start The start of the range.
				 * @param {number} end The end of the range.
				 * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
				 */
				function baseInRange(number, start, end) {
					return number >= nativeMin(start, end) && number < nativeMax(start, end);
				}

				/**
				 * The base implementation of methods like `_.intersection`, without support
				 * for iteratee shorthands, that accepts an array of arrays to inspect.
				 *
				 * @private
				 * @param {Array} arrays The arrays to inspect.
				 * @param {Function} [iteratee] The iteratee invoked per element.
				 * @param {Function} [comparator] The comparator invoked per element.
				 * @returns {Array} Returns the new array of shared values.
				 */
				function baseIntersection(arrays, iteratee, comparator) {
					var includes = comparator ? arrayIncludesWith : arrayIncludes,
						length = arrays[0].length,
						othLength = arrays.length,
						othIndex = othLength,
						caches = Array(othLength),
						maxLength = Infinity,
						result = [];

					while (othIndex--) {
						var array = arrays[othIndex];
						if (othIndex && iteratee) {
							array = arrayMap(array, baseUnary(iteratee));
						}
						maxLength = nativeMin(array.length, maxLength);
						caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
							? new SetCache(othIndex && array)
							: undefined$1;
					}
					array = arrays[0];

					var index = -1,
						seen = caches[0];

					outer:
					while (++index < length && result.length < maxLength) {
						var value = array[index],
							computed = iteratee ? iteratee(value) : value;

						value = (comparator || value !== 0) ? value : 0;
						if (!(seen
							? cacheHas(seen, computed)
							: includes(result, computed, comparator)
						)) {
							othIndex = othLength;
							while (--othIndex) {
								var cache = caches[othIndex];
								if (!(cache
									? cacheHas(cache, computed)
									: includes(arrays[othIndex], computed, comparator))
								) {
									continue outer;
								}
							}
							if (seen) {
								seen.push(computed);
							}
							result.push(value);
						}
					}
					return result;
				}

				/**
				 * The base implementation of `_.invert` and `_.invertBy` which inverts
				 * `object` with values transformed by `iteratee` and set by `setter`.
				 *
				 * @private
				 * @param {Object} object The object to iterate over.
				 * @param {Function} setter The function to set `accumulator` values.
				 * @param {Function} iteratee The iteratee to transform values.
				 * @param {Object} accumulator The initial inverted object.
				 * @returns {Function} Returns `accumulator`.
				 */
				function baseInverter(object, setter, iteratee, accumulator) {
					baseForOwn(object, function (value, key, object) {
						setter(accumulator, iteratee(value), key, object);
					});
					return accumulator;
				}

				/**
				 * The base implementation of `_.invoke` without support for individual
				 * method arguments.
				 *
				 * @private
				 * @param {Object} object The object to query.
				 * @param {Array|string} path The path of the method to invoke.
				 * @param {Array} args The arguments to invoke the method with.
				 * @returns {*} Returns the result of the invoked method.
				 */
				function baseInvoke(object, path, args) {
					path = castPath(path, object);
					object = parent(object, path);
					var func = object == null ? object : object[toKey(last(path))];
					return func == null ? undefined$1 : apply(func, object, args);
				}

				/**
				 * The base implementation of `_.isArguments`.
				 *
				 * @private
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
				 */
				function baseIsArguments(value) {
					return isObjectLike(value) && baseGetTag(value) == argsTag;
				}

				/**
				 * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
				 *
				 * @private
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
				 */
				function baseIsArrayBuffer(value) {
					return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
				}

				/**
				 * The base implementation of `_.isDate` without Node.js optimizations.
				 *
				 * @private
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
				 */
				function baseIsDate(value) {
					return isObjectLike(value) && baseGetTag(value) == dateTag;
				}

				/**
				 * The base implementation of `_.isEqual` which supports partial comparisons
				 * and tracks traversed objects.
				 *
				 * @private
				 * @param {*} value The value to compare.
				 * @param {*} other The other value to compare.
				 * @param {boolean} bitmask The bitmask flags.
				 *  1 - Unordered comparison
				 *  2 - Partial comparison
				 * @param {Function} [customizer] The function to customize comparisons.
				 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
				 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
				 */
				function baseIsEqual(value, other, bitmask, customizer, stack) {
					if (value === other) {
						return true;
					}
					if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
						return value !== value && other !== other;
					}
					return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
				}

				/**
				 * A specialized version of `baseIsEqual` for arrays and objects which performs
				 * deep comparisons and tracks traversed objects enabling objects with circular
				 * references to be compared.
				 *
				 * @private
				 * @param {Object} object The object to compare.
				 * @param {Object} other The other object to compare.
				 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
				 * @param {Function} customizer The function to customize comparisons.
				 * @param {Function} equalFunc The function to determine equivalents of values.
				 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
				 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
				 */
				function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
					var objIsArr = isArray(object),
						othIsArr = isArray(other),
						objTag = objIsArr ? arrayTag : getTag(object),
						othTag = othIsArr ? arrayTag : getTag(other);

					objTag = objTag == argsTag ? objectTag : objTag;
					othTag = othTag == argsTag ? objectTag : othTag;

					var objIsObj = objTag == objectTag,
						othIsObj = othTag == objectTag,
						isSameTag = objTag == othTag;

					if (isSameTag && isBuffer(object)) {
						if (!isBuffer(other)) {
							return false;
						}
						objIsArr = true;
						objIsObj = false;
					}
					if (isSameTag && !objIsObj) {
						stack || (stack = new Stack);
						return (objIsArr || isTypedArray(object))
							? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
							: equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
					}
					if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
						var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
							othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

						if (objIsWrapped || othIsWrapped) {
							var objUnwrapped = objIsWrapped ? object.value() : object,
								othUnwrapped = othIsWrapped ? other.value() : other;

							stack || (stack = new Stack);
							return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
						}
					}
					if (!isSameTag) {
						return false;
					}
					stack || (stack = new Stack);
					return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
				}

				/**
				 * The base implementation of `_.isMap` without Node.js optimizations.
				 *
				 * @private
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
				 */
				function baseIsMap(value) {
					return isObjectLike(value) && getTag(value) == mapTag;
				}

				/**
				 * The base implementation of `_.isMatch` without support for iteratee shorthands.
				 *
				 * @private
				 * @param {Object} object The object to inspect.
				 * @param {Object} source The object of property values to match.
				 * @param {Array} matchData The property names, values, and compare flags to match.
				 * @param {Function} [customizer] The function to customize comparisons.
				 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
				 */
				function baseIsMatch(object, source, matchData, customizer) {
					var index = matchData.length,
						length = index,
						noCustomizer = !customizer;

					if (object == null) {
						return !length;
					}
					object = Object(object);
					while (index--) {
						var data = matchData[index];
						if ((noCustomizer && data[2])
							? data[1] !== object[data[0]]
							: !(data[0] in object)
						) {
							return false;
						}
					}
					while (++index < length) {
						data = matchData[index];
						var key = data[0],
							objValue = object[key],
							srcValue = data[1];

						if (noCustomizer && data[2]) {
							if (objValue === undefined$1 && !(key in object)) {
								return false;
							}
						} else {
							var stack = new Stack;
							if (customizer) {
								var result = customizer(objValue, srcValue, key, object, source, stack);
							}
							if (!(result === undefined$1
								? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
								: result
							)) {
								return false;
							}
						}
					}
					return true;
				}

				/**
				 * The base implementation of `_.isNative` without bad shim checks.
				 *
				 * @private
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a native function,
				 *  else `false`.
				 */
				function baseIsNative(value) {
					if (!isObject(value) || isMasked(value)) {
						return false;
					}
					var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
					return pattern.test(toSource(value));
				}

				/**
				 * The base implementation of `_.isRegExp` without Node.js optimizations.
				 *
				 * @private
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
				 */
				function baseIsRegExp(value) {
					return isObjectLike(value) && baseGetTag(value) == regexpTag;
				}

				/**
				 * The base implementation of `_.isSet` without Node.js optimizations.
				 *
				 * @private
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
				 */
				function baseIsSet(value) {
					return isObjectLike(value) && getTag(value) == setTag;
				}

				/**
				 * The base implementation of `_.isTypedArray` without Node.js optimizations.
				 *
				 * @private
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
				 */
				function baseIsTypedArray(value) {
					return isObjectLike(value) &&
						isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
				}

				/**
				 * The base implementation of `_.iteratee`.
				 *
				 * @private
				 * @param {*} [value=_.identity] The value to convert to an iteratee.
				 * @returns {Function} Returns the iteratee.
				 */
				function baseIteratee(value) {
					// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
					// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
					if (typeof value == 'function') {
						return value;
					}
					if (value == null) {
						return identity;
					}
					if (typeof value == 'object') {
						return isArray(value)
							? baseMatchesProperty(value[0], value[1])
							: baseMatches(value);
					}
					return property(value);
				}

				/**
				 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
				 *
				 * @private
				 * @param {Object} object The object to query.
				 * @returns {Array} Returns the array of property names.
				 */
				function baseKeys(object) {
					if (!isPrototype(object)) {
						return nativeKeys(object);
					}
					var result = [];
					for (var key in Object(object)) {
						if (hasOwnProperty.call(object, key) && key != 'constructor') {
							result.push(key);
						}
					}
					return result;
				}

				/**
				 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
				 *
				 * @private
				 * @param {Object} object The object to query.
				 * @returns {Array} Returns the array of property names.
				 */
				function baseKeysIn(object) {
					if (!isObject(object)) {
						return nativeKeysIn(object);
					}
					var isProto = isPrototype(object),
						result = [];

					for (var key in object) {
						if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
							result.push(key);
						}
					}
					return result;
				}

				/**
				 * The base implementation of `_.lt` which doesn't coerce arguments.
				 *
				 * @private
				 * @param {*} value The value to compare.
				 * @param {*} other The other value to compare.
				 * @returns {boolean} Returns `true` if `value` is less than `other`,
				 *  else `false`.
				 */
				function baseLt(value, other) {
					return value < other;
				}

				/**
				 * The base implementation of `_.map` without support for iteratee shorthands.
				 *
				 * @private
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Function} iteratee The function invoked per iteration.
				 * @returns {Array} Returns the new mapped array.
				 */
				function baseMap(collection, iteratee) {
					var index = -1,
						result = isArrayLike(collection) ? Array(collection.length) : [];

					baseEach(collection, function (value, key, collection) {
						result[++index] = iteratee(value, key, collection);
					});
					return result;
				}

				/**
				 * The base implementation of `_.matches` which doesn't clone `source`.
				 *
				 * @private
				 * @param {Object} source The object of property values to match.
				 * @returns {Function} Returns the new spec function.
				 */
				function baseMatches(source) {
					var matchData = getMatchData(source);
					if (matchData.length == 1 && matchData[0][2]) {
						return matchesStrictComparable(matchData[0][0], matchData[0][1]);
					}
					return function (object) {
						return object === source || baseIsMatch(object, source, matchData);
					};
				}

				/**
				 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
				 *
				 * @private
				 * @param {string} path The path of the property to get.
				 * @param {*} srcValue The value to match.
				 * @returns {Function} Returns the new spec function.
				 */
				function baseMatchesProperty(path, srcValue) {
					if (isKey(path) && isStrictComparable(srcValue)) {
						return matchesStrictComparable(toKey(path), srcValue);
					}
					return function (object) {
						var objValue = get(object, path);
						return (objValue === undefined$1 && objValue === srcValue)
							? hasIn(object, path)
							: baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
					};
				}

				/**
				 * The base implementation of `_.merge` without support for multiple sources.
				 *
				 * @private
				 * @param {Object} object The destination object.
				 * @param {Object} source The source object.
				 * @param {number} srcIndex The index of `source`.
				 * @param {Function} [customizer] The function to customize merged values.
				 * @param {Object} [stack] Tracks traversed source values and their merged
				 *  counterparts.
				 */
				function baseMerge(object, source, srcIndex, customizer, stack) {
					if (object === source) {
						return;
					}
					baseFor(source, function (srcValue, key) {
						stack || (stack = new Stack);
						if (isObject(srcValue)) {
							baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
						}
						else {
							var newValue = customizer
								? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
								: undefined$1;

							if (newValue === undefined$1) {
								newValue = srcValue;
							}
							assignMergeValue(object, key, newValue);
						}
					}, keysIn);
				}

				/**
				 * A specialized version of `baseMerge` for arrays and objects which performs
				 * deep merges and tracks traversed objects enabling objects with circular
				 * references to be merged.
				 *
				 * @private
				 * @param {Object} object The destination object.
				 * @param {Object} source The source object.
				 * @param {string} key The key of the value to merge.
				 * @param {number} srcIndex The index of `source`.
				 * @param {Function} mergeFunc The function to merge values.
				 * @param {Function} [customizer] The function to customize assigned values.
				 * @param {Object} [stack] Tracks traversed source values and their merged
				 *  counterparts.
				 */
				function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
					var objValue = safeGet(object, key),
						srcValue = safeGet(source, key),
						stacked = stack.get(srcValue);

					if (stacked) {
						assignMergeValue(object, key, stacked);
						return;
					}
					var newValue = customizer
						? customizer(objValue, srcValue, (key + ''), object, source, stack)
						: undefined$1;

					var isCommon = newValue === undefined$1;

					if (isCommon) {
						var isArr = isArray(srcValue),
							isBuff = !isArr && isBuffer(srcValue),
							isTyped = !isArr && !isBuff && isTypedArray(srcValue);

						newValue = srcValue;
						if (isArr || isBuff || isTyped) {
							if (isArray(objValue)) {
								newValue = objValue;
							}
							else if (isArrayLikeObject(objValue)) {
								newValue = copyArray(objValue);
							}
							else if (isBuff) {
								isCommon = false;
								newValue = cloneBuffer(srcValue, true);
							}
							else if (isTyped) {
								isCommon = false;
								newValue = cloneTypedArray(srcValue, true);
							}
							else {
								newValue = [];
							}
						}
						else if (isPlainObject(srcValue) || isArguments(srcValue)) {
							newValue = objValue;
							if (isArguments(objValue)) {
								newValue = toPlainObject(objValue);
							}
							else if (!isObject(objValue) || isFunction(objValue)) {
								newValue = initCloneObject(srcValue);
							}
						}
						else {
							isCommon = false;
						}
					}
					if (isCommon) {
						// Recursively merge objects and arrays (susceptible to call stack limits).
						stack.set(srcValue, newValue);
						mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
						stack['delete'](srcValue);
					}
					assignMergeValue(object, key, newValue);
				}

				/**
				 * The base implementation of `_.nth` which doesn't coerce arguments.
				 *
				 * @private
				 * @param {Array} array The array to query.
				 * @param {number} n The index of the element to return.
				 * @returns {*} Returns the nth element of `array`.
				 */
				function baseNth(array, n) {
					var length = array.length;
					if (!length) {
						return;
					}
					n += n < 0 ? length : 0;
					return isIndex(n, length) ? array[n] : undefined$1;
				}

				/**
				 * The base implementation of `_.orderBy` without param guards.
				 *
				 * @private
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
				 * @param {string[]} orders The sort orders of `iteratees`.
				 * @returns {Array} Returns the new sorted array.
				 */
				function baseOrderBy(collection, iteratees, orders) {
					if (iteratees.length) {
						iteratees = arrayMap(iteratees, function (iteratee) {
							if (isArray(iteratee)) {
								return function (value) {
									return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
								}
							}
							return iteratee;
						});
					} else {
						iteratees = [identity];
					}

					var index = -1;
					iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

					var result = baseMap(collection, function (value, key, collection) {
						var criteria = arrayMap(iteratees, function (iteratee) {
							return iteratee(value);
						});
						return { 'criteria': criteria, 'index': ++index, 'value': value };
					});

					return baseSortBy(result, function (object, other) {
						return compareMultiple(object, other, orders);
					});
				}

				/**
				 * The base implementation of `_.pick` without support for individual
				 * property identifiers.
				 *
				 * @private
				 * @param {Object} object The source object.
				 * @param {string[]} paths The property paths to pick.
				 * @returns {Object} Returns the new object.
				 */
				function basePick(object, paths) {
					return basePickBy(object, paths, function (value, path) {
						return hasIn(object, path);
					});
				}

				/**
				 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
				 *
				 * @private
				 * @param {Object} object The source object.
				 * @param {string[]} paths The property paths to pick.
				 * @param {Function} predicate The function invoked per property.
				 * @returns {Object} Returns the new object.
				 */
				function basePickBy(object, paths, predicate) {
					var index = -1,
						length = paths.length,
						result = {};

					while (++index < length) {
						var path = paths[index],
							value = baseGet(object, path);

						if (predicate(value, path)) {
							baseSet(result, castPath(path, object), value);
						}
					}
					return result;
				}

				/**
				 * A specialized version of `baseProperty` which supports deep paths.
				 *
				 * @private
				 * @param {Array|string} path The path of the property to get.
				 * @returns {Function} Returns the new accessor function.
				 */
				function basePropertyDeep(path) {
					return function (object) {
						return baseGet(object, path);
					};
				}

				/**
				 * The base implementation of `_.pullAllBy` without support for iteratee
				 * shorthands.
				 *
				 * @private
				 * @param {Array} array The array to modify.
				 * @param {Array} values The values to remove.
				 * @param {Function} [iteratee] The iteratee invoked per element.
				 * @param {Function} [comparator] The comparator invoked per element.
				 * @returns {Array} Returns `array`.
				 */
				function basePullAll(array, values, iteratee, comparator) {
					var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
						index = -1,
						length = values.length,
						seen = array;

					if (array === values) {
						values = copyArray(values);
					}
					if (iteratee) {
						seen = arrayMap(array, baseUnary(iteratee));
					}
					while (++index < length) {
						var fromIndex = 0,
							value = values[index],
							computed = iteratee ? iteratee(value) : value;

						while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
							if (seen !== array) {
								splice.call(seen, fromIndex, 1);
							}
							splice.call(array, fromIndex, 1);
						}
					}
					return array;
				}

				/**
				 * The base implementation of `_.pullAt` without support for individual
				 * indexes or capturing the removed elements.
				 *
				 * @private
				 * @param {Array} array The array to modify.
				 * @param {number[]} indexes The indexes of elements to remove.
				 * @returns {Array} Returns `array`.
				 */
				function basePullAt(array, indexes) {
					var length = array ? indexes.length : 0,
						lastIndex = length - 1;

					while (length--) {
						var index = indexes[length];
						if (length == lastIndex || index !== previous) {
							var previous = index;
							if (isIndex(index)) {
								splice.call(array, index, 1);
							} else {
								baseUnset(array, index);
							}
						}
					}
					return array;
				}

				/**
				 * The base implementation of `_.random` without support for returning
				 * floating-point numbers.
				 *
				 * @private
				 * @param {number} lower The lower bound.
				 * @param {number} upper The upper bound.
				 * @returns {number} Returns the random number.
				 */
				function baseRandom(lower, upper) {
					return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
				}

				/**
				 * The base implementation of `_.range` and `_.rangeRight` which doesn't
				 * coerce arguments.
				 *
				 * @private
				 * @param {number} start The start of the range.
				 * @param {number} end The end of the range.
				 * @param {number} step The value to increment or decrement by.
				 * @param {boolean} [fromRight] Specify iterating from right to left.
				 * @returns {Array} Returns the range of numbers.
				 */
				function baseRange(start, end, step, fromRight) {
					var index = -1,
						length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
						result = Array(length);

					while (length--) {
						result[fromRight ? length : ++index] = start;
						start += step;
					}
					return result;
				}

				/**
				 * The base implementation of `_.repeat` which doesn't coerce arguments.
				 *
				 * @private
				 * @param {string} string The string to repeat.
				 * @param {number} n The number of times to repeat the string.
				 * @returns {string} Returns the repeated string.
				 */
				function baseRepeat(string, n) {
					var result = '';
					if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
						return result;
					}
					// Leverage the exponentiation by squaring algorithm for a faster repeat.
					// See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
					do {
						if (n % 2) {
							result += string;
						}
						n = nativeFloor(n / 2);
						if (n) {
							string += string;
						}
					} while (n);

					return result;
				}

				/**
				 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
				 *
				 * @private
				 * @param {Function} func The function to apply a rest parameter to.
				 * @param {number} [start=func.length-1] The start position of the rest parameter.
				 * @returns {Function} Returns the new function.
				 */
				function baseRest(func, start) {
					return setToString(overRest(func, start, identity), func + '');
				}

				/**
				 * The base implementation of `_.sample`.
				 *
				 * @private
				 * @param {Array|Object} collection The collection to sample.
				 * @returns {*} Returns the random element.
				 */
				function baseSample(collection) {
					return arraySample(values(collection));
				}

				/**
				 * The base implementation of `_.sampleSize` without param guards.
				 *
				 * @private
				 * @param {Array|Object} collection The collection to sample.
				 * @param {number} n The number of elements to sample.
				 * @returns {Array} Returns the random elements.
				 */
				function baseSampleSize(collection, n) {
					var array = values(collection);
					return shuffleSelf(array, baseClamp(n, 0, array.length));
				}

				/**
				 * The base implementation of `_.set`.
				 *
				 * @private
				 * @param {Object} object The object to modify.
				 * @param {Array|string} path The path of the property to set.
				 * @param {*} value The value to set.
				 * @param {Function} [customizer] The function to customize path creation.
				 * @returns {Object} Returns `object`.
				 */
				function baseSet(object, path, value, customizer) {
					if (!isObject(object)) {
						return object;
					}
					path = castPath(path, object);

					var index = -1,
						length = path.length,
						lastIndex = length - 1,
						nested = object;

					while (nested != null && ++index < length) {
						var key = toKey(path[index]),
							newValue = value;

						if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
							return object;
						}

						if (index != lastIndex) {
							var objValue = nested[key];
							newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
							if (newValue === undefined$1) {
								newValue = isObject(objValue)
									? objValue
									: (isIndex(path[index + 1]) ? [] : {});
							}
						}
						assignValue(nested, key, newValue);
						nested = nested[key];
					}
					return object;
				}

				/**
				 * The base implementation of `setData` without support for hot loop shorting.
				 *
				 * @private
				 * @param {Function} func The function to associate metadata with.
				 * @param {*} data The metadata.
				 * @returns {Function} Returns `func`.
				 */
				var baseSetData = !metaMap ? identity : function (func, data) {
					metaMap.set(func, data);
					return func;
				};

				/**
				 * The base implementation of `setToString` without support for hot loop shorting.
				 *
				 * @private
				 * @param {Function} func The function to modify.
				 * @param {Function} string The `toString` result.
				 * @returns {Function} Returns `func`.
				 */
				var baseSetToString = !defineProperty ? identity : function (func, string) {
					return defineProperty(func, 'toString', {
						'configurable': true,
						'enumerable': false,
						'value': constant(string),
						'writable': true
					});
				};

				/**
				 * The base implementation of `_.shuffle`.
				 *
				 * @private
				 * @param {Array|Object} collection The collection to shuffle.
				 * @returns {Array} Returns the new shuffled array.
				 */
				function baseShuffle(collection) {
					return shuffleSelf(values(collection));
				}

				/**
				 * The base implementation of `_.slice` without an iteratee call guard.
				 *
				 * @private
				 * @param {Array} array The array to slice.
				 * @param {number} [start=0] The start position.
				 * @param {number} [end=array.length] The end position.
				 * @returns {Array} Returns the slice of `array`.
				 */
				function baseSlice(array, start, end) {
					var index = -1,
						length = array.length;

					if (start < 0) {
						start = -start > length ? 0 : (length + start);
					}
					end = end > length ? length : end;
					if (end < 0) {
						end += length;
					}
					length = start > end ? 0 : ((end - start) >>> 0);
					start >>>= 0;

					var result = Array(length);
					while (++index < length) {
						result[index] = array[index + start];
					}
					return result;
				}

				/**
				 * The base implementation of `_.some` without support for iteratee shorthands.
				 *
				 * @private
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Function} predicate The function invoked per iteration.
				 * @returns {boolean} Returns `true` if any element passes the predicate check,
				 *  else `false`.
				 */
				function baseSome(collection, predicate) {
					var result;

					baseEach(collection, function (value, index, collection) {
						result = predicate(value, index, collection);
						return !result;
					});
					return !!result;
				}

				/**
				 * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
				 * performs a binary search of `array` to determine the index at which `value`
				 * should be inserted into `array` in order to maintain its sort order.
				 *
				 * @private
				 * @param {Array} array The sorted array to inspect.
				 * @param {*} value The value to evaluate.
				 * @param {boolean} [retHighest] Specify returning the highest qualified index.
				 * @returns {number} Returns the index at which `value` should be inserted
				 *  into `array`.
				 */
				function baseSortedIndex(array, value, retHighest) {
					var low = 0,
						high = array == null ? low : array.length;

					if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
						while (low < high) {
							var mid = (low + high) >>> 1,
								computed = array[mid];

							if (computed !== null && !isSymbol(computed) &&
								(retHighest ? (computed <= value) : (computed < value))) {
								low = mid + 1;
							} else {
								high = mid;
							}
						}
						return high;
					}
					return baseSortedIndexBy(array, value, identity, retHighest);
				}

				/**
				 * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
				 * which invokes `iteratee` for `value` and each element of `array` to compute
				 * their sort ranking. The iteratee is invoked with one argument; (value).
				 *
				 * @private
				 * @param {Array} array The sorted array to inspect.
				 * @param {*} value The value to evaluate.
				 * @param {Function} iteratee The iteratee invoked per element.
				 * @param {boolean} [retHighest] Specify returning the highest qualified index.
				 * @returns {number} Returns the index at which `value` should be inserted
				 *  into `array`.
				 */
				function baseSortedIndexBy(array, value, iteratee, retHighest) {
					var low = 0,
						high = array == null ? 0 : array.length;
					if (high === 0) {
						return 0;
					}

					value = iteratee(value);
					var valIsNaN = value !== value,
						valIsNull = value === null,
						valIsSymbol = isSymbol(value),
						valIsUndefined = value === undefined$1;

					while (low < high) {
						var mid = nativeFloor((low + high) / 2),
							computed = iteratee(array[mid]),
							othIsDefined = computed !== undefined$1,
							othIsNull = computed === null,
							othIsReflexive = computed === computed,
							othIsSymbol = isSymbol(computed);

						if (valIsNaN) {
							var setLow = retHighest || othIsReflexive;
						} else if (valIsUndefined) {
							setLow = othIsReflexive && (retHighest || othIsDefined);
						} else if (valIsNull) {
							setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
						} else if (valIsSymbol) {
							setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
						} else if (othIsNull || othIsSymbol) {
							setLow = false;
						} else {
							setLow = retHighest ? (computed <= value) : (computed < value);
						}
						if (setLow) {
							low = mid + 1;
						} else {
							high = mid;
						}
					}
					return nativeMin(high, MAX_ARRAY_INDEX);
				}

				/**
				 * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
				 * support for iteratee shorthands.
				 *
				 * @private
				 * @param {Array} array The array to inspect.
				 * @param {Function} [iteratee] The iteratee invoked per element.
				 * @returns {Array} Returns the new duplicate free array.
				 */
				function baseSortedUniq(array, iteratee) {
					var index = -1,
						length = array.length,
						resIndex = 0,
						result = [];

					while (++index < length) {
						var value = array[index],
							computed = iteratee ? iteratee(value) : value;

						if (!index || !eq(computed, seen)) {
							var seen = computed;
							result[resIndex++] = value === 0 ? 0 : value;
						}
					}
					return result;
				}

				/**
				 * The base implementation of `_.toNumber` which doesn't ensure correct
				 * conversions of binary, hexadecimal, or octal string values.
				 *
				 * @private
				 * @param {*} value The value to process.
				 * @returns {number} Returns the number.
				 */
				function baseToNumber(value) {
					if (typeof value == 'number') {
						return value;
					}
					if (isSymbol(value)) {
						return NAN;
					}
					return +value;
				}

				/**
				 * The base implementation of `_.toString` which doesn't convert nullish
				 * values to empty strings.
				 *
				 * @private
				 * @param {*} value The value to process.
				 * @returns {string} Returns the string.
				 */
				function baseToString(value) {
					// Exit early for strings to avoid a performance hit in some environments.
					if (typeof value == 'string') {
						return value;
					}
					if (isArray(value)) {
						// Recursively convert values (susceptible to call stack limits).
						return arrayMap(value, baseToString) + '';
					}
					if (isSymbol(value)) {
						return symbolToString ? symbolToString.call(value) : '';
					}
					var result = (value + '');
					return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
				}

				/**
				 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
				 *
				 * @private
				 * @param {Array} array The array to inspect.
				 * @param {Function} [iteratee] The iteratee invoked per element.
				 * @param {Function} [comparator] The comparator invoked per element.
				 * @returns {Array} Returns the new duplicate free array.
				 */
				function baseUniq(array, iteratee, comparator) {
					var index = -1,
						includes = arrayIncludes,
						length = array.length,
						isCommon = true,
						result = [],
						seen = result;

					if (comparator) {
						isCommon = false;
						includes = arrayIncludesWith;
					}
					else if (length >= LARGE_ARRAY_SIZE) {
						var set = iteratee ? null : createSet(array);
						if (set) {
							return setToArray(set);
						}
						isCommon = false;
						includes = cacheHas;
						seen = new SetCache;
					}
					else {
						seen = iteratee ? [] : result;
					}
					outer:
					while (++index < length) {
						var value = array[index],
							computed = iteratee ? iteratee(value) : value;

						value = (comparator || value !== 0) ? value : 0;
						if (isCommon && computed === computed) {
							var seenIndex = seen.length;
							while (seenIndex--) {
								if (seen[seenIndex] === computed) {
									continue outer;
								}
							}
							if (iteratee) {
								seen.push(computed);
							}
							result.push(value);
						}
						else if (!includes(seen, computed, comparator)) {
							if (seen !== result) {
								seen.push(computed);
							}
							result.push(value);
						}
					}
					return result;
				}

				/**
				 * The base implementation of `_.unset`.
				 *
				 * @private
				 * @param {Object} object The object to modify.
				 * @param {Array|string} path The property path to unset.
				 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
				 */
				function baseUnset(object, path) {
					path = castPath(path, object);
					object = parent(object, path);
					return object == null || delete object[toKey(last(path))];
				}

				/**
				 * The base implementation of `_.update`.
				 *
				 * @private
				 * @param {Object} object The object to modify.
				 * @param {Array|string} path The path of the property to update.
				 * @param {Function} updater The function to produce the updated value.
				 * @param {Function} [customizer] The function to customize path creation.
				 * @returns {Object} Returns `object`.
				 */
				function baseUpdate(object, path, updater, customizer) {
					return baseSet(object, path, updater(baseGet(object, path)), customizer);
				}

				/**
				 * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
				 * without support for iteratee shorthands.
				 *
				 * @private
				 * @param {Array} array The array to query.
				 * @param {Function} predicate The function invoked per iteration.
				 * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
				 * @param {boolean} [fromRight] Specify iterating from right to left.
				 * @returns {Array} Returns the slice of `array`.
				 */
				function baseWhile(array, predicate, isDrop, fromRight) {
					var length = array.length,
						index = fromRight ? length : -1;

					while ((fromRight ? index-- : ++index < length) &&
						predicate(array[index], index, array)) { }

					return isDrop
						? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
						: baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
				}

				/**
				 * The base implementation of `wrapperValue` which returns the result of
				 * performing a sequence of actions on the unwrapped `value`, where each
				 * successive action is supplied the return value of the previous.
				 *
				 * @private
				 * @param {*} value The unwrapped value.
				 * @param {Array} actions Actions to perform to resolve the unwrapped value.
				 * @returns {*} Returns the resolved value.
				 */
				function baseWrapperValue(value, actions) {
					var result = value;
					if (result instanceof LazyWrapper) {
						result = result.value();
					}
					return arrayReduce(actions, function (result, action) {
						return action.func.apply(action.thisArg, arrayPush([result], action.args));
					}, result);
				}

				/**
				 * The base implementation of methods like `_.xor`, without support for
				 * iteratee shorthands, that accepts an array of arrays to inspect.
				 *
				 * @private
				 * @param {Array} arrays The arrays to inspect.
				 * @param {Function} [iteratee] The iteratee invoked per element.
				 * @param {Function} [comparator] The comparator invoked per element.
				 * @returns {Array} Returns the new array of values.
				 */
				function baseXor(arrays, iteratee, comparator) {
					var length = arrays.length;
					if (length < 2) {
						return length ? baseUniq(arrays[0]) : [];
					}
					var index = -1,
						result = Array(length);

					while (++index < length) {
						var array = arrays[index],
							othIndex = -1;

						while (++othIndex < length) {
							if (othIndex != index) {
								result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
							}
						}
					}
					return baseUniq(baseFlatten(result, 1), iteratee, comparator);
				}

				/**
				 * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
				 *
				 * @private
				 * @param {Array} props The property identifiers.
				 * @param {Array} values The property values.
				 * @param {Function} assignFunc The function to assign values.
				 * @returns {Object} Returns the new object.
				 */
				function baseZipObject(props, values, assignFunc) {
					var index = -1,
						length = props.length,
						valsLength = values.length,
						result = {};

					while (++index < length) {
						var value = index < valsLength ? values[index] : undefined$1;
						assignFunc(result, props[index], value);
					}
					return result;
				}

				/**
				 * Casts `value` to an empty array if it's not an array like object.
				 *
				 * @private
				 * @param {*} value The value to inspect.
				 * @returns {Array|Object} Returns the cast array-like object.
				 */
				function castArrayLikeObject(value) {
					return isArrayLikeObject(value) ? value : [];
				}

				/**
				 * Casts `value` to `identity` if it's not a function.
				 *
				 * @private
				 * @param {*} value The value to inspect.
				 * @returns {Function} Returns cast function.
				 */
				function castFunction(value) {
					return typeof value == 'function' ? value : identity;
				}

				/**
				 * Casts `value` to a path array if it's not one.
				 *
				 * @private
				 * @param {*} value The value to inspect.
				 * @param {Object} [object] The object to query keys on.
				 * @returns {Array} Returns the cast property path array.
				 */
				function castPath(value, object) {
					if (isArray(value)) {
						return value;
					}
					return isKey(value, object) ? [value] : stringToPath(toString(value));
				}

				/**
				 * A `baseRest` alias which can be replaced with `identity` by module
				 * replacement plugins.
				 *
				 * @private
				 * @type {Function}
				 * @param {Function} func The function to apply a rest parameter to.
				 * @returns {Function} Returns the new function.
				 */
				var castRest = baseRest;

				/**
				 * Casts `array` to a slice if it's needed.
				 *
				 * @private
				 * @param {Array} array The array to inspect.
				 * @param {number} start The start position.
				 * @param {number} [end=array.length] The end position.
				 * @returns {Array} Returns the cast slice.
				 */
				function castSlice(array, start, end) {
					var length = array.length;
					end = end === undefined$1 ? length : end;
					return (!start && end >= length) ? array : baseSlice(array, start, end);
				}

				/**
				 * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
				 *
				 * @private
				 * @param {number|Object} id The timer id or timeout object of the timer to clear.
				 */
				var clearTimeout = ctxClearTimeout || function (id) {
					return root.clearTimeout(id);
				};

				/**
				 * Creates a clone of  `buffer`.
				 *
				 * @private
				 * @param {Buffer} buffer The buffer to clone.
				 * @param {boolean} [isDeep] Specify a deep clone.
				 * @returns {Buffer} Returns the cloned buffer.
				 */
				function cloneBuffer(buffer, isDeep) {
					if (isDeep) {
						return buffer.slice();
					}
					var length = buffer.length,
						result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

					buffer.copy(result);
					return result;
				}

				/**
				 * Creates a clone of `arrayBuffer`.
				 *
				 * @private
				 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
				 * @returns {ArrayBuffer} Returns the cloned array buffer.
				 */
				function cloneArrayBuffer(arrayBuffer) {
					var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
					new Uint8Array(result).set(new Uint8Array(arrayBuffer));
					return result;
				}

				/**
				 * Creates a clone of `dataView`.
				 *
				 * @private
				 * @param {Object} dataView The data view to clone.
				 * @param {boolean} [isDeep] Specify a deep clone.
				 * @returns {Object} Returns the cloned data view.
				 */
				function cloneDataView(dataView, isDeep) {
					var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
					return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
				}

				/**
				 * Creates a clone of `regexp`.
				 *
				 * @private
				 * @param {Object} regexp The regexp to clone.
				 * @returns {Object} Returns the cloned regexp.
				 */
				function cloneRegExp(regexp) {
					var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
					result.lastIndex = regexp.lastIndex;
					return result;
				}

				/**
				 * Creates a clone of the `symbol` object.
				 *
				 * @private
				 * @param {Object} symbol The symbol object to clone.
				 * @returns {Object} Returns the cloned symbol object.
				 */
				function cloneSymbol(symbol) {
					return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
				}

				/**
				 * Creates a clone of `typedArray`.
				 *
				 * @private
				 * @param {Object} typedArray The typed array to clone.
				 * @param {boolean} [isDeep] Specify a deep clone.
				 * @returns {Object} Returns the cloned typed array.
				 */
				function cloneTypedArray(typedArray, isDeep) {
					var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
					return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
				}

				/**
				 * Compares values to sort them in ascending order.
				 *
				 * @private
				 * @param {*} value The value to compare.
				 * @param {*} other The other value to compare.
				 * @returns {number} Returns the sort order indicator for `value`.
				 */
				function compareAscending(value, other) {
					if (value !== other) {
						var valIsDefined = value !== undefined$1,
							valIsNull = value === null,
							valIsReflexive = value === value,
							valIsSymbol = isSymbol(value);

						var othIsDefined = other !== undefined$1,
							othIsNull = other === null,
							othIsReflexive = other === other,
							othIsSymbol = isSymbol(other);

						if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
							(valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
							(valIsNull && othIsDefined && othIsReflexive) ||
							(!valIsDefined && othIsReflexive) ||
							!valIsReflexive) {
							return 1;
						}
						if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
							(othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
							(othIsNull && valIsDefined && valIsReflexive) ||
							(!othIsDefined && valIsReflexive) ||
							!othIsReflexive) {
							return -1;
						}
					}
					return 0;
				}

				/**
				 * Used by `_.orderBy` to compare multiple properties of a value to another
				 * and stable sort them.
				 *
				 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
				 * specify an order of "desc" for descending or "asc" for ascending sort order
				 * of corresponding values.
				 *
				 * @private
				 * @param {Object} object The object to compare.
				 * @param {Object} other The other object to compare.
				 * @param {boolean[]|string[]} orders The order to sort by for each property.
				 * @returns {number} Returns the sort order indicator for `object`.
				 */
				function compareMultiple(object, other, orders) {
					var index = -1,
						objCriteria = object.criteria,
						othCriteria = other.criteria,
						length = objCriteria.length,
						ordersLength = orders.length;

					while (++index < length) {
						var result = compareAscending(objCriteria[index], othCriteria[index]);
						if (result) {
							if (index >= ordersLength) {
								return result;
							}
							var order = orders[index];
							return result * (order == 'desc' ? -1 : 1);
						}
					}
					// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
					// that causes it, under certain circumstances, to provide the same value for
					// `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
					// for more details.
					//
					// This also ensures a stable sort in V8 and other engines.
					// See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
					return object.index - other.index;
				}

				/**
				 * Creates an array that is the composition of partially applied arguments,
				 * placeholders, and provided arguments into a single array of arguments.
				 *
				 * @private
				 * @param {Array} args The provided arguments.
				 * @param {Array} partials The arguments to prepend to those provided.
				 * @param {Array} holders The `partials` placeholder indexes.
				 * @params {boolean} [isCurried] Specify composing for a curried function.
				 * @returns {Array} Returns the new array of composed arguments.
				 */
				function composeArgs(args, partials, holders, isCurried) {
					var argsIndex = -1,
						argsLength = args.length,
						holdersLength = holders.length,
						leftIndex = -1,
						leftLength = partials.length,
						rangeLength = nativeMax(argsLength - holdersLength, 0),
						result = Array(leftLength + rangeLength),
						isUncurried = !isCurried;

					while (++leftIndex < leftLength) {
						result[leftIndex] = partials[leftIndex];
					}
					while (++argsIndex < holdersLength) {
						if (isUncurried || argsIndex < argsLength) {
							result[holders[argsIndex]] = args[argsIndex];
						}
					}
					while (rangeLength--) {
						result[leftIndex++] = args[argsIndex++];
					}
					return result;
				}

				/**
				 * This function is like `composeArgs` except that the arguments composition
				 * is tailored for `_.partialRight`.
				 *
				 * @private
				 * @param {Array} args The provided arguments.
				 * @param {Array} partials The arguments to append to those provided.
				 * @param {Array} holders The `partials` placeholder indexes.
				 * @params {boolean} [isCurried] Specify composing for a curried function.
				 * @returns {Array} Returns the new array of composed arguments.
				 */
				function composeArgsRight(args, partials, holders, isCurried) {
					var argsIndex = -1,
						argsLength = args.length,
						holdersIndex = -1,
						holdersLength = holders.length,
						rightIndex = -1,
						rightLength = partials.length,
						rangeLength = nativeMax(argsLength - holdersLength, 0),
						result = Array(rangeLength + rightLength),
						isUncurried = !isCurried;

					while (++argsIndex < rangeLength) {
						result[argsIndex] = args[argsIndex];
					}
					var offset = argsIndex;
					while (++rightIndex < rightLength) {
						result[offset + rightIndex] = partials[rightIndex];
					}
					while (++holdersIndex < holdersLength) {
						if (isUncurried || argsIndex < argsLength) {
							result[offset + holders[holdersIndex]] = args[argsIndex++];
						}
					}
					return result;
				}

				/**
				 * Copies the values of `source` to `array`.
				 *
				 * @private
				 * @param {Array} source The array to copy values from.
				 * @param {Array} [array=[]] The array to copy values to.
				 * @returns {Array} Returns `array`.
				 */
				function copyArray(source, array) {
					var index = -1,
						length = source.length;

					array || (array = Array(length));
					while (++index < length) {
						array[index] = source[index];
					}
					return array;
				}

				/**
				 * Copies properties of `source` to `object`.
				 *
				 * @private
				 * @param {Object} source The object to copy properties from.
				 * @param {Array} props The property identifiers to copy.
				 * @param {Object} [object={}] The object to copy properties to.
				 * @param {Function} [customizer] The function to customize copied values.
				 * @returns {Object} Returns `object`.
				 */
				function copyObject(source, props, object, customizer) {
					var isNew = !object;
					object || (object = {});

					var index = -1,
						length = props.length;

					while (++index < length) {
						var key = props[index];

						var newValue = customizer
							? customizer(object[key], source[key], key, object, source)
							: undefined$1;

						if (newValue === undefined$1) {
							newValue = source[key];
						}
						if (isNew) {
							baseAssignValue(object, key, newValue);
						} else {
							assignValue(object, key, newValue);
						}
					}
					return object;
				}

				/**
				 * Copies own symbols of `source` to `object`.
				 *
				 * @private
				 * @param {Object} source The object to copy symbols from.
				 * @param {Object} [object={}] The object to copy symbols to.
				 * @returns {Object} Returns `object`.
				 */
				function copySymbols(source, object) {
					return copyObject(source, getSymbols(source), object);
				}

				/**
				 * Copies own and inherited symbols of `source` to `object`.
				 *
				 * @private
				 * @param {Object} source The object to copy symbols from.
				 * @param {Object} [object={}] The object to copy symbols to.
				 * @returns {Object} Returns `object`.
				 */
				function copySymbolsIn(source, object) {
					return copyObject(source, getSymbolsIn(source), object);
				}

				/**
				 * Creates a function like `_.groupBy`.
				 *
				 * @private
				 * @param {Function} setter The function to set accumulator values.
				 * @param {Function} [initializer] The accumulator object initializer.
				 * @returns {Function} Returns the new aggregator function.
				 */
				function createAggregator(setter, initializer) {
					return function (collection, iteratee) {
						var func = isArray(collection) ? arrayAggregator : baseAggregator,
							accumulator = initializer ? initializer() : {};

						return func(collection, setter, getIteratee(iteratee, 2), accumulator);
					};
				}

				/**
				 * Creates a function like `_.assign`.
				 *
				 * @private
				 * @param {Function} assigner The function to assign values.
				 * @returns {Function} Returns the new assigner function.
				 */
				function createAssigner(assigner) {
					return baseRest(function (object, sources) {
						var index = -1,
							length = sources.length,
							customizer = length > 1 ? sources[length - 1] : undefined$1,
							guard = length > 2 ? sources[2] : undefined$1;

						customizer = (assigner.length > 3 && typeof customizer == 'function')
							? (length--, customizer)
							: undefined$1;

						if (guard && isIterateeCall(sources[0], sources[1], guard)) {
							customizer = length < 3 ? undefined$1 : customizer;
							length = 1;
						}
						object = Object(object);
						while (++index < length) {
							var source = sources[index];
							if (source) {
								assigner(object, source, index, customizer);
							}
						}
						return object;
					});
				}

				/**
				 * Creates a `baseEach` or `baseEachRight` function.
				 *
				 * @private
				 * @param {Function} eachFunc The function to iterate over a collection.
				 * @param {boolean} [fromRight] Specify iterating from right to left.
				 * @returns {Function} Returns the new base function.
				 */
				function createBaseEach(eachFunc, fromRight) {
					return function (collection, iteratee) {
						if (collection == null) {
							return collection;
						}
						if (!isArrayLike(collection)) {
							return eachFunc(collection, iteratee);
						}
						var length = collection.length,
							index = fromRight ? length : -1,
							iterable = Object(collection);

						while ((fromRight ? index-- : ++index < length)) {
							if (iteratee(iterable[index], index, iterable) === false) {
								break;
							}
						}
						return collection;
					};
				}

				/**
				 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
				 *
				 * @private
				 * @param {boolean} [fromRight] Specify iterating from right to left.
				 * @returns {Function} Returns the new base function.
				 */
				function createBaseFor(fromRight) {
					return function (object, iteratee, keysFunc) {
						var index = -1,
							iterable = Object(object),
							props = keysFunc(object),
							length = props.length;

						while (length--) {
							var key = props[fromRight ? length : ++index];
							if (iteratee(iterable[key], key, iterable) === false) {
								break;
							}
						}
						return object;
					};
				}

				/**
				 * Creates a function that wraps `func` to invoke it with the optional `this`
				 * binding of `thisArg`.
				 *
				 * @private
				 * @param {Function} func The function to wrap.
				 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
				 * @param {*} [thisArg] The `this` binding of `func`.
				 * @returns {Function} Returns the new wrapped function.
				 */
				function createBind(func, bitmask, thisArg) {
					var isBind = bitmask & WRAP_BIND_FLAG,
						Ctor = createCtor(func);

					function wrapper() {
						var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
						return fn.apply(isBind ? thisArg : this, arguments);
					}
					return wrapper;
				}

				/**
				 * Creates a function like `_.lowerFirst`.
				 *
				 * @private
				 * @param {string} methodName The name of the `String` case method to use.
				 * @returns {Function} Returns the new case function.
				 */
				function createCaseFirst(methodName) {
					return function (string) {
						string = toString(string);

						var strSymbols = hasUnicode(string)
							? stringToArray(string)
							: undefined$1;

						var chr = strSymbols
							? strSymbols[0]
							: string.charAt(0);

						var trailing = strSymbols
							? castSlice(strSymbols, 1).join('')
							: string.slice(1);

						return chr[methodName]() + trailing;
					};
				}

				/**
				 * Creates a function like `_.camelCase`.
				 *
				 * @private
				 * @param {Function} callback The function to combine each word.
				 * @returns {Function} Returns the new compounder function.
				 */
				function createCompounder(callback) {
					return function (string) {
						return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
					};
				}

				/**
				 * Creates a function that produces an instance of `Ctor` regardless of
				 * whether it was invoked as part of a `new` expression or by `call` or `apply`.
				 *
				 * @private
				 * @param {Function} Ctor The constructor to wrap.
				 * @returns {Function} Returns the new wrapped function.
				 */
				function createCtor(Ctor) {
					return function () {
						// Use a `switch` statement to work with class constructors. See
						// http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
						// for more details.
						var args = arguments;
						switch (args.length) {
							case 0: return new Ctor;
							case 1: return new Ctor(args[0]);
							case 2: return new Ctor(args[0], args[1]);
							case 3: return new Ctor(args[0], args[1], args[2]);
							case 4: return new Ctor(args[0], args[1], args[2], args[3]);
							case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
							case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
							case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
						}
						var thisBinding = baseCreate(Ctor.prototype),
							result = Ctor.apply(thisBinding, args);

						// Mimic the constructor's `return` behavior.
						// See https://es5.github.io/#x13.2.2 for more details.
						return isObject(result) ? result : thisBinding;
					};
				}

				/**
				 * Creates a function that wraps `func` to enable currying.
				 *
				 * @private
				 * @param {Function} func The function to wrap.
				 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
				 * @param {number} arity The arity of `func`.
				 * @returns {Function} Returns the new wrapped function.
				 */
				function createCurry(func, bitmask, arity) {
					var Ctor = createCtor(func);

					function wrapper() {
						var length = arguments.length,
							args = Array(length),
							index = length,
							placeholder = getHolder(wrapper);

						while (index--) {
							args[index] = arguments[index];
						}
						var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
							? []
							: replaceHolders(args, placeholder);

						length -= holders.length;
						if (length < arity) {
							return createRecurry(
								func, bitmask, createHybrid, wrapper.placeholder, undefined$1,
								args, holders, undefined$1, undefined$1, arity - length);
						}
						var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
						return apply(fn, this, args);
					}
					return wrapper;
				}

				/**
				 * Creates a `_.find` or `_.findLast` function.
				 *
				 * @private
				 * @param {Function} findIndexFunc The function to find the collection index.
				 * @returns {Function} Returns the new find function.
				 */
				function createFind(findIndexFunc) {
					return function (collection, predicate, fromIndex) {
						var iterable = Object(collection);
						if (!isArrayLike(collection)) {
							var iteratee = getIteratee(predicate, 3);
							collection = keys(collection);
							predicate = function (key) { return iteratee(iterable[key], key, iterable); };
						}
						var index = findIndexFunc(collection, predicate, fromIndex);
						return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined$1;
					};
				}

				/**
				 * Creates a `_.flow` or `_.flowRight` function.
				 *
				 * @private
				 * @param {boolean} [fromRight] Specify iterating from right to left.
				 * @returns {Function} Returns the new flow function.
				 */
				function createFlow(fromRight) {
					return flatRest(function (funcs) {
						var length = funcs.length,
							index = length,
							prereq = LodashWrapper.prototype.thru;

						if (fromRight) {
							funcs.reverse();
						}
						while (index--) {
							var func = funcs[index];
							if (typeof func != 'function') {
								throw new TypeError(FUNC_ERROR_TEXT);
							}
							if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
								var wrapper = new LodashWrapper([], true);
							}
						}
						index = wrapper ? index : length;
						while (++index < length) {
							func = funcs[index];

							var funcName = getFuncName(func),
								data = funcName == 'wrapper' ? getData(func) : undefined$1;

							if (data && isLaziable(data[0]) &&
								data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
								!data[4].length && data[9] == 1
							) {
								wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
							} else {
								wrapper = (func.length == 1 && isLaziable(func))
									? wrapper[funcName]()
									: wrapper.thru(func);
							}
						}
						return function () {
							var args = arguments,
								value = args[0];

							if (wrapper && args.length == 1 && isArray(value)) {
								return wrapper.plant(value).value();
							}
							var index = 0,
								result = length ? funcs[index].apply(this, args) : value;

							while (++index < length) {
								result = funcs[index].call(this, result);
							}
							return result;
						};
					});
				}

				/**
				 * Creates a function that wraps `func` to invoke it with optional `this`
				 * binding of `thisArg`, partial application, and currying.
				 *
				 * @private
				 * @param {Function|string} func The function or method name to wrap.
				 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
				 * @param {*} [thisArg] The `this` binding of `func`.
				 * @param {Array} [partials] The arguments to prepend to those provided to
				 *  the new function.
				 * @param {Array} [holders] The `partials` placeholder indexes.
				 * @param {Array} [partialsRight] The arguments to append to those provided
				 *  to the new function.
				 * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
				 * @param {Array} [argPos] The argument positions of the new function.
				 * @param {number} [ary] The arity cap of `func`.
				 * @param {number} [arity] The arity of `func`.
				 * @returns {Function} Returns the new wrapped function.
				 */
				function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
					var isAry = bitmask & WRAP_ARY_FLAG,
						isBind = bitmask & WRAP_BIND_FLAG,
						isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
						isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
						isFlip = bitmask & WRAP_FLIP_FLAG,
						Ctor = isBindKey ? undefined$1 : createCtor(func);

					function wrapper() {
						var length = arguments.length,
							args = Array(length),
							index = length;

						while (index--) {
							args[index] = arguments[index];
						}
						if (isCurried) {
							var placeholder = getHolder(wrapper),
								holdersCount = countHolders(args, placeholder);
						}
						if (partials) {
							args = composeArgs(args, partials, holders, isCurried);
						}
						if (partialsRight) {
							args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
						}
						length -= holdersCount;
						if (isCurried && length < arity) {
							var newHolders = replaceHolders(args, placeholder);
							return createRecurry(
								func, bitmask, createHybrid, wrapper.placeholder, thisArg,
								args, newHolders, argPos, ary, arity - length
							);
						}
						var thisBinding = isBind ? thisArg : this,
							fn = isBindKey ? thisBinding[func] : func;

						length = args.length;
						if (argPos) {
							args = reorder(args, argPos);
						} else if (isFlip && length > 1) {
							args.reverse();
						}
						if (isAry && ary < length) {
							args.length = ary;
						}
						if (this && this !== root && this instanceof wrapper) {
							fn = Ctor || createCtor(fn);
						}
						return fn.apply(thisBinding, args);
					}
					return wrapper;
				}

				/**
				 * Creates a function like `_.invertBy`.
				 *
				 * @private
				 * @param {Function} setter The function to set accumulator values.
				 * @param {Function} toIteratee The function to resolve iteratees.
				 * @returns {Function} Returns the new inverter function.
				 */
				function createInverter(setter, toIteratee) {
					return function (object, iteratee) {
						return baseInverter(object, setter, toIteratee(iteratee), {});
					};
				}

				/**
				 * Creates a function that performs a mathematical operation on two values.
				 *
				 * @private
				 * @param {Function} operator The function to perform the operation.
				 * @param {number} [defaultValue] The value used for `undefined` arguments.
				 * @returns {Function} Returns the new mathematical operation function.
				 */
				function createMathOperation(operator, defaultValue) {
					return function (value, other) {
						var result;
						if (value === undefined$1 && other === undefined$1) {
							return defaultValue;
						}
						if (value !== undefined$1) {
							result = value;
						}
						if (other !== undefined$1) {
							if (result === undefined$1) {
								return other;
							}
							if (typeof value == 'string' || typeof other == 'string') {
								value = baseToString(value);
								other = baseToString(other);
							} else {
								value = baseToNumber(value);
								other = baseToNumber(other);
							}
							result = operator(value, other);
						}
						return result;
					};
				}

				/**
				 * Creates a function like `_.over`.
				 *
				 * @private
				 * @param {Function} arrayFunc The function to iterate over iteratees.
				 * @returns {Function} Returns the new over function.
				 */
				function createOver(arrayFunc) {
					return flatRest(function (iteratees) {
						iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
						return baseRest(function (args) {
							var thisArg = this;
							return arrayFunc(iteratees, function (iteratee) {
								return apply(iteratee, thisArg, args);
							});
						});
					});
				}

				/**
				 * Creates the padding for `string` based on `length`. The `chars` string
				 * is truncated if the number of characters exceeds `length`.
				 *
				 * @private
				 * @param {number} length The padding length.
				 * @param {string} [chars=' '] The string used as padding.
				 * @returns {string} Returns the padding for `string`.
				 */
				function createPadding(length, chars) {
					chars = chars === undefined$1 ? ' ' : baseToString(chars);

					var charsLength = chars.length;
					if (charsLength < 2) {
						return charsLength ? baseRepeat(chars, length) : chars;
					}
					var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
					return hasUnicode(chars)
						? castSlice(stringToArray(result), 0, length).join('')
						: result.slice(0, length);
				}

				/**
				 * Creates a function that wraps `func` to invoke it with the `this` binding
				 * of `thisArg` and `partials` prepended to the arguments it receives.
				 *
				 * @private
				 * @param {Function} func The function to wrap.
				 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
				 * @param {*} thisArg The `this` binding of `func`.
				 * @param {Array} partials The arguments to prepend to those provided to
				 *  the new function.
				 * @returns {Function} Returns the new wrapped function.
				 */
				function createPartial(func, bitmask, thisArg, partials) {
					var isBind = bitmask & WRAP_BIND_FLAG,
						Ctor = createCtor(func);

					function wrapper() {
						var argsIndex = -1,
							argsLength = arguments.length,
							leftIndex = -1,
							leftLength = partials.length,
							args = Array(leftLength + argsLength),
							fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

						while (++leftIndex < leftLength) {
							args[leftIndex] = partials[leftIndex];
						}
						while (argsLength--) {
							args[leftIndex++] = arguments[++argsIndex];
						}
						return apply(fn, isBind ? thisArg : this, args);
					}
					return wrapper;
				}

				/**
				 * Creates a `_.range` or `_.rangeRight` function.
				 *
				 * @private
				 * @param {boolean} [fromRight] Specify iterating from right to left.
				 * @returns {Function} Returns the new range function.
				 */
				function createRange(fromRight) {
					return function (start, end, step) {
						if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
							end = step = undefined$1;
						}
						// Ensure the sign of `-0` is preserved.
						start = toFinite(start);
						if (end === undefined$1) {
							end = start;
							start = 0;
						} else {
							end = toFinite(end);
						}
						step = step === undefined$1 ? (start < end ? 1 : -1) : toFinite(step);
						return baseRange(start, end, step, fromRight);
					};
				}

				/**
				 * Creates a function that performs a relational operation on two values.
				 *
				 * @private
				 * @param {Function} operator The function to perform the operation.
				 * @returns {Function} Returns the new relational operation function.
				 */
				function createRelationalOperation(operator) {
					return function (value, other) {
						if (!(typeof value == 'string' && typeof other == 'string')) {
							value = toNumber(value);
							other = toNumber(other);
						}
						return operator(value, other);
					};
				}

				/**
				 * Creates a function that wraps `func` to continue currying.
				 *
				 * @private
				 * @param {Function} func The function to wrap.
				 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
				 * @param {Function} wrapFunc The function to create the `func` wrapper.
				 * @param {*} placeholder The placeholder value.
				 * @param {*} [thisArg] The `this` binding of `func`.
				 * @param {Array} [partials] The arguments to prepend to those provided to
				 *  the new function.
				 * @param {Array} [holders] The `partials` placeholder indexes.
				 * @param {Array} [argPos] The argument positions of the new function.
				 * @param {number} [ary] The arity cap of `func`.
				 * @param {number} [arity] The arity of `func`.
				 * @returns {Function} Returns the new wrapped function.
				 */
				function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
					var isCurry = bitmask & WRAP_CURRY_FLAG,
						newHolders = isCurry ? holders : undefined$1,
						newHoldersRight = isCurry ? undefined$1 : holders,
						newPartials = isCurry ? partials : undefined$1,
						newPartialsRight = isCurry ? undefined$1 : partials;

					bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
					bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

					if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
						bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
					}
					var newData = [
						func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
						newHoldersRight, argPos, ary, arity
					];

					var result = wrapFunc.apply(undefined$1, newData);
					if (isLaziable(func)) {
						setData(result, newData);
					}
					result.placeholder = placeholder;
					return setWrapToString(result, func, bitmask);
				}

				/**
				 * Creates a function like `_.round`.
				 *
				 * @private
				 * @param {string} methodName The name of the `Math` method to use when rounding.
				 * @returns {Function} Returns the new round function.
				 */
				function createRound(methodName) {
					var func = Math[methodName];
					return function (number, precision) {
						number = toNumber(number);
						precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
						if (precision && nativeIsFinite(number)) {
							// Shift with exponential notation to avoid floating-point issues.
							// See [MDN](https://mdn.io/round#Examples) for more details.
							var pair = (toString(number) + 'e').split('e'),
								value = func(pair[0] + 'e' + (+pair[1] + precision));

							pair = (toString(value) + 'e').split('e');
							return +(pair[0] + 'e' + (+pair[1] - precision));
						}
						return func(number);
					};
				}

				/**
				 * Creates a set object of `values`.
				 *
				 * @private
				 * @param {Array} values The values to add to the set.
				 * @returns {Object} Returns the new set.
				 */
				var createSet = !(Set && (1 / setToArray(new Set([, -0]))[1]) == INFINITY) ? noop : function (values) {
					return new Set(values);
				};

				/**
				 * Creates a `_.toPairs` or `_.toPairsIn` function.
				 *
				 * @private
				 * @param {Function} keysFunc The function to get the keys of a given object.
				 * @returns {Function} Returns the new pairs function.
				 */
				function createToPairs(keysFunc) {
					return function (object) {
						var tag = getTag(object);
						if (tag == mapTag) {
							return mapToArray(object);
						}
						if (tag == setTag) {
							return setToPairs(object);
						}
						return baseToPairs(object, keysFunc(object));
					};
				}

				/**
				 * Creates a function that either curries or invokes `func` with optional
				 * `this` binding and partially applied arguments.
				 *
				 * @private
				 * @param {Function|string} func The function or method name to wrap.
				 * @param {number} bitmask The bitmask flags.
				 *    1 - `_.bind`
				 *    2 - `_.bindKey`
				 *    4 - `_.curry` or `_.curryRight` of a bound function
				 *    8 - `_.curry`
				 *   16 - `_.curryRight`
				 *   32 - `_.partial`
				 *   64 - `_.partialRight`
				 *  128 - `_.rearg`
				 *  256 - `_.ary`
				 *  512 - `_.flip`
				 * @param {*} [thisArg] The `this` binding of `func`.
				 * @param {Array} [partials] The arguments to be partially applied.
				 * @param {Array} [holders] The `partials` placeholder indexes.
				 * @param {Array} [argPos] The argument positions of the new function.
				 * @param {number} [ary] The arity cap of `func`.
				 * @param {number} [arity] The arity of `func`.
				 * @returns {Function} Returns the new wrapped function.
				 */
				function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
					var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
					if (!isBindKey && typeof func != 'function') {
						throw new TypeError(FUNC_ERROR_TEXT);
					}
					var length = partials ? partials.length : 0;
					if (!length) {
						bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
						partials = holders = undefined$1;
					}
					ary = ary === undefined$1 ? ary : nativeMax(toInteger(ary), 0);
					arity = arity === undefined$1 ? arity : toInteger(arity);
					length -= holders ? holders.length : 0;

					if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
						var partialsRight = partials,
							holdersRight = holders;

						partials = holders = undefined$1;
					}
					var data = isBindKey ? undefined$1 : getData(func);

					var newData = [
						func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
						argPos, ary, arity
					];

					if (data) {
						mergeData(newData, data);
					}
					func = newData[0];
					bitmask = newData[1];
					thisArg = newData[2];
					partials = newData[3];
					holders = newData[4];
					arity = newData[9] = newData[9] === undefined$1
						? (isBindKey ? 0 : func.length)
						: nativeMax(newData[9] - length, 0);

					if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
						bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
					}
					if (!bitmask || bitmask == WRAP_BIND_FLAG) {
						var result = createBind(func, bitmask, thisArg);
					} else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
						result = createCurry(func, bitmask, arity);
					} else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
						result = createPartial(func, bitmask, thisArg, partials);
					} else {
						result = createHybrid.apply(undefined$1, newData);
					}
					var setter = data ? baseSetData : setData;
					return setWrapToString(setter(result, newData), func, bitmask);
				}

				/**
				 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
				 * of source objects to the destination object for all destination properties
				 * that resolve to `undefined`.
				 *
				 * @private
				 * @param {*} objValue The destination value.
				 * @param {*} srcValue The source value.
				 * @param {string} key The key of the property to assign.
				 * @param {Object} object The parent object of `objValue`.
				 * @returns {*} Returns the value to assign.
				 */
				function customDefaultsAssignIn(objValue, srcValue, key, object) {
					if (objValue === undefined$1 ||
						(eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
						return srcValue;
					}
					return objValue;
				}

				/**
				 * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
				 * objects into destination objects that are passed thru.
				 *
				 * @private
				 * @param {*} objValue The destination value.
				 * @param {*} srcValue The source value.
				 * @param {string} key The key of the property to merge.
				 * @param {Object} object The parent object of `objValue`.
				 * @param {Object} source The parent object of `srcValue`.
				 * @param {Object} [stack] Tracks traversed source values and their merged
				 *  counterparts.
				 * @returns {*} Returns the value to assign.
				 */
				function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
					if (isObject(objValue) && isObject(srcValue)) {
						// Recursively merge objects and arrays (susceptible to call stack limits).
						stack.set(srcValue, objValue);
						baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
						stack['delete'](srcValue);
					}
					return objValue;
				}

				/**
				 * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
				 * objects.
				 *
				 * @private
				 * @param {*} value The value to inspect.
				 * @param {string} key The key of the property to inspect.
				 * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
				 */
				function customOmitClone(value) {
					return isPlainObject(value) ? undefined$1 : value;
				}

				/**
				 * A specialized version of `baseIsEqualDeep` for arrays with support for
				 * partial deep comparisons.
				 *
				 * @private
				 * @param {Array} array The array to compare.
				 * @param {Array} other The other array to compare.
				 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
				 * @param {Function} customizer The function to customize comparisons.
				 * @param {Function} equalFunc The function to determine equivalents of values.
				 * @param {Object} stack Tracks traversed `array` and `other` objects.
				 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
				 */
				function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
					var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
						arrLength = array.length,
						othLength = other.length;

					if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
						return false;
					}
					// Check that cyclic values are equal.
					var arrStacked = stack.get(array);
					var othStacked = stack.get(other);
					if (arrStacked && othStacked) {
						return arrStacked == other && othStacked == array;
					}
					var index = -1,
						result = true,
						seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined$1;

					stack.set(array, other);
					stack.set(other, array);

					// Ignore non-index properties.
					while (++index < arrLength) {
						var arrValue = array[index],
							othValue = other[index];

						if (customizer) {
							var compared = isPartial
								? customizer(othValue, arrValue, index, other, array, stack)
								: customizer(arrValue, othValue, index, array, other, stack);
						}
						if (compared !== undefined$1) {
							if (compared) {
								continue;
							}
							result = false;
							break;
						}
						// Recursively compare arrays (susceptible to call stack limits).
						if (seen) {
							if (!arraySome(other, function (othValue, othIndex) {
								if (!cacheHas(seen, othIndex) &&
									(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
									return seen.push(othIndex);
								}
							})) {
								result = false;
								break;
							}
						} else if (!(
							arrValue === othValue ||
							equalFunc(arrValue, othValue, bitmask, customizer, stack)
						)) {
							result = false;
							break;
						}
					}
					stack['delete'](array);
					stack['delete'](other);
					return result;
				}

				/**
				 * A specialized version of `baseIsEqualDeep` for comparing objects of
				 * the same `toStringTag`.
				 *
				 * **Note:** This function only supports comparing values with tags of
				 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
				 *
				 * @private
				 * @param {Object} object The object to compare.
				 * @param {Object} other The other object to compare.
				 * @param {string} tag The `toStringTag` of the objects to compare.
				 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
				 * @param {Function} customizer The function to customize comparisons.
				 * @param {Function} equalFunc The function to determine equivalents of values.
				 * @param {Object} stack Tracks traversed `object` and `other` objects.
				 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
				 */
				function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
					switch (tag) {
						case dataViewTag:
							if ((object.byteLength != other.byteLength) ||
								(object.byteOffset != other.byteOffset)) {
								return false;
							}
							object = object.buffer;
							other = other.buffer;

						case arrayBufferTag:
							if ((object.byteLength != other.byteLength) ||
								!equalFunc(new Uint8Array(object), new Uint8Array(other))) {
								return false;
							}
							return true;

						case boolTag:
						case dateTag:
						case numberTag:
							// Coerce booleans to `1` or `0` and dates to milliseconds.
							// Invalid dates are coerced to `NaN`.
							return eq(+object, +other);

						case errorTag:
							return object.name == other.name && object.message == other.message;

						case regexpTag:
						case stringTag:
							// Coerce regexes to strings and treat strings, primitives and objects,
							// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
							// for more details.
							return object == (other + '');

						case mapTag:
							var convert = mapToArray;

						case setTag:
							var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
							convert || (convert = setToArray);

							if (object.size != other.size && !isPartial) {
								return false;
							}
							// Assume cyclic values are equal.
							var stacked = stack.get(object);
							if (stacked) {
								return stacked == other;
							}
							bitmask |= COMPARE_UNORDERED_FLAG;

							// Recursively compare objects (susceptible to call stack limits).
							stack.set(object, other);
							var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
							stack['delete'](object);
							return result;

						case symbolTag:
							if (symbolValueOf) {
								return symbolValueOf.call(object) == symbolValueOf.call(other);
							}
					}
					return false;
				}

				/**
				 * A specialized version of `baseIsEqualDeep` for objects with support for
				 * partial deep comparisons.
				 *
				 * @private
				 * @param {Object} object The object to compare.
				 * @param {Object} other The other object to compare.
				 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
				 * @param {Function} customizer The function to customize comparisons.
				 * @param {Function} equalFunc The function to determine equivalents of values.
				 * @param {Object} stack Tracks traversed `object` and `other` objects.
				 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
				 */
				function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
					var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
						objProps = getAllKeys(object),
						objLength = objProps.length,
						othProps = getAllKeys(other),
						othLength = othProps.length;

					if (objLength != othLength && !isPartial) {
						return false;
					}
					var index = objLength;
					while (index--) {
						var key = objProps[index];
						if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
							return false;
						}
					}
					// Check that cyclic values are equal.
					var objStacked = stack.get(object);
					var othStacked = stack.get(other);
					if (objStacked && othStacked) {
						return objStacked == other && othStacked == object;
					}
					var result = true;
					stack.set(object, other);
					stack.set(other, object);

					var skipCtor = isPartial;
					while (++index < objLength) {
						key = objProps[index];
						var objValue = object[key],
							othValue = other[key];

						if (customizer) {
							var compared = isPartial
								? customizer(othValue, objValue, key, other, object, stack)
								: customizer(objValue, othValue, key, object, other, stack);
						}
						// Recursively compare objects (susceptible to call stack limits).
						if (!(compared === undefined$1
							? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
							: compared
						)) {
							result = false;
							break;
						}
						skipCtor || (skipCtor = key == 'constructor');
					}
					if (result && !skipCtor) {
						var objCtor = object.constructor,
							othCtor = other.constructor;

						// Non `Object` object instances with different constructors are not equal.
						if (objCtor != othCtor &&
							('constructor' in object && 'constructor' in other) &&
							!(typeof objCtor == 'function' && objCtor instanceof objCtor &&
								typeof othCtor == 'function' && othCtor instanceof othCtor)) {
							result = false;
						}
					}
					stack['delete'](object);
					stack['delete'](other);
					return result;
				}

				/**
				 * A specialized version of `baseRest` which flattens the rest array.
				 *
				 * @private
				 * @param {Function} func The function to apply a rest parameter to.
				 * @returns {Function} Returns the new function.
				 */
				function flatRest(func) {
					return setToString(overRest(func, undefined$1, flatten), func + '');
				}

				/**
				 * Creates an array of own enumerable property names and symbols of `object`.
				 *
				 * @private
				 * @param {Object} object The object to query.
				 * @returns {Array} Returns the array of property names and symbols.
				 */
				function getAllKeys(object) {
					return baseGetAllKeys(object, keys, getSymbols);
				}

				/**
				 * Creates an array of own and inherited enumerable property names and
				 * symbols of `object`.
				 *
				 * @private
				 * @param {Object} object The object to query.
				 * @returns {Array} Returns the array of property names and symbols.
				 */
				function getAllKeysIn(object) {
					return baseGetAllKeys(object, keysIn, getSymbolsIn);
				}

				/**
				 * Gets metadata for `func`.
				 *
				 * @private
				 * @param {Function} func The function to query.
				 * @returns {*} Returns the metadata for `func`.
				 */
				var getData = !metaMap ? noop : function (func) {
					return metaMap.get(func);
				};

				/**
				 * Gets the name of `func`.
				 *
				 * @private
				 * @param {Function} func The function to query.
				 * @returns {string} Returns the function name.
				 */
				function getFuncName(func) {
					var result = (func.name + ''),
						array = realNames[result],
						length = hasOwnProperty.call(realNames, result) ? array.length : 0;

					while (length--) {
						var data = array[length],
							otherFunc = data.func;
						if (otherFunc == null || otherFunc == func) {
							return data.name;
						}
					}
					return result;
				}

				/**
				 * Gets the argument placeholder value for `func`.
				 *
				 * @private
				 * @param {Function} func The function to inspect.
				 * @returns {*} Returns the placeholder value.
				 */
				function getHolder(func) {
					var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
					return object.placeholder;
				}

				/**
				 * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
				 * this function returns the custom method, otherwise it returns `baseIteratee`.
				 * If arguments are provided, the chosen function is invoked with them and
				 * its result is returned.
				 *
				 * @private
				 * @param {*} [value] The value to convert to an iteratee.
				 * @param {number} [arity] The arity of the created iteratee.
				 * @returns {Function} Returns the chosen function or its result.
				 */
				function getIteratee() {
					var result = lodash.iteratee || iteratee;
					result = result === iteratee ? baseIteratee : result;
					return arguments.length ? result(arguments[0], arguments[1]) : result;
				}

				/**
				 * Gets the data for `map`.
				 *
				 * @private
				 * @param {Object} map The map to query.
				 * @param {string} key The reference key.
				 * @returns {*} Returns the map data.
				 */
				function getMapData(map, key) {
					var data = map.__data__;
					return isKeyable(key)
						? data[typeof key == 'string' ? 'string' : 'hash']
						: data.map;
				}

				/**
				 * Gets the property names, values, and compare flags of `object`.
				 *
				 * @private
				 * @param {Object} object The object to query.
				 * @returns {Array} Returns the match data of `object`.
				 */
				function getMatchData(object) {
					var result = keys(object),
						length = result.length;

					while (length--) {
						var key = result[length],
							value = object[key];

						result[length] = [key, value, isStrictComparable(value)];
					}
					return result;
				}

				/**
				 * Gets the native function at `key` of `object`.
				 *
				 * @private
				 * @param {Object} object The object to query.
				 * @param {string} key The key of the method to get.
				 * @returns {*} Returns the function if it's native, else `undefined`.
				 */
				function getNative(object, key) {
					var value = getValue(object, key);
					return baseIsNative(value) ? value : undefined$1;
				}

				/**
				 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
				 *
				 * @private
				 * @param {*} value The value to query.
				 * @returns {string} Returns the raw `toStringTag`.
				 */
				function getRawTag(value) {
					var isOwn = hasOwnProperty.call(value, symToStringTag),
						tag = value[symToStringTag];

					try {
						value[symToStringTag] = undefined$1;
						var unmasked = true;
					} catch (e) { }

					var result = nativeObjectToString.call(value);
					if (unmasked) {
						if (isOwn) {
							value[symToStringTag] = tag;
						} else {
							delete value[symToStringTag];
						}
					}
					return result;
				}

				/**
				 * Creates an array of the own enumerable symbols of `object`.
				 *
				 * @private
				 * @param {Object} object The object to query.
				 * @returns {Array} Returns the array of symbols.
				 */
				var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
					if (object == null) {
						return [];
					}
					object = Object(object);
					return arrayFilter(nativeGetSymbols(object), function (symbol) {
						return propertyIsEnumerable.call(object, symbol);
					});
				};

				/**
				 * Creates an array of the own and inherited enumerable symbols of `object`.
				 *
				 * @private
				 * @param {Object} object The object to query.
				 * @returns {Array} Returns the array of symbols.
				 */
				var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
					var result = [];
					while (object) {
						arrayPush(result, getSymbols(object));
						object = getPrototype(object);
					}
					return result;
				};

				/**
				 * Gets the `toStringTag` of `value`.
				 *
				 * @private
				 * @param {*} value The value to query.
				 * @returns {string} Returns the `toStringTag`.
				 */
				var getTag = baseGetTag;

				// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
				if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
					(Map && getTag(new Map) != mapTag) ||
					(Promise && getTag(Promise.resolve()) != promiseTag) ||
					(Set && getTag(new Set) != setTag) ||
					(WeakMap && getTag(new WeakMap) != weakMapTag)) {
					getTag = function (value) {
						var result = baseGetTag(value),
							Ctor = result == objectTag ? value.constructor : undefined$1,
							ctorString = Ctor ? toSource(Ctor) : '';

						if (ctorString) {
							switch (ctorString) {
								case dataViewCtorString: return dataViewTag;
								case mapCtorString: return mapTag;
								case promiseCtorString: return promiseTag;
								case setCtorString: return setTag;
								case weakMapCtorString: return weakMapTag;
							}
						}
						return result;
					};
				}

				/**
				 * Gets the view, applying any `transforms` to the `start` and `end` positions.
				 *
				 * @private
				 * @param {number} start The start of the view.
				 * @param {number} end The end of the view.
				 * @param {Array} transforms The transformations to apply to the view.
				 * @returns {Object} Returns an object containing the `start` and `end`
				 *  positions of the view.
				 */
				function getView(start, end, transforms) {
					var index = -1,
						length = transforms.length;

					while (++index < length) {
						var data = transforms[index],
							size = data.size;

						switch (data.type) {
							case 'drop': start += size; break;
							case 'dropRight': end -= size; break;
							case 'take': end = nativeMin(end, start + size); break;
							case 'takeRight': start = nativeMax(start, end - size); break;
						}
					}
					return { 'start': start, 'end': end };
				}

				/**
				 * Extracts wrapper details from the `source` body comment.
				 *
				 * @private
				 * @param {string} source The source to inspect.
				 * @returns {Array} Returns the wrapper details.
				 */
				function getWrapDetails(source) {
					var match = source.match(reWrapDetails);
					return match ? match[1].split(reSplitDetails) : [];
				}

				/**
				 * Checks if `path` exists on `object`.
				 *
				 * @private
				 * @param {Object} object The object to query.
				 * @param {Array|string} path The path to check.
				 * @param {Function} hasFunc The function to check properties.
				 * @returns {boolean} Returns `true` if `path` exists, else `false`.
				 */
				function hasPath(object, path, hasFunc) {
					path = castPath(path, object);

					var index = -1,
						length = path.length,
						result = false;

					while (++index < length) {
						var key = toKey(path[index]);
						if (!(result = object != null && hasFunc(object, key))) {
							break;
						}
						object = object[key];
					}
					if (result || ++index != length) {
						return result;
					}
					length = object == null ? 0 : object.length;
					return !!length && isLength(length) && isIndex(key, length) &&
						(isArray(object) || isArguments(object));
				}

				/**
				 * Initializes an array clone.
				 *
				 * @private
				 * @param {Array} array The array to clone.
				 * @returns {Array} Returns the initialized clone.
				 */
				function initCloneArray(array) {
					var length = array.length,
						result = new array.constructor(length);

					// Add properties assigned by `RegExp#exec`.
					if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
						result.index = array.index;
						result.input = array.input;
					}
					return result;
				}

				/**
				 * Initializes an object clone.
				 *
				 * @private
				 * @param {Object} object The object to clone.
				 * @returns {Object} Returns the initialized clone.
				 */
				function initCloneObject(object) {
					return (typeof object.constructor == 'function' && !isPrototype(object))
						? baseCreate(getPrototype(object))
						: {};
				}

				/**
				 * Initializes an object clone based on its `toStringTag`.
				 *
				 * **Note:** This function only supports cloning values with tags of
				 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
				 *
				 * @private
				 * @param {Object} object The object to clone.
				 * @param {string} tag The `toStringTag` of the object to clone.
				 * @param {boolean} [isDeep] Specify a deep clone.
				 * @returns {Object} Returns the initialized clone.
				 */
				function initCloneByTag(object, tag, isDeep) {
					var Ctor = object.constructor;
					switch (tag) {
						case arrayBufferTag:
							return cloneArrayBuffer(object);

						case boolTag:
						case dateTag:
							return new Ctor(+object);

						case dataViewTag:
							return cloneDataView(object, isDeep);

						case float32Tag: case float64Tag:
						case int8Tag: case int16Tag: case int32Tag:
						case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
							return cloneTypedArray(object, isDeep);

						case mapTag:
							return new Ctor;

						case numberTag:
						case stringTag:
							return new Ctor(object);

						case regexpTag:
							return cloneRegExp(object);

						case setTag:
							return new Ctor;

						case symbolTag:
							return cloneSymbol(object);
					}
				}

				/**
				 * Inserts wrapper `details` in a comment at the top of the `source` body.
				 *
				 * @private
				 * @param {string} source The source to modify.
				 * @returns {Array} details The details to insert.
				 * @returns {string} Returns the modified source.
				 */
				function insertWrapDetails(source, details) {
					var length = details.length;
					if (!length) {
						return source;
					}
					var lastIndex = length - 1;
					details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
					details = details.join(length > 2 ? ', ' : ' ');
					return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
				}

				/**
				 * Checks if `value` is a flattenable `arguments` object or array.
				 *
				 * @private
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
				 */
				function isFlattenable(value) {
					return isArray(value) || isArguments(value) ||
						!!(spreadableSymbol && value && value[spreadableSymbol]);
				}

				/**
				 * Checks if `value` is a valid array-like index.
				 *
				 * @private
				 * @param {*} value The value to check.
				 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
				 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
				 */
				function isIndex(value, length) {
					var type = typeof value;
					length = length == null ? MAX_SAFE_INTEGER : length;

					return !!length &&
						(type == 'number' ||
							(type != 'symbol' && reIsUint.test(value))) &&
						(value > -1 && value % 1 == 0 && value < length);
				}

				/**
				 * Checks if the given arguments are from an iteratee call.
				 *
				 * @private
				 * @param {*} value The potential iteratee value argument.
				 * @param {*} index The potential iteratee index or key argument.
				 * @param {*} object The potential iteratee object argument.
				 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
				 *  else `false`.
				 */
				function isIterateeCall(value, index, object) {
					if (!isObject(object)) {
						return false;
					}
					var type = typeof index;
					if (type == 'number'
						? (isArrayLike(object) && isIndex(index, object.length))
						: (type == 'string' && index in object)
					) {
						return eq(object[index], value);
					}
					return false;
				}

				/**
				 * Checks if `value` is a property name and not a property path.
				 *
				 * @private
				 * @param {*} value The value to check.
				 * @param {Object} [object] The object to query keys on.
				 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
				 */
				function isKey(value, object) {
					if (isArray(value)) {
						return false;
					}
					var type = typeof value;
					if (type == 'number' || type == 'symbol' || type == 'boolean' ||
						value == null || isSymbol(value)) {
						return true;
					}
					return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
						(object != null && value in Object(object));
				}

				/**
				 * Checks if `value` is suitable for use as unique object key.
				 *
				 * @private
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
				 */
				function isKeyable(value) {
					var type = typeof value;
					return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
						? (value !== '__proto__')
						: (value === null);
				}

				/**
				 * Checks if `func` has a lazy counterpart.
				 *
				 * @private
				 * @param {Function} func The function to check.
				 * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
				 *  else `false`.
				 */
				function isLaziable(func) {
					var funcName = getFuncName(func),
						other = lodash[funcName];

					if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
						return false;
					}
					if (func === other) {
						return true;
					}
					var data = getData(other);
					return !!data && func === data[0];
				}

				/**
				 * Checks if `func` has its source masked.
				 *
				 * @private
				 * @param {Function} func The function to check.
				 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
				 */
				function isMasked(func) {
					return !!maskSrcKey && (maskSrcKey in func);
				}

				/**
				 * Checks if `func` is capable of being masked.
				 *
				 * @private
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
				 */
				var isMaskable = coreJsData ? isFunction : stubFalse;

				/**
				 * Checks if `value` is likely a prototype object.
				 *
				 * @private
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
				 */
				function isPrototype(value) {
					var Ctor = value && value.constructor,
						proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

					return value === proto;
				}

				/**
				 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
				 *
				 * @private
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` if suitable for strict
				 *  equality comparisons, else `false`.
				 */
				function isStrictComparable(value) {
					return value === value && !isObject(value);
				}

				/**
				 * A specialized version of `matchesProperty` for source values suitable
				 * for strict equality comparisons, i.e. `===`.
				 *
				 * @private
				 * @param {string} key The key of the property to get.
				 * @param {*} srcValue The value to match.
				 * @returns {Function} Returns the new spec function.
				 */
				function matchesStrictComparable(key, srcValue) {
					return function (object) {
						if (object == null) {
							return false;
						}
						return object[key] === srcValue &&
							(srcValue !== undefined$1 || (key in Object(object)));
					};
				}

				/**
				 * A specialized version of `_.memoize` which clears the memoized function's
				 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
				 *
				 * @private
				 * @param {Function} func The function to have its output memoized.
				 * @returns {Function} Returns the new memoized function.
				 */
				function memoizeCapped(func) {
					var result = memoize(func, function (key) {
						if (cache.size === MAX_MEMOIZE_SIZE) {
							cache.clear();
						}
						return key;
					});

					var cache = result.cache;
					return result;
				}

				/**
				 * Merges the function metadata of `source` into `data`.
				 *
				 * Merging metadata reduces the number of wrappers used to invoke a function.
				 * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
				 * may be applied regardless of execution order. Methods like `_.ary` and
				 * `_.rearg` modify function arguments, making the order in which they are
				 * executed important, preventing the merging of metadata. However, we make
				 * an exception for a safe combined case where curried functions have `_.ary`
				 * and or `_.rearg` applied.
				 *
				 * @private
				 * @param {Array} data The destination metadata.
				 * @param {Array} source The source metadata.
				 * @returns {Array} Returns `data`.
				 */
				function mergeData(data, source) {
					var bitmask = data[1],
						srcBitmask = source[1],
						newBitmask = bitmask | srcBitmask,
						isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

					var isCombo =
						((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
						((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
						((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

					// Exit early if metadata can't be merged.
					if (!(isCommon || isCombo)) {
						return data;
					}
					// Use source `thisArg` if available.
					if (srcBitmask & WRAP_BIND_FLAG) {
						data[2] = source[2];
						// Set when currying a bound function.
						newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
					}
					// Compose partial arguments.
					var value = source[3];
					if (value) {
						var partials = data[3];
						data[3] = partials ? composeArgs(partials, value, source[4]) : value;
						data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
					}
					// Compose partial right arguments.
					value = source[5];
					if (value) {
						partials = data[5];
						data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
						data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
					}
					// Use source `argPos` if available.
					value = source[7];
					if (value) {
						data[7] = value;
					}
					// Use source `ary` if it's smaller.
					if (srcBitmask & WRAP_ARY_FLAG) {
						data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
					}
					// Use source `arity` if one is not provided.
					if (data[9] == null) {
						data[9] = source[9];
					}
					// Use source `func` and merge bitmasks.
					data[0] = source[0];
					data[1] = newBitmask;

					return data;
				}

				/**
				 * This function is like
				 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
				 * except that it includes inherited enumerable properties.
				 *
				 * @private
				 * @param {Object} object The object to query.
				 * @returns {Array} Returns the array of property names.
				 */
				function nativeKeysIn(object) {
					var result = [];
					if (object != null) {
						for (var key in Object(object)) {
							result.push(key);
						}
					}
					return result;
				}

				/**
				 * Converts `value` to a string using `Object.prototype.toString`.
				 *
				 * @private
				 * @param {*} value The value to convert.
				 * @returns {string} Returns the converted string.
				 */
				function objectToString(value) {
					return nativeObjectToString.call(value);
				}

				/**
				 * A specialized version of `baseRest` which transforms the rest array.
				 *
				 * @private
				 * @param {Function} func The function to apply a rest parameter to.
				 * @param {number} [start=func.length-1] The start position of the rest parameter.
				 * @param {Function} transform The rest array transform.
				 * @returns {Function} Returns the new function.
				 */
				function overRest(func, start, transform) {
					start = nativeMax(start === undefined$1 ? (func.length - 1) : start, 0);
					return function () {
						var args = arguments,
							index = -1,
							length = nativeMax(args.length - start, 0),
							array = Array(length);

						while (++index < length) {
							array[index] = args[start + index];
						}
						index = -1;
						var otherArgs = Array(start + 1);
						while (++index < start) {
							otherArgs[index] = args[index];
						}
						otherArgs[start] = transform(array);
						return apply(func, this, otherArgs);
					};
				}

				/**
				 * Gets the parent value at `path` of `object`.
				 *
				 * @private
				 * @param {Object} object The object to query.
				 * @param {Array} path The path to get the parent value of.
				 * @returns {*} Returns the parent value.
				 */
				function parent(object, path) {
					return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
				}

				/**
				 * Reorder `array` according to the specified indexes where the element at
				 * the first index is assigned as the first element, the element at
				 * the second index is assigned as the second element, and so on.
				 *
				 * @private
				 * @param {Array} array The array to reorder.
				 * @param {Array} indexes The arranged array indexes.
				 * @returns {Array} Returns `array`.
				 */
				function reorder(array, indexes) {
					var arrLength = array.length,
						length = nativeMin(indexes.length, arrLength),
						oldArray = copyArray(array);

					while (length--) {
						var index = indexes[length];
						array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
					}
					return array;
				}

				/**
				 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
				 *
				 * @private
				 * @param {Object} object The object to query.
				 * @param {string} key The key of the property to get.
				 * @returns {*} Returns the property value.
				 */
				function safeGet(object, key) {
					if (key === 'constructor' && typeof object[key] === 'function') {
						return;
					}

					if (key == '__proto__') {
						return;
					}

					return object[key];
				}

				/**
				 * Sets metadata for `func`.
				 *
				 * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
				 * period of time, it will trip its breaker and transition to an identity
				 * function to avoid garbage collection pauses in V8. See
				 * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
				 * for more details.
				 *
				 * @private
				 * @param {Function} func The function to associate metadata with.
				 * @param {*} data The metadata.
				 * @returns {Function} Returns `func`.
				 */
				var setData = shortOut(baseSetData);

				/**
				 * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
				 *
				 * @private
				 * @param {Function} func The function to delay.
				 * @param {number} wait The number of milliseconds to delay invocation.
				 * @returns {number|Object} Returns the timer id or timeout object.
				 */
				var setTimeout = ctxSetTimeout || function (func, wait) {
					return root.setTimeout(func, wait);
				};

				/**
				 * Sets the `toString` method of `func` to return `string`.
				 *
				 * @private
				 * @param {Function} func The function to modify.
				 * @param {Function} string The `toString` result.
				 * @returns {Function} Returns `func`.
				 */
				var setToString = shortOut(baseSetToString);

				/**
				 * Sets the `toString` method of `wrapper` to mimic the source of `reference`
				 * with wrapper details in a comment at the top of the source body.
				 *
				 * @private
				 * @param {Function} wrapper The function to modify.
				 * @param {Function} reference The reference function.
				 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
				 * @returns {Function} Returns `wrapper`.
				 */
				function setWrapToString(wrapper, reference, bitmask) {
					var source = (reference + '');
					return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
				}

				/**
				 * Creates a function that'll short out and invoke `identity` instead
				 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
				 * milliseconds.
				 *
				 * @private
				 * @param {Function} func The function to restrict.
				 * @returns {Function} Returns the new shortable function.
				 */
				function shortOut(func) {
					var count = 0,
						lastCalled = 0;

					return function () {
						var stamp = nativeNow(),
							remaining = HOT_SPAN - (stamp - lastCalled);

						lastCalled = stamp;
						if (remaining > 0) {
							if (++count >= HOT_COUNT) {
								return arguments[0];
							}
						} else {
							count = 0;
						}
						return func.apply(undefined$1, arguments);
					};
				}

				/**
				 * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
				 *
				 * @private
				 * @param {Array} array The array to shuffle.
				 * @param {number} [size=array.length] The size of `array`.
				 * @returns {Array} Returns `array`.
				 */
				function shuffleSelf(array, size) {
					var index = -1,
						length = array.length,
						lastIndex = length - 1;

					size = size === undefined$1 ? length : size;
					while (++index < size) {
						var rand = baseRandom(index, lastIndex),
							value = array[rand];

						array[rand] = array[index];
						array[index] = value;
					}
					array.length = size;
					return array;
				}

				/**
				 * Converts `string` to a property path array.
				 *
				 * @private
				 * @param {string} string The string to convert.
				 * @returns {Array} Returns the property path array.
				 */
				var stringToPath = memoizeCapped(function (string) {
					var result = [];
					if (string.charCodeAt(0) === 46 /* . */) {
						result.push('');
					}
					string.replace(rePropName, function (match, number, quote, subString) {
						result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
					});
					return result;
				});

				/**
				 * Converts `value` to a string key if it's not a string or symbol.
				 *
				 * @private
				 * @param {*} value The value to inspect.
				 * @returns {string|symbol} Returns the key.
				 */
				function toKey(value) {
					if (typeof value == 'string' || isSymbol(value)) {
						return value;
					}
					var result = (value + '');
					return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
				}

				/**
				 * Converts `func` to its source code.
				 *
				 * @private
				 * @param {Function} func The function to convert.
				 * @returns {string} Returns the source code.
				 */
				function toSource(func) {
					if (func != null) {
						try {
							return funcToString.call(func);
						} catch (e) { }
						try {
							return (func + '');
						} catch (e) { }
					}
					return '';
				}

				/**
				 * Updates wrapper `details` based on `bitmask` flags.
				 *
				 * @private
				 * @returns {Array} details The details to modify.
				 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
				 * @returns {Array} Returns `details`.
				 */
				function updateWrapDetails(details, bitmask) {
					arrayEach(wrapFlags, function (pair) {
						var value = '_.' + pair[0];
						if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
							details.push(value);
						}
					});
					return details.sort();
				}

				/**
				 * Creates a clone of `wrapper`.
				 *
				 * @private
				 * @param {Object} wrapper The wrapper to clone.
				 * @returns {Object} Returns the cloned wrapper.
				 */
				function wrapperClone(wrapper) {
					if (wrapper instanceof LazyWrapper) {
						return wrapper.clone();
					}
					var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
					result.__actions__ = copyArray(wrapper.__actions__);
					result.__index__ = wrapper.__index__;
					result.__values__ = wrapper.__values__;
					return result;
				}

				/*------------------------------------------------------------------------*/

				/**
				 * Creates an array of elements split into groups the length of `size`.
				 * If `array` can't be split evenly, the final chunk will be the remaining
				 * elements.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Array
				 * @param {Array} array The array to process.
				 * @param {number} [size=1] The length of each chunk
				 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
				 * @returns {Array} Returns the new array of chunks.
				 * @example
				 *
				 * _.chunk(['a', 'b', 'c', 'd'], 2);
				 * // => [['a', 'b'], ['c', 'd']]
				 *
				 * _.chunk(['a', 'b', 'c', 'd'], 3);
				 * // => [['a', 'b', 'c'], ['d']]
				 */
				function chunk(array, size, guard) {
					if ((guard ? isIterateeCall(array, size, guard) : size === undefined$1)) {
						size = 1;
					} else {
						size = nativeMax(toInteger(size), 0);
					}
					var length = array == null ? 0 : array.length;
					if (!length || size < 1) {
						return [];
					}
					var index = 0,
						resIndex = 0,
						result = Array(nativeCeil(length / size));

					while (index < length) {
						result[resIndex++] = baseSlice(array, index, (index += size));
					}
					return result;
				}

				/**
				 * Creates an array with all falsey values removed. The values `false`, `null`,
				 * `0`, `""`, `undefined`, and `NaN` are falsey.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Array
				 * @param {Array} array The array to compact.
				 * @returns {Array} Returns the new array of filtered values.
				 * @example
				 *
				 * _.compact([0, 1, false, 2, '', 3]);
				 * // => [1, 2, 3]
				 */
				function compact(array) {
					var index = -1,
						length = array == null ? 0 : array.length,
						resIndex = 0,
						result = [];

					while (++index < length) {
						var value = array[index];
						if (value) {
							result[resIndex++] = value;
						}
					}
					return result;
				}

				/**
				 * Creates a new array concatenating `array` with any additional arrays
				 * and/or values.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Array
				 * @param {Array} array The array to concatenate.
				 * @param {...*} [values] The values to concatenate.
				 * @returns {Array} Returns the new concatenated array.
				 * @example
				 *
				 * var array = [1];
				 * var other = _.concat(array, 2, [3], [[4]]);
				 *
				 * console.log(other);
				 * // => [1, 2, 3, [4]]
				 *
				 * console.log(array);
				 * // => [1]
				 */
				function concat() {
					var length = arguments.length;
					if (!length) {
						return [];
					}
					var args = Array(length - 1),
						array = arguments[0],
						index = length;

					while (index--) {
						args[index - 1] = arguments[index];
					}
					return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
				}

				/**
				 * Creates an array of `array` values not included in the other given arrays
				 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
				 * for equality comparisons. The order and references of result values are
				 * determined by the first array.
				 *
				 * **Note:** Unlike `_.pullAll`, this method returns a new array.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Array
				 * @param {Array} array The array to inspect.
				 * @param {...Array} [values] The values to exclude.
				 * @returns {Array} Returns the new array of filtered values.
				 * @see _.without, _.xor
				 * @example
				 *
				 * _.difference([2, 1], [2, 3]);
				 * // => [1]
				 */
				var difference = baseRest(function (array, values) {
					return isArrayLikeObject(array)
						? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
						: [];
				});

				/**
				 * This method is like `_.difference` except that it accepts `iteratee` which
				 * is invoked for each element of `array` and `values` to generate the criterion
				 * by which they're compared. The order and references of result values are
				 * determined by the first array. The iteratee is invoked with one argument:
				 * (value).
				 *
				 * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Array
				 * @param {Array} array The array to inspect.
				 * @param {...Array} [values] The values to exclude.
				 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
				 * @returns {Array} Returns the new array of filtered values.
				 * @example
				 *
				 * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
				 * // => [1.2]
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
				 * // => [{ 'x': 2 }]
				 */
				var differenceBy = baseRest(function (array, values) {
					var iteratee = last(values);
					if (isArrayLikeObject(iteratee)) {
						iteratee = undefined$1;
					}
					return isArrayLikeObject(array)
						? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
						: [];
				});

				/**
				 * This method is like `_.difference` except that it accepts `comparator`
				 * which is invoked to compare elements of `array` to `values`. The order and
				 * references of result values are determined by the first array. The comparator
				 * is invoked with two arguments: (arrVal, othVal).
				 *
				 * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Array
				 * @param {Array} array The array to inspect.
				 * @param {...Array} [values] The values to exclude.
				 * @param {Function} [comparator] The comparator invoked per element.
				 * @returns {Array} Returns the new array of filtered values.
				 * @example
				 *
				 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
				 *
				 * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
				 * // => [{ 'x': 2, 'y': 1 }]
				 */
				var differenceWith = baseRest(function (array, values) {
					var comparator = last(values);
					if (isArrayLikeObject(comparator)) {
						comparator = undefined$1;
					}
					return isArrayLikeObject(array)
						? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined$1, comparator)
						: [];
				});

				/**
				 * Creates a slice of `array` with `n` elements dropped from the beginning.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.5.0
				 * @category Array
				 * @param {Array} array The array to query.
				 * @param {number} [n=1] The number of elements to drop.
				 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
				 * @returns {Array} Returns the slice of `array`.
				 * @example
				 *
				 * _.drop([1, 2, 3]);
				 * // => [2, 3]
				 *
				 * _.drop([1, 2, 3], 2);
				 * // => [3]
				 *
				 * _.drop([1, 2, 3], 5);
				 * // => []
				 *
				 * _.drop([1, 2, 3], 0);
				 * // => [1, 2, 3]
				 */
				function drop(array, n, guard) {
					var length = array == null ? 0 : array.length;
					if (!length) {
						return [];
					}
					n = (guard || n === undefined$1) ? 1 : toInteger(n);
					return baseSlice(array, n < 0 ? 0 : n, length);
				}

				/**
				 * Creates a slice of `array` with `n` elements dropped from the end.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Array
				 * @param {Array} array The array to query.
				 * @param {number} [n=1] The number of elements to drop.
				 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
				 * @returns {Array} Returns the slice of `array`.
				 * @example
				 *
				 * _.dropRight([1, 2, 3]);
				 * // => [1, 2]
				 *
				 * _.dropRight([1, 2, 3], 2);
				 * // => [1]
				 *
				 * _.dropRight([1, 2, 3], 5);
				 * // => []
				 *
				 * _.dropRight([1, 2, 3], 0);
				 * // => [1, 2, 3]
				 */
				function dropRight(array, n, guard) {
					var length = array == null ? 0 : array.length;
					if (!length) {
						return [];
					}
					n = (guard || n === undefined$1) ? 1 : toInteger(n);
					n = length - n;
					return baseSlice(array, 0, n < 0 ? 0 : n);
				}

				/**
				 * Creates a slice of `array` excluding elements dropped from the end.
				 * Elements are dropped until `predicate` returns falsey. The predicate is
				 * invoked with three arguments: (value, index, array).
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Array
				 * @param {Array} array The array to query.
				 * @param {Function} [predicate=_.identity] The function invoked per iteration.
				 * @returns {Array} Returns the slice of `array`.
				 * @example
				 *
				 * var users = [
				 *   { 'user': 'barney',  'active': true },
				 *   { 'user': 'fred',    'active': false },
				 *   { 'user': 'pebbles', 'active': false }
				 * ];
				 *
				 * _.dropRightWhile(users, function(o) { return !o.active; });
				 * // => objects for ['barney']
				 *
				 * // The `_.matches` iteratee shorthand.
				 * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
				 * // => objects for ['barney', 'fred']
				 *
				 * // The `_.matchesProperty` iteratee shorthand.
				 * _.dropRightWhile(users, ['active', false]);
				 * // => objects for ['barney']
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.dropRightWhile(users, 'active');
				 * // => objects for ['barney', 'fred', 'pebbles']
				 */
				function dropRightWhile(array, predicate) {
					return (array && array.length)
						? baseWhile(array, getIteratee(predicate, 3), true, true)
						: [];
				}

				/**
				 * Creates a slice of `array` excluding elements dropped from the beginning.
				 * Elements are dropped until `predicate` returns falsey. The predicate is
				 * invoked with three arguments: (value, index, array).
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Array
				 * @param {Array} array The array to query.
				 * @param {Function} [predicate=_.identity] The function invoked per iteration.
				 * @returns {Array} Returns the slice of `array`.
				 * @example
				 *
				 * var users = [
				 *   { 'user': 'barney',  'active': false },
				 *   { 'user': 'fred',    'active': false },
				 *   { 'user': 'pebbles', 'active': true }
				 * ];
				 *
				 * _.dropWhile(users, function(o) { return !o.active; });
				 * // => objects for ['pebbles']
				 *
				 * // The `_.matches` iteratee shorthand.
				 * _.dropWhile(users, { 'user': 'barney', 'active': false });
				 * // => objects for ['fred', 'pebbles']
				 *
				 * // The `_.matchesProperty` iteratee shorthand.
				 * _.dropWhile(users, ['active', false]);
				 * // => objects for ['pebbles']
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.dropWhile(users, 'active');
				 * // => objects for ['barney', 'fred', 'pebbles']
				 */
				function dropWhile(array, predicate) {
					return (array && array.length)
						? baseWhile(array, getIteratee(predicate, 3), true)
						: [];
				}

				/**
				 * Fills elements of `array` with `value` from `start` up to, but not
				 * including, `end`.
				 *
				 * **Note:** This method mutates `array`.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.2.0
				 * @category Array
				 * @param {Array} array The array to fill.
				 * @param {*} value The value to fill `array` with.
				 * @param {number} [start=0] The start position.
				 * @param {number} [end=array.length] The end position.
				 * @returns {Array} Returns `array`.
				 * @example
				 *
				 * var array = [1, 2, 3];
				 *
				 * _.fill(array, 'a');
				 * console.log(array);
				 * // => ['a', 'a', 'a']
				 *
				 * _.fill(Array(3), 2);
				 * // => [2, 2, 2]
				 *
				 * _.fill([4, 6, 8, 10], '*', 1, 3);
				 * // => [4, '*', '*', 10]
				 */
				function fill(array, value, start, end) {
					var length = array == null ? 0 : array.length;
					if (!length) {
						return [];
					}
					if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
						start = 0;
						end = length;
					}
					return baseFill(array, value, start, end);
				}

				/**
				 * This method is like `_.find` except that it returns the index of the first
				 * element `predicate` returns truthy for instead of the element itself.
				 *
				 * @static
				 * @memberOf _
				 * @since 1.1.0
				 * @category Array
				 * @param {Array} array The array to inspect.
				 * @param {Function} [predicate=_.identity] The function invoked per iteration.
				 * @param {number} [fromIndex=0] The index to search from.
				 * @returns {number} Returns the index of the found element, else `-1`.
				 * @example
				 *
				 * var users = [
				 *   { 'user': 'barney',  'active': false },
				 *   { 'user': 'fred',    'active': false },
				 *   { 'user': 'pebbles', 'active': true }
				 * ];
				 *
				 * _.findIndex(users, function(o) { return o.user == 'barney'; });
				 * // => 0
				 *
				 * // The `_.matches` iteratee shorthand.
				 * _.findIndex(users, { 'user': 'fred', 'active': false });
				 * // => 1
				 *
				 * // The `_.matchesProperty` iteratee shorthand.
				 * _.findIndex(users, ['active', false]);
				 * // => 0
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.findIndex(users, 'active');
				 * // => 2
				 */
				function findIndex(array, predicate, fromIndex) {
					var length = array == null ? 0 : array.length;
					if (!length) {
						return -1;
					}
					var index = fromIndex == null ? 0 : toInteger(fromIndex);
					if (index < 0) {
						index = nativeMax(length + index, 0);
					}
					return baseFindIndex(array, getIteratee(predicate, 3), index);
				}

				/**
				 * This method is like `_.findIndex` except that it iterates over elements
				 * of `collection` from right to left.
				 *
				 * @static
				 * @memberOf _
				 * @since 2.0.0
				 * @category Array
				 * @param {Array} array The array to inspect.
				 * @param {Function} [predicate=_.identity] The function invoked per iteration.
				 * @param {number} [fromIndex=array.length-1] The index to search from.
				 * @returns {number} Returns the index of the found element, else `-1`.
				 * @example
				 *
				 * var users = [
				 *   { 'user': 'barney',  'active': true },
				 *   { 'user': 'fred',    'active': false },
				 *   { 'user': 'pebbles', 'active': false }
				 * ];
				 *
				 * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
				 * // => 2
				 *
				 * // The `_.matches` iteratee shorthand.
				 * _.findLastIndex(users, { 'user': 'barney', 'active': true });
				 * // => 0
				 *
				 * // The `_.matchesProperty` iteratee shorthand.
				 * _.findLastIndex(users, ['active', false]);
				 * // => 2
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.findLastIndex(users, 'active');
				 * // => 0
				 */
				function findLastIndex(array, predicate, fromIndex) {
					var length = array == null ? 0 : array.length;
					if (!length) {
						return -1;
					}
					var index = length - 1;
					if (fromIndex !== undefined$1) {
						index = toInteger(fromIndex);
						index = fromIndex < 0
							? nativeMax(length + index, 0)
							: nativeMin(index, length - 1);
					}
					return baseFindIndex(array, getIteratee(predicate, 3), index, true);
				}

				/**
				 * Flattens `array` a single level deep.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Array
				 * @param {Array} array The array to flatten.
				 * @returns {Array} Returns the new flattened array.
				 * @example
				 *
				 * _.flatten([1, [2, [3, [4]], 5]]);
				 * // => [1, 2, [3, [4]], 5]
				 */
				function flatten(array) {
					var length = array == null ? 0 : array.length;
					return length ? baseFlatten(array, 1) : [];
				}

				/**
				 * Recursively flattens `array`.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Array
				 * @param {Array} array The array to flatten.
				 * @returns {Array} Returns the new flattened array.
				 * @example
				 *
				 * _.flattenDeep([1, [2, [3, [4]], 5]]);
				 * // => [1, 2, 3, 4, 5]
				 */
				function flattenDeep(array) {
					var length = array == null ? 0 : array.length;
					return length ? baseFlatten(array, INFINITY) : [];
				}

				/**
				 * Recursively flatten `array` up to `depth` times.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.4.0
				 * @category Array
				 * @param {Array} array The array to flatten.
				 * @param {number} [depth=1] The maximum recursion depth.
				 * @returns {Array} Returns the new flattened array.
				 * @example
				 *
				 * var array = [1, [2, [3, [4]], 5]];
				 *
				 * _.flattenDepth(array, 1);
				 * // => [1, 2, [3, [4]], 5]
				 *
				 * _.flattenDepth(array, 2);
				 * // => [1, 2, 3, [4], 5]
				 */
				function flattenDepth(array, depth) {
					var length = array == null ? 0 : array.length;
					if (!length) {
						return [];
					}
					depth = depth === undefined$1 ? 1 : toInteger(depth);
					return baseFlatten(array, depth);
				}

				/**
				 * The inverse of `_.toPairs`; this method returns an object composed
				 * from key-value `pairs`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Array
				 * @param {Array} pairs The key-value pairs.
				 * @returns {Object} Returns the new object.
				 * @example
				 *
				 * _.fromPairs([['a', 1], ['b', 2]]);
				 * // => { 'a': 1, 'b': 2 }
				 */
				function fromPairs(pairs) {
					var index = -1,
						length = pairs == null ? 0 : pairs.length,
						result = {};

					while (++index < length) {
						var pair = pairs[index];
						result[pair[0]] = pair[1];
					}
					return result;
				}

				/**
				 * Gets the first element of `array`.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @alias first
				 * @category Array
				 * @param {Array} array The array to query.
				 * @returns {*} Returns the first element of `array`.
				 * @example
				 *
				 * _.head([1, 2, 3]);
				 * // => 1
				 *
				 * _.head([]);
				 * // => undefined
				 */
				function head(array) {
					return (array && array.length) ? array[0] : undefined$1;
				}

				/**
				 * Gets the index at which the first occurrence of `value` is found in `array`
				 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
				 * for equality comparisons. If `fromIndex` is negative, it's used as the
				 * offset from the end of `array`.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Array
				 * @param {Array} array The array to inspect.
				 * @param {*} value The value to search for.
				 * @param {number} [fromIndex=0] The index to search from.
				 * @returns {number} Returns the index of the matched value, else `-1`.
				 * @example
				 *
				 * _.indexOf([1, 2, 1, 2], 2);
				 * // => 1
				 *
				 * // Search from the `fromIndex`.
				 * _.indexOf([1, 2, 1, 2], 2, 2);
				 * // => 3
				 */
				function indexOf(array, value, fromIndex) {
					var length = array == null ? 0 : array.length;
					if (!length) {
						return -1;
					}
					var index = fromIndex == null ? 0 : toInteger(fromIndex);
					if (index < 0) {
						index = nativeMax(length + index, 0);
					}
					return baseIndexOf(array, value, index);
				}

				/**
				 * Gets all but the last element of `array`.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Array
				 * @param {Array} array The array to query.
				 * @returns {Array} Returns the slice of `array`.
				 * @example
				 *
				 * _.initial([1, 2, 3]);
				 * // => [1, 2]
				 */
				function initial(array) {
					var length = array == null ? 0 : array.length;
					return length ? baseSlice(array, 0, -1) : [];
				}

				/**
				 * Creates an array of unique values that are included in all given arrays
				 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
				 * for equality comparisons. The order and references of result values are
				 * determined by the first array.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Array
				 * @param {...Array} [arrays] The arrays to inspect.
				 * @returns {Array} Returns the new array of intersecting values.
				 * @example
				 *
				 * _.intersection([2, 1], [2, 3]);
				 * // => [2]
				 */
				var intersection = baseRest(function (arrays) {
					var mapped = arrayMap(arrays, castArrayLikeObject);
					return (mapped.length && mapped[0] === arrays[0])
						? baseIntersection(mapped)
						: [];
				});

				/**
				 * This method is like `_.intersection` except that it accepts `iteratee`
				 * which is invoked for each element of each `arrays` to generate the criterion
				 * by which they're compared. The order and references of result values are
				 * determined by the first array. The iteratee is invoked with one argument:
				 * (value).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Array
				 * @param {...Array} [arrays] The arrays to inspect.
				 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
				 * @returns {Array} Returns the new array of intersecting values.
				 * @example
				 *
				 * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
				 * // => [2.1]
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
				 * // => [{ 'x': 1 }]
				 */
				var intersectionBy = baseRest(function (arrays) {
					var iteratee = last(arrays),
						mapped = arrayMap(arrays, castArrayLikeObject);

					if (iteratee === last(mapped)) {
						iteratee = undefined$1;
					} else {
						mapped.pop();
					}
					return (mapped.length && mapped[0] === arrays[0])
						? baseIntersection(mapped, getIteratee(iteratee, 2))
						: [];
				});

				/**
				 * This method is like `_.intersection` except that it accepts `comparator`
				 * which is invoked to compare elements of `arrays`. The order and references
				 * of result values are determined by the first array. The comparator is
				 * invoked with two arguments: (arrVal, othVal).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Array
				 * @param {...Array} [arrays] The arrays to inspect.
				 * @param {Function} [comparator] The comparator invoked per element.
				 * @returns {Array} Returns the new array of intersecting values.
				 * @example
				 *
				 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
				 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
				 *
				 * _.intersectionWith(objects, others, _.isEqual);
				 * // => [{ 'x': 1, 'y': 2 }]
				 */
				var intersectionWith = baseRest(function (arrays) {
					var comparator = last(arrays),
						mapped = arrayMap(arrays, castArrayLikeObject);

					comparator = typeof comparator == 'function' ? comparator : undefined$1;
					if (comparator) {
						mapped.pop();
					}
					return (mapped.length && mapped[0] === arrays[0])
						? baseIntersection(mapped, undefined$1, comparator)
						: [];
				});

				/**
				 * Converts all elements in `array` into a string separated by `separator`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Array
				 * @param {Array} array The array to convert.
				 * @param {string} [separator=','] The element separator.
				 * @returns {string} Returns the joined string.
				 * @example
				 *
				 * _.join(['a', 'b', 'c'], '~');
				 * // => 'a~b~c'
				 */
				function join(array, separator) {
					return array == null ? '' : nativeJoin.call(array, separator);
				}

				/**
				 * Gets the last element of `array`.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Array
				 * @param {Array} array The array to query.
				 * @returns {*} Returns the last element of `array`.
				 * @example
				 *
				 * _.last([1, 2, 3]);
				 * // => 3
				 */
				function last(array) {
					var length = array == null ? 0 : array.length;
					return length ? array[length - 1] : undefined$1;
				}

				/**
				 * This method is like `_.indexOf` except that it iterates over elements of
				 * `array` from right to left.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Array
				 * @param {Array} array The array to inspect.
				 * @param {*} value The value to search for.
				 * @param {number} [fromIndex=array.length-1] The index to search from.
				 * @returns {number} Returns the index of the matched value, else `-1`.
				 * @example
				 *
				 * _.lastIndexOf([1, 2, 1, 2], 2);
				 * // => 3
				 *
				 * // Search from the `fromIndex`.
				 * _.lastIndexOf([1, 2, 1, 2], 2, 2);
				 * // => 1
				 */
				function lastIndexOf(array, value, fromIndex) {
					var length = array == null ? 0 : array.length;
					if (!length) {
						return -1;
					}
					var index = length;
					if (fromIndex !== undefined$1) {
						index = toInteger(fromIndex);
						index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
					}
					return value === value
						? strictLastIndexOf(array, value, index)
						: baseFindIndex(array, baseIsNaN, index, true);
				}

				/**
				 * Gets the element at index `n` of `array`. If `n` is negative, the nth
				 * element from the end is returned.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.11.0
				 * @category Array
				 * @param {Array} array The array to query.
				 * @param {number} [n=0] The index of the element to return.
				 * @returns {*} Returns the nth element of `array`.
				 * @example
				 *
				 * var array = ['a', 'b', 'c', 'd'];
				 *
				 * _.nth(array, 1);
				 * // => 'b'
				 *
				 * _.nth(array, -2);
				 * // => 'c';
				 */
				function nth(array, n) {
					return (array && array.length) ? baseNth(array, toInteger(n)) : undefined$1;
				}

				/**
				 * Removes all given values from `array` using
				 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
				 * for equality comparisons.
				 *
				 * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
				 * to remove elements from an array by predicate.
				 *
				 * @static
				 * @memberOf _
				 * @since 2.0.0
				 * @category Array
				 * @param {Array} array The array to modify.
				 * @param {...*} [values] The values to remove.
				 * @returns {Array} Returns `array`.
				 * @example
				 *
				 * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
				 *
				 * _.pull(array, 'a', 'c');
				 * console.log(array);
				 * // => ['b', 'b']
				 */
				var pull = baseRest(pullAll);

				/**
				 * This method is like `_.pull` except that it accepts an array of values to remove.
				 *
				 * **Note:** Unlike `_.difference`, this method mutates `array`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Array
				 * @param {Array} array The array to modify.
				 * @param {Array} values The values to remove.
				 * @returns {Array} Returns `array`.
				 * @example
				 *
				 * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
				 *
				 * _.pullAll(array, ['a', 'c']);
				 * console.log(array);
				 * // => ['b', 'b']
				 */
				function pullAll(array, values) {
					return (array && array.length && values && values.length)
						? basePullAll(array, values)
						: array;
				}

				/**
				 * This method is like `_.pullAll` except that it accepts `iteratee` which is
				 * invoked for each element of `array` and `values` to generate the criterion
				 * by which they're compared. The iteratee is invoked with one argument: (value).
				 *
				 * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Array
				 * @param {Array} array The array to modify.
				 * @param {Array} values The values to remove.
				 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
				 * @returns {Array} Returns `array`.
				 * @example
				 *
				 * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
				 *
				 * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
				 * console.log(array);
				 * // => [{ 'x': 2 }]
				 */
				function pullAllBy(array, values, iteratee) {
					return (array && array.length && values && values.length)
						? basePullAll(array, values, getIteratee(iteratee, 2))
						: array;
				}

				/**
				 * This method is like `_.pullAll` except that it accepts `comparator` which
				 * is invoked to compare elements of `array` to `values`. The comparator is
				 * invoked with two arguments: (arrVal, othVal).
				 *
				 * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.6.0
				 * @category Array
				 * @param {Array} array The array to modify.
				 * @param {Array} values The values to remove.
				 * @param {Function} [comparator] The comparator invoked per element.
				 * @returns {Array} Returns `array`.
				 * @example
				 *
				 * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
				 *
				 * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
				 * console.log(array);
				 * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
				 */
				function pullAllWith(array, values, comparator) {
					return (array && array.length && values && values.length)
						? basePullAll(array, values, undefined$1, comparator)
						: array;
				}

				/**
				 * Removes elements from `array` corresponding to `indexes` and returns an
				 * array of removed elements.
				 *
				 * **Note:** Unlike `_.at`, this method mutates `array`.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Array
				 * @param {Array} array The array to modify.
				 * @param {...(number|number[])} [indexes] The indexes of elements to remove.
				 * @returns {Array} Returns the new array of removed elements.
				 * @example
				 *
				 * var array = ['a', 'b', 'c', 'd'];
				 * var pulled = _.pullAt(array, [1, 3]);
				 *
				 * console.log(array);
				 * // => ['a', 'c']
				 *
				 * console.log(pulled);
				 * // => ['b', 'd']
				 */
				var pullAt = flatRest(function (array, indexes) {
					var length = array == null ? 0 : array.length,
						result = baseAt(array, indexes);

					basePullAt(array, arrayMap(indexes, function (index) {
						return isIndex(index, length) ? +index : index;
					}).sort(compareAscending));

					return result;
				});

				/**
				 * Removes all elements from `array` that `predicate` returns truthy for
				 * and returns an array of the removed elements. The predicate is invoked
				 * with three arguments: (value, index, array).
				 *
				 * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
				 * to pull elements from an array by value.
				 *
				 * @static
				 * @memberOf _
				 * @since 2.0.0
				 * @category Array
				 * @param {Array} array The array to modify.
				 * @param {Function} [predicate=_.identity] The function invoked per iteration.
				 * @returns {Array} Returns the new array of removed elements.
				 * @example
				 *
				 * var array = [1, 2, 3, 4];
				 * var evens = _.remove(array, function(n) {
				 *   return n % 2 == 0;
				 * });
				 *
				 * console.log(array);
				 * // => [1, 3]
				 *
				 * console.log(evens);
				 * // => [2, 4]
				 */
				function remove(array, predicate) {
					var result = [];
					if (!(array && array.length)) {
						return result;
					}
					var index = -1,
						indexes = [],
						length = array.length;

					predicate = getIteratee(predicate, 3);
					while (++index < length) {
						var value = array[index];
						if (predicate(value, index, array)) {
							result.push(value);
							indexes.push(index);
						}
					}
					basePullAt(array, indexes);
					return result;
				}

				/**
				 * Reverses `array` so that the first element becomes the last, the second
				 * element becomes the second to last, and so on.
				 *
				 * **Note:** This method mutates `array` and is based on
				 * [`Array#reverse`](https://mdn.io/Array/reverse).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Array
				 * @param {Array} array The array to modify.
				 * @returns {Array} Returns `array`.
				 * @example
				 *
				 * var array = [1, 2, 3];
				 *
				 * _.reverse(array);
				 * // => [3, 2, 1]
				 *
				 * console.log(array);
				 * // => [3, 2, 1]
				 */
				function reverse(array) {
					return array == null ? array : nativeReverse.call(array);
				}

				/**
				 * Creates a slice of `array` from `start` up to, but not including, `end`.
				 *
				 * **Note:** This method is used instead of
				 * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
				 * returned.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Array
				 * @param {Array} array The array to slice.
				 * @param {number} [start=0] The start position.
				 * @param {number} [end=array.length] The end position.
				 * @returns {Array} Returns the slice of `array`.
				 */
				function slice(array, start, end) {
					var length = array == null ? 0 : array.length;
					if (!length) {
						return [];
					}
					if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
						start = 0;
						end = length;
					}
					else {
						start = start == null ? 0 : toInteger(start);
						end = end === undefined$1 ? length : toInteger(end);
					}
					return baseSlice(array, start, end);
				}

				/**
				 * Uses a binary search to determine the lowest index at which `value`
				 * should be inserted into `array` in order to maintain its sort order.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Array
				 * @param {Array} array The sorted array to inspect.
				 * @param {*} value The value to evaluate.
				 * @returns {number} Returns the index at which `value` should be inserted
				 *  into `array`.
				 * @example
				 *
				 * _.sortedIndex([30, 50], 40);
				 * // => 1
				 */
				function sortedIndex(array, value) {
					return baseSortedIndex(array, value);
				}

				/**
				 * This method is like `_.sortedIndex` except that it accepts `iteratee`
				 * which is invoked for `value` and each element of `array` to compute their
				 * sort ranking. The iteratee is invoked with one argument: (value).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Array
				 * @param {Array} array The sorted array to inspect.
				 * @param {*} value The value to evaluate.
				 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
				 * @returns {number} Returns the index at which `value` should be inserted
				 *  into `array`.
				 * @example
				 *
				 * var objects = [{ 'x': 4 }, { 'x': 5 }];
				 *
				 * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
				 * // => 0
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
				 * // => 0
				 */
				function sortedIndexBy(array, value, iteratee) {
					return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
				}

				/**
				 * This method is like `_.indexOf` except that it performs a binary
				 * search on a sorted `array`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Array
				 * @param {Array} array The array to inspect.
				 * @param {*} value The value to search for.
				 * @returns {number} Returns the index of the matched value, else `-1`.
				 * @example
				 *
				 * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
				 * // => 1
				 */
				function sortedIndexOf(array, value) {
					var length = array == null ? 0 : array.length;
					if (length) {
						var index = baseSortedIndex(array, value);
						if (index < length && eq(array[index], value)) {
							return index;
						}
					}
					return -1;
				}

				/**
				 * This method is like `_.sortedIndex` except that it returns the highest
				 * index at which `value` should be inserted into `array` in order to
				 * maintain its sort order.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Array
				 * @param {Array} array The sorted array to inspect.
				 * @param {*} value The value to evaluate.
				 * @returns {number} Returns the index at which `value` should be inserted
				 *  into `array`.
				 * @example
				 *
				 * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
				 * // => 4
				 */
				function sortedLastIndex(array, value) {
					return baseSortedIndex(array, value, true);
				}

				/**
				 * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
				 * which is invoked for `value` and each element of `array` to compute their
				 * sort ranking. The iteratee is invoked with one argument: (value).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Array
				 * @param {Array} array The sorted array to inspect.
				 * @param {*} value The value to evaluate.
				 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
				 * @returns {number} Returns the index at which `value` should be inserted
				 *  into `array`.
				 * @example
				 *
				 * var objects = [{ 'x': 4 }, { 'x': 5 }];
				 *
				 * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
				 * // => 1
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
				 * // => 1
				 */
				function sortedLastIndexBy(array, value, iteratee) {
					return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
				}

				/**
				 * This method is like `_.lastIndexOf` except that it performs a binary
				 * search on a sorted `array`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Array
				 * @param {Array} array The array to inspect.
				 * @param {*} value The value to search for.
				 * @returns {number} Returns the index of the matched value, else `-1`.
				 * @example
				 *
				 * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
				 * // => 3
				 */
				function sortedLastIndexOf(array, value) {
					var length = array == null ? 0 : array.length;
					if (length) {
						var index = baseSortedIndex(array, value, true) - 1;
						if (eq(array[index], value)) {
							return index;
						}
					}
					return -1;
				}

				/**
				 * This method is like `_.uniq` except that it's designed and optimized
				 * for sorted arrays.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Array
				 * @param {Array} array The array to inspect.
				 * @returns {Array} Returns the new duplicate free array.
				 * @example
				 *
				 * _.sortedUniq([1, 1, 2]);
				 * // => [1, 2]
				 */
				function sortedUniq(array) {
					return (array && array.length)
						? baseSortedUniq(array)
						: [];
				}

				/**
				 * This method is like `_.uniqBy` except that it's designed and optimized
				 * for sorted arrays.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Array
				 * @param {Array} array The array to inspect.
				 * @param {Function} [iteratee] The iteratee invoked per element.
				 * @returns {Array} Returns the new duplicate free array.
				 * @example
				 *
				 * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
				 * // => [1.1, 2.3]
				 */
				function sortedUniqBy(array, iteratee) {
					return (array && array.length)
						? baseSortedUniq(array, getIteratee(iteratee, 2))
						: [];
				}

				/**
				 * Gets all but the first element of `array`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Array
				 * @param {Array} array The array to query.
				 * @returns {Array} Returns the slice of `array`.
				 * @example
				 *
				 * _.tail([1, 2, 3]);
				 * // => [2, 3]
				 */
				function tail(array) {
					var length = array == null ? 0 : array.length;
					return length ? baseSlice(array, 1, length) : [];
				}

				/**
				 * Creates a slice of `array` with `n` elements taken from the beginning.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Array
				 * @param {Array} array The array to query.
				 * @param {number} [n=1] The number of elements to take.
				 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
				 * @returns {Array} Returns the slice of `array`.
				 * @example
				 *
				 * _.take([1, 2, 3]);
				 * // => [1]
				 *
				 * _.take([1, 2, 3], 2);
				 * // => [1, 2]
				 *
				 * _.take([1, 2, 3], 5);
				 * // => [1, 2, 3]
				 *
				 * _.take([1, 2, 3], 0);
				 * // => []
				 */
				function take(array, n, guard) {
					if (!(array && array.length)) {
						return [];
					}
					n = (guard || n === undefined$1) ? 1 : toInteger(n);
					return baseSlice(array, 0, n < 0 ? 0 : n);
				}

				/**
				 * Creates a slice of `array` with `n` elements taken from the end.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Array
				 * @param {Array} array The array to query.
				 * @param {number} [n=1] The number of elements to take.
				 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
				 * @returns {Array} Returns the slice of `array`.
				 * @example
				 *
				 * _.takeRight([1, 2, 3]);
				 * // => [3]
				 *
				 * _.takeRight([1, 2, 3], 2);
				 * // => [2, 3]
				 *
				 * _.takeRight([1, 2, 3], 5);
				 * // => [1, 2, 3]
				 *
				 * _.takeRight([1, 2, 3], 0);
				 * // => []
				 */
				function takeRight(array, n, guard) {
					var length = array == null ? 0 : array.length;
					if (!length) {
						return [];
					}
					n = (guard || n === undefined$1) ? 1 : toInteger(n);
					n = length - n;
					return baseSlice(array, n < 0 ? 0 : n, length);
				}

				/**
				 * Creates a slice of `array` with elements taken from the end. Elements are
				 * taken until `predicate` returns falsey. The predicate is invoked with
				 * three arguments: (value, index, array).
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Array
				 * @param {Array} array The array to query.
				 * @param {Function} [predicate=_.identity] The function invoked per iteration.
				 * @returns {Array} Returns the slice of `array`.
				 * @example
				 *
				 * var users = [
				 *   { 'user': 'barney',  'active': true },
				 *   { 'user': 'fred',    'active': false },
				 *   { 'user': 'pebbles', 'active': false }
				 * ];
				 *
				 * _.takeRightWhile(users, function(o) { return !o.active; });
				 * // => objects for ['fred', 'pebbles']
				 *
				 * // The `_.matches` iteratee shorthand.
				 * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
				 * // => objects for ['pebbles']
				 *
				 * // The `_.matchesProperty` iteratee shorthand.
				 * _.takeRightWhile(users, ['active', false]);
				 * // => objects for ['fred', 'pebbles']
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.takeRightWhile(users, 'active');
				 * // => []
				 */
				function takeRightWhile(array, predicate) {
					return (array && array.length)
						? baseWhile(array, getIteratee(predicate, 3), false, true)
						: [];
				}

				/**
				 * Creates a slice of `array` with elements taken from the beginning. Elements
				 * are taken until `predicate` returns falsey. The predicate is invoked with
				 * three arguments: (value, index, array).
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Array
				 * @param {Array} array The array to query.
				 * @param {Function} [predicate=_.identity] The function invoked per iteration.
				 * @returns {Array} Returns the slice of `array`.
				 * @example
				 *
				 * var users = [
				 *   { 'user': 'barney',  'active': false },
				 *   { 'user': 'fred',    'active': false },
				 *   { 'user': 'pebbles', 'active': true }
				 * ];
				 *
				 * _.takeWhile(users, function(o) { return !o.active; });
				 * // => objects for ['barney', 'fred']
				 *
				 * // The `_.matches` iteratee shorthand.
				 * _.takeWhile(users, { 'user': 'barney', 'active': false });
				 * // => objects for ['barney']
				 *
				 * // The `_.matchesProperty` iteratee shorthand.
				 * _.takeWhile(users, ['active', false]);
				 * // => objects for ['barney', 'fred']
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.takeWhile(users, 'active');
				 * // => []
				 */
				function takeWhile(array, predicate) {
					return (array && array.length)
						? baseWhile(array, getIteratee(predicate, 3))
						: [];
				}

				/**
				 * Creates an array of unique values, in order, from all given arrays using
				 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
				 * for equality comparisons.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Array
				 * @param {...Array} [arrays] The arrays to inspect.
				 * @returns {Array} Returns the new array of combined values.
				 * @example
				 *
				 * _.union([2], [1, 2]);
				 * // => [2, 1]
				 */
				var union = baseRest(function (arrays) {
					return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
				});

				/**
				 * This method is like `_.union` except that it accepts `iteratee` which is
				 * invoked for each element of each `arrays` to generate the criterion by
				 * which uniqueness is computed. Result values are chosen from the first
				 * array in which the value occurs. The iteratee is invoked with one argument:
				 * (value).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Array
				 * @param {...Array} [arrays] The arrays to inspect.
				 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
				 * @returns {Array} Returns the new array of combined values.
				 * @example
				 *
				 * _.unionBy([2.1], [1.2, 2.3], Math.floor);
				 * // => [2.1, 1.2]
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
				 * // => [{ 'x': 1 }, { 'x': 2 }]
				 */
				var unionBy = baseRest(function (arrays) {
					var iteratee = last(arrays);
					if (isArrayLikeObject(iteratee)) {
						iteratee = undefined$1;
					}
					return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
				});

				/**
				 * This method is like `_.union` except that it accepts `comparator` which
				 * is invoked to compare elements of `arrays`. Result values are chosen from
				 * the first array in which the value occurs. The comparator is invoked
				 * with two arguments: (arrVal, othVal).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Array
				 * @param {...Array} [arrays] The arrays to inspect.
				 * @param {Function} [comparator] The comparator invoked per element.
				 * @returns {Array} Returns the new array of combined values.
				 * @example
				 *
				 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
				 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
				 *
				 * _.unionWith(objects, others, _.isEqual);
				 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
				 */
				var unionWith = baseRest(function (arrays) {
					var comparator = last(arrays);
					comparator = typeof comparator == 'function' ? comparator : undefined$1;
					return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
				});

				/**
				 * Creates a duplicate-free version of an array, using
				 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
				 * for equality comparisons, in which only the first occurrence of each element
				 * is kept. The order of result values is determined by the order they occur
				 * in the array.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Array
				 * @param {Array} array The array to inspect.
				 * @returns {Array} Returns the new duplicate free array.
				 * @example
				 *
				 * _.uniq([2, 1, 2]);
				 * // => [2, 1]
				 */
				function uniq(array) {
					return (array && array.length) ? baseUniq(array) : [];
				}

				/**
				 * This method is like `_.uniq` except that it accepts `iteratee` which is
				 * invoked for each element in `array` to generate the criterion by which
				 * uniqueness is computed. The order of result values is determined by the
				 * order they occur in the array. The iteratee is invoked with one argument:
				 * (value).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Array
				 * @param {Array} array The array to inspect.
				 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
				 * @returns {Array} Returns the new duplicate free array.
				 * @example
				 *
				 * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
				 * // => [2.1, 1.2]
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
				 * // => [{ 'x': 1 }, { 'x': 2 }]
				 */
				function uniqBy(array, iteratee) {
					return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
				}

				/**
				 * This method is like `_.uniq` except that it accepts `comparator` which
				 * is invoked to compare elements of `array`. The order of result values is
				 * determined by the order they occur in the array.The comparator is invoked
				 * with two arguments: (arrVal, othVal).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Array
				 * @param {Array} array The array to inspect.
				 * @param {Function} [comparator] The comparator invoked per element.
				 * @returns {Array} Returns the new duplicate free array.
				 * @example
				 *
				 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
				 *
				 * _.uniqWith(objects, _.isEqual);
				 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
				 */
				function uniqWith(array, comparator) {
					comparator = typeof comparator == 'function' ? comparator : undefined$1;
					return (array && array.length) ? baseUniq(array, undefined$1, comparator) : [];
				}

				/**
				 * This method is like `_.zip` except that it accepts an array of grouped
				 * elements and creates an array regrouping the elements to their pre-zip
				 * configuration.
				 *
				 * @static
				 * @memberOf _
				 * @since 1.2.0
				 * @category Array
				 * @param {Array} array The array of grouped elements to process.
				 * @returns {Array} Returns the new array of regrouped elements.
				 * @example
				 *
				 * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
				 * // => [['a', 1, true], ['b', 2, false]]
				 *
				 * _.unzip(zipped);
				 * // => [['a', 'b'], [1, 2], [true, false]]
				 */
				function unzip(array) {
					if (!(array && array.length)) {
						return [];
					}
					var length = 0;
					array = arrayFilter(array, function (group) {
						if (isArrayLikeObject(group)) {
							length = nativeMax(group.length, length);
							return true;
						}
					});
					return baseTimes(length, function (index) {
						return arrayMap(array, baseProperty(index));
					});
				}

				/**
				 * This method is like `_.unzip` except that it accepts `iteratee` to specify
				 * how regrouped values should be combined. The iteratee is invoked with the
				 * elements of each group: (...group).
				 *
				 * @static
				 * @memberOf _
				 * @since 3.8.0
				 * @category Array
				 * @param {Array} array The array of grouped elements to process.
				 * @param {Function} [iteratee=_.identity] The function to combine
				 *  regrouped values.
				 * @returns {Array} Returns the new array of regrouped elements.
				 * @example
				 *
				 * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
				 * // => [[1, 10, 100], [2, 20, 200]]
				 *
				 * _.unzipWith(zipped, _.add);
				 * // => [3, 30, 300]
				 */
				function unzipWith(array, iteratee) {
					if (!(array && array.length)) {
						return [];
					}
					var result = unzip(array);
					if (iteratee == null) {
						return result;
					}
					return arrayMap(result, function (group) {
						return apply(iteratee, undefined$1, group);
					});
				}

				/**
				 * Creates an array excluding all given values using
				 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
				 * for equality comparisons.
				 *
				 * **Note:** Unlike `_.pull`, this method returns a new array.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Array
				 * @param {Array} array The array to inspect.
				 * @param {...*} [values] The values to exclude.
				 * @returns {Array} Returns the new array of filtered values.
				 * @see _.difference, _.xor
				 * @example
				 *
				 * _.without([2, 1, 2, 3], 1, 2);
				 * // => [3]
				 */
				var without = baseRest(function (array, values) {
					return isArrayLikeObject(array)
						? baseDifference(array, values)
						: [];
				});

				/**
				 * Creates an array of unique values that is the
				 * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
				 * of the given arrays. The order of result values is determined by the order
				 * they occur in the arrays.
				 *
				 * @static
				 * @memberOf _
				 * @since 2.4.0
				 * @category Array
				 * @param {...Array} [arrays] The arrays to inspect.
				 * @returns {Array} Returns the new array of filtered values.
				 * @see _.difference, _.without
				 * @example
				 *
				 * _.xor([2, 1], [2, 3]);
				 * // => [1, 3]
				 */
				var xor = baseRest(function (arrays) {
					return baseXor(arrayFilter(arrays, isArrayLikeObject));
				});

				/**
				 * This method is like `_.xor` except that it accepts `iteratee` which is
				 * invoked for each element of each `arrays` to generate the criterion by
				 * which by which they're compared. The order of result values is determined
				 * by the order they occur in the arrays. The iteratee is invoked with one
				 * argument: (value).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Array
				 * @param {...Array} [arrays] The arrays to inspect.
				 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
				 * @returns {Array} Returns the new array of filtered values.
				 * @example
				 *
				 * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
				 * // => [1.2, 3.4]
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
				 * // => [{ 'x': 2 }]
				 */
				var xorBy = baseRest(function (arrays) {
					var iteratee = last(arrays);
					if (isArrayLikeObject(iteratee)) {
						iteratee = undefined$1;
					}
					return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
				});

				/**
				 * This method is like `_.xor` except that it accepts `comparator` which is
				 * invoked to compare elements of `arrays`. The order of result values is
				 * determined by the order they occur in the arrays. The comparator is invoked
				 * with two arguments: (arrVal, othVal).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Array
				 * @param {...Array} [arrays] The arrays to inspect.
				 * @param {Function} [comparator] The comparator invoked per element.
				 * @returns {Array} Returns the new array of filtered values.
				 * @example
				 *
				 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
				 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
				 *
				 * _.xorWith(objects, others, _.isEqual);
				 * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
				 */
				var xorWith = baseRest(function (arrays) {
					var comparator = last(arrays);
					comparator = typeof comparator == 'function' ? comparator : undefined$1;
					return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
				});

				/**
				 * Creates an array of grouped elements, the first of which contains the
				 * first elements of the given arrays, the second of which contains the
				 * second elements of the given arrays, and so on.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Array
				 * @param {...Array} [arrays] The arrays to process.
				 * @returns {Array} Returns the new array of grouped elements.
				 * @example
				 *
				 * _.zip(['a', 'b'], [1, 2], [true, false]);
				 * // => [['a', 1, true], ['b', 2, false]]
				 */
				var zip = baseRest(unzip);

				/**
				 * This method is like `_.fromPairs` except that it accepts two arrays,
				 * one of property identifiers and one of corresponding values.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.4.0
				 * @category Array
				 * @param {Array} [props=[]] The property identifiers.
				 * @param {Array} [values=[]] The property values.
				 * @returns {Object} Returns the new object.
				 * @example
				 *
				 * _.zipObject(['a', 'b'], [1, 2]);
				 * // => { 'a': 1, 'b': 2 }
				 */
				function zipObject(props, values) {
					return baseZipObject(props || [], values || [], assignValue);
				}

				/**
				 * This method is like `_.zipObject` except that it supports property paths.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.1.0
				 * @category Array
				 * @param {Array} [props=[]] The property identifiers.
				 * @param {Array} [values=[]] The property values.
				 * @returns {Object} Returns the new object.
				 * @example
				 *
				 * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
				 * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
				 */
				function zipObjectDeep(props, values) {
					return baseZipObject(props || [], values || [], baseSet);
				}

				/**
				 * This method is like `_.zip` except that it accepts `iteratee` to specify
				 * how grouped values should be combined. The iteratee is invoked with the
				 * elements of each group: (...group).
				 *
				 * @static
				 * @memberOf _
				 * @since 3.8.0
				 * @category Array
				 * @param {...Array} [arrays] The arrays to process.
				 * @param {Function} [iteratee=_.identity] The function to combine
				 *  grouped values.
				 * @returns {Array} Returns the new array of grouped elements.
				 * @example
				 *
				 * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
				 *   return a + b + c;
				 * });
				 * // => [111, 222]
				 */
				var zipWith = baseRest(function (arrays) {
					var length = arrays.length,
						iteratee = length > 1 ? arrays[length - 1] : undefined$1;

					iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined$1;
					return unzipWith(arrays, iteratee);
				});

				/*------------------------------------------------------------------------*/

				/**
				 * Creates a `lodash` wrapper instance that wraps `value` with explicit method
				 * chain sequences enabled. The result of such sequences must be unwrapped
				 * with `_#value`.
				 *
				 * @static
				 * @memberOf _
				 * @since 1.3.0
				 * @category Seq
				 * @param {*} value The value to wrap.
				 * @returns {Object} Returns the new `lodash` wrapper instance.
				 * @example
				 *
				 * var users = [
				 *   { 'user': 'barney',  'age': 36 },
				 *   { 'user': 'fred',    'age': 40 },
				 *   { 'user': 'pebbles', 'age': 1 }
				 * ];
				 *
				 * var youngest = _
				 *   .chain(users)
				 *   .sortBy('age')
				 *   .map(function(o) {
				 *     return o.user + ' is ' + o.age;
				 *   })
				 *   .head()
				 *   .value();
				 * // => 'pebbles is 1'
				 */
				function chain(value) {
					var result = lodash(value);
					result.__chain__ = true;
					return result;
				}

				/**
				 * This method invokes `interceptor` and returns `value`. The interceptor
				 * is invoked with one argument; (value). The purpose of this method is to
				 * "tap into" a method chain sequence in order to modify intermediate results.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Seq
				 * @param {*} value The value to provide to `interceptor`.
				 * @param {Function} interceptor The function to invoke.
				 * @returns {*} Returns `value`.
				 * @example
				 *
				 * _([1, 2, 3])
				 *  .tap(function(array) {
				 *    // Mutate input array.
				 *    array.pop();
				 *  })
				 *  .reverse()
				 *  .value();
				 * // => [2, 1]
				 */
				function tap(value, interceptor) {
					interceptor(value);
					return value;
				}

				/**
				 * This method is like `_.tap` except that it returns the result of `interceptor`.
				 * The purpose of this method is to "pass thru" values replacing intermediate
				 * results in a method chain sequence.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Seq
				 * @param {*} value The value to provide to `interceptor`.
				 * @param {Function} interceptor The function to invoke.
				 * @returns {*} Returns the result of `interceptor`.
				 * @example
				 *
				 * _('  abc  ')
				 *  .chain()
				 *  .trim()
				 *  .thru(function(value) {
				 *    return [value];
				 *  })
				 *  .value();
				 * // => ['abc']
				 */
				function thru(value, interceptor) {
					return interceptor(value);
				}

				/**
				 * This method is the wrapper version of `_.at`.
				 *
				 * @name at
				 * @memberOf _
				 * @since 1.0.0
				 * @category Seq
				 * @param {...(string|string[])} [paths] The property paths to pick.
				 * @returns {Object} Returns the new `lodash` wrapper instance.
				 * @example
				 *
				 * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
				 *
				 * _(object).at(['a[0].b.c', 'a[1]']).value();
				 * // => [3, 4]
				 */
				var wrapperAt = flatRest(function (paths) {
					var length = paths.length,
						start = length ? paths[0] : 0,
						value = this.__wrapped__,
						interceptor = function (object) { return baseAt(object, paths); };

					if (length > 1 || this.__actions__.length ||
						!(value instanceof LazyWrapper) || !isIndex(start)) {
						return this.thru(interceptor);
					}
					value = value.slice(start, +start + (length ? 1 : 0));
					value.__actions__.push({
						'func': thru,
						'args': [interceptor],
						'thisArg': undefined$1
					});
					return new LodashWrapper(value, this.__chain__).thru(function (array) {
						if (length && !array.length) {
							array.push(undefined$1);
						}
						return array;
					});
				});

				/**
				 * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
				 *
				 * @name chain
				 * @memberOf _
				 * @since 0.1.0
				 * @category Seq
				 * @returns {Object} Returns the new `lodash` wrapper instance.
				 * @example
				 *
				 * var users = [
				 *   { 'user': 'barney', 'age': 36 },
				 *   { 'user': 'fred',   'age': 40 }
				 * ];
				 *
				 * // A sequence without explicit chaining.
				 * _(users).head();
				 * // => { 'user': 'barney', 'age': 36 }
				 *
				 * // A sequence with explicit chaining.
				 * _(users)
				 *   .chain()
				 *   .head()
				 *   .pick('user')
				 *   .value();
				 * // => { 'user': 'barney' }
				 */
				function wrapperChain() {
					return chain(this);
				}

				/**
				 * Executes the chain sequence and returns the wrapped result.
				 *
				 * @name commit
				 * @memberOf _
				 * @since 3.2.0
				 * @category Seq
				 * @returns {Object} Returns the new `lodash` wrapper instance.
				 * @example
				 *
				 * var array = [1, 2];
				 * var wrapped = _(array).push(3);
				 *
				 * console.log(array);
				 * // => [1, 2]
				 *
				 * wrapped = wrapped.commit();
				 * console.log(array);
				 * // => [1, 2, 3]
				 *
				 * wrapped.last();
				 * // => 3
				 *
				 * console.log(array);
				 * // => [1, 2, 3]
				 */
				function wrapperCommit() {
					return new LodashWrapper(this.value(), this.__chain__);
				}

				/**
				 * Gets the next value on a wrapped object following the
				 * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
				 *
				 * @name next
				 * @memberOf _
				 * @since 4.0.0
				 * @category Seq
				 * @returns {Object} Returns the next iterator value.
				 * @example
				 *
				 * var wrapped = _([1, 2]);
				 *
				 * wrapped.next();
				 * // => { 'done': false, 'value': 1 }
				 *
				 * wrapped.next();
				 * // => { 'done': false, 'value': 2 }
				 *
				 * wrapped.next();
				 * // => { 'done': true, 'value': undefined }
				 */
				function wrapperNext() {
					if (this.__values__ === undefined$1) {
						this.__values__ = toArray(this.value());
					}
					var done = this.__index__ >= this.__values__.length,
						value = done ? undefined$1 : this.__values__[this.__index__++];

					return { 'done': done, 'value': value };
				}

				/**
				 * Enables the wrapper to be iterable.
				 *
				 * @name Symbol.iterator
				 * @memberOf _
				 * @since 4.0.0
				 * @category Seq
				 * @returns {Object} Returns the wrapper object.
				 * @example
				 *
				 * var wrapped = _([1, 2]);
				 *
				 * wrapped[Symbol.iterator]() === wrapped;
				 * // => true
				 *
				 * Array.from(wrapped);
				 * // => [1, 2]
				 */
				function wrapperToIterator() {
					return this;
				}

				/**
				 * Creates a clone of the chain sequence planting `value` as the wrapped value.
				 *
				 * @name plant
				 * @memberOf _
				 * @since 3.2.0
				 * @category Seq
				 * @param {*} value The value to plant.
				 * @returns {Object} Returns the new `lodash` wrapper instance.
				 * @example
				 *
				 * function square(n) {
				 *   return n * n;
				 * }
				 *
				 * var wrapped = _([1, 2]).map(square);
				 * var other = wrapped.plant([3, 4]);
				 *
				 * other.value();
				 * // => [9, 16]
				 *
				 * wrapped.value();
				 * // => [1, 4]
				 */
				function wrapperPlant(value) {
					var result,
						parent = this;

					while (parent instanceof baseLodash) {
						var clone = wrapperClone(parent);
						clone.__index__ = 0;
						clone.__values__ = undefined$1;
						if (result) {
							previous.__wrapped__ = clone;
						} else {
							result = clone;
						}
						var previous = clone;
						parent = parent.__wrapped__;
					}
					previous.__wrapped__ = value;
					return result;
				}

				/**
				 * This method is the wrapper version of `_.reverse`.
				 *
				 * **Note:** This method mutates the wrapped array.
				 *
				 * @name reverse
				 * @memberOf _
				 * @since 0.1.0
				 * @category Seq
				 * @returns {Object} Returns the new `lodash` wrapper instance.
				 * @example
				 *
				 * var array = [1, 2, 3];
				 *
				 * _(array).reverse().value()
				 * // => [3, 2, 1]
				 *
				 * console.log(array);
				 * // => [3, 2, 1]
				 */
				function wrapperReverse() {
					var value = this.__wrapped__;
					if (value instanceof LazyWrapper) {
						var wrapped = value;
						if (this.__actions__.length) {
							wrapped = new LazyWrapper(this);
						}
						wrapped = wrapped.reverse();
						wrapped.__actions__.push({
							'func': thru,
							'args': [reverse],
							'thisArg': undefined$1
						});
						return new LodashWrapper(wrapped, this.__chain__);
					}
					return this.thru(reverse);
				}

				/**
				 * Executes the chain sequence to resolve the unwrapped value.
				 *
				 * @name value
				 * @memberOf _
				 * @since 0.1.0
				 * @alias toJSON, valueOf
				 * @category Seq
				 * @returns {*} Returns the resolved unwrapped value.
				 * @example
				 *
				 * _([1, 2, 3]).value();
				 * // => [1, 2, 3]
				 */
				function wrapperValue() {
					return baseWrapperValue(this.__wrapped__, this.__actions__);
				}

				/*------------------------------------------------------------------------*/

				/**
				 * Creates an object composed of keys generated from the results of running
				 * each element of `collection` thru `iteratee`. The corresponding value of
				 * each key is the number of times the key was returned by `iteratee`. The
				 * iteratee is invoked with one argument: (value).
				 *
				 * @static
				 * @memberOf _
				 * @since 0.5.0
				 * @category Collection
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
				 * @returns {Object} Returns the composed aggregate object.
				 * @example
				 *
				 * _.countBy([6.1, 4.2, 6.3], Math.floor);
				 * // => { '4': 1, '6': 2 }
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.countBy(['one', 'two', 'three'], 'length');
				 * // => { '3': 2, '5': 1 }
				 */
				var countBy = createAggregator(function (result, value, key) {
					if (hasOwnProperty.call(result, key)) {
						++result[key];
					} else {
						baseAssignValue(result, key, 1);
					}
				});

				/**
				 * Checks if `predicate` returns truthy for **all** elements of `collection`.
				 * Iteration is stopped once `predicate` returns falsey. The predicate is
				 * invoked with three arguments: (value, index|key, collection).
				 *
				 * **Note:** This method returns `true` for
				 * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
				 * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
				 * elements of empty collections.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Collection
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Function} [predicate=_.identity] The function invoked per iteration.
				 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
				 * @returns {boolean} Returns `true` if all elements pass the predicate check,
				 *  else `false`.
				 * @example
				 *
				 * _.every([true, 1, null, 'yes'], Boolean);
				 * // => false
				 *
				 * var users = [
				 *   { 'user': 'barney', 'age': 36, 'active': false },
				 *   { 'user': 'fred',   'age': 40, 'active': false }
				 * ];
				 *
				 * // The `_.matches` iteratee shorthand.
				 * _.every(users, { 'user': 'barney', 'active': false });
				 * // => false
				 *
				 * // The `_.matchesProperty` iteratee shorthand.
				 * _.every(users, ['active', false]);
				 * // => true
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.every(users, 'active');
				 * // => false
				 */
				function every(collection, predicate, guard) {
					var func = isArray(collection) ? arrayEvery : baseEvery;
					if (guard && isIterateeCall(collection, predicate, guard)) {
						predicate = undefined$1;
					}
					return func(collection, getIteratee(predicate, 3));
				}

				/**
				 * Iterates over elements of `collection`, returning an array of all elements
				 * `predicate` returns truthy for. The predicate is invoked with three
				 * arguments: (value, index|key, collection).
				 *
				 * **Note:** Unlike `_.remove`, this method returns a new array.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Collection
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Function} [predicate=_.identity] The function invoked per iteration.
				 * @returns {Array} Returns the new filtered array.
				 * @see _.reject
				 * @example
				 *
				 * var users = [
				 *   { 'user': 'barney', 'age': 36, 'active': true },
				 *   { 'user': 'fred',   'age': 40, 'active': false }
				 * ];
				 *
				 * _.filter(users, function(o) { return !o.active; });
				 * // => objects for ['fred']
				 *
				 * // The `_.matches` iteratee shorthand.
				 * _.filter(users, { 'age': 36, 'active': true });
				 * // => objects for ['barney']
				 *
				 * // The `_.matchesProperty` iteratee shorthand.
				 * _.filter(users, ['active', false]);
				 * // => objects for ['fred']
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.filter(users, 'active');
				 * // => objects for ['barney']
				 *
				 * // Combining several predicates using `_.overEvery` or `_.overSome`.
				 * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
				 * // => objects for ['fred', 'barney']
				 */
				function filter(collection, predicate) {
					var func = isArray(collection) ? arrayFilter : baseFilter;
					return func(collection, getIteratee(predicate, 3));
				}

				/**
				 * Iterates over elements of `collection`, returning the first element
				 * `predicate` returns truthy for. The predicate is invoked with three
				 * arguments: (value, index|key, collection).
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Collection
				 * @param {Array|Object} collection The collection to inspect.
				 * @param {Function} [predicate=_.identity] The function invoked per iteration.
				 * @param {number} [fromIndex=0] The index to search from.
				 * @returns {*} Returns the matched element, else `undefined`.
				 * @example
				 *
				 * var users = [
				 *   { 'user': 'barney',  'age': 36, 'active': true },
				 *   { 'user': 'fred',    'age': 40, 'active': false },
				 *   { 'user': 'pebbles', 'age': 1,  'active': true }
				 * ];
				 *
				 * _.find(users, function(o) { return o.age < 40; });
				 * // => object for 'barney'
				 *
				 * // The `_.matches` iteratee shorthand.
				 * _.find(users, { 'age': 1, 'active': true });
				 * // => object for 'pebbles'
				 *
				 * // The `_.matchesProperty` iteratee shorthand.
				 * _.find(users, ['active', false]);
				 * // => object for 'fred'
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.find(users, 'active');
				 * // => object for 'barney'
				 */
				var find = createFind(findIndex);

				/**
				 * This method is like `_.find` except that it iterates over elements of
				 * `collection` from right to left.
				 *
				 * @static
				 * @memberOf _
				 * @since 2.0.0
				 * @category Collection
				 * @param {Array|Object} collection The collection to inspect.
				 * @param {Function} [predicate=_.identity] The function invoked per iteration.
				 * @param {number} [fromIndex=collection.length-1] The index to search from.
				 * @returns {*} Returns the matched element, else `undefined`.
				 * @example
				 *
				 * _.findLast([1, 2, 3, 4], function(n) {
				 *   return n % 2 == 1;
				 * });
				 * // => 3
				 */
				var findLast = createFind(findLastIndex);

				/**
				 * Creates a flattened array of values by running each element in `collection`
				 * thru `iteratee` and flattening the mapped results. The iteratee is invoked
				 * with three arguments: (value, index|key, collection).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Collection
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
				 * @returns {Array} Returns the new flattened array.
				 * @example
				 *
				 * function duplicate(n) {
				 *   return [n, n];
				 * }
				 *
				 * _.flatMap([1, 2], duplicate);
				 * // => [1, 1, 2, 2]
				 */
				function flatMap(collection, iteratee) {
					return baseFlatten(map(collection, iteratee), 1);
				}

				/**
				 * This method is like `_.flatMap` except that it recursively flattens the
				 * mapped results.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.7.0
				 * @category Collection
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
				 * @returns {Array} Returns the new flattened array.
				 * @example
				 *
				 * function duplicate(n) {
				 *   return [[[n, n]]];
				 * }
				 *
				 * _.flatMapDeep([1, 2], duplicate);
				 * // => [1, 1, 2, 2]
				 */
				function flatMapDeep(collection, iteratee) {
					return baseFlatten(map(collection, iteratee), INFINITY);
				}

				/**
				 * This method is like `_.flatMap` except that it recursively flattens the
				 * mapped results up to `depth` times.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.7.0
				 * @category Collection
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
				 * @param {number} [depth=1] The maximum recursion depth.
				 * @returns {Array} Returns the new flattened array.
				 * @example
				 *
				 * function duplicate(n) {
				 *   return [[[n, n]]];
				 * }
				 *
				 * _.flatMapDepth([1, 2], duplicate, 2);
				 * // => [[1, 1], [2, 2]]
				 */
				function flatMapDepth(collection, iteratee, depth) {
					depth = depth === undefined$1 ? 1 : toInteger(depth);
					return baseFlatten(map(collection, iteratee), depth);
				}

				/**
				 * Iterates over elements of `collection` and invokes `iteratee` for each element.
				 * The iteratee is invoked with three arguments: (value, index|key, collection).
				 * Iteratee functions may exit iteration early by explicitly returning `false`.
				 *
				 * **Note:** As with other "Collections" methods, objects with a "length"
				 * property are iterated like arrays. To avoid this behavior use `_.forIn`
				 * or `_.forOwn` for object iteration.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @alias each
				 * @category Collection
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
				 * @returns {Array|Object} Returns `collection`.
				 * @see _.forEachRight
				 * @example
				 *
				 * _.forEach([1, 2], function(value) {
				 *   console.log(value);
				 * });
				 * // => Logs `1` then `2`.
				 *
				 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
				 *   console.log(key);
				 * });
				 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
				 */
				function forEach(collection, iteratee) {
					var func = isArray(collection) ? arrayEach : baseEach;
					return func(collection, getIteratee(iteratee, 3));
				}

				/**
				 * This method is like `_.forEach` except that it iterates over elements of
				 * `collection` from right to left.
				 *
				 * @static
				 * @memberOf _
				 * @since 2.0.0
				 * @alias eachRight
				 * @category Collection
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
				 * @returns {Array|Object} Returns `collection`.
				 * @see _.forEach
				 * @example
				 *
				 * _.forEachRight([1, 2], function(value) {
				 *   console.log(value);
				 * });
				 * // => Logs `2` then `1`.
				 */
				function forEachRight(collection, iteratee) {
					var func = isArray(collection) ? arrayEachRight : baseEachRight;
					return func(collection, getIteratee(iteratee, 3));
				}

				/**
				 * Creates an object composed of keys generated from the results of running
				 * each element of `collection` thru `iteratee`. The order of grouped values
				 * is determined by the order they occur in `collection`. The corresponding
				 * value of each key is an array of elements responsible for generating the
				 * key. The iteratee is invoked with one argument: (value).
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Collection
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
				 * @returns {Object} Returns the composed aggregate object.
				 * @example
				 *
				 * _.groupBy([6.1, 4.2, 6.3], Math.floor);
				 * // => { '4': [4.2], '6': [6.1, 6.3] }
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.groupBy(['one', 'two', 'three'], 'length');
				 * // => { '3': ['one', 'two'], '5': ['three'] }
				 */
				var groupBy = createAggregator(function (result, value, key) {
					if (hasOwnProperty.call(result, key)) {
						result[key].push(value);
					} else {
						baseAssignValue(result, key, [value]);
					}
				});

				/**
				 * Checks if `value` is in `collection`. If `collection` is a string, it's
				 * checked for a substring of `value`, otherwise
				 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
				 * is used for equality comparisons. If `fromIndex` is negative, it's used as
				 * the offset from the end of `collection`.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Collection
				 * @param {Array|Object|string} collection The collection to inspect.
				 * @param {*} value The value to search for.
				 * @param {number} [fromIndex=0] The index to search from.
				 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
				 * @returns {boolean} Returns `true` if `value` is found, else `false`.
				 * @example
				 *
				 * _.includes([1, 2, 3], 1);
				 * // => true
				 *
				 * _.includes([1, 2, 3], 1, 2);
				 * // => false
				 *
				 * _.includes({ 'a': 1, 'b': 2 }, 1);
				 * // => true
				 *
				 * _.includes('abcd', 'bc');
				 * // => true
				 */
				function includes(collection, value, fromIndex, guard) {
					collection = isArrayLike(collection) ? collection : values(collection);
					fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

					var length = collection.length;
					if (fromIndex < 0) {
						fromIndex = nativeMax(length + fromIndex, 0);
					}
					return isString(collection)
						? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
						: (!!length && baseIndexOf(collection, value, fromIndex) > -1);
				}

				/**
				 * Invokes the method at `path` of each element in `collection`, returning
				 * an array of the results of each invoked method. Any additional arguments
				 * are provided to each invoked method. If `path` is a function, it's invoked
				 * for, and `this` bound to, each element in `collection`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Collection
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Array|Function|string} path The path of the method to invoke or
				 *  the function invoked per iteration.
				 * @param {...*} [args] The arguments to invoke each method with.
				 * @returns {Array} Returns the array of results.
				 * @example
				 *
				 * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
				 * // => [[1, 5, 7], [1, 2, 3]]
				 *
				 * _.invokeMap([123, 456], String.prototype.split, '');
				 * // => [['1', '2', '3'], ['4', '5', '6']]
				 */
				var invokeMap = baseRest(function (collection, path, args) {
					var index = -1,
						isFunc = typeof path == 'function',
						result = isArrayLike(collection) ? Array(collection.length) : [];

					baseEach(collection, function (value) {
						result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
					});
					return result;
				});

				/**
				 * Creates an object composed of keys generated from the results of running
				 * each element of `collection` thru `iteratee`. The corresponding value of
				 * each key is the last element responsible for generating the key. The
				 * iteratee is invoked with one argument: (value).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Collection
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
				 * @returns {Object} Returns the composed aggregate object.
				 * @example
				 *
				 * var array = [
				 *   { 'dir': 'left', 'code': 97 },
				 *   { 'dir': 'right', 'code': 100 }
				 * ];
				 *
				 * _.keyBy(array, function(o) {
				 *   return String.fromCharCode(o.code);
				 * });
				 * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
				 *
				 * _.keyBy(array, 'dir');
				 * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
				 */
				var keyBy = createAggregator(function (result, value, key) {
					baseAssignValue(result, key, value);
				});

				/**
				 * Creates an array of values by running each element in `collection` thru
				 * `iteratee`. The iteratee is invoked with three arguments:
				 * (value, index|key, collection).
				 *
				 * Many lodash methods are guarded to work as iteratees for methods like
				 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
				 *
				 * The guarded methods are:
				 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
				 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
				 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
				 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Collection
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
				 * @returns {Array} Returns the new mapped array.
				 * @example
				 *
				 * function square(n) {
				 *   return n * n;
				 * }
				 *
				 * _.map([4, 8], square);
				 * // => [16, 64]
				 *
				 * _.map({ 'a': 4, 'b': 8 }, square);
				 * // => [16, 64] (iteration order is not guaranteed)
				 *
				 * var users = [
				 *   { 'user': 'barney' },
				 *   { 'user': 'fred' }
				 * ];
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.map(users, 'user');
				 * // => ['barney', 'fred']
				 */
				function map(collection, iteratee) {
					var func = isArray(collection) ? arrayMap : baseMap;
					return func(collection, getIteratee(iteratee, 3));
				}

				/**
				 * This method is like `_.sortBy` except that it allows specifying the sort
				 * orders of the iteratees to sort by. If `orders` is unspecified, all values
				 * are sorted in ascending order. Otherwise, specify an order of "desc" for
				 * descending or "asc" for ascending sort order of corresponding values.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Collection
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
				 *  The iteratees to sort by.
				 * @param {string[]} [orders] The sort orders of `iteratees`.
				 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
				 * @returns {Array} Returns the new sorted array.
				 * @example
				 *
				 * var users = [
				 *   { 'user': 'fred',   'age': 48 },
				 *   { 'user': 'barney', 'age': 34 },
				 *   { 'user': 'fred',   'age': 40 },
				 *   { 'user': 'barney', 'age': 36 }
				 * ];
				 *
				 * // Sort by `user` in ascending order and by `age` in descending order.
				 * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
				 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
				 */
				function orderBy(collection, iteratees, orders, guard) {
					if (collection == null) {
						return [];
					}
					if (!isArray(iteratees)) {
						iteratees = iteratees == null ? [] : [iteratees];
					}
					orders = guard ? undefined$1 : orders;
					if (!isArray(orders)) {
						orders = orders == null ? [] : [orders];
					}
					return baseOrderBy(collection, iteratees, orders);
				}

				/**
				 * Creates an array of elements split into two groups, the first of which
				 * contains elements `predicate` returns truthy for, the second of which
				 * contains elements `predicate` returns falsey for. The predicate is
				 * invoked with one argument: (value).
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Collection
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Function} [predicate=_.identity] The function invoked per iteration.
				 * @returns {Array} Returns the array of grouped elements.
				 * @example
				 *
				 * var users = [
				 *   { 'user': 'barney',  'age': 36, 'active': false },
				 *   { 'user': 'fred',    'age': 40, 'active': true },
				 *   { 'user': 'pebbles', 'age': 1,  'active': false }
				 * ];
				 *
				 * _.partition(users, function(o) { return o.active; });
				 * // => objects for [['fred'], ['barney', 'pebbles']]
				 *
				 * // The `_.matches` iteratee shorthand.
				 * _.partition(users, { 'age': 1, 'active': false });
				 * // => objects for [['pebbles'], ['barney', 'fred']]
				 *
				 * // The `_.matchesProperty` iteratee shorthand.
				 * _.partition(users, ['active', false]);
				 * // => objects for [['barney', 'pebbles'], ['fred']]
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.partition(users, 'active');
				 * // => objects for [['fred'], ['barney', 'pebbles']]
				 */
				var partition = createAggregator(function (result, value, key) {
					result[key ? 0 : 1].push(value);
				}, function () { return [[], []]; });

				/**
				 * Reduces `collection` to a value which is the accumulated result of running
				 * each element in `collection` thru `iteratee`, where each successive
				 * invocation is supplied the return value of the previous. If `accumulator`
				 * is not given, the first element of `collection` is used as the initial
				 * value. The iteratee is invoked with four arguments:
				 * (accumulator, value, index|key, collection).
				 *
				 * Many lodash methods are guarded to work as iteratees for methods like
				 * `_.reduce`, `_.reduceRight`, and `_.transform`.
				 *
				 * The guarded methods are:
				 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
				 * and `sortBy`
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Collection
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
				 * @param {*} [accumulator] The initial value.
				 * @returns {*} Returns the accumulated value.
				 * @see _.reduceRight
				 * @example
				 *
				 * _.reduce([1, 2], function(sum, n) {
				 *   return sum + n;
				 * }, 0);
				 * // => 3
				 *
				 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
				 *   (result[value] || (result[value] = [])).push(key);
				 *   return result;
				 * }, {});
				 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
				 */
				function reduce(collection, iteratee, accumulator) {
					var func = isArray(collection) ? arrayReduce : baseReduce,
						initAccum = arguments.length < 3;

					return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
				}

				/**
				 * This method is like `_.reduce` except that it iterates over elements of
				 * `collection` from right to left.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Collection
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
				 * @param {*} [accumulator] The initial value.
				 * @returns {*} Returns the accumulated value.
				 * @see _.reduce
				 * @example
				 *
				 * var array = [[0, 1], [2, 3], [4, 5]];
				 *
				 * _.reduceRight(array, function(flattened, other) {
				 *   return flattened.concat(other);
				 * }, []);
				 * // => [4, 5, 2, 3, 0, 1]
				 */
				function reduceRight(collection, iteratee, accumulator) {
					var func = isArray(collection) ? arrayReduceRight : baseReduce,
						initAccum = arguments.length < 3;

					return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
				}

				/**
				 * The opposite of `_.filter`; this method returns the elements of `collection`
				 * that `predicate` does **not** return truthy for.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Collection
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Function} [predicate=_.identity] The function invoked per iteration.
				 * @returns {Array} Returns the new filtered array.
				 * @see _.filter
				 * @example
				 *
				 * var users = [
				 *   { 'user': 'barney', 'age': 36, 'active': false },
				 *   { 'user': 'fred',   'age': 40, 'active': true }
				 * ];
				 *
				 * _.reject(users, function(o) { return !o.active; });
				 * // => objects for ['fred']
				 *
				 * // The `_.matches` iteratee shorthand.
				 * _.reject(users, { 'age': 40, 'active': true });
				 * // => objects for ['barney']
				 *
				 * // The `_.matchesProperty` iteratee shorthand.
				 * _.reject(users, ['active', false]);
				 * // => objects for ['fred']
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.reject(users, 'active');
				 * // => objects for ['barney']
				 */
				function reject(collection, predicate) {
					var func = isArray(collection) ? arrayFilter : baseFilter;
					return func(collection, negate(getIteratee(predicate, 3)));
				}

				/**
				 * Gets a random element from `collection`.
				 *
				 * @static
				 * @memberOf _
				 * @since 2.0.0
				 * @category Collection
				 * @param {Array|Object} collection The collection to sample.
				 * @returns {*} Returns the random element.
				 * @example
				 *
				 * _.sample([1, 2, 3, 4]);
				 * // => 2
				 */
				function sample(collection) {
					var func = isArray(collection) ? arraySample : baseSample;
					return func(collection);
				}

				/**
				 * Gets `n` random elements at unique keys from `collection` up to the
				 * size of `collection`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Collection
				 * @param {Array|Object} collection The collection to sample.
				 * @param {number} [n=1] The number of elements to sample.
				 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
				 * @returns {Array} Returns the random elements.
				 * @example
				 *
				 * _.sampleSize([1, 2, 3], 2);
				 * // => [3, 1]
				 *
				 * _.sampleSize([1, 2, 3], 4);
				 * // => [2, 3, 1]
				 */
				function sampleSize(collection, n, guard) {
					if ((guard ? isIterateeCall(collection, n, guard) : n === undefined$1)) {
						n = 1;
					} else {
						n = toInteger(n);
					}
					var func = isArray(collection) ? arraySampleSize : baseSampleSize;
					return func(collection, n);
				}

				/**
				 * Creates an array of shuffled values, using a version of the
				 * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Collection
				 * @param {Array|Object} collection The collection to shuffle.
				 * @returns {Array} Returns the new shuffled array.
				 * @example
				 *
				 * _.shuffle([1, 2, 3, 4]);
				 * // => [4, 1, 3, 2]
				 */
				function shuffle(collection) {
					var func = isArray(collection) ? arrayShuffle : baseShuffle;
					return func(collection);
				}

				/**
				 * Gets the size of `collection` by returning its length for array-like
				 * values or the number of own enumerable string keyed properties for objects.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Collection
				 * @param {Array|Object|string} collection The collection to inspect.
				 * @returns {number} Returns the collection size.
				 * @example
				 *
				 * _.size([1, 2, 3]);
				 * // => 3
				 *
				 * _.size({ 'a': 1, 'b': 2 });
				 * // => 2
				 *
				 * _.size('pebbles');
				 * // => 7
				 */
				function size(collection) {
					if (collection == null) {
						return 0;
					}
					if (isArrayLike(collection)) {
						return isString(collection) ? stringSize(collection) : collection.length;
					}
					var tag = getTag(collection);
					if (tag == mapTag || tag == setTag) {
						return collection.size;
					}
					return baseKeys(collection).length;
				}

				/**
				 * Checks if `predicate` returns truthy for **any** element of `collection`.
				 * Iteration is stopped once `predicate` returns truthy. The predicate is
				 * invoked with three arguments: (value, index|key, collection).
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Collection
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {Function} [predicate=_.identity] The function invoked per iteration.
				 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
				 * @returns {boolean} Returns `true` if any element passes the predicate check,
				 *  else `false`.
				 * @example
				 *
				 * _.some([null, 0, 'yes', false], Boolean);
				 * // => true
				 *
				 * var users = [
				 *   { 'user': 'barney', 'active': true },
				 *   { 'user': 'fred',   'active': false }
				 * ];
				 *
				 * // The `_.matches` iteratee shorthand.
				 * _.some(users, { 'user': 'barney', 'active': false });
				 * // => false
				 *
				 * // The `_.matchesProperty` iteratee shorthand.
				 * _.some(users, ['active', false]);
				 * // => true
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.some(users, 'active');
				 * // => true
				 */
				function some(collection, predicate, guard) {
					var func = isArray(collection) ? arraySome : baseSome;
					if (guard && isIterateeCall(collection, predicate, guard)) {
						predicate = undefined$1;
					}
					return func(collection, getIteratee(predicate, 3));
				}

				/**
				 * Creates an array of elements, sorted in ascending order by the results of
				 * running each element in a collection thru each iteratee. This method
				 * performs a stable sort, that is, it preserves the original sort order of
				 * equal elements. The iteratees are invoked with one argument: (value).
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Collection
				 * @param {Array|Object} collection The collection to iterate over.
				 * @param {...(Function|Function[])} [iteratees=[_.identity]]
				 *  The iteratees to sort by.
				 * @returns {Array} Returns the new sorted array.
				 * @example
				 *
				 * var users = [
				 *   { 'user': 'fred',   'age': 48 },
				 *   { 'user': 'barney', 'age': 36 },
				 *   { 'user': 'fred',   'age': 30 },
				 *   { 'user': 'barney', 'age': 34 }
				 * ];
				 *
				 * _.sortBy(users, [function(o) { return o.user; }]);
				 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
				 *
				 * _.sortBy(users, ['user', 'age']);
				 * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
				 */
				var sortBy = baseRest(function (collection, iteratees) {
					if (collection == null) {
						return [];
					}
					var length = iteratees.length;
					if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
						iteratees = [];
					} else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
						iteratees = [iteratees[0]];
					}
					return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
				});

				/*------------------------------------------------------------------------*/

				/**
				 * Gets the timestamp of the number of milliseconds that have elapsed since
				 * the Unix epoch (1 January 1970 00:00:00 UTC).
				 *
				 * @static
				 * @memberOf _
				 * @since 2.4.0
				 * @category Date
				 * @returns {number} Returns the timestamp.
				 * @example
				 *
				 * _.defer(function(stamp) {
				 *   console.log(_.now() - stamp);
				 * }, _.now());
				 * // => Logs the number of milliseconds it took for the deferred invocation.
				 */
				var now = ctxNow || function () {
					return root.Date.now();
				};

				/*------------------------------------------------------------------------*/

				/**
				 * The opposite of `_.before`; this method creates a function that invokes
				 * `func` once it's called `n` or more times.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Function
				 * @param {number} n The number of calls before `func` is invoked.
				 * @param {Function} func The function to restrict.
				 * @returns {Function} Returns the new restricted function.
				 * @example
				 *
				 * var saves = ['profile', 'settings'];
				 *
				 * var done = _.after(saves.length, function() {
				 *   console.log('done saving!');
				 * });
				 *
				 * _.forEach(saves, function(type) {
				 *   asyncSave({ 'type': type, 'complete': done });
				 * });
				 * // => Logs 'done saving!' after the two async saves have completed.
				 */
				function after(n, func) {
					if (typeof func != 'function') {
						throw new TypeError(FUNC_ERROR_TEXT);
					}
					n = toInteger(n);
					return function () {
						if (--n < 1) {
							return func.apply(this, arguments);
						}
					};
				}

				/**
				 * Creates a function that invokes `func`, with up to `n` arguments,
				 * ignoring any additional arguments.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Function
				 * @param {Function} func The function to cap arguments for.
				 * @param {number} [n=func.length] The arity cap.
				 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
				 * @returns {Function} Returns the new capped function.
				 * @example
				 *
				 * _.map(['6', '8', '10'], _.ary(parseInt, 1));
				 * // => [6, 8, 10]
				 */
				function ary(func, n, guard) {
					n = guard ? undefined$1 : n;
					n = (func && n == null) ? func.length : n;
					return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
				}

				/**
				 * Creates a function that invokes `func`, with the `this` binding and arguments
				 * of the created function, while it's called less than `n` times. Subsequent
				 * calls to the created function return the result of the last `func` invocation.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Function
				 * @param {number} n The number of calls at which `func` is no longer invoked.
				 * @param {Function} func The function to restrict.
				 * @returns {Function} Returns the new restricted function.
				 * @example
				 *
				 * jQuery(element).on('click', _.before(5, addContactToList));
				 * // => Allows adding up to 4 contacts to the list.
				 */
				function before(n, func) {
					var result;
					if (typeof func != 'function') {
						throw new TypeError(FUNC_ERROR_TEXT);
					}
					n = toInteger(n);
					return function () {
						if (--n > 0) {
							result = func.apply(this, arguments);
						}
						if (n <= 1) {
							func = undefined$1;
						}
						return result;
					};
				}

				/**
				 * Creates a function that invokes `func` with the `this` binding of `thisArg`
				 * and `partials` prepended to the arguments it receives.
				 *
				 * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
				 * may be used as a placeholder for partially applied arguments.
				 *
				 * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
				 * property of bound functions.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Function
				 * @param {Function} func The function to bind.
				 * @param {*} thisArg The `this` binding of `func`.
				 * @param {...*} [partials] The arguments to be partially applied.
				 * @returns {Function} Returns the new bound function.
				 * @example
				 *
				 * function greet(greeting, punctuation) {
				 *   return greeting + ' ' + this.user + punctuation;
				 * }
				 *
				 * var object = { 'user': 'fred' };
				 *
				 * var bound = _.bind(greet, object, 'hi');
				 * bound('!');
				 * // => 'hi fred!'
				 *
				 * // Bound with placeholders.
				 * var bound = _.bind(greet, object, _, '!');
				 * bound('hi');
				 * // => 'hi fred!'
				 */
				var bind = baseRest(function (func, thisArg, partials) {
					var bitmask = WRAP_BIND_FLAG;
					if (partials.length) {
						var holders = replaceHolders(partials, getHolder(bind));
						bitmask |= WRAP_PARTIAL_FLAG;
					}
					return createWrap(func, bitmask, thisArg, partials, holders);
				});

				/**
				 * Creates a function that invokes the method at `object[key]` with `partials`
				 * prepended to the arguments it receives.
				 *
				 * This method differs from `_.bind` by allowing bound functions to reference
				 * methods that may be redefined or don't yet exist. See
				 * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
				 * for more details.
				 *
				 * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
				 * builds, may be used as a placeholder for partially applied arguments.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.10.0
				 * @category Function
				 * @param {Object} object The object to invoke the method on.
				 * @param {string} key The key of the method.
				 * @param {...*} [partials] The arguments to be partially applied.
				 * @returns {Function} Returns the new bound function.
				 * @example
				 *
				 * var object = {
				 *   'user': 'fred',
				 *   'greet': function(greeting, punctuation) {
				 *     return greeting + ' ' + this.user + punctuation;
				 *   }
				 * };
				 *
				 * var bound = _.bindKey(object, 'greet', 'hi');
				 * bound('!');
				 * // => 'hi fred!'
				 *
				 * object.greet = function(greeting, punctuation) {
				 *   return greeting + 'ya ' + this.user + punctuation;
				 * };
				 *
				 * bound('!');
				 * // => 'hiya fred!'
				 *
				 * // Bound with placeholders.
				 * var bound = _.bindKey(object, 'greet', _, '!');
				 * bound('hi');
				 * // => 'hiya fred!'
				 */
				var bindKey = baseRest(function (object, key, partials) {
					var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
					if (partials.length) {
						var holders = replaceHolders(partials, getHolder(bindKey));
						bitmask |= WRAP_PARTIAL_FLAG;
					}
					return createWrap(key, bitmask, object, partials, holders);
				});

				/**
				 * Creates a function that accepts arguments of `func` and either invokes
				 * `func` returning its result, if at least `arity` number of arguments have
				 * been provided, or returns a function that accepts the remaining `func`
				 * arguments, and so on. The arity of `func` may be specified if `func.length`
				 * is not sufficient.
				 *
				 * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
				 * may be used as a placeholder for provided arguments.
				 *
				 * **Note:** This method doesn't set the "length" property of curried functions.
				 *
				 * @static
				 * @memberOf _
				 * @since 2.0.0
				 * @category Function
				 * @param {Function} func The function to curry.
				 * @param {number} [arity=func.length] The arity of `func`.
				 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
				 * @returns {Function} Returns the new curried function.
				 * @example
				 *
				 * var abc = function(a, b, c) {
				 *   return [a, b, c];
				 * };
				 *
				 * var curried = _.curry(abc);
				 *
				 * curried(1)(2)(3);
				 * // => [1, 2, 3]
				 *
				 * curried(1, 2)(3);
				 * // => [1, 2, 3]
				 *
				 * curried(1, 2, 3);
				 * // => [1, 2, 3]
				 *
				 * // Curried with placeholders.
				 * curried(1)(_, 3)(2);
				 * // => [1, 2, 3]
				 */
				function curry(func, arity, guard) {
					arity = guard ? undefined$1 : arity;
					var result = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
					result.placeholder = curry.placeholder;
					return result;
				}

				/**
				 * This method is like `_.curry` except that arguments are applied to `func`
				 * in the manner of `_.partialRight` instead of `_.partial`.
				 *
				 * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
				 * builds, may be used as a placeholder for provided arguments.
				 *
				 * **Note:** This method doesn't set the "length" property of curried functions.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Function
				 * @param {Function} func The function to curry.
				 * @param {number} [arity=func.length] The arity of `func`.
				 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
				 * @returns {Function} Returns the new curried function.
				 * @example
				 *
				 * var abc = function(a, b, c) {
				 *   return [a, b, c];
				 * };
				 *
				 * var curried = _.curryRight(abc);
				 *
				 * curried(3)(2)(1);
				 * // => [1, 2, 3]
				 *
				 * curried(2, 3)(1);
				 * // => [1, 2, 3]
				 *
				 * curried(1, 2, 3);
				 * // => [1, 2, 3]
				 *
				 * // Curried with placeholders.
				 * curried(3)(1, _)(2);
				 * // => [1, 2, 3]
				 */
				function curryRight(func, arity, guard) {
					arity = guard ? undefined$1 : arity;
					var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
					result.placeholder = curryRight.placeholder;
					return result;
				}

				/**
				 * Creates a debounced function that delays invoking `func` until after `wait`
				 * milliseconds have elapsed since the last time the debounced function was
				 * invoked. The debounced function comes with a `cancel` method to cancel
				 * delayed `func` invocations and a `flush` method to immediately invoke them.
				 * Provide `options` to indicate whether `func` should be invoked on the
				 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
				 * with the last arguments provided to the debounced function. Subsequent
				 * calls to the debounced function return the result of the last `func`
				 * invocation.
				 *
				 * **Note:** If `leading` and `trailing` options are `true`, `func` is
				 * invoked on the trailing edge of the timeout only if the debounced function
				 * is invoked more than once during the `wait` timeout.
				 *
				 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
				 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
				 *
				 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
				 * for details over the differences between `_.debounce` and `_.throttle`.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Function
				 * @param {Function} func The function to debounce.
				 * @param {number} [wait=0] The number of milliseconds to delay.
				 * @param {Object} [options={}] The options object.
				 * @param {boolean} [options.leading=false]
				 *  Specify invoking on the leading edge of the timeout.
				 * @param {number} [options.maxWait]
				 *  The maximum time `func` is allowed to be delayed before it's invoked.
				 * @param {boolean} [options.trailing=true]
				 *  Specify invoking on the trailing edge of the timeout.
				 * @returns {Function} Returns the new debounced function.
				 * @example
				 *
				 * // Avoid costly calculations while the window size is in flux.
				 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
				 *
				 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
				 * jQuery(element).on('click', _.debounce(sendMail, 300, {
				 *   'leading': true,
				 *   'trailing': false
				 * }));
				 *
				 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
				 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
				 * var source = new EventSource('/stream');
				 * jQuery(source).on('message', debounced);
				 *
				 * // Cancel the trailing debounced invocation.
				 * jQuery(window).on('popstate', debounced.cancel);
				 */
				function debounce(func, wait, options) {
					var lastArgs,
						lastThis,
						maxWait,
						result,
						timerId,
						lastCallTime,
						lastInvokeTime = 0,
						leading = false,
						maxing = false,
						trailing = true;

					if (typeof func != 'function') {
						throw new TypeError(FUNC_ERROR_TEXT);
					}
					wait = toNumber(wait) || 0;
					if (isObject(options)) {
						leading = !!options.leading;
						maxing = 'maxWait' in options;
						maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
						trailing = 'trailing' in options ? !!options.trailing : trailing;
					}

					function invokeFunc(time) {
						var args = lastArgs,
							thisArg = lastThis;

						lastArgs = lastThis = undefined$1;
						lastInvokeTime = time;
						result = func.apply(thisArg, args);
						return result;
					}

					function leadingEdge(time) {
						// Reset any `maxWait` timer.
						lastInvokeTime = time;
						// Start the timer for the trailing edge.
						timerId = setTimeout(timerExpired, wait);
						// Invoke the leading edge.
						return leading ? invokeFunc(time) : result;
					}

					function remainingWait(time) {
						var timeSinceLastCall = time - lastCallTime,
							timeSinceLastInvoke = time - lastInvokeTime,
							timeWaiting = wait - timeSinceLastCall;

						return maxing
							? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
							: timeWaiting;
					}

					function shouldInvoke(time) {
						var timeSinceLastCall = time - lastCallTime,
							timeSinceLastInvoke = time - lastInvokeTime;

						// Either this is the first call, activity has stopped and we're at the
						// trailing edge, the system time has gone backwards and we're treating
						// it as the trailing edge, or we've hit the `maxWait` limit.
						return (lastCallTime === undefined$1 || (timeSinceLastCall >= wait) ||
							(timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
					}

					function timerExpired() {
						var time = now();
						if (shouldInvoke(time)) {
							return trailingEdge(time);
						}
						// Restart the timer.
						timerId = setTimeout(timerExpired, remainingWait(time));
					}

					function trailingEdge(time) {
						timerId = undefined$1;

						// Only invoke if we have `lastArgs` which means `func` has been
						// debounced at least once.
						if (trailing && lastArgs) {
							return invokeFunc(time);
						}
						lastArgs = lastThis = undefined$1;
						return result;
					}

					function cancel() {
						if (timerId !== undefined$1) {
							clearTimeout(timerId);
						}
						lastInvokeTime = 0;
						lastArgs = lastCallTime = lastThis = timerId = undefined$1;
					}

					function flush() {
						return timerId === undefined$1 ? result : trailingEdge(now());
					}

					function debounced() {
						var time = now(),
							isInvoking = shouldInvoke(time);

						lastArgs = arguments;
						lastThis = this;
						lastCallTime = time;

						if (isInvoking) {
							if (timerId === undefined$1) {
								return leadingEdge(lastCallTime);
							}
							if (maxing) {
								// Handle invocations in a tight loop.
								clearTimeout(timerId);
								timerId = setTimeout(timerExpired, wait);
								return invokeFunc(lastCallTime);
							}
						}
						if (timerId === undefined$1) {
							timerId = setTimeout(timerExpired, wait);
						}
						return result;
					}
					debounced.cancel = cancel;
					debounced.flush = flush;
					return debounced;
				}

				/**
				 * Defers invoking the `func` until the current call stack has cleared. Any
				 * additional arguments are provided to `func` when it's invoked.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Function
				 * @param {Function} func The function to defer.
				 * @param {...*} [args] The arguments to invoke `func` with.
				 * @returns {number} Returns the timer id.
				 * @example
				 *
				 * _.defer(function(text) {
				 *   console.log(text);
				 * }, 'deferred');
				 * // => Logs 'deferred' after one millisecond.
				 */
				var defer = baseRest(function (func, args) {
					return baseDelay(func, 1, args);
				});

				/**
				 * Invokes `func` after `wait` milliseconds. Any additional arguments are
				 * provided to `func` when it's invoked.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Function
				 * @param {Function} func The function to delay.
				 * @param {number} wait The number of milliseconds to delay invocation.
				 * @param {...*} [args] The arguments to invoke `func` with.
				 * @returns {number} Returns the timer id.
				 * @example
				 *
				 * _.delay(function(text) {
				 *   console.log(text);
				 * }, 1000, 'later');
				 * // => Logs 'later' after one second.
				 */
				var delay = baseRest(function (func, wait, args) {
					return baseDelay(func, toNumber(wait) || 0, args);
				});

				/**
				 * Creates a function that invokes `func` with arguments reversed.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Function
				 * @param {Function} func The function to flip arguments for.
				 * @returns {Function} Returns the new flipped function.
				 * @example
				 *
				 * var flipped = _.flip(function() {
				 *   return _.toArray(arguments);
				 * });
				 *
				 * flipped('a', 'b', 'c', 'd');
				 * // => ['d', 'c', 'b', 'a']
				 */
				function flip(func) {
					return createWrap(func, WRAP_FLIP_FLAG);
				}

				/**
				 * Creates a function that memoizes the result of `func`. If `resolver` is
				 * provided, it determines the cache key for storing the result based on the
				 * arguments provided to the memoized function. By default, the first argument
				 * provided to the memoized function is used as the map cache key. The `func`
				 * is invoked with the `this` binding of the memoized function.
				 *
				 * **Note:** The cache is exposed as the `cache` property on the memoized
				 * function. Its creation may be customized by replacing the `_.memoize.Cache`
				 * constructor with one whose instances implement the
				 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
				 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Function
				 * @param {Function} func The function to have its output memoized.
				 * @param {Function} [resolver] The function to resolve the cache key.
				 * @returns {Function} Returns the new memoized function.
				 * @example
				 *
				 * var object = { 'a': 1, 'b': 2 };
				 * var other = { 'c': 3, 'd': 4 };
				 *
				 * var values = _.memoize(_.values);
				 * values(object);
				 * // => [1, 2]
				 *
				 * values(other);
				 * // => [3, 4]
				 *
				 * object.a = 2;
				 * values(object);
				 * // => [1, 2]
				 *
				 * // Modify the result cache.
				 * values.cache.set(object, ['a', 'b']);
				 * values(object);
				 * // => ['a', 'b']
				 *
				 * // Replace `_.memoize.Cache`.
				 * _.memoize.Cache = WeakMap;
				 */
				function memoize(func, resolver) {
					if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
						throw new TypeError(FUNC_ERROR_TEXT);
					}
					var memoized = function () {
						var args = arguments,
							key = resolver ? resolver.apply(this, args) : args[0],
							cache = memoized.cache;

						if (cache.has(key)) {
							return cache.get(key);
						}
						var result = func.apply(this, args);
						memoized.cache = cache.set(key, result) || cache;
						return result;
					};
					memoized.cache = new (memoize.Cache || MapCache);
					return memoized;
				}

				// Expose `MapCache`.
				memoize.Cache = MapCache;

				/**
				 * Creates a function that negates the result of the predicate `func`. The
				 * `func` predicate is invoked with the `this` binding and arguments of the
				 * created function.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Function
				 * @param {Function} predicate The predicate to negate.
				 * @returns {Function} Returns the new negated function.
				 * @example
				 *
				 * function isEven(n) {
				 *   return n % 2 == 0;
				 * }
				 *
				 * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
				 * // => [1, 3, 5]
				 */
				function negate(predicate) {
					if (typeof predicate != 'function') {
						throw new TypeError(FUNC_ERROR_TEXT);
					}
					return function () {
						var args = arguments;
						switch (args.length) {
							case 0: return !predicate.call(this);
							case 1: return !predicate.call(this, args[0]);
							case 2: return !predicate.call(this, args[0], args[1]);
							case 3: return !predicate.call(this, args[0], args[1], args[2]);
						}
						return !predicate.apply(this, args);
					};
				}

				/**
				 * Creates a function that is restricted to invoking `func` once. Repeat calls
				 * to the function return the value of the first invocation. The `func` is
				 * invoked with the `this` binding and arguments of the created function.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Function
				 * @param {Function} func The function to restrict.
				 * @returns {Function} Returns the new restricted function.
				 * @example
				 *
				 * var initialize = _.once(createApplication);
				 * initialize();
				 * initialize();
				 * // => `createApplication` is invoked once
				 */
				function once(func) {
					return before(2, func);
				}

				/**
				 * Creates a function that invokes `func` with its arguments transformed.
				 *
				 * @static
				 * @since 4.0.0
				 * @memberOf _
				 * @category Function
				 * @param {Function} func The function to wrap.
				 * @param {...(Function|Function[])} [transforms=[_.identity]]
				 *  The argument transforms.
				 * @returns {Function} Returns the new function.
				 * @example
				 *
				 * function doubled(n) {
				 *   return n * 2;
				 * }
				 *
				 * function square(n) {
				 *   return n * n;
				 * }
				 *
				 * var func = _.overArgs(function(x, y) {
				 *   return [x, y];
				 * }, [square, doubled]);
				 *
				 * func(9, 3);
				 * // => [81, 6]
				 *
				 * func(10, 5);
				 * // => [100, 10]
				 */
				var overArgs = castRest(function (func, transforms) {
					transforms = (transforms.length == 1 && isArray(transforms[0]))
						? arrayMap(transforms[0], baseUnary(getIteratee()))
						: arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

					var funcsLength = transforms.length;
					return baseRest(function (args) {
						var index = -1,
							length = nativeMin(args.length, funcsLength);

						while (++index < length) {
							args[index] = transforms[index].call(this, args[index]);
						}
						return apply(func, this, args);
					});
				});

				/**
				 * Creates a function that invokes `func` with `partials` prepended to the
				 * arguments it receives. This method is like `_.bind` except it does **not**
				 * alter the `this` binding.
				 *
				 * The `_.partial.placeholder` value, which defaults to `_` in monolithic
				 * builds, may be used as a placeholder for partially applied arguments.
				 *
				 * **Note:** This method doesn't set the "length" property of partially
				 * applied functions.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.2.0
				 * @category Function
				 * @param {Function} func The function to partially apply arguments to.
				 * @param {...*} [partials] The arguments to be partially applied.
				 * @returns {Function} Returns the new partially applied function.
				 * @example
				 *
				 * function greet(greeting, name) {
				 *   return greeting + ' ' + name;
				 * }
				 *
				 * var sayHelloTo = _.partial(greet, 'hello');
				 * sayHelloTo('fred');
				 * // => 'hello fred'
				 *
				 * // Partially applied with placeholders.
				 * var greetFred = _.partial(greet, _, 'fred');
				 * greetFred('hi');
				 * // => 'hi fred'
				 */
				var partial = baseRest(function (func, partials) {
					var holders = replaceHolders(partials, getHolder(partial));
					return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
				});

				/**
				 * This method is like `_.partial` except that partially applied arguments
				 * are appended to the arguments it receives.
				 *
				 * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
				 * builds, may be used as a placeholder for partially applied arguments.
				 *
				 * **Note:** This method doesn't set the "length" property of partially
				 * applied functions.
				 *
				 * @static
				 * @memberOf _
				 * @since 1.0.0
				 * @category Function
				 * @param {Function} func The function to partially apply arguments to.
				 * @param {...*} [partials] The arguments to be partially applied.
				 * @returns {Function} Returns the new partially applied function.
				 * @example
				 *
				 * function greet(greeting, name) {
				 *   return greeting + ' ' + name;
				 * }
				 *
				 * var greetFred = _.partialRight(greet, 'fred');
				 * greetFred('hi');
				 * // => 'hi fred'
				 *
				 * // Partially applied with placeholders.
				 * var sayHelloTo = _.partialRight(greet, 'hello', _);
				 * sayHelloTo('fred');
				 * // => 'hello fred'
				 */
				var partialRight = baseRest(function (func, partials) {
					var holders = replaceHolders(partials, getHolder(partialRight));
					return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
				});

				/**
				 * Creates a function that invokes `func` with arguments arranged according
				 * to the specified `indexes` where the argument value at the first index is
				 * provided as the first argument, the argument value at the second index is
				 * provided as the second argument, and so on.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Function
				 * @param {Function} func The function to rearrange arguments for.
				 * @param {...(number|number[])} indexes The arranged argument indexes.
				 * @returns {Function} Returns the new function.
				 * @example
				 *
				 * var rearged = _.rearg(function(a, b, c) {
				 *   return [a, b, c];
				 * }, [2, 0, 1]);
				 *
				 * rearged('b', 'c', 'a')
				 * // => ['a', 'b', 'c']
				 */
				var rearg = flatRest(function (func, indexes) {
					return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
				});

				/**
				 * Creates a function that invokes `func` with the `this` binding of the
				 * created function and arguments from `start` and beyond provided as
				 * an array.
				 *
				 * **Note:** This method is based on the
				 * [rest parameter](https://mdn.io/rest_parameters).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Function
				 * @param {Function} func The function to apply a rest parameter to.
				 * @param {number} [start=func.length-1] The start position of the rest parameter.
				 * @returns {Function} Returns the new function.
				 * @example
				 *
				 * var say = _.rest(function(what, names) {
				 *   return what + ' ' + _.initial(names).join(', ') +
				 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
				 * });
				 *
				 * say('hello', 'fred', 'barney', 'pebbles');
				 * // => 'hello fred, barney, & pebbles'
				 */
				function rest(func, start) {
					if (typeof func != 'function') {
						throw new TypeError(FUNC_ERROR_TEXT);
					}
					start = start === undefined$1 ? start : toInteger(start);
					return baseRest(func, start);
				}

				/**
				 * Creates a function that invokes `func` with the `this` binding of the
				 * create function and an array of arguments much like
				 * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
				 *
				 * **Note:** This method is based on the
				 * [spread operator](https://mdn.io/spread_operator).
				 *
				 * @static
				 * @memberOf _
				 * @since 3.2.0
				 * @category Function
				 * @param {Function} func The function to spread arguments over.
				 * @param {number} [start=0] The start position of the spread.
				 * @returns {Function} Returns the new function.
				 * @example
				 *
				 * var say = _.spread(function(who, what) {
				 *   return who + ' says ' + what;
				 * });
				 *
				 * say(['fred', 'hello']);
				 * // => 'fred says hello'
				 *
				 * var numbers = Promise.all([
				 *   Promise.resolve(40),
				 *   Promise.resolve(36)
				 * ]);
				 *
				 * numbers.then(_.spread(function(x, y) {
				 *   return x + y;
				 * }));
				 * // => a Promise of 76
				 */
				function spread(func, start) {
					if (typeof func != 'function') {
						throw new TypeError(FUNC_ERROR_TEXT);
					}
					start = start == null ? 0 : nativeMax(toInteger(start), 0);
					return baseRest(function (args) {
						var array = args[start],
							otherArgs = castSlice(args, 0, start);

						if (array) {
							arrayPush(otherArgs, array);
						}
						return apply(func, this, otherArgs);
					});
				}

				/**
				 * Creates a throttled function that only invokes `func` at most once per
				 * every `wait` milliseconds. The throttled function comes with a `cancel`
				 * method to cancel delayed `func` invocations and a `flush` method to
				 * immediately invoke them. Provide `options` to indicate whether `func`
				 * should be invoked on the leading and/or trailing edge of the `wait`
				 * timeout. The `func` is invoked with the last arguments provided to the
				 * throttled function. Subsequent calls to the throttled function return the
				 * result of the last `func` invocation.
				 *
				 * **Note:** If `leading` and `trailing` options are `true`, `func` is
				 * invoked on the trailing edge of the timeout only if the throttled function
				 * is invoked more than once during the `wait` timeout.
				 *
				 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
				 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
				 *
				 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
				 * for details over the differences between `_.throttle` and `_.debounce`.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Function
				 * @param {Function} func The function to throttle.
				 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
				 * @param {Object} [options={}] The options object.
				 * @param {boolean} [options.leading=true]
				 *  Specify invoking on the leading edge of the timeout.
				 * @param {boolean} [options.trailing=true]
				 *  Specify invoking on the trailing edge of the timeout.
				 * @returns {Function} Returns the new throttled function.
				 * @example
				 *
				 * // Avoid excessively updating the position while scrolling.
				 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
				 *
				 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
				 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
				 * jQuery(element).on('click', throttled);
				 *
				 * // Cancel the trailing throttled invocation.
				 * jQuery(window).on('popstate', throttled.cancel);
				 */
				function throttle(func, wait, options) {
					var leading = true,
						trailing = true;

					if (typeof func != 'function') {
						throw new TypeError(FUNC_ERROR_TEXT);
					}
					if (isObject(options)) {
						leading = 'leading' in options ? !!options.leading : leading;
						trailing = 'trailing' in options ? !!options.trailing : trailing;
					}
					return debounce(func, wait, {
						'leading': leading,
						'maxWait': wait,
						'trailing': trailing
					});
				}

				/**
				 * Creates a function that accepts up to one argument, ignoring any
				 * additional arguments.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Function
				 * @param {Function} func The function to cap arguments for.
				 * @returns {Function} Returns the new capped function.
				 * @example
				 *
				 * _.map(['6', '8', '10'], _.unary(parseInt));
				 * // => [6, 8, 10]
				 */
				function unary(func) {
					return ary(func, 1);
				}

				/**
				 * Creates a function that provides `value` to `wrapper` as its first
				 * argument. Any additional arguments provided to the function are appended
				 * to those provided to the `wrapper`. The wrapper is invoked with the `this`
				 * binding of the created function.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Function
				 * @param {*} value The value to wrap.
				 * @param {Function} [wrapper=identity] The wrapper function.
				 * @returns {Function} Returns the new function.
				 * @example
				 *
				 * var p = _.wrap(_.escape, function(func, text) {
				 *   return '<p>' + func(text) + '</p>';
				 * });
				 *
				 * p('fred, barney, & pebbles');
				 * // => '<p>fred, barney, &amp; pebbles</p>'
				 */
				function wrap(value, wrapper) {
					return partial(castFunction(wrapper), value);
				}

				/*------------------------------------------------------------------------*/

				/**
				 * Casts `value` as an array if it's not one.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.4.0
				 * @category Lang
				 * @param {*} value The value to inspect.
				 * @returns {Array} Returns the cast array.
				 * @example
				 *
				 * _.castArray(1);
				 * // => [1]
				 *
				 * _.castArray({ 'a': 1 });
				 * // => [{ 'a': 1 }]
				 *
				 * _.castArray('abc');
				 * // => ['abc']
				 *
				 * _.castArray(null);
				 * // => [null]
				 *
				 * _.castArray(undefined);
				 * // => [undefined]
				 *
				 * _.castArray();
				 * // => []
				 *
				 * var array = [1, 2, 3];
				 * console.log(_.castArray(array) === array);
				 * // => true
				 */
				function castArray() {
					if (!arguments.length) {
						return [];
					}
					var value = arguments[0];
					return isArray(value) ? value : [value];
				}

				/**
				 * Creates a shallow clone of `value`.
				 *
				 * **Note:** This method is loosely based on the
				 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
				 * and supports cloning arrays, array buffers, booleans, date objects, maps,
				 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
				 * arrays. The own enumerable properties of `arguments` objects are cloned
				 * as plain objects. An empty object is returned for uncloneable values such
				 * as error objects, functions, DOM nodes, and WeakMaps.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Lang
				 * @param {*} value The value to clone.
				 * @returns {*} Returns the cloned value.
				 * @see _.cloneDeep
				 * @example
				 *
				 * var objects = [{ 'a': 1 }, { 'b': 2 }];
				 *
				 * var shallow = _.clone(objects);
				 * console.log(shallow[0] === objects[0]);
				 * // => true
				 */
				function clone(value) {
					return baseClone(value, CLONE_SYMBOLS_FLAG);
				}

				/**
				 * This method is like `_.clone` except that it accepts `customizer` which
				 * is invoked to produce the cloned value. If `customizer` returns `undefined`,
				 * cloning is handled by the method instead. The `customizer` is invoked with
				 * up to four arguments; (value [, index|key, object, stack]).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Lang
				 * @param {*} value The value to clone.
				 * @param {Function} [customizer] The function to customize cloning.
				 * @returns {*} Returns the cloned value.
				 * @see _.cloneDeepWith
				 * @example
				 *
				 * function customizer(value) {
				 *   if (_.isElement(value)) {
				 *     return value.cloneNode(false);
				 *   }
				 * }
				 *
				 * var el = _.cloneWith(document.body, customizer);
				 *
				 * console.log(el === document.body);
				 * // => false
				 * console.log(el.nodeName);
				 * // => 'BODY'
				 * console.log(el.childNodes.length);
				 * // => 0
				 */
				function cloneWith(value, customizer) {
					customizer = typeof customizer == 'function' ? customizer : undefined$1;
					return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
				}

				/**
				 * This method is like `_.clone` except that it recursively clones `value`.
				 *
				 * @static
				 * @memberOf _
				 * @since 1.0.0
				 * @category Lang
				 * @param {*} value The value to recursively clone.
				 * @returns {*} Returns the deep cloned value.
				 * @see _.clone
				 * @example
				 *
				 * var objects = [{ 'a': 1 }, { 'b': 2 }];
				 *
				 * var deep = _.cloneDeep(objects);
				 * console.log(deep[0] === objects[0]);
				 * // => false
				 */
				function cloneDeep(value) {
					return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
				}

				/**
				 * This method is like `_.cloneWith` except that it recursively clones `value`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Lang
				 * @param {*} value The value to recursively clone.
				 * @param {Function} [customizer] The function to customize cloning.
				 * @returns {*} Returns the deep cloned value.
				 * @see _.cloneWith
				 * @example
				 *
				 * function customizer(value) {
				 *   if (_.isElement(value)) {
				 *     return value.cloneNode(true);
				 *   }
				 * }
				 *
				 * var el = _.cloneDeepWith(document.body, customizer);
				 *
				 * console.log(el === document.body);
				 * // => false
				 * console.log(el.nodeName);
				 * // => 'BODY'
				 * console.log(el.childNodes.length);
				 * // => 20
				 */
				function cloneDeepWith(value, customizer) {
					customizer = typeof customizer == 'function' ? customizer : undefined$1;
					return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
				}

				/**
				 * Checks if `object` conforms to `source` by invoking the predicate
				 * properties of `source` with the corresponding property values of `object`.
				 *
				 * **Note:** This method is equivalent to `_.conforms` when `source` is
				 * partially applied.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.14.0
				 * @category Lang
				 * @param {Object} object The object to inspect.
				 * @param {Object} source The object of property predicates to conform to.
				 * @returns {boolean} Returns `true` if `object` conforms, else `false`.
				 * @example
				 *
				 * var object = { 'a': 1, 'b': 2 };
				 *
				 * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
				 * // => true
				 *
				 * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
				 * // => false
				 */
				function conformsTo(object, source) {
					return source == null || baseConformsTo(object, source, keys(source));
				}

				/**
				 * Performs a
				 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
				 * comparison between two values to determine if they are equivalent.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Lang
				 * @param {*} value The value to compare.
				 * @param {*} other The other value to compare.
				 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
				 * @example
				 *
				 * var object = { 'a': 1 };
				 * var other = { 'a': 1 };
				 *
				 * _.eq(object, object);
				 * // => true
				 *
				 * _.eq(object, other);
				 * // => false
				 *
				 * _.eq('a', 'a');
				 * // => true
				 *
				 * _.eq('a', Object('a'));
				 * // => false
				 *
				 * _.eq(NaN, NaN);
				 * // => true
				 */
				function eq(value, other) {
					return value === other || (value !== value && other !== other);
				}

				/**
				 * Checks if `value` is greater than `other`.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.9.0
				 * @category Lang
				 * @param {*} value The value to compare.
				 * @param {*} other The other value to compare.
				 * @returns {boolean} Returns `true` if `value` is greater than `other`,
				 *  else `false`.
				 * @see _.lt
				 * @example
				 *
				 * _.gt(3, 1);
				 * // => true
				 *
				 * _.gt(3, 3);
				 * // => false
				 *
				 * _.gt(1, 3);
				 * // => false
				 */
				var gt = createRelationalOperation(baseGt);

				/**
				 * Checks if `value` is greater than or equal to `other`.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.9.0
				 * @category Lang
				 * @param {*} value The value to compare.
				 * @param {*} other The other value to compare.
				 * @returns {boolean} Returns `true` if `value` is greater than or equal to
				 *  `other`, else `false`.
				 * @see _.lte
				 * @example
				 *
				 * _.gte(3, 1);
				 * // => true
				 *
				 * _.gte(3, 3);
				 * // => true
				 *
				 * _.gte(1, 3);
				 * // => false
				 */
				var gte = createRelationalOperation(function (value, other) {
					return value >= other;
				});

				/**
				 * Checks if `value` is likely an `arguments` object.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
				 *  else `false`.
				 * @example
				 *
				 * _.isArguments(function() { return arguments; }());
				 * // => true
				 *
				 * _.isArguments([1, 2, 3]);
				 * // => false
				 */
				var isArguments = baseIsArguments(function () { return arguments; }()) ? baseIsArguments : function (value) {
					return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
						!propertyIsEnumerable.call(value, 'callee');
				};

				/**
				 * Checks if `value` is classified as an `Array` object.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
				 * @example
				 *
				 * _.isArray([1, 2, 3]);
				 * // => true
				 *
				 * _.isArray(document.body.children);
				 * // => false
				 *
				 * _.isArray('abc');
				 * // => false
				 *
				 * _.isArray(_.noop);
				 * // => false
				 */
				var isArray = Array.isArray;

				/**
				 * Checks if `value` is classified as an `ArrayBuffer` object.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.3.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
				 * @example
				 *
				 * _.isArrayBuffer(new ArrayBuffer(2));
				 * // => true
				 *
				 * _.isArrayBuffer(new Array(2));
				 * // => false
				 */
				var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

				/**
				 * Checks if `value` is array-like. A value is considered array-like if it's
				 * not a function and has a `value.length` that's an integer greater than or
				 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
				 * @example
				 *
				 * _.isArrayLike([1, 2, 3]);
				 * // => true
				 *
				 * _.isArrayLike(document.body.children);
				 * // => true
				 *
				 * _.isArrayLike('abc');
				 * // => true
				 *
				 * _.isArrayLike(_.noop);
				 * // => false
				 */
				function isArrayLike(value) {
					return value != null && isLength(value.length) && !isFunction(value);
				}

				/**
				 * This method is like `_.isArrayLike` except that it also checks if `value`
				 * is an object.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is an array-like object,
				 *  else `false`.
				 * @example
				 *
				 * _.isArrayLikeObject([1, 2, 3]);
				 * // => true
				 *
				 * _.isArrayLikeObject(document.body.children);
				 * // => true
				 *
				 * _.isArrayLikeObject('abc');
				 * // => false
				 *
				 * _.isArrayLikeObject(_.noop);
				 * // => false
				 */
				function isArrayLikeObject(value) {
					return isObjectLike(value) && isArrayLike(value);
				}

				/**
				 * Checks if `value` is classified as a boolean primitive or object.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
				 * @example
				 *
				 * _.isBoolean(false);
				 * // => true
				 *
				 * _.isBoolean(null);
				 * // => false
				 */
				function isBoolean(value) {
					return value === true || value === false ||
						(isObjectLike(value) && baseGetTag(value) == boolTag);
				}

				/**
				 * Checks if `value` is a buffer.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.3.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
				 * @example
				 *
				 * _.isBuffer(new Buffer(2));
				 * // => true
				 *
				 * _.isBuffer(new Uint8Array(2));
				 * // => false
				 */
				var isBuffer = nativeIsBuffer || stubFalse;

				/**
				 * Checks if `value` is classified as a `Date` object.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
				 * @example
				 *
				 * _.isDate(new Date);
				 * // => true
				 *
				 * _.isDate('Mon April 23 2012');
				 * // => false
				 */
				var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

				/**
				 * Checks if `value` is likely a DOM element.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
				 * @example
				 *
				 * _.isElement(document.body);
				 * // => true
				 *
				 * _.isElement('<body>');
				 * // => false
				 */
				function isElement(value) {
					return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
				}

				/**
				 * Checks if `value` is an empty object, collection, map, or set.
				 *
				 * Objects are considered empty if they have no own enumerable string keyed
				 * properties.
				 *
				 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
				 * jQuery-like collections are considered empty if they have a `length` of `0`.
				 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
				 * @example
				 *
				 * _.isEmpty(null);
				 * // => true
				 *
				 * _.isEmpty(true);
				 * // => true
				 *
				 * _.isEmpty(1);
				 * // => true
				 *
				 * _.isEmpty([1, 2, 3]);
				 * // => false
				 *
				 * _.isEmpty({ 'a': 1 });
				 * // => false
				 */
				function isEmpty(value) {
					if (value == null) {
						return true;
					}
					if (isArrayLike(value) &&
						(isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
							isBuffer(value) || isTypedArray(value) || isArguments(value))) {
						return !value.length;
					}
					var tag = getTag(value);
					if (tag == mapTag || tag == setTag) {
						return !value.size;
					}
					if (isPrototype(value)) {
						return !baseKeys(value).length;
					}
					for (var key in value) {
						if (hasOwnProperty.call(value, key)) {
							return false;
						}
					}
					return true;
				}

				/**
				 * Performs a deep comparison between two values to determine if they are
				 * equivalent.
				 *
				 * **Note:** This method supports comparing arrays, array buffers, booleans,
				 * date objects, error objects, maps, numbers, `Object` objects, regexes,
				 * sets, strings, symbols, and typed arrays. `Object` objects are compared
				 * by their own, not inherited, enumerable properties. Functions and DOM
				 * nodes are compared by strict equality, i.e. `===`.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Lang
				 * @param {*} value The value to compare.
				 * @param {*} other The other value to compare.
				 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
				 * @example
				 *
				 * var object = { 'a': 1 };
				 * var other = { 'a': 1 };
				 *
				 * _.isEqual(object, other);
				 * // => true
				 *
				 * object === other;
				 * // => false
				 */
				function isEqual(value, other) {
					return baseIsEqual(value, other);
				}

				/**
				 * This method is like `_.isEqual` except that it accepts `customizer` which
				 * is invoked to compare values. If `customizer` returns `undefined`, comparisons
				 * are handled by the method instead. The `customizer` is invoked with up to
				 * six arguments: (objValue, othValue [, index|key, object, other, stack]).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Lang
				 * @param {*} value The value to compare.
				 * @param {*} other The other value to compare.
				 * @param {Function} [customizer] The function to customize comparisons.
				 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
				 * @example
				 *
				 * function isGreeting(value) {
				 *   return /^h(?:i|ello)$/.test(value);
				 * }
				 *
				 * function customizer(objValue, othValue) {
				 *   if (isGreeting(objValue) && isGreeting(othValue)) {
				 *     return true;
				 *   }
				 * }
				 *
				 * var array = ['hello', 'goodbye'];
				 * var other = ['hi', 'goodbye'];
				 *
				 * _.isEqualWith(array, other, customizer);
				 * // => true
				 */
				function isEqualWith(value, other, customizer) {
					customizer = typeof customizer == 'function' ? customizer : undefined$1;
					var result = customizer ? customizer(value, other) : undefined$1;
					return result === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result;
				}

				/**
				 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
				 * `SyntaxError`, `TypeError`, or `URIError` object.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
				 * @example
				 *
				 * _.isError(new Error);
				 * // => true
				 *
				 * _.isError(Error);
				 * // => false
				 */
				function isError(value) {
					if (!isObjectLike(value)) {
						return false;
					}
					var tag = baseGetTag(value);
					return tag == errorTag || tag == domExcTag ||
						(typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
				}

				/**
				 * Checks if `value` is a finite primitive number.
				 *
				 * **Note:** This method is based on
				 * [`Number.isFinite`](https://mdn.io/Number/isFinite).
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
				 * @example
				 *
				 * _.isFinite(3);
				 * // => true
				 *
				 * _.isFinite(Number.MIN_VALUE);
				 * // => true
				 *
				 * _.isFinite(Infinity);
				 * // => false
				 *
				 * _.isFinite('3');
				 * // => false
				 */
				function isFinite(value) {
					return typeof value == 'number' && nativeIsFinite(value);
				}

				/**
				 * Checks if `value` is classified as a `Function` object.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
				 * @example
				 *
				 * _.isFunction(_);
				 * // => true
				 *
				 * _.isFunction(/abc/);
				 * // => false
				 */
				function isFunction(value) {
					if (!isObject(value)) {
						return false;
					}
					// The use of `Object#toString` avoids issues with the `typeof` operator
					// in Safari 9 which returns 'object' for typed arrays and other constructors.
					var tag = baseGetTag(value);
					return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
				}

				/**
				 * Checks if `value` is an integer.
				 *
				 * **Note:** This method is based on
				 * [`Number.isInteger`](https://mdn.io/Number/isInteger).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
				 * @example
				 *
				 * _.isInteger(3);
				 * // => true
				 *
				 * _.isInteger(Number.MIN_VALUE);
				 * // => false
				 *
				 * _.isInteger(Infinity);
				 * // => false
				 *
				 * _.isInteger('3');
				 * // => false
				 */
				function isInteger(value) {
					return typeof value == 'number' && value == toInteger(value);
				}

				/**
				 * Checks if `value` is a valid array-like length.
				 *
				 * **Note:** This method is loosely based on
				 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
				 * @example
				 *
				 * _.isLength(3);
				 * // => true
				 *
				 * _.isLength(Number.MIN_VALUE);
				 * // => false
				 *
				 * _.isLength(Infinity);
				 * // => false
				 *
				 * _.isLength('3');
				 * // => false
				 */
				function isLength(value) {
					return typeof value == 'number' &&
						value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
				}

				/**
				 * Checks if `value` is the
				 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
				 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
				 * @example
				 *
				 * _.isObject({});
				 * // => true
				 *
				 * _.isObject([1, 2, 3]);
				 * // => true
				 *
				 * _.isObject(_.noop);
				 * // => true
				 *
				 * _.isObject(null);
				 * // => false
				 */
				function isObject(value) {
					var type = typeof value;
					return value != null && (type == 'object' || type == 'function');
				}

				/**
				 * Checks if `value` is object-like. A value is object-like if it's not `null`
				 * and has a `typeof` result of "object".
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
				 * @example
				 *
				 * _.isObjectLike({});
				 * // => true
				 *
				 * _.isObjectLike([1, 2, 3]);
				 * // => true
				 *
				 * _.isObjectLike(_.noop);
				 * // => false
				 *
				 * _.isObjectLike(null);
				 * // => false
				 */
				function isObjectLike(value) {
					return value != null && typeof value == 'object';
				}

				/**
				 * Checks if `value` is classified as a `Map` object.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.3.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
				 * @example
				 *
				 * _.isMap(new Map);
				 * // => true
				 *
				 * _.isMap(new WeakMap);
				 * // => false
				 */
				var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

				/**
				 * Performs a partial deep comparison between `object` and `source` to
				 * determine if `object` contains equivalent property values.
				 *
				 * **Note:** This method is equivalent to `_.matches` when `source` is
				 * partially applied.
				 *
				 * Partial comparisons will match empty array and empty object `source`
				 * values against any array or object value, respectively. See `_.isEqual`
				 * for a list of supported value comparisons.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Lang
				 * @param {Object} object The object to inspect.
				 * @param {Object} source The object of property values to match.
				 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
				 * @example
				 *
				 * var object = { 'a': 1, 'b': 2 };
				 *
				 * _.isMatch(object, { 'b': 2 });
				 * // => true
				 *
				 * _.isMatch(object, { 'b': 1 });
				 * // => false
				 */
				function isMatch(object, source) {
					return object === source || baseIsMatch(object, source, getMatchData(source));
				}

				/**
				 * This method is like `_.isMatch` except that it accepts `customizer` which
				 * is invoked to compare values. If `customizer` returns `undefined`, comparisons
				 * are handled by the method instead. The `customizer` is invoked with five
				 * arguments: (objValue, srcValue, index|key, object, source).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Lang
				 * @param {Object} object The object to inspect.
				 * @param {Object} source The object of property values to match.
				 * @param {Function} [customizer] The function to customize comparisons.
				 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
				 * @example
				 *
				 * function isGreeting(value) {
				 *   return /^h(?:i|ello)$/.test(value);
				 * }
				 *
				 * function customizer(objValue, srcValue) {
				 *   if (isGreeting(objValue) && isGreeting(srcValue)) {
				 *     return true;
				 *   }
				 * }
				 *
				 * var object = { 'greeting': 'hello' };
				 * var source = { 'greeting': 'hi' };
				 *
				 * _.isMatchWith(object, source, customizer);
				 * // => true
				 */
				function isMatchWith(object, source, customizer) {
					customizer = typeof customizer == 'function' ? customizer : undefined$1;
					return baseIsMatch(object, source, getMatchData(source), customizer);
				}

				/**
				 * Checks if `value` is `NaN`.
				 *
				 * **Note:** This method is based on
				 * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
				 * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
				 * `undefined` and other non-number values.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
				 * @example
				 *
				 * _.isNaN(NaN);
				 * // => true
				 *
				 * _.isNaN(new Number(NaN));
				 * // => true
				 *
				 * isNaN(undefined);
				 * // => true
				 *
				 * _.isNaN(undefined);
				 * // => false
				 */
				function isNaN(value) {
					// An `NaN` primitive is the only value that is not equal to itself.
					// Perform the `toStringTag` check first to avoid errors with some
					// ActiveX objects in IE.
					return isNumber(value) && value != +value;
				}

				/**
				 * Checks if `value` is a pristine native function.
				 *
				 * **Note:** This method can't reliably detect native functions in the presence
				 * of the core-js package because core-js circumvents this kind of detection.
				 * Despite multiple requests, the core-js maintainer has made it clear: any
				 * attempt to fix the detection will be obstructed. As a result, we're left
				 * with little choice but to throw an error. Unfortunately, this also affects
				 * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
				 * which rely on core-js.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a native function,
				 *  else `false`.
				 * @example
				 *
				 * _.isNative(Array.prototype.push);
				 * // => true
				 *
				 * _.isNative(_);
				 * // => false
				 */
				function isNative(value) {
					if (isMaskable(value)) {
						throw new Error(CORE_ERROR_TEXT);
					}
					return baseIsNative(value);
				}

				/**
				 * Checks if `value` is `null`.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
				 * @example
				 *
				 * _.isNull(null);
				 * // => true
				 *
				 * _.isNull(void 0);
				 * // => false
				 */
				function isNull(value) {
					return value === null;
				}

				/**
				 * Checks if `value` is `null` or `undefined`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
				 * @example
				 *
				 * _.isNil(null);
				 * // => true
				 *
				 * _.isNil(void 0);
				 * // => true
				 *
				 * _.isNil(NaN);
				 * // => false
				 */
				function isNil(value) {
					return value == null;
				}

				/**
				 * Checks if `value` is classified as a `Number` primitive or object.
				 *
				 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
				 * classified as numbers, use the `_.isFinite` method.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
				 * @example
				 *
				 * _.isNumber(3);
				 * // => true
				 *
				 * _.isNumber(Number.MIN_VALUE);
				 * // => true
				 *
				 * _.isNumber(Infinity);
				 * // => true
				 *
				 * _.isNumber('3');
				 * // => false
				 */
				function isNumber(value) {
					return typeof value == 'number' ||
						(isObjectLike(value) && baseGetTag(value) == numberTag);
				}

				/**
				 * Checks if `value` is a plain object, that is, an object created by the
				 * `Object` constructor or one with a `[[Prototype]]` of `null`.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.8.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
				 * @example
				 *
				 * function Foo() {
				 *   this.a = 1;
				 * }
				 *
				 * _.isPlainObject(new Foo);
				 * // => false
				 *
				 * _.isPlainObject([1, 2, 3]);
				 * // => false
				 *
				 * _.isPlainObject({ 'x': 0, 'y': 0 });
				 * // => true
				 *
				 * _.isPlainObject(Object.create(null));
				 * // => true
				 */
				function isPlainObject(value) {
					if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
						return false;
					}
					var proto = getPrototype(value);
					if (proto === null) {
						return true;
					}
					var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
					return typeof Ctor == 'function' && Ctor instanceof Ctor &&
						funcToString.call(Ctor) == objectCtorString;
				}

				/**
				 * Checks if `value` is classified as a `RegExp` object.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
				 * @example
				 *
				 * _.isRegExp(/abc/);
				 * // => true
				 *
				 * _.isRegExp('/abc/');
				 * // => false
				 */
				var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

				/**
				 * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
				 * double precision number which isn't the result of a rounded unsafe integer.
				 *
				 * **Note:** This method is based on
				 * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
				 * @example
				 *
				 * _.isSafeInteger(3);
				 * // => true
				 *
				 * _.isSafeInteger(Number.MIN_VALUE);
				 * // => false
				 *
				 * _.isSafeInteger(Infinity);
				 * // => false
				 *
				 * _.isSafeInteger('3');
				 * // => false
				 */
				function isSafeInteger(value) {
					return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
				}

				/**
				 * Checks if `value` is classified as a `Set` object.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.3.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
				 * @example
				 *
				 * _.isSet(new Set);
				 * // => true
				 *
				 * _.isSet(new WeakSet);
				 * // => false
				 */
				var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

				/**
				 * Checks if `value` is classified as a `String` primitive or object.
				 *
				 * @static
				 * @since 0.1.0
				 * @memberOf _
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
				 * @example
				 *
				 * _.isString('abc');
				 * // => true
				 *
				 * _.isString(1);
				 * // => false
				 */
				function isString(value) {
					return typeof value == 'string' ||
						(!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
				}

				/**
				 * Checks if `value` is classified as a `Symbol` primitive or object.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
				 * @example
				 *
				 * _.isSymbol(Symbol.iterator);
				 * // => true
				 *
				 * _.isSymbol('abc');
				 * // => false
				 */
				function isSymbol(value) {
					return typeof value == 'symbol' ||
						(isObjectLike(value) && baseGetTag(value) == symbolTag);
				}

				/**
				 * Checks if `value` is classified as a typed array.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
				 * @example
				 *
				 * _.isTypedArray(new Uint8Array);
				 * // => true
				 *
				 * _.isTypedArray([]);
				 * // => false
				 */
				var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

				/**
				 * Checks if `value` is `undefined`.
				 *
				 * @static
				 * @since 0.1.0
				 * @memberOf _
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
				 * @example
				 *
				 * _.isUndefined(void 0);
				 * // => true
				 *
				 * _.isUndefined(null);
				 * // => false
				 */
				function isUndefined(value) {
					return value === undefined$1;
				}

				/**
				 * Checks if `value` is classified as a `WeakMap` object.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.3.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
				 * @example
				 *
				 * _.isWeakMap(new WeakMap);
				 * // => true
				 *
				 * _.isWeakMap(new Map);
				 * // => false
				 */
				function isWeakMap(value) {
					return isObjectLike(value) && getTag(value) == weakMapTag;
				}

				/**
				 * Checks if `value` is classified as a `WeakSet` object.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.3.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
				 * @example
				 *
				 * _.isWeakSet(new WeakSet);
				 * // => true
				 *
				 * _.isWeakSet(new Set);
				 * // => false
				 */
				function isWeakSet(value) {
					return isObjectLike(value) && baseGetTag(value) == weakSetTag;
				}

				/**
				 * Checks if `value` is less than `other`.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.9.0
				 * @category Lang
				 * @param {*} value The value to compare.
				 * @param {*} other The other value to compare.
				 * @returns {boolean} Returns `true` if `value` is less than `other`,
				 *  else `false`.
				 * @see _.gt
				 * @example
				 *
				 * _.lt(1, 3);
				 * // => true
				 *
				 * _.lt(3, 3);
				 * // => false
				 *
				 * _.lt(3, 1);
				 * // => false
				 */
				var lt = createRelationalOperation(baseLt);

				/**
				 * Checks if `value` is less than or equal to `other`.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.9.0
				 * @category Lang
				 * @param {*} value The value to compare.
				 * @param {*} other The other value to compare.
				 * @returns {boolean} Returns `true` if `value` is less than or equal to
				 *  `other`, else `false`.
				 * @see _.gte
				 * @example
				 *
				 * _.lte(1, 3);
				 * // => true
				 *
				 * _.lte(3, 3);
				 * // => true
				 *
				 * _.lte(3, 1);
				 * // => false
				 */
				var lte = createRelationalOperation(function (value, other) {
					return value <= other;
				});

				/**
				 * Converts `value` to an array.
				 *
				 * @static
				 * @since 0.1.0
				 * @memberOf _
				 * @category Lang
				 * @param {*} value The value to convert.
				 * @returns {Array} Returns the converted array.
				 * @example
				 *
				 * _.toArray({ 'a': 1, 'b': 2 });
				 * // => [1, 2]
				 *
				 * _.toArray('abc');
				 * // => ['a', 'b', 'c']
				 *
				 * _.toArray(1);
				 * // => []
				 *
				 * _.toArray(null);
				 * // => []
				 */
				function toArray(value) {
					if (!value) {
						return [];
					}
					if (isArrayLike(value)) {
						return isString(value) ? stringToArray(value) : copyArray(value);
					}
					if (symIterator && value[symIterator]) {
						return iteratorToArray(value[symIterator]());
					}
					var tag = getTag(value),
						func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

					return func(value);
				}

				/**
				 * Converts `value` to a finite number.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.12.0
				 * @category Lang
				 * @param {*} value The value to convert.
				 * @returns {number} Returns the converted number.
				 * @example
				 *
				 * _.toFinite(3.2);
				 * // => 3.2
				 *
				 * _.toFinite(Number.MIN_VALUE);
				 * // => 5e-324
				 *
				 * _.toFinite(Infinity);
				 * // => 1.7976931348623157e+308
				 *
				 * _.toFinite('3.2');
				 * // => 3.2
				 */
				function toFinite(value) {
					if (!value) {
						return value === 0 ? value : 0;
					}
					value = toNumber(value);
					if (value === INFINITY || value === -INFINITY) {
						var sign = (value < 0 ? -1 : 1);
						return sign * MAX_INTEGER;
					}
					return value === value ? value : 0;
				}

				/**
				 * Converts `value` to an integer.
				 *
				 * **Note:** This method is loosely based on
				 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Lang
				 * @param {*} value The value to convert.
				 * @returns {number} Returns the converted integer.
				 * @example
				 *
				 * _.toInteger(3.2);
				 * // => 3
				 *
				 * _.toInteger(Number.MIN_VALUE);
				 * // => 0
				 *
				 * _.toInteger(Infinity);
				 * // => 1.7976931348623157e+308
				 *
				 * _.toInteger('3.2');
				 * // => 3
				 */
				function toInteger(value) {
					var result = toFinite(value),
						remainder = result % 1;

					return result === result ? (remainder ? result - remainder : result) : 0;
				}

				/**
				 * Converts `value` to an integer suitable for use as the length of an
				 * array-like object.
				 *
				 * **Note:** This method is based on
				 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Lang
				 * @param {*} value The value to convert.
				 * @returns {number} Returns the converted integer.
				 * @example
				 *
				 * _.toLength(3.2);
				 * // => 3
				 *
				 * _.toLength(Number.MIN_VALUE);
				 * // => 0
				 *
				 * _.toLength(Infinity);
				 * // => 4294967295
				 *
				 * _.toLength('3.2');
				 * // => 3
				 */
				function toLength(value) {
					return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
				}

				/**
				 * Converts `value` to a number.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Lang
				 * @param {*} value The value to process.
				 * @returns {number} Returns the number.
				 * @example
				 *
				 * _.toNumber(3.2);
				 * // => 3.2
				 *
				 * _.toNumber(Number.MIN_VALUE);
				 * // => 5e-324
				 *
				 * _.toNumber(Infinity);
				 * // => Infinity
				 *
				 * _.toNumber('3.2');
				 * // => 3.2
				 */
				function toNumber(value) {
					if (typeof value == 'number') {
						return value;
					}
					if (isSymbol(value)) {
						return NAN;
					}
					if (isObject(value)) {
						var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
						value = isObject(other) ? (other + '') : other;
					}
					if (typeof value != 'string') {
						return value === 0 ? value : +value;
					}
					value = baseTrim(value);
					var isBinary = reIsBinary.test(value);
					return (isBinary || reIsOctal.test(value))
						? freeParseInt(value.slice(2), isBinary ? 2 : 8)
						: (reIsBadHex.test(value) ? NAN : +value);
				}

				/**
				 * Converts `value` to a plain object flattening inherited enumerable string
				 * keyed properties of `value` to own properties of the plain object.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Lang
				 * @param {*} value The value to convert.
				 * @returns {Object} Returns the converted plain object.
				 * @example
				 *
				 * function Foo() {
				 *   this.b = 2;
				 * }
				 *
				 * Foo.prototype.c = 3;
				 *
				 * _.assign({ 'a': 1 }, new Foo);
				 * // => { 'a': 1, 'b': 2 }
				 *
				 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
				 * // => { 'a': 1, 'b': 2, 'c': 3 }
				 */
				function toPlainObject(value) {
					return copyObject(value, keysIn(value));
				}

				/**
				 * Converts `value` to a safe integer. A safe integer can be compared and
				 * represented correctly.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Lang
				 * @param {*} value The value to convert.
				 * @returns {number} Returns the converted integer.
				 * @example
				 *
				 * _.toSafeInteger(3.2);
				 * // => 3
				 *
				 * _.toSafeInteger(Number.MIN_VALUE);
				 * // => 0
				 *
				 * _.toSafeInteger(Infinity);
				 * // => 9007199254740991
				 *
				 * _.toSafeInteger('3.2');
				 * // => 3
				 */
				function toSafeInteger(value) {
					return value
						? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
						: (value === 0 ? value : 0);
				}

				/**
				 * Converts `value` to a string. An empty string is returned for `null`
				 * and `undefined` values. The sign of `-0` is preserved.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Lang
				 * @param {*} value The value to convert.
				 * @returns {string} Returns the converted string.
				 * @example
				 *
				 * _.toString(null);
				 * // => ''
				 *
				 * _.toString(-0);
				 * // => '-0'
				 *
				 * _.toString([1, 2, 3]);
				 * // => '1,2,3'
				 */
				function toString(value) {
					return value == null ? '' : baseToString(value);
				}

				/*------------------------------------------------------------------------*/

				/**
				 * Assigns own enumerable string keyed properties of source objects to the
				 * destination object. Source objects are applied from left to right.
				 * Subsequent sources overwrite property assignments of previous sources.
				 *
				 * **Note:** This method mutates `object` and is loosely based on
				 * [`Object.assign`](https://mdn.io/Object/assign).
				 *
				 * @static
				 * @memberOf _
				 * @since 0.10.0
				 * @category Object
				 * @param {Object} object The destination object.
				 * @param {...Object} [sources] The source objects.
				 * @returns {Object} Returns `object`.
				 * @see _.assignIn
				 * @example
				 *
				 * function Foo() {
				 *   this.a = 1;
				 * }
				 *
				 * function Bar() {
				 *   this.c = 3;
				 * }
				 *
				 * Foo.prototype.b = 2;
				 * Bar.prototype.d = 4;
				 *
				 * _.assign({ 'a': 0 }, new Foo, new Bar);
				 * // => { 'a': 1, 'c': 3 }
				 */
				var assign = createAssigner(function (object, source) {
					if (isPrototype(source) || isArrayLike(source)) {
						copyObject(source, keys(source), object);
						return;
					}
					for (var key in source) {
						if (hasOwnProperty.call(source, key)) {
							assignValue(object, key, source[key]);
						}
					}
				});

				/**
				 * This method is like `_.assign` except that it iterates over own and
				 * inherited source properties.
				 *
				 * **Note:** This method mutates `object`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @alias extend
				 * @category Object
				 * @param {Object} object The destination object.
				 * @param {...Object} [sources] The source objects.
				 * @returns {Object} Returns `object`.
				 * @see _.assign
				 * @example
				 *
				 * function Foo() {
				 *   this.a = 1;
				 * }
				 *
				 * function Bar() {
				 *   this.c = 3;
				 * }
				 *
				 * Foo.prototype.b = 2;
				 * Bar.prototype.d = 4;
				 *
				 * _.assignIn({ 'a': 0 }, new Foo, new Bar);
				 * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
				 */
				var assignIn = createAssigner(function (object, source) {
					copyObject(source, keysIn(source), object);
				});

				/**
				 * This method is like `_.assignIn` except that it accepts `customizer`
				 * which is invoked to produce the assigned values. If `customizer` returns
				 * `undefined`, assignment is handled by the method instead. The `customizer`
				 * is invoked with five arguments: (objValue, srcValue, key, object, source).
				 *
				 * **Note:** This method mutates `object`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @alias extendWith
				 * @category Object
				 * @param {Object} object The destination object.
				 * @param {...Object} sources The source objects.
				 * @param {Function} [customizer] The function to customize assigned values.
				 * @returns {Object} Returns `object`.
				 * @see _.assignWith
				 * @example
				 *
				 * function customizer(objValue, srcValue) {
				 *   return _.isUndefined(objValue) ? srcValue : objValue;
				 * }
				 *
				 * var defaults = _.partialRight(_.assignInWith, customizer);
				 *
				 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
				 * // => { 'a': 1, 'b': 2 }
				 */
				var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
					copyObject(source, keysIn(source), object, customizer);
				});

				/**
				 * This method is like `_.assign` except that it accepts `customizer`
				 * which is invoked to produce the assigned values. If `customizer` returns
				 * `undefined`, assignment is handled by the method instead. The `customizer`
				 * is invoked with five arguments: (objValue, srcValue, key, object, source).
				 *
				 * **Note:** This method mutates `object`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Object
				 * @param {Object} object The destination object.
				 * @param {...Object} sources The source objects.
				 * @param {Function} [customizer] The function to customize assigned values.
				 * @returns {Object} Returns `object`.
				 * @see _.assignInWith
				 * @example
				 *
				 * function customizer(objValue, srcValue) {
				 *   return _.isUndefined(objValue) ? srcValue : objValue;
				 * }
				 *
				 * var defaults = _.partialRight(_.assignWith, customizer);
				 *
				 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
				 * // => { 'a': 1, 'b': 2 }
				 */
				var assignWith = createAssigner(function (object, source, srcIndex, customizer) {
					copyObject(source, keys(source), object, customizer);
				});

				/**
				 * Creates an array of values corresponding to `paths` of `object`.
				 *
				 * @static
				 * @memberOf _
				 * @since 1.0.0
				 * @category Object
				 * @param {Object} object The object to iterate over.
				 * @param {...(string|string[])} [paths] The property paths to pick.
				 * @returns {Array} Returns the picked values.
				 * @example
				 *
				 * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
				 *
				 * _.at(object, ['a[0].b.c', 'a[1]']);
				 * // => [3, 4]
				 */
				var at = flatRest(baseAt);

				/**
				 * Creates an object that inherits from the `prototype` object. If a
				 * `properties` object is given, its own enumerable string keyed properties
				 * are assigned to the created object.
				 *
				 * @static
				 * @memberOf _
				 * @since 2.3.0
				 * @category Object
				 * @param {Object} prototype The object to inherit from.
				 * @param {Object} [properties] The properties to assign to the object.
				 * @returns {Object} Returns the new object.
				 * @example
				 *
				 * function Shape() {
				 *   this.x = 0;
				 *   this.y = 0;
				 * }
				 *
				 * function Circle() {
				 *   Shape.call(this);
				 * }
				 *
				 * Circle.prototype = _.create(Shape.prototype, {
				 *   'constructor': Circle
				 * });
				 *
				 * var circle = new Circle;
				 * circle instanceof Circle;
				 * // => true
				 *
				 * circle instanceof Shape;
				 * // => true
				 */
				function create(prototype, properties) {
					var result = baseCreate(prototype);
					return properties == null ? result : baseAssign(result, properties);
				}

				/**
				 * Assigns own and inherited enumerable string keyed properties of source
				 * objects to the destination object for all destination properties that
				 * resolve to `undefined`. Source objects are applied from left to right.
				 * Once a property is set, additional values of the same property are ignored.
				 *
				 * **Note:** This method mutates `object`.
				 *
				 * @static
				 * @since 0.1.0
				 * @memberOf _
				 * @category Object
				 * @param {Object} object The destination object.
				 * @param {...Object} [sources] The source objects.
				 * @returns {Object} Returns `object`.
				 * @see _.defaultsDeep
				 * @example
				 *
				 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
				 * // => { 'a': 1, 'b': 2 }
				 */
				var defaults = baseRest(function (object, sources) {
					object = Object(object);

					var index = -1;
					var length = sources.length;
					var guard = length > 2 ? sources[2] : undefined$1;

					if (guard && isIterateeCall(sources[0], sources[1], guard)) {
						length = 1;
					}

					while (++index < length) {
						var source = sources[index];
						var props = keysIn(source);
						var propsIndex = -1;
						var propsLength = props.length;

						while (++propsIndex < propsLength) {
							var key = props[propsIndex];
							var value = object[key];

							if (value === undefined$1 ||
								(eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
								object[key] = source[key];
							}
						}
					}

					return object;
				});

				/**
				 * This method is like `_.defaults` except that it recursively assigns
				 * default properties.
				 *
				 * **Note:** This method mutates `object`.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.10.0
				 * @category Object
				 * @param {Object} object The destination object.
				 * @param {...Object} [sources] The source objects.
				 * @returns {Object} Returns `object`.
				 * @see _.defaults
				 * @example
				 *
				 * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
				 * // => { 'a': { 'b': 2, 'c': 3 } }
				 */
				var defaultsDeep = baseRest(function (args) {
					args.push(undefined$1, customDefaultsMerge);
					return apply(mergeWith, undefined$1, args);
				});

				/**
				 * This method is like `_.find` except that it returns the key of the first
				 * element `predicate` returns truthy for instead of the element itself.
				 *
				 * @static
				 * @memberOf _
				 * @since 1.1.0
				 * @category Object
				 * @param {Object} object The object to inspect.
				 * @param {Function} [predicate=_.identity] The function invoked per iteration.
				 * @returns {string|undefined} Returns the key of the matched element,
				 *  else `undefined`.
				 * @example
				 *
				 * var users = {
				 *   'barney':  { 'age': 36, 'active': true },
				 *   'fred':    { 'age': 40, 'active': false },
				 *   'pebbles': { 'age': 1,  'active': true }
				 * };
				 *
				 * _.findKey(users, function(o) { return o.age < 40; });
				 * // => 'barney' (iteration order is not guaranteed)
				 *
				 * // The `_.matches` iteratee shorthand.
				 * _.findKey(users, { 'age': 1, 'active': true });
				 * // => 'pebbles'
				 *
				 * // The `_.matchesProperty` iteratee shorthand.
				 * _.findKey(users, ['active', false]);
				 * // => 'fred'
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.findKey(users, 'active');
				 * // => 'barney'
				 */
				function findKey(object, predicate) {
					return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
				}

				/**
				 * This method is like `_.findKey` except that it iterates over elements of
				 * a collection in the opposite order.
				 *
				 * @static
				 * @memberOf _
				 * @since 2.0.0
				 * @category Object
				 * @param {Object} object The object to inspect.
				 * @param {Function} [predicate=_.identity] The function invoked per iteration.
				 * @returns {string|undefined} Returns the key of the matched element,
				 *  else `undefined`.
				 * @example
				 *
				 * var users = {
				 *   'barney':  { 'age': 36, 'active': true },
				 *   'fred':    { 'age': 40, 'active': false },
				 *   'pebbles': { 'age': 1,  'active': true }
				 * };
				 *
				 * _.findLastKey(users, function(o) { return o.age < 40; });
				 * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
				 *
				 * // The `_.matches` iteratee shorthand.
				 * _.findLastKey(users, { 'age': 36, 'active': true });
				 * // => 'barney'
				 *
				 * // The `_.matchesProperty` iteratee shorthand.
				 * _.findLastKey(users, ['active', false]);
				 * // => 'fred'
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.findLastKey(users, 'active');
				 * // => 'pebbles'
				 */
				function findLastKey(object, predicate) {
					return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
				}

				/**
				 * Iterates over own and inherited enumerable string keyed properties of an
				 * object and invokes `iteratee` for each property. The iteratee is invoked
				 * with three arguments: (value, key, object). Iteratee functions may exit
				 * iteration early by explicitly returning `false`.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.3.0
				 * @category Object
				 * @param {Object} object The object to iterate over.
				 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
				 * @returns {Object} Returns `object`.
				 * @see _.forInRight
				 * @example
				 *
				 * function Foo() {
				 *   this.a = 1;
				 *   this.b = 2;
				 * }
				 *
				 * Foo.prototype.c = 3;
				 *
				 * _.forIn(new Foo, function(value, key) {
				 *   console.log(key);
				 * });
				 * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
				 */
				function forIn(object, iteratee) {
					return object == null
						? object
						: baseFor(object, getIteratee(iteratee, 3), keysIn);
				}

				/**
				 * This method is like `_.forIn` except that it iterates over properties of
				 * `object` in the opposite order.
				 *
				 * @static
				 * @memberOf _
				 * @since 2.0.0
				 * @category Object
				 * @param {Object} object The object to iterate over.
				 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
				 * @returns {Object} Returns `object`.
				 * @see _.forIn
				 * @example
				 *
				 * function Foo() {
				 *   this.a = 1;
				 *   this.b = 2;
				 * }
				 *
				 * Foo.prototype.c = 3;
				 *
				 * _.forInRight(new Foo, function(value, key) {
				 *   console.log(key);
				 * });
				 * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
				 */
				function forInRight(object, iteratee) {
					return object == null
						? object
						: baseForRight(object, getIteratee(iteratee, 3), keysIn);
				}

				/**
				 * Iterates over own enumerable string keyed properties of an object and
				 * invokes `iteratee` for each property. The iteratee is invoked with three
				 * arguments: (value, key, object). Iteratee functions may exit iteration
				 * early by explicitly returning `false`.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.3.0
				 * @category Object
				 * @param {Object} object The object to iterate over.
				 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
				 * @returns {Object} Returns `object`.
				 * @see _.forOwnRight
				 * @example
				 *
				 * function Foo() {
				 *   this.a = 1;
				 *   this.b = 2;
				 * }
				 *
				 * Foo.prototype.c = 3;
				 *
				 * _.forOwn(new Foo, function(value, key) {
				 *   console.log(key);
				 * });
				 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
				 */
				function forOwn(object, iteratee) {
					return object && baseForOwn(object, getIteratee(iteratee, 3));
				}

				/**
				 * This method is like `_.forOwn` except that it iterates over properties of
				 * `object` in the opposite order.
				 *
				 * @static
				 * @memberOf _
				 * @since 2.0.0
				 * @category Object
				 * @param {Object} object The object to iterate over.
				 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
				 * @returns {Object} Returns `object`.
				 * @see _.forOwn
				 * @example
				 *
				 * function Foo() {
				 *   this.a = 1;
				 *   this.b = 2;
				 * }
				 *
				 * Foo.prototype.c = 3;
				 *
				 * _.forOwnRight(new Foo, function(value, key) {
				 *   console.log(key);
				 * });
				 * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
				 */
				function forOwnRight(object, iteratee) {
					return object && baseForOwnRight(object, getIteratee(iteratee, 3));
				}

				/**
				 * Creates an array of function property names from own enumerable properties
				 * of `object`.
				 *
				 * @static
				 * @since 0.1.0
				 * @memberOf _
				 * @category Object
				 * @param {Object} object The object to inspect.
				 * @returns {Array} Returns the function names.
				 * @see _.functionsIn
				 * @example
				 *
				 * function Foo() {
				 *   this.a = _.constant('a');
				 *   this.b = _.constant('b');
				 * }
				 *
				 * Foo.prototype.c = _.constant('c');
				 *
				 * _.functions(new Foo);
				 * // => ['a', 'b']
				 */
				function functions(object) {
					return object == null ? [] : baseFunctions(object, keys(object));
				}

				/**
				 * Creates an array of function property names from own and inherited
				 * enumerable properties of `object`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Object
				 * @param {Object} object The object to inspect.
				 * @returns {Array} Returns the function names.
				 * @see _.functions
				 * @example
				 *
				 * function Foo() {
				 *   this.a = _.constant('a');
				 *   this.b = _.constant('b');
				 * }
				 *
				 * Foo.prototype.c = _.constant('c');
				 *
				 * _.functionsIn(new Foo);
				 * // => ['a', 'b', 'c']
				 */
				function functionsIn(object) {
					return object == null ? [] : baseFunctions(object, keysIn(object));
				}

				/**
				 * Gets the value at `path` of `object`. If the resolved value is
				 * `undefined`, the `defaultValue` is returned in its place.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.7.0
				 * @category Object
				 * @param {Object} object The object to query.
				 * @param {Array|string} path The path of the property to get.
				 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
				 * @returns {*} Returns the resolved value.
				 * @example
				 *
				 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
				 *
				 * _.get(object, 'a[0].b.c');
				 * // => 3
				 *
				 * _.get(object, ['a', '0', 'b', 'c']);
				 * // => 3
				 *
				 * _.get(object, 'a.b.c', 'default');
				 * // => 'default'
				 */
				function get(object, path, defaultValue) {
					var result = object == null ? undefined$1 : baseGet(object, path);
					return result === undefined$1 ? defaultValue : result;
				}

				/**
				 * Checks if `path` is a direct property of `object`.
				 *
				 * @static
				 * @since 0.1.0
				 * @memberOf _
				 * @category Object
				 * @param {Object} object The object to query.
				 * @param {Array|string} path The path to check.
				 * @returns {boolean} Returns `true` if `path` exists, else `false`.
				 * @example
				 *
				 * var object = { 'a': { 'b': 2 } };
				 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
				 *
				 * _.has(object, 'a');
				 * // => true
				 *
				 * _.has(object, 'a.b');
				 * // => true
				 *
				 * _.has(object, ['a', 'b']);
				 * // => true
				 *
				 * _.has(other, 'a');
				 * // => false
				 */
				function has(object, path) {
					return object != null && hasPath(object, path, baseHas);
				}

				/**
				 * Checks if `path` is a direct or inherited property of `object`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Object
				 * @param {Object} object The object to query.
				 * @param {Array|string} path The path to check.
				 * @returns {boolean} Returns `true` if `path` exists, else `false`.
				 * @example
				 *
				 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
				 *
				 * _.hasIn(object, 'a');
				 * // => true
				 *
				 * _.hasIn(object, 'a.b');
				 * // => true
				 *
				 * _.hasIn(object, ['a', 'b']);
				 * // => true
				 *
				 * _.hasIn(object, 'b');
				 * // => false
				 */
				function hasIn(object, path) {
					return object != null && hasPath(object, path, baseHasIn);
				}

				/**
				 * Creates an object composed of the inverted keys and values of `object`.
				 * If `object` contains duplicate values, subsequent values overwrite
				 * property assignments of previous values.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.7.0
				 * @category Object
				 * @param {Object} object The object to invert.
				 * @returns {Object} Returns the new inverted object.
				 * @example
				 *
				 * var object = { 'a': 1, 'b': 2, 'c': 1 };
				 *
				 * _.invert(object);
				 * // => { '1': 'c', '2': 'b' }
				 */
				var invert = createInverter(function (result, value, key) {
					if (value != null &&
						typeof value.toString != 'function') {
						value = nativeObjectToString.call(value);
					}

					result[value] = key;
				}, constant(identity));

				/**
				 * This method is like `_.invert` except that the inverted object is generated
				 * from the results of running each element of `object` thru `iteratee`. The
				 * corresponding inverted value of each inverted key is an array of keys
				 * responsible for generating the inverted value. The iteratee is invoked
				 * with one argument: (value).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.1.0
				 * @category Object
				 * @param {Object} object The object to invert.
				 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
				 * @returns {Object} Returns the new inverted object.
				 * @example
				 *
				 * var object = { 'a': 1, 'b': 2, 'c': 1 };
				 *
				 * _.invertBy(object);
				 * // => { '1': ['a', 'c'], '2': ['b'] }
				 *
				 * _.invertBy(object, function(value) {
				 *   return 'group' + value;
				 * });
				 * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
				 */
				var invertBy = createInverter(function (result, value, key) {
					if (value != null &&
						typeof value.toString != 'function') {
						value = nativeObjectToString.call(value);
					}

					if (hasOwnProperty.call(result, value)) {
						result[value].push(key);
					} else {
						result[value] = [key];
					}
				}, getIteratee);

				/**
				 * Invokes the method at `path` of `object`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Object
				 * @param {Object} object The object to query.
				 * @param {Array|string} path The path of the method to invoke.
				 * @param {...*} [args] The arguments to invoke the method with.
				 * @returns {*} Returns the result of the invoked method.
				 * @example
				 *
				 * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
				 *
				 * _.invoke(object, 'a[0].b.c.slice', 1, 3);
				 * // => [2, 3]
				 */
				var invoke = baseRest(baseInvoke);

				/**
				 * Creates an array of the own enumerable property names of `object`.
				 *
				 * **Note:** Non-object values are coerced to objects. See the
				 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
				 * for more details.
				 *
				 * @static
				 * @since 0.1.0
				 * @memberOf _
				 * @category Object
				 * @param {Object} object The object to query.
				 * @returns {Array} Returns the array of property names.
				 * @example
				 *
				 * function Foo() {
				 *   this.a = 1;
				 *   this.b = 2;
				 * }
				 *
				 * Foo.prototype.c = 3;
				 *
				 * _.keys(new Foo);
				 * // => ['a', 'b'] (iteration order is not guaranteed)
				 *
				 * _.keys('hi');
				 * // => ['0', '1']
				 */
				function keys(object) {
					return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
				}

				/**
				 * Creates an array of the own and inherited enumerable property names of `object`.
				 *
				 * **Note:** Non-object values are coerced to objects.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Object
				 * @param {Object} object The object to query.
				 * @returns {Array} Returns the array of property names.
				 * @example
				 *
				 * function Foo() {
				 *   this.a = 1;
				 *   this.b = 2;
				 * }
				 *
				 * Foo.prototype.c = 3;
				 *
				 * _.keysIn(new Foo);
				 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
				 */
				function keysIn(object) {
					return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
				}

				/**
				 * The opposite of `_.mapValues`; this method creates an object with the
				 * same values as `object` and keys generated by running each own enumerable
				 * string keyed property of `object` thru `iteratee`. The iteratee is invoked
				 * with three arguments: (value, key, object).
				 *
				 * @static
				 * @memberOf _
				 * @since 3.8.0
				 * @category Object
				 * @param {Object} object The object to iterate over.
				 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
				 * @returns {Object} Returns the new mapped object.
				 * @see _.mapValues
				 * @example
				 *
				 * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
				 *   return key + value;
				 * });
				 * // => { 'a1': 1, 'b2': 2 }
				 */
				function mapKeys(object, iteratee) {
					var result = {};
					iteratee = getIteratee(iteratee, 3);

					baseForOwn(object, function (value, key, object) {
						baseAssignValue(result, iteratee(value, key, object), value);
					});
					return result;
				}

				/**
				 * Creates an object with the same keys as `object` and values generated
				 * by running each own enumerable string keyed property of `object` thru
				 * `iteratee`. The iteratee is invoked with three arguments:
				 * (value, key, object).
				 *
				 * @static
				 * @memberOf _
				 * @since 2.4.0
				 * @category Object
				 * @param {Object} object The object to iterate over.
				 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
				 * @returns {Object} Returns the new mapped object.
				 * @see _.mapKeys
				 * @example
				 *
				 * var users = {
				 *   'fred':    { 'user': 'fred',    'age': 40 },
				 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
				 * };
				 *
				 * _.mapValues(users, function(o) { return o.age; });
				 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.mapValues(users, 'age');
				 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
				 */
				function mapValues(object, iteratee) {
					var result = {};
					iteratee = getIteratee(iteratee, 3);

					baseForOwn(object, function (value, key, object) {
						baseAssignValue(result, key, iteratee(value, key, object));
					});
					return result;
				}

				/**
				 * This method is like `_.assign` except that it recursively merges own and
				 * inherited enumerable string keyed properties of source objects into the
				 * destination object. Source properties that resolve to `undefined` are
				 * skipped if a destination value exists. Array and plain object properties
				 * are merged recursively. Other objects and value types are overridden by
				 * assignment. Source objects are applied from left to right. Subsequent
				 * sources overwrite property assignments of previous sources.
				 *
				 * **Note:** This method mutates `object`.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.5.0
				 * @category Object
				 * @param {Object} object The destination object.
				 * @param {...Object} [sources] The source objects.
				 * @returns {Object} Returns `object`.
				 * @example
				 *
				 * var object = {
				 *   'a': [{ 'b': 2 }, { 'd': 4 }]
				 * };
				 *
				 * var other = {
				 *   'a': [{ 'c': 3 }, { 'e': 5 }]
				 * };
				 *
				 * _.merge(object, other);
				 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
				 */
				var merge = createAssigner(function (object, source, srcIndex) {
					baseMerge(object, source, srcIndex);
				});

				/**
				 * This method is like `_.merge` except that it accepts `customizer` which
				 * is invoked to produce the merged values of the destination and source
				 * properties. If `customizer` returns `undefined`, merging is handled by the
				 * method instead. The `customizer` is invoked with six arguments:
				 * (objValue, srcValue, key, object, source, stack).
				 *
				 * **Note:** This method mutates `object`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Object
				 * @param {Object} object The destination object.
				 * @param {...Object} sources The source objects.
				 * @param {Function} customizer The function to customize assigned values.
				 * @returns {Object} Returns `object`.
				 * @example
				 *
				 * function customizer(objValue, srcValue) {
				 *   if (_.isArray(objValue)) {
				 *     return objValue.concat(srcValue);
				 *   }
				 * }
				 *
				 * var object = { 'a': [1], 'b': [2] };
				 * var other = { 'a': [3], 'b': [4] };
				 *
				 * _.mergeWith(object, other, customizer);
				 * // => { 'a': [1, 3], 'b': [2, 4] }
				 */
				var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
					baseMerge(object, source, srcIndex, customizer);
				});

				/**
				 * The opposite of `_.pick`; this method creates an object composed of the
				 * own and inherited enumerable property paths of `object` that are not omitted.
				 *
				 * **Note:** This method is considerably slower than `_.pick`.
				 *
				 * @static
				 * @since 0.1.0
				 * @memberOf _
				 * @category Object
				 * @param {Object} object The source object.
				 * @param {...(string|string[])} [paths] The property paths to omit.
				 * @returns {Object} Returns the new object.
				 * @example
				 *
				 * var object = { 'a': 1, 'b': '2', 'c': 3 };
				 *
				 * _.omit(object, ['a', 'c']);
				 * // => { 'b': '2' }
				 */
				var omit = flatRest(function (object, paths) {
					var result = {};
					if (object == null) {
						return result;
					}
					var isDeep = false;
					paths = arrayMap(paths, function (path) {
						path = castPath(path, object);
						isDeep || (isDeep = path.length > 1);
						return path;
					});
					copyObject(object, getAllKeysIn(object), result);
					if (isDeep) {
						result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
					}
					var length = paths.length;
					while (length--) {
						baseUnset(result, paths[length]);
					}
					return result;
				});

				/**
				 * The opposite of `_.pickBy`; this method creates an object composed of
				 * the own and inherited enumerable string keyed properties of `object` that
				 * `predicate` doesn't return truthy for. The predicate is invoked with two
				 * arguments: (value, key).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Object
				 * @param {Object} object The source object.
				 * @param {Function} [predicate=_.identity] The function invoked per property.
				 * @returns {Object} Returns the new object.
				 * @example
				 *
				 * var object = { 'a': 1, 'b': '2', 'c': 3 };
				 *
				 * _.omitBy(object, _.isNumber);
				 * // => { 'b': '2' }
				 */
				function omitBy(object, predicate) {
					return pickBy(object, negate(getIteratee(predicate)));
				}

				/**
				 * Creates an object composed of the picked `object` properties.
				 *
				 * @static
				 * @since 0.1.0
				 * @memberOf _
				 * @category Object
				 * @param {Object} object The source object.
				 * @param {...(string|string[])} [paths] The property paths to pick.
				 * @returns {Object} Returns the new object.
				 * @example
				 *
				 * var object = { 'a': 1, 'b': '2', 'c': 3 };
				 *
				 * _.pick(object, ['a', 'c']);
				 * // => { 'a': 1, 'c': 3 }
				 */
				var pick = flatRest(function (object, paths) {
					return object == null ? {} : basePick(object, paths);
				});

				/**
				 * Creates an object composed of the `object` properties `predicate` returns
				 * truthy for. The predicate is invoked with two arguments: (value, key).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Object
				 * @param {Object} object The source object.
				 * @param {Function} [predicate=_.identity] The function invoked per property.
				 * @returns {Object} Returns the new object.
				 * @example
				 *
				 * var object = { 'a': 1, 'b': '2', 'c': 3 };
				 *
				 * _.pickBy(object, _.isNumber);
				 * // => { 'a': 1, 'c': 3 }
				 */
				function pickBy(object, predicate) {
					if (object == null) {
						return {};
					}
					var props = arrayMap(getAllKeysIn(object), function (prop) {
						return [prop];
					});
					predicate = getIteratee(predicate);
					return basePickBy(object, props, function (value, path) {
						return predicate(value, path[0]);
					});
				}

				/**
				 * This method is like `_.get` except that if the resolved value is a
				 * function it's invoked with the `this` binding of its parent object and
				 * its result is returned.
				 *
				 * @static
				 * @since 0.1.0
				 * @memberOf _
				 * @category Object
				 * @param {Object} object The object to query.
				 * @param {Array|string} path The path of the property to resolve.
				 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
				 * @returns {*} Returns the resolved value.
				 * @example
				 *
				 * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
				 *
				 * _.result(object, 'a[0].b.c1');
				 * // => 3
				 *
				 * _.result(object, 'a[0].b.c2');
				 * // => 4
				 *
				 * _.result(object, 'a[0].b.c3', 'default');
				 * // => 'default'
				 *
				 * _.result(object, 'a[0].b.c3', _.constant('default'));
				 * // => 'default'
				 */
				function result(object, path, defaultValue) {
					path = castPath(path, object);

					var index = -1,
						length = path.length;

					// Ensure the loop is entered when path is empty.
					if (!length) {
						length = 1;
						object = undefined$1;
					}
					while (++index < length) {
						var value = object == null ? undefined$1 : object[toKey(path[index])];
						if (value === undefined$1) {
							index = length;
							value = defaultValue;
						}
						object = isFunction(value) ? value.call(object) : value;
					}
					return object;
				}

				/**
				 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
				 * it's created. Arrays are created for missing index properties while objects
				 * are created for all other missing properties. Use `_.setWith` to customize
				 * `path` creation.
				 *
				 * **Note:** This method mutates `object`.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.7.0
				 * @category Object
				 * @param {Object} object The object to modify.
				 * @param {Array|string} path The path of the property to set.
				 * @param {*} value The value to set.
				 * @returns {Object} Returns `object`.
				 * @example
				 *
				 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
				 *
				 * _.set(object, 'a[0].b.c', 4);
				 * console.log(object.a[0].b.c);
				 * // => 4
				 *
				 * _.set(object, ['x', '0', 'y', 'z'], 5);
				 * console.log(object.x[0].y.z);
				 * // => 5
				 */
				function set(object, path, value) {
					return object == null ? object : baseSet(object, path, value);
				}

				/**
				 * This method is like `_.set` except that it accepts `customizer` which is
				 * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
				 * path creation is handled by the method instead. The `customizer` is invoked
				 * with three arguments: (nsValue, key, nsObject).
				 *
				 * **Note:** This method mutates `object`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Object
				 * @param {Object} object The object to modify.
				 * @param {Array|string} path The path of the property to set.
				 * @param {*} value The value to set.
				 * @param {Function} [customizer] The function to customize assigned values.
				 * @returns {Object} Returns `object`.
				 * @example
				 *
				 * var object = {};
				 *
				 * _.setWith(object, '[0][1]', 'a', Object);
				 * // => { '0': { '1': 'a' } }
				 */
				function setWith(object, path, value, customizer) {
					customizer = typeof customizer == 'function' ? customizer : undefined$1;
					return object == null ? object : baseSet(object, path, value, customizer);
				}

				/**
				 * Creates an array of own enumerable string keyed-value pairs for `object`
				 * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
				 * entries are returned.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @alias entries
				 * @category Object
				 * @param {Object} object The object to query.
				 * @returns {Array} Returns the key-value pairs.
				 * @example
				 *
				 * function Foo() {
				 *   this.a = 1;
				 *   this.b = 2;
				 * }
				 *
				 * Foo.prototype.c = 3;
				 *
				 * _.toPairs(new Foo);
				 * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
				 */
				var toPairs = createToPairs(keys);

				/**
				 * Creates an array of own and inherited enumerable string keyed-value pairs
				 * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
				 * or set, its entries are returned.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @alias entriesIn
				 * @category Object
				 * @param {Object} object The object to query.
				 * @returns {Array} Returns the key-value pairs.
				 * @example
				 *
				 * function Foo() {
				 *   this.a = 1;
				 *   this.b = 2;
				 * }
				 *
				 * Foo.prototype.c = 3;
				 *
				 * _.toPairsIn(new Foo);
				 * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
				 */
				var toPairsIn = createToPairs(keysIn);

				/**
				 * An alternative to `_.reduce`; this method transforms `object` to a new
				 * `accumulator` object which is the result of running each of its own
				 * enumerable string keyed properties thru `iteratee`, with each invocation
				 * potentially mutating the `accumulator` object. If `accumulator` is not
				 * provided, a new object with the same `[[Prototype]]` will be used. The
				 * iteratee is invoked with four arguments: (accumulator, value, key, object).
				 * Iteratee functions may exit iteration early by explicitly returning `false`.
				 *
				 * @static
				 * @memberOf _
				 * @since 1.3.0
				 * @category Object
				 * @param {Object} object The object to iterate over.
				 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
				 * @param {*} [accumulator] The custom accumulator value.
				 * @returns {*} Returns the accumulated value.
				 * @example
				 *
				 * _.transform([2, 3, 4], function(result, n) {
				 *   result.push(n *= n);
				 *   return n % 2 == 0;
				 * }, []);
				 * // => [4, 9]
				 *
				 * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
				 *   (result[value] || (result[value] = [])).push(key);
				 * }, {});
				 * // => { '1': ['a', 'c'], '2': ['b'] }
				 */
				function transform(object, iteratee, accumulator) {
					var isArr = isArray(object),
						isArrLike = isArr || isBuffer(object) || isTypedArray(object);

					iteratee = getIteratee(iteratee, 4);
					if (accumulator == null) {
						var Ctor = object && object.constructor;
						if (isArrLike) {
							accumulator = isArr ? new Ctor : [];
						}
						else if (isObject(object)) {
							accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
						}
						else {
							accumulator = {};
						}
					}
					(isArrLike ? arrayEach : baseForOwn)(object, function (value, index, object) {
						return iteratee(accumulator, value, index, object);
					});
					return accumulator;
				}

				/**
				 * Removes the property at `path` of `object`.
				 *
				 * **Note:** This method mutates `object`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Object
				 * @param {Object} object The object to modify.
				 * @param {Array|string} path The path of the property to unset.
				 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
				 * @example
				 *
				 * var object = { 'a': [{ 'b': { 'c': 7 } }] };
				 * _.unset(object, 'a[0].b.c');
				 * // => true
				 *
				 * console.log(object);
				 * // => { 'a': [{ 'b': {} }] };
				 *
				 * _.unset(object, ['a', '0', 'b', 'c']);
				 * // => true
				 *
				 * console.log(object);
				 * // => { 'a': [{ 'b': {} }] };
				 */
				function unset(object, path) {
					return object == null ? true : baseUnset(object, path);
				}

				/**
				 * This method is like `_.set` except that accepts `updater` to produce the
				 * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
				 * is invoked with one argument: (value).
				 *
				 * **Note:** This method mutates `object`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.6.0
				 * @category Object
				 * @param {Object} object The object to modify.
				 * @param {Array|string} path The path of the property to set.
				 * @param {Function} updater The function to produce the updated value.
				 * @returns {Object} Returns `object`.
				 * @example
				 *
				 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
				 *
				 * _.update(object, 'a[0].b.c', function(n) { return n * n; });
				 * console.log(object.a[0].b.c);
				 * // => 9
				 *
				 * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
				 * console.log(object.x[0].y.z);
				 * // => 0
				 */
				function update(object, path, updater) {
					return object == null ? object : baseUpdate(object, path, castFunction(updater));
				}

				/**
				 * This method is like `_.update` except that it accepts `customizer` which is
				 * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
				 * path creation is handled by the method instead. The `customizer` is invoked
				 * with three arguments: (nsValue, key, nsObject).
				 *
				 * **Note:** This method mutates `object`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.6.0
				 * @category Object
				 * @param {Object} object The object to modify.
				 * @param {Array|string} path The path of the property to set.
				 * @param {Function} updater The function to produce the updated value.
				 * @param {Function} [customizer] The function to customize assigned values.
				 * @returns {Object} Returns `object`.
				 * @example
				 *
				 * var object = {};
				 *
				 * _.updateWith(object, '[0][1]', _.constant('a'), Object);
				 * // => { '0': { '1': 'a' } }
				 */
				function updateWith(object, path, updater, customizer) {
					customizer = typeof customizer == 'function' ? customizer : undefined$1;
					return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
				}

				/**
				 * Creates an array of the own enumerable string keyed property values of `object`.
				 *
				 * **Note:** Non-object values are coerced to objects.
				 *
				 * @static
				 * @since 0.1.0
				 * @memberOf _
				 * @category Object
				 * @param {Object} object The object to query.
				 * @returns {Array} Returns the array of property values.
				 * @example
				 *
				 * function Foo() {
				 *   this.a = 1;
				 *   this.b = 2;
				 * }
				 *
				 * Foo.prototype.c = 3;
				 *
				 * _.values(new Foo);
				 * // => [1, 2] (iteration order is not guaranteed)
				 *
				 * _.values('hi');
				 * // => ['h', 'i']
				 */
				function values(object) {
					return object == null ? [] : baseValues(object, keys(object));
				}

				/**
				 * Creates an array of the own and inherited enumerable string keyed property
				 * values of `object`.
				 *
				 * **Note:** Non-object values are coerced to objects.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Object
				 * @param {Object} object The object to query.
				 * @returns {Array} Returns the array of property values.
				 * @example
				 *
				 * function Foo() {
				 *   this.a = 1;
				 *   this.b = 2;
				 * }
				 *
				 * Foo.prototype.c = 3;
				 *
				 * _.valuesIn(new Foo);
				 * // => [1, 2, 3] (iteration order is not guaranteed)
				 */
				function valuesIn(object) {
					return object == null ? [] : baseValues(object, keysIn(object));
				}

				/*------------------------------------------------------------------------*/

				/**
				 * Clamps `number` within the inclusive `lower` and `upper` bounds.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Number
				 * @param {number} number The number to clamp.
				 * @param {number} [lower] The lower bound.
				 * @param {number} upper The upper bound.
				 * @returns {number} Returns the clamped number.
				 * @example
				 *
				 * _.clamp(-10, -5, 5);
				 * // => -5
				 *
				 * _.clamp(10, -5, 5);
				 * // => 5
				 */
				function clamp(number, lower, upper) {
					if (upper === undefined$1) {
						upper = lower;
						lower = undefined$1;
					}
					if (upper !== undefined$1) {
						upper = toNumber(upper);
						upper = upper === upper ? upper : 0;
					}
					if (lower !== undefined$1) {
						lower = toNumber(lower);
						lower = lower === lower ? lower : 0;
					}
					return baseClamp(toNumber(number), lower, upper);
				}

				/**
				 * Checks if `n` is between `start` and up to, but not including, `end`. If
				 * `end` is not specified, it's set to `start` with `start` then set to `0`.
				 * If `start` is greater than `end` the params are swapped to support
				 * negative ranges.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.3.0
				 * @category Number
				 * @param {number} number The number to check.
				 * @param {number} [start=0] The start of the range.
				 * @param {number} end The end of the range.
				 * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
				 * @see _.range, _.rangeRight
				 * @example
				 *
				 * _.inRange(3, 2, 4);
				 * // => true
				 *
				 * _.inRange(4, 8);
				 * // => true
				 *
				 * _.inRange(4, 2);
				 * // => false
				 *
				 * _.inRange(2, 2);
				 * // => false
				 *
				 * _.inRange(1.2, 2);
				 * // => true
				 *
				 * _.inRange(5.2, 4);
				 * // => false
				 *
				 * _.inRange(-3, -2, -6);
				 * // => true
				 */
				function inRange(number, start, end) {
					start = toFinite(start);
					if (end === undefined$1) {
						end = start;
						start = 0;
					} else {
						end = toFinite(end);
					}
					number = toNumber(number);
					return baseInRange(number, start, end);
				}

				/**
				 * Produces a random number between the inclusive `lower` and `upper` bounds.
				 * If only one argument is provided a number between `0` and the given number
				 * is returned. If `floating` is `true`, or either `lower` or `upper` are
				 * floats, a floating-point number is returned instead of an integer.
				 *
				 * **Note:** JavaScript follows the IEEE-754 standard for resolving
				 * floating-point values which can produce unexpected results.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.7.0
				 * @category Number
				 * @param {number} [lower=0] The lower bound.
				 * @param {number} [upper=1] The upper bound.
				 * @param {boolean} [floating] Specify returning a floating-point number.
				 * @returns {number} Returns the random number.
				 * @example
				 *
				 * _.random(0, 5);
				 * // => an integer between 0 and 5
				 *
				 * _.random(5);
				 * // => also an integer between 0 and 5
				 *
				 * _.random(5, true);
				 * // => a floating-point number between 0 and 5
				 *
				 * _.random(1.2, 5.2);
				 * // => a floating-point number between 1.2 and 5.2
				 */
				function random(lower, upper, floating) {
					if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
						upper = floating = undefined$1;
					}
					if (floating === undefined$1) {
						if (typeof upper == 'boolean') {
							floating = upper;
							upper = undefined$1;
						}
						else if (typeof lower == 'boolean') {
							floating = lower;
							lower = undefined$1;
						}
					}
					if (lower === undefined$1 && upper === undefined$1) {
						lower = 0;
						upper = 1;
					}
					else {
						lower = toFinite(lower);
						if (upper === undefined$1) {
							upper = lower;
							lower = 0;
						} else {
							upper = toFinite(upper);
						}
					}
					if (lower > upper) {
						var temp = lower;
						lower = upper;
						upper = temp;
					}
					if (floating || lower % 1 || upper % 1) {
						var rand = nativeRandom();
						return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
					}
					return baseRandom(lower, upper);
				}

				/*------------------------------------------------------------------------*/

				/**
				 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category String
				 * @param {string} [string=''] The string to convert.
				 * @returns {string} Returns the camel cased string.
				 * @example
				 *
				 * _.camelCase('Foo Bar');
				 * // => 'fooBar'
				 *
				 * _.camelCase('--foo-bar--');
				 * // => 'fooBar'
				 *
				 * _.camelCase('__FOO_BAR__');
				 * // => 'fooBar'
				 */
				var camelCase = createCompounder(function (result, word, index) {
					word = word.toLowerCase();
					return result + (index ? capitalize(word) : word);
				});

				/**
				 * Converts the first character of `string` to upper case and the remaining
				 * to lower case.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category String
				 * @param {string} [string=''] The string to capitalize.
				 * @returns {string} Returns the capitalized string.
				 * @example
				 *
				 * _.capitalize('FRED');
				 * // => 'Fred'
				 */
				function capitalize(string) {
					return upperFirst(toString(string).toLowerCase());
				}

				/**
				 * Deburrs `string` by converting
				 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
				 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
				 * letters to basic Latin letters and removing
				 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category String
				 * @param {string} [string=''] The string to deburr.
				 * @returns {string} Returns the deburred string.
				 * @example
				 *
				 * _.deburr('déjà vu');
				 * // => 'deja vu'
				 */
				function deburr(string) {
					string = toString(string);
					return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
				}

				/**
				 * Checks if `string` ends with the given target string.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category String
				 * @param {string} [string=''] The string to inspect.
				 * @param {string} [target] The string to search for.
				 * @param {number} [position=string.length] The position to search up to.
				 * @returns {boolean} Returns `true` if `string` ends with `target`,
				 *  else `false`.
				 * @example
				 *
				 * _.endsWith('abc', 'c');
				 * // => true
				 *
				 * _.endsWith('abc', 'b');
				 * // => false
				 *
				 * _.endsWith('abc', 'b', 2);
				 * // => true
				 */
				function endsWith(string, target, position) {
					string = toString(string);
					target = baseToString(target);

					var length = string.length;
					position = position === undefined$1
						? length
						: baseClamp(toInteger(position), 0, length);

					var end = position;
					position -= target.length;
					return position >= 0 && string.slice(position, end) == target;
				}

				/**
				 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
				 * corresponding HTML entities.
				 *
				 * **Note:** No other characters are escaped. To escape additional
				 * characters use a third-party library like [_he_](https://mths.be/he).
				 *
				 * Though the ">" character is escaped for symmetry, characters like
				 * ">" and "/" don't need escaping in HTML and have no special meaning
				 * unless they're part of a tag or unquoted attribute value. See
				 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
				 * (under "semi-related fun fact") for more details.
				 *
				 * When working with HTML you should always
				 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
				 * XSS vectors.
				 *
				 * @static
				 * @since 0.1.0
				 * @memberOf _
				 * @category String
				 * @param {string} [string=''] The string to escape.
				 * @returns {string} Returns the escaped string.
				 * @example
				 *
				 * _.escape('fred, barney, & pebbles');
				 * // => 'fred, barney, &amp; pebbles'
				 */
				function escape(string) {
					string = toString(string);
					return (string && reHasUnescapedHtml.test(string))
						? string.replace(reUnescapedHtml, escapeHtmlChar)
						: string;
				}

				/**
				 * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
				 * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category String
				 * @param {string} [string=''] The string to escape.
				 * @returns {string} Returns the escaped string.
				 * @example
				 *
				 * _.escapeRegExp('[lodash](https://lodash.com/)');
				 * // => '\[lodash\]\(https://lodash\.com/\)'
				 */
				function escapeRegExp(string) {
					string = toString(string);
					return (string && reHasRegExpChar.test(string))
						? string.replace(reRegExpChar, '\\$&')
						: string;
				}

				/**
				 * Converts `string` to
				 * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category String
				 * @param {string} [string=''] The string to convert.
				 * @returns {string} Returns the kebab cased string.
				 * @example
				 *
				 * _.kebabCase('Foo Bar');
				 * // => 'foo-bar'
				 *
				 * _.kebabCase('fooBar');
				 * // => 'foo-bar'
				 *
				 * _.kebabCase('__FOO_BAR__');
				 * // => 'foo-bar'
				 */
				var kebabCase = createCompounder(function (result, word, index) {
					return result + (index ? '-' : '') + word.toLowerCase();
				});

				/**
				 * Converts `string`, as space separated words, to lower case.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category String
				 * @param {string} [string=''] The string to convert.
				 * @returns {string} Returns the lower cased string.
				 * @example
				 *
				 * _.lowerCase('--Foo-Bar--');
				 * // => 'foo bar'
				 *
				 * _.lowerCase('fooBar');
				 * // => 'foo bar'
				 *
				 * _.lowerCase('__FOO_BAR__');
				 * // => 'foo bar'
				 */
				var lowerCase = createCompounder(function (result, word, index) {
					return result + (index ? ' ' : '') + word.toLowerCase();
				});

				/**
				 * Converts the first character of `string` to lower case.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category String
				 * @param {string} [string=''] The string to convert.
				 * @returns {string} Returns the converted string.
				 * @example
				 *
				 * _.lowerFirst('Fred');
				 * // => 'fred'
				 *
				 * _.lowerFirst('FRED');
				 * // => 'fRED'
				 */
				var lowerFirst = createCaseFirst('toLowerCase');

				/**
				 * Pads `string` on the left and right sides if it's shorter than `length`.
				 * Padding characters are truncated if they can't be evenly divided by `length`.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category String
				 * @param {string} [string=''] The string to pad.
				 * @param {number} [length=0] The padding length.
				 * @param {string} [chars=' '] The string used as padding.
				 * @returns {string} Returns the padded string.
				 * @example
				 *
				 * _.pad('abc', 8);
				 * // => '  abc   '
				 *
				 * _.pad('abc', 8, '_-');
				 * // => '_-abc_-_'
				 *
				 * _.pad('abc', 3);
				 * // => 'abc'
				 */
				function pad(string, length, chars) {
					string = toString(string);
					length = toInteger(length);

					var strLength = length ? stringSize(string) : 0;
					if (!length || strLength >= length) {
						return string;
					}
					var mid = (length - strLength) / 2;
					return (
						createPadding(nativeFloor(mid), chars) +
						string +
						createPadding(nativeCeil(mid), chars)
					);
				}

				/**
				 * Pads `string` on the right side if it's shorter than `length`. Padding
				 * characters are truncated if they exceed `length`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category String
				 * @param {string} [string=''] The string to pad.
				 * @param {number} [length=0] The padding length.
				 * @param {string} [chars=' '] The string used as padding.
				 * @returns {string} Returns the padded string.
				 * @example
				 *
				 * _.padEnd('abc', 6);
				 * // => 'abc   '
				 *
				 * _.padEnd('abc', 6, '_-');
				 * // => 'abc_-_'
				 *
				 * _.padEnd('abc', 3);
				 * // => 'abc'
				 */
				function padEnd(string, length, chars) {
					string = toString(string);
					length = toInteger(length);

					var strLength = length ? stringSize(string) : 0;
					return (length && strLength < length)
						? (string + createPadding(length - strLength, chars))
						: string;
				}

				/**
				 * Pads `string` on the left side if it's shorter than `length`. Padding
				 * characters are truncated if they exceed `length`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category String
				 * @param {string} [string=''] The string to pad.
				 * @param {number} [length=0] The padding length.
				 * @param {string} [chars=' '] The string used as padding.
				 * @returns {string} Returns the padded string.
				 * @example
				 *
				 * _.padStart('abc', 6);
				 * // => '   abc'
				 *
				 * _.padStart('abc', 6, '_-');
				 * // => '_-_abc'
				 *
				 * _.padStart('abc', 3);
				 * // => 'abc'
				 */
				function padStart(string, length, chars) {
					string = toString(string);
					length = toInteger(length);

					var strLength = length ? stringSize(string) : 0;
					return (length && strLength < length)
						? (createPadding(length - strLength, chars) + string)
						: string;
				}

				/**
				 * Converts `string` to an integer of the specified radix. If `radix` is
				 * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
				 * hexadecimal, in which case a `radix` of `16` is used.
				 *
				 * **Note:** This method aligns with the
				 * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
				 *
				 * @static
				 * @memberOf _
				 * @since 1.1.0
				 * @category String
				 * @param {string} string The string to convert.
				 * @param {number} [radix=10] The radix to interpret `value` by.
				 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
				 * @returns {number} Returns the converted integer.
				 * @example
				 *
				 * _.parseInt('08');
				 * // => 8
				 *
				 * _.map(['6', '08', '10'], _.parseInt);
				 * // => [6, 8, 10]
				 */
				function parseInt(string, radix, guard) {
					if (guard || radix == null) {
						radix = 0;
					} else if (radix) {
						radix = +radix;
					}
					return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
				}

				/**
				 * Repeats the given string `n` times.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category String
				 * @param {string} [string=''] The string to repeat.
				 * @param {number} [n=1] The number of times to repeat the string.
				 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
				 * @returns {string} Returns the repeated string.
				 * @example
				 *
				 * _.repeat('*', 3);
				 * // => '***'
				 *
				 * _.repeat('abc', 2);
				 * // => 'abcabc'
				 *
				 * _.repeat('abc', 0);
				 * // => ''
				 */
				function repeat(string, n, guard) {
					if ((guard ? isIterateeCall(string, n, guard) : n === undefined$1)) {
						n = 1;
					} else {
						n = toInteger(n);
					}
					return baseRepeat(toString(string), n);
				}

				/**
				 * Replaces matches for `pattern` in `string` with `replacement`.
				 *
				 * **Note:** This method is based on
				 * [`String#replace`](https://mdn.io/String/replace).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category String
				 * @param {string} [string=''] The string to modify.
				 * @param {RegExp|string} pattern The pattern to replace.
				 * @param {Function|string} replacement The match replacement.
				 * @returns {string} Returns the modified string.
				 * @example
				 *
				 * _.replace('Hi Fred', 'Fred', 'Barney');
				 * // => 'Hi Barney'
				 */
				function replace() {
					var args = arguments,
						string = toString(args[0]);

					return args.length < 3 ? string : string.replace(args[1], args[2]);
				}

				/**
				 * Converts `string` to
				 * [snake case](https://en.wikipedia.org/wiki/Snake_case).
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category String
				 * @param {string} [string=''] The string to convert.
				 * @returns {string} Returns the snake cased string.
				 * @example
				 *
				 * _.snakeCase('Foo Bar');
				 * // => 'foo_bar'
				 *
				 * _.snakeCase('fooBar');
				 * // => 'foo_bar'
				 *
				 * _.snakeCase('--FOO-BAR--');
				 * // => 'foo_bar'
				 */
				var snakeCase = createCompounder(function (result, word, index) {
					return result + (index ? '_' : '') + word.toLowerCase();
				});

				/**
				 * Splits `string` by `separator`.
				 *
				 * **Note:** This method is based on
				 * [`String#split`](https://mdn.io/String/split).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category String
				 * @param {string} [string=''] The string to split.
				 * @param {RegExp|string} separator The separator pattern to split by.
				 * @param {number} [limit] The length to truncate results to.
				 * @returns {Array} Returns the string segments.
				 * @example
				 *
				 * _.split('a-b-c', '-', 2);
				 * // => ['a', 'b']
				 */
				function split(string, separator, limit) {
					if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
						separator = limit = undefined$1;
					}
					limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
					if (!limit) {
						return [];
					}
					string = toString(string);
					if (string && (
						typeof separator == 'string' ||
						(separator != null && !isRegExp(separator))
					)) {
						separator = baseToString(separator);
						if (!separator && hasUnicode(string)) {
							return castSlice(stringToArray(string), 0, limit);
						}
					}
					return string.split(separator, limit);
				}

				/**
				 * Converts `string` to
				 * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
				 *
				 * @static
				 * @memberOf _
				 * @since 3.1.0
				 * @category String
				 * @param {string} [string=''] The string to convert.
				 * @returns {string} Returns the start cased string.
				 * @example
				 *
				 * _.startCase('--foo-bar--');
				 * // => 'Foo Bar'
				 *
				 * _.startCase('fooBar');
				 * // => 'Foo Bar'
				 *
				 * _.startCase('__FOO_BAR__');
				 * // => 'FOO BAR'
				 */
				var startCase = createCompounder(function (result, word, index) {
					return result + (index ? ' ' : '') + upperFirst(word);
				});

				/**
				 * Checks if `string` starts with the given target string.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category String
				 * @param {string} [string=''] The string to inspect.
				 * @param {string} [target] The string to search for.
				 * @param {number} [position=0] The position to search from.
				 * @returns {boolean} Returns `true` if `string` starts with `target`,
				 *  else `false`.
				 * @example
				 *
				 * _.startsWith('abc', 'a');
				 * // => true
				 *
				 * _.startsWith('abc', 'b');
				 * // => false
				 *
				 * _.startsWith('abc', 'b', 1);
				 * // => true
				 */
				function startsWith(string, target, position) {
					string = toString(string);
					position = position == null
						? 0
						: baseClamp(toInteger(position), 0, string.length);

					target = baseToString(target);
					return string.slice(position, position + target.length) == target;
				}

				/**
				 * Creates a compiled template function that can interpolate data properties
				 * in "interpolate" delimiters, HTML-escape interpolated data properties in
				 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
				 * properties may be accessed as free variables in the template. If a setting
				 * object is given, it takes precedence over `_.templateSettings` values.
				 *
				 * **Note:** In the development build `_.template` utilizes
				 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
				 * for easier debugging.
				 *
				 * For more information on precompiling templates see
				 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
				 *
				 * For more information on Chrome extension sandboxes see
				 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
				 *
				 * @static
				 * @since 0.1.0
				 * @memberOf _
				 * @category String
				 * @param {string} [string=''] The template string.
				 * @param {Object} [options={}] The options object.
				 * @param {RegExp} [options.escape=_.templateSettings.escape]
				 *  The HTML "escape" delimiter.
				 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
				 *  The "evaluate" delimiter.
				 * @param {Object} [options.imports=_.templateSettings.imports]
				 *  An object to import into the template as free variables.
				 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
				 *  The "interpolate" delimiter.
				 * @param {string} [options.sourceURL='lodash.templateSources[n]']
				 *  The sourceURL of the compiled template.
				 * @param {string} [options.variable='obj']
				 *  The data object variable name.
				 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
				 * @returns {Function} Returns the compiled template function.
				 * @example
				 *
				 * // Use the "interpolate" delimiter to create a compiled template.
				 * var compiled = _.template('hello <%= user %>!');
				 * compiled({ 'user': 'fred' });
				 * // => 'hello fred!'
				 *
				 * // Use the HTML "escape" delimiter to escape data property values.
				 * var compiled = _.template('<b><%- value %></b>');
				 * compiled({ 'value': '<script>' });
				 * // => '<b>&lt;script&gt;</b>'
				 *
				 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
				 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
				 * compiled({ 'users': ['fred', 'barney'] });
				 * // => '<li>fred</li><li>barney</li>'
				 *
				 * // Use the internal `print` function in "evaluate" delimiters.
				 * var compiled = _.template('<% print("hello " + user); %>!');
				 * compiled({ 'user': 'barney' });
				 * // => 'hello barney!'
				 *
				 * // Use the ES template literal delimiter as an "interpolate" delimiter.
				 * // Disable support by replacing the "interpolate" delimiter.
				 * var compiled = _.template('hello ${ user }!');
				 * compiled({ 'user': 'pebbles' });
				 * // => 'hello pebbles!'
				 *
				 * // Use backslashes to treat delimiters as plain text.
				 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
				 * compiled({ 'value': 'ignored' });
				 * // => '<%- value %>'
				 *
				 * // Use the `imports` option to import `jQuery` as `jq`.
				 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
				 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
				 * compiled({ 'users': ['fred', 'barney'] });
				 * // => '<li>fred</li><li>barney</li>'
				 *
				 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
				 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
				 * compiled(data);
				 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
				 *
				 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
				 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
				 * compiled.source;
				 * // => function(data) {
				 * //   var __t, __p = '';
				 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
				 * //   return __p;
				 * // }
				 *
				 * // Use custom template delimiters.
				 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
				 * var compiled = _.template('hello {{ user }}!');
				 * compiled({ 'user': 'mustache' });
				 * // => 'hello mustache!'
				 *
				 * // Use the `source` property to inline compiled templates for meaningful
				 * // line numbers in error messages and stack traces.
				 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
				 *   var JST = {\
				 *     "main": ' + _.template(mainText).source + '\
				 *   };\
				 * ');
				 */
				function template(string, options, guard) {
					// Based on John Resig's `tmpl` implementation
					// (http://ejohn.org/blog/javascript-micro-templating/)
					// and Laura Doktorova's doT.js (https://github.com/olado/doT).
					var settings = lodash.templateSettings;

					if (guard && isIterateeCall(string, options, guard)) {
						options = undefined$1;
					}
					string = toString(string);
					options = assignInWith({}, options, settings, customDefaultsAssignIn);

					var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
						importsKeys = keys(imports),
						importsValues = baseValues(imports, importsKeys);

					var isEscaping,
						isEvaluating,
						index = 0,
						interpolate = options.interpolate || reNoMatch,
						source = "__p += '";

					// Compile the regexp to match each delimiter.
					var reDelimiters = RegExp(
						(options.escape || reNoMatch).source + '|' +
						interpolate.source + '|' +
						(interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
						(options.evaluate || reNoMatch).source + '|$'
						, 'g');

					// Use a sourceURL for easier debugging.
					// The sourceURL gets injected into the source that's eval-ed, so be careful
					// to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
					// and escape the comment, thus injecting code that gets evaled.
					var sourceURL = '//# sourceURL=' +
						(hasOwnProperty.call(options, 'sourceURL')
							? (options.sourceURL + '').replace(/\s/g, ' ')
							: ('lodash.templateSources[' + (++templateCounter) + ']')
						) + '\n';

					string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
						interpolateValue || (interpolateValue = esTemplateValue);

						// Escape characters that can't be included in string literals.
						source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

						// Replace delimiters with snippets.
						if (escapeValue) {
							isEscaping = true;
							source += "' +\n__e(" + escapeValue + ") +\n'";
						}
						if (evaluateValue) {
							isEvaluating = true;
							source += "';\n" + evaluateValue + ";\n__p += '";
						}
						if (interpolateValue) {
							source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
						}
						index = offset + match.length;

						// The JS engine embedded in Adobe products needs `match` returned in
						// order to produce the correct `offset` value.
						return match;
					});

					source += "';\n";

					// If `variable` is not specified wrap a with-statement around the generated
					// code to add the data object to the top of the scope chain.
					var variable = hasOwnProperty.call(options, 'variable') && options.variable;
					if (!variable) {
						source = 'with (obj) {\n' + source + '\n}\n';
					}
					// Throw an error if a forbidden character was found in `variable`, to prevent
					// potential command injection attacks.
					else if (reForbiddenIdentifierChars.test(variable)) {
						throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
					}

					// Cleanup code by stripping empty strings.
					source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
						.replace(reEmptyStringMiddle, '$1')
						.replace(reEmptyStringTrailing, '$1;');

					// Frame code as the function body.
					source = 'function(' + (variable || 'obj') + ') {\n' +
						(variable
							? ''
							: 'obj || (obj = {});\n'
						) +
						"var __t, __p = ''" +
						(isEscaping
							? ', __e = _.escape'
							: ''
						) +
						(isEvaluating
							? ', __j = Array.prototype.join;\n' +
							"function print() { __p += __j.call(arguments, '') }\n"
							: ';\n'
						) +
						source +
						'return __p\n}';

					var result = attempt(function () {
						return Function(importsKeys, sourceURL + 'return ' + source)
							.apply(undefined$1, importsValues);
					});

					// Provide the compiled function's source by its `toString` method or
					// the `source` property as a convenience for inlining compiled templates.
					result.source = source;
					if (isError(result)) {
						throw result;
					}
					return result;
				}

				/**
				 * Converts `string`, as a whole, to lower case just like
				 * [String#toLowerCase](https://mdn.io/toLowerCase).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category String
				 * @param {string} [string=''] The string to convert.
				 * @returns {string} Returns the lower cased string.
				 * @example
				 *
				 * _.toLower('--Foo-Bar--');
				 * // => '--foo-bar--'
				 *
				 * _.toLower('fooBar');
				 * // => 'foobar'
				 *
				 * _.toLower('__FOO_BAR__');
				 * // => '__foo_bar__'
				 */
				function toLower(value) {
					return toString(value).toLowerCase();
				}

				/**
				 * Converts `string`, as a whole, to upper case just like
				 * [String#toUpperCase](https://mdn.io/toUpperCase).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category String
				 * @param {string} [string=''] The string to convert.
				 * @returns {string} Returns the upper cased string.
				 * @example
				 *
				 * _.toUpper('--foo-bar--');
				 * // => '--FOO-BAR--'
				 *
				 * _.toUpper('fooBar');
				 * // => 'FOOBAR'
				 *
				 * _.toUpper('__foo_bar__');
				 * // => '__FOO_BAR__'
				 */
				function toUpper(value) {
					return toString(value).toUpperCase();
				}

				/**
				 * Removes leading and trailing whitespace or specified characters from `string`.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category String
				 * @param {string} [string=''] The string to trim.
				 * @param {string} [chars=whitespace] The characters to trim.
				 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
				 * @returns {string} Returns the trimmed string.
				 * @example
				 *
				 * _.trim('  abc  ');
				 * // => 'abc'
				 *
				 * _.trim('-_-abc-_-', '_-');
				 * // => 'abc'
				 *
				 * _.map(['  foo  ', '  bar  '], _.trim);
				 * // => ['foo', 'bar']
				 */
				function trim(string, chars, guard) {
					string = toString(string);
					if (string && (guard || chars === undefined$1)) {
						return baseTrim(string);
					}
					if (!string || !(chars = baseToString(chars))) {
						return string;
					}
					var strSymbols = stringToArray(string),
						chrSymbols = stringToArray(chars),
						start = charsStartIndex(strSymbols, chrSymbols),
						end = charsEndIndex(strSymbols, chrSymbols) + 1;

					return castSlice(strSymbols, start, end).join('');
				}

				/**
				 * Removes trailing whitespace or specified characters from `string`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category String
				 * @param {string} [string=''] The string to trim.
				 * @param {string} [chars=whitespace] The characters to trim.
				 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
				 * @returns {string} Returns the trimmed string.
				 * @example
				 *
				 * _.trimEnd('  abc  ');
				 * // => '  abc'
				 *
				 * _.trimEnd('-_-abc-_-', '_-');
				 * // => '-_-abc'
				 */
				function trimEnd(string, chars, guard) {
					string = toString(string);
					if (string && (guard || chars === undefined$1)) {
						return string.slice(0, trimmedEndIndex(string) + 1);
					}
					if (!string || !(chars = baseToString(chars))) {
						return string;
					}
					var strSymbols = stringToArray(string),
						end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

					return castSlice(strSymbols, 0, end).join('');
				}

				/**
				 * Removes leading whitespace or specified characters from `string`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category String
				 * @param {string} [string=''] The string to trim.
				 * @param {string} [chars=whitespace] The characters to trim.
				 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
				 * @returns {string} Returns the trimmed string.
				 * @example
				 *
				 * _.trimStart('  abc  ');
				 * // => 'abc  '
				 *
				 * _.trimStart('-_-abc-_-', '_-');
				 * // => 'abc-_-'
				 */
				function trimStart(string, chars, guard) {
					string = toString(string);
					if (string && (guard || chars === undefined$1)) {
						return string.replace(reTrimStart, '');
					}
					if (!string || !(chars = baseToString(chars))) {
						return string;
					}
					var strSymbols = stringToArray(string),
						start = charsStartIndex(strSymbols, stringToArray(chars));

					return castSlice(strSymbols, start).join('');
				}

				/**
				 * Truncates `string` if it's longer than the given maximum string length.
				 * The last characters of the truncated string are replaced with the omission
				 * string which defaults to "...".
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category String
				 * @param {string} [string=''] The string to truncate.
				 * @param {Object} [options={}] The options object.
				 * @param {number} [options.length=30] The maximum string length.
				 * @param {string} [options.omission='...'] The string to indicate text is omitted.
				 * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
				 * @returns {string} Returns the truncated string.
				 * @example
				 *
				 * _.truncate('hi-diddly-ho there, neighborino');
				 * // => 'hi-diddly-ho there, neighbo...'
				 *
				 * _.truncate('hi-diddly-ho there, neighborino', {
				 *   'length': 24,
				 *   'separator': ' '
				 * });
				 * // => 'hi-diddly-ho there,...'
				 *
				 * _.truncate('hi-diddly-ho there, neighborino', {
				 *   'length': 24,
				 *   'separator': /,? +/
				 * });
				 * // => 'hi-diddly-ho there...'
				 *
				 * _.truncate('hi-diddly-ho there, neighborino', {
				 *   'omission': ' [...]'
				 * });
				 * // => 'hi-diddly-ho there, neig [...]'
				 */
				function truncate(string, options) {
					var length = DEFAULT_TRUNC_LENGTH,
						omission = DEFAULT_TRUNC_OMISSION;

					if (isObject(options)) {
						var separator = 'separator' in options ? options.separator : separator;
						length = 'length' in options ? toInteger(options.length) : length;
						omission = 'omission' in options ? baseToString(options.omission) : omission;
					}
					string = toString(string);

					var strLength = string.length;
					if (hasUnicode(string)) {
						var strSymbols = stringToArray(string);
						strLength = strSymbols.length;
					}
					if (length >= strLength) {
						return string;
					}
					var end = length - stringSize(omission);
					if (end < 1) {
						return omission;
					}
					var result = strSymbols
						? castSlice(strSymbols, 0, end).join('')
						: string.slice(0, end);

					if (separator === undefined$1) {
						return result + omission;
					}
					if (strSymbols) {
						end += (result.length - end);
					}
					if (isRegExp(separator)) {
						if (string.slice(end).search(separator)) {
							var match,
								substring = result;

							if (!separator.global) {
								separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
							}
							separator.lastIndex = 0;
							while ((match = separator.exec(substring))) {
								var newEnd = match.index;
							}
							result = result.slice(0, newEnd === undefined$1 ? end : newEnd);
						}
					} else if (string.indexOf(baseToString(separator), end) != end) {
						var index = result.lastIndexOf(separator);
						if (index > -1) {
							result = result.slice(0, index);
						}
					}
					return result + omission;
				}

				/**
				 * The inverse of `_.escape`; this method converts the HTML entities
				 * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
				 * their corresponding characters.
				 *
				 * **Note:** No other HTML entities are unescaped. To unescape additional
				 * HTML entities use a third-party library like [_he_](https://mths.be/he).
				 *
				 * @static
				 * @memberOf _
				 * @since 0.6.0
				 * @category String
				 * @param {string} [string=''] The string to unescape.
				 * @returns {string} Returns the unescaped string.
				 * @example
				 *
				 * _.unescape('fred, barney, &amp; pebbles');
				 * // => 'fred, barney, & pebbles'
				 */
				function unescape(string) {
					string = toString(string);
					return (string && reHasEscapedHtml.test(string))
						? string.replace(reEscapedHtml, unescapeHtmlChar)
						: string;
				}

				/**
				 * Converts `string`, as space separated words, to upper case.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category String
				 * @param {string} [string=''] The string to convert.
				 * @returns {string} Returns the upper cased string.
				 * @example
				 *
				 * _.upperCase('--foo-bar');
				 * // => 'FOO BAR'
				 *
				 * _.upperCase('fooBar');
				 * // => 'FOO BAR'
				 *
				 * _.upperCase('__foo_bar__');
				 * // => 'FOO BAR'
				 */
				var upperCase = createCompounder(function (result, word, index) {
					return result + (index ? ' ' : '') + word.toUpperCase();
				});

				/**
				 * Converts the first character of `string` to upper case.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category String
				 * @param {string} [string=''] The string to convert.
				 * @returns {string} Returns the converted string.
				 * @example
				 *
				 * _.upperFirst('fred');
				 * // => 'Fred'
				 *
				 * _.upperFirst('FRED');
				 * // => 'FRED'
				 */
				var upperFirst = createCaseFirst('toUpperCase');

				/**
				 * Splits `string` into an array of its words.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category String
				 * @param {string} [string=''] The string to inspect.
				 * @param {RegExp|string} [pattern] The pattern to match words.
				 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
				 * @returns {Array} Returns the words of `string`.
				 * @example
				 *
				 * _.words('fred, barney, & pebbles');
				 * // => ['fred', 'barney', 'pebbles']
				 *
				 * _.words('fred, barney, & pebbles', /[^, ]+/g);
				 * // => ['fred', 'barney', '&', 'pebbles']
				 */
				function words(string, pattern, guard) {
					string = toString(string);
					pattern = guard ? undefined$1 : pattern;

					if (pattern === undefined$1) {
						return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
					}
					return string.match(pattern) || [];
				}

				/*------------------------------------------------------------------------*/

				/**
				 * Attempts to invoke `func`, returning either the result or the caught error
				 * object. Any additional arguments are provided to `func` when it's invoked.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Util
				 * @param {Function} func The function to attempt.
				 * @param {...*} [args] The arguments to invoke `func` with.
				 * @returns {*} Returns the `func` result or error object.
				 * @example
				 *
				 * // Avoid throwing errors for invalid selectors.
				 * var elements = _.attempt(function(selector) {
				 *   return document.querySelectorAll(selector);
				 * }, '>_>');
				 *
				 * if (_.isError(elements)) {
				 *   elements = [];
				 * }
				 */
				var attempt = baseRest(function (func, args) {
					try {
						return apply(func, undefined$1, args);
					} catch (e) {
						return isError(e) ? e : new Error(e);
					}
				});

				/**
				 * Binds methods of an object to the object itself, overwriting the existing
				 * method.
				 *
				 * **Note:** This method doesn't set the "length" property of bound functions.
				 *
				 * @static
				 * @since 0.1.0
				 * @memberOf _
				 * @category Util
				 * @param {Object} object The object to bind and assign the bound methods to.
				 * @param {...(string|string[])} methodNames The object method names to bind.
				 * @returns {Object} Returns `object`.
				 * @example
				 *
				 * var view = {
				 *   'label': 'docs',
				 *   'click': function() {
				 *     console.log('clicked ' + this.label);
				 *   }
				 * };
				 *
				 * _.bindAll(view, ['click']);
				 * jQuery(element).on('click', view.click);
				 * // => Logs 'clicked docs' when clicked.
				 */
				var bindAll = flatRest(function (object, methodNames) {
					arrayEach(methodNames, function (key) {
						key = toKey(key);
						baseAssignValue(object, key, bind(object[key], object));
					});
					return object;
				});

				/**
				 * Creates a function that iterates over `pairs` and invokes the corresponding
				 * function of the first predicate to return truthy. The predicate-function
				 * pairs are invoked with the `this` binding and arguments of the created
				 * function.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Util
				 * @param {Array} pairs The predicate-function pairs.
				 * @returns {Function} Returns the new composite function.
				 * @example
				 *
				 * var func = _.cond([
				 *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
				 *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
				 *   [_.stubTrue,                      _.constant('no match')]
				 * ]);
				 *
				 * func({ 'a': 1, 'b': 2 });
				 * // => 'matches A'
				 *
				 * func({ 'a': 0, 'b': 1 });
				 * // => 'matches B'
				 *
				 * func({ 'a': '1', 'b': '2' });
				 * // => 'no match'
				 */
				function cond(pairs) {
					var length = pairs == null ? 0 : pairs.length,
						toIteratee = getIteratee();

					pairs = !length ? [] : arrayMap(pairs, function (pair) {
						if (typeof pair[1] != 'function') {
							throw new TypeError(FUNC_ERROR_TEXT);
						}
						return [toIteratee(pair[0]), pair[1]];
					});

					return baseRest(function (args) {
						var index = -1;
						while (++index < length) {
							var pair = pairs[index];
							if (apply(pair[0], this, args)) {
								return apply(pair[1], this, args);
							}
						}
					});
				}

				/**
				 * Creates a function that invokes the predicate properties of `source` with
				 * the corresponding property values of a given object, returning `true` if
				 * all predicates return truthy, else `false`.
				 *
				 * **Note:** The created function is equivalent to `_.conformsTo` with
				 * `source` partially applied.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Util
				 * @param {Object} source The object of property predicates to conform to.
				 * @returns {Function} Returns the new spec function.
				 * @example
				 *
				 * var objects = [
				 *   { 'a': 2, 'b': 1 },
				 *   { 'a': 1, 'b': 2 }
				 * ];
				 *
				 * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
				 * // => [{ 'a': 1, 'b': 2 }]
				 */
				function conforms(source) {
					return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
				}

				/**
				 * Creates a function that returns `value`.
				 *
				 * @static
				 * @memberOf _
				 * @since 2.4.0
				 * @category Util
				 * @param {*} value The value to return from the new function.
				 * @returns {Function} Returns the new constant function.
				 * @example
				 *
				 * var objects = _.times(2, _.constant({ 'a': 1 }));
				 *
				 * console.log(objects);
				 * // => [{ 'a': 1 }, { 'a': 1 }]
				 *
				 * console.log(objects[0] === objects[1]);
				 * // => true
				 */
				function constant(value) {
					return function () {
						return value;
					};
				}

				/**
				 * Checks `value` to determine whether a default value should be returned in
				 * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
				 * or `undefined`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.14.0
				 * @category Util
				 * @param {*} value The value to check.
				 * @param {*} defaultValue The default value.
				 * @returns {*} Returns the resolved value.
				 * @example
				 *
				 * _.defaultTo(1, 10);
				 * // => 1
				 *
				 * _.defaultTo(undefined, 10);
				 * // => 10
				 */
				function defaultTo(value, defaultValue) {
					return (value == null || value !== value) ? defaultValue : value;
				}

				/**
				 * Creates a function that returns the result of invoking the given functions
				 * with the `this` binding of the created function, where each successive
				 * invocation is supplied the return value of the previous.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Util
				 * @param {...(Function|Function[])} [funcs] The functions to invoke.
				 * @returns {Function} Returns the new composite function.
				 * @see _.flowRight
				 * @example
				 *
				 * function square(n) {
				 *   return n * n;
				 * }
				 *
				 * var addSquare = _.flow([_.add, square]);
				 * addSquare(1, 2);
				 * // => 9
				 */
				var flow = createFlow();

				/**
				 * This method is like `_.flow` except that it creates a function that
				 * invokes the given functions from right to left.
				 *
				 * @static
				 * @since 3.0.0
				 * @memberOf _
				 * @category Util
				 * @param {...(Function|Function[])} [funcs] The functions to invoke.
				 * @returns {Function} Returns the new composite function.
				 * @see _.flow
				 * @example
				 *
				 * function square(n) {
				 *   return n * n;
				 * }
				 *
				 * var addSquare = _.flowRight([square, _.add]);
				 * addSquare(1, 2);
				 * // => 9
				 */
				var flowRight = createFlow(true);

				/**
				 * This method returns the first argument it receives.
				 *
				 * @static
				 * @since 0.1.0
				 * @memberOf _
				 * @category Util
				 * @param {*} value Any value.
				 * @returns {*} Returns `value`.
				 * @example
				 *
				 * var object = { 'a': 1 };
				 *
				 * console.log(_.identity(object) === object);
				 * // => true
				 */
				function identity(value) {
					return value;
				}

				/**
				 * Creates a function that invokes `func` with the arguments of the created
				 * function. If `func` is a property name, the created function returns the
				 * property value for a given element. If `func` is an array or object, the
				 * created function returns `true` for elements that contain the equivalent
				 * source properties, otherwise it returns `false`.
				 *
				 * @static
				 * @since 4.0.0
				 * @memberOf _
				 * @category Util
				 * @param {*} [func=_.identity] The value to convert to a callback.
				 * @returns {Function} Returns the callback.
				 * @example
				 *
				 * var users = [
				 *   { 'user': 'barney', 'age': 36, 'active': true },
				 *   { 'user': 'fred',   'age': 40, 'active': false }
				 * ];
				 *
				 * // The `_.matches` iteratee shorthand.
				 * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
				 * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
				 *
				 * // The `_.matchesProperty` iteratee shorthand.
				 * _.filter(users, _.iteratee(['user', 'fred']));
				 * // => [{ 'user': 'fred', 'age': 40 }]
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.map(users, _.iteratee('user'));
				 * // => ['barney', 'fred']
				 *
				 * // Create custom iteratee shorthands.
				 * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
				 *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
				 *     return func.test(string);
				 *   };
				 * });
				 *
				 * _.filter(['abc', 'def'], /ef/);
				 * // => ['def']
				 */
				function iteratee(func) {
					return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
				}

				/**
				 * Creates a function that performs a partial deep comparison between a given
				 * object and `source`, returning `true` if the given object has equivalent
				 * property values, else `false`.
				 *
				 * **Note:** The created function is equivalent to `_.isMatch` with `source`
				 * partially applied.
				 *
				 * Partial comparisons will match empty array and empty object `source`
				 * values against any array or object value, respectively. See `_.isEqual`
				 * for a list of supported value comparisons.
				 *
				 * **Note:** Multiple values can be checked by combining several matchers
				 * using `_.overSome`
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Util
				 * @param {Object} source The object of property values to match.
				 * @returns {Function} Returns the new spec function.
				 * @example
				 *
				 * var objects = [
				 *   { 'a': 1, 'b': 2, 'c': 3 },
				 *   { 'a': 4, 'b': 5, 'c': 6 }
				 * ];
				 *
				 * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
				 * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
				 *
				 * // Checking for several possible values
				 * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
				 * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
				 */
				function matches(source) {
					return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
				}

				/**
				 * Creates a function that performs a partial deep comparison between the
				 * value at `path` of a given object to `srcValue`, returning `true` if the
				 * object value is equivalent, else `false`.
				 *
				 * **Note:** Partial comparisons will match empty array and empty object
				 * `srcValue` values against any array or object value, respectively. See
				 * `_.isEqual` for a list of supported value comparisons.
				 *
				 * **Note:** Multiple values can be checked by combining several matchers
				 * using `_.overSome`
				 *
				 * @static
				 * @memberOf _
				 * @since 3.2.0
				 * @category Util
				 * @param {Array|string} path The path of the property to get.
				 * @param {*} srcValue The value to match.
				 * @returns {Function} Returns the new spec function.
				 * @example
				 *
				 * var objects = [
				 *   { 'a': 1, 'b': 2, 'c': 3 },
				 *   { 'a': 4, 'b': 5, 'c': 6 }
				 * ];
				 *
				 * _.find(objects, _.matchesProperty('a', 4));
				 * // => { 'a': 4, 'b': 5, 'c': 6 }
				 *
				 * // Checking for several possible values
				 * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
				 * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
				 */
				function matchesProperty(path, srcValue) {
					return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
				}

				/**
				 * Creates a function that invokes the method at `path` of a given object.
				 * Any additional arguments are provided to the invoked method.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.7.0
				 * @category Util
				 * @param {Array|string} path The path of the method to invoke.
				 * @param {...*} [args] The arguments to invoke the method with.
				 * @returns {Function} Returns the new invoker function.
				 * @example
				 *
				 * var objects = [
				 *   { 'a': { 'b': _.constant(2) } },
				 *   { 'a': { 'b': _.constant(1) } }
				 * ];
				 *
				 * _.map(objects, _.method('a.b'));
				 * // => [2, 1]
				 *
				 * _.map(objects, _.method(['a', 'b']));
				 * // => [2, 1]
				 */
				var method = baseRest(function (path, args) {
					return function (object) {
						return baseInvoke(object, path, args);
					};
				});

				/**
				 * The opposite of `_.method`; this method creates a function that invokes
				 * the method at a given path of `object`. Any additional arguments are
				 * provided to the invoked method.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.7.0
				 * @category Util
				 * @param {Object} object The object to query.
				 * @param {...*} [args] The arguments to invoke the method with.
				 * @returns {Function} Returns the new invoker function.
				 * @example
				 *
				 * var array = _.times(3, _.constant),
				 *     object = { 'a': array, 'b': array, 'c': array };
				 *
				 * _.map(['a[2]', 'c[0]'], _.methodOf(object));
				 * // => [2, 0]
				 *
				 * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
				 * // => [2, 0]
				 */
				var methodOf = baseRest(function (object, args) {
					return function (path) {
						return baseInvoke(object, path, args);
					};
				});

				/**
				 * Adds all own enumerable string keyed function properties of a source
				 * object to the destination object. If `object` is a function, then methods
				 * are added to its prototype as well.
				 *
				 * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
				 * avoid conflicts caused by modifying the original.
				 *
				 * @static
				 * @since 0.1.0
				 * @memberOf _
				 * @category Util
				 * @param {Function|Object} [object=lodash] The destination object.
				 * @param {Object} source The object of functions to add.
				 * @param {Object} [options={}] The options object.
				 * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
				 * @returns {Function|Object} Returns `object`.
				 * @example
				 *
				 * function vowels(string) {
				 *   return _.filter(string, function(v) {
				 *     return /[aeiou]/i.test(v);
				 *   });
				 * }
				 *
				 * _.mixin({ 'vowels': vowels });
				 * _.vowels('fred');
				 * // => ['e']
				 *
				 * _('fred').vowels().value();
				 * // => ['e']
				 *
				 * _.mixin({ 'vowels': vowels }, { 'chain': false });
				 * _('fred').vowels();
				 * // => ['e']
				 */
				function mixin(object, source, options) {
					var props = keys(source),
						methodNames = baseFunctions(source, props);

					if (options == null &&
						!(isObject(source) && (methodNames.length || !props.length))) {
						options = source;
						source = object;
						object = this;
						methodNames = baseFunctions(source, keys(source));
					}
					var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
						isFunc = isFunction(object);

					arrayEach(methodNames, function (methodName) {
						var func = source[methodName];
						object[methodName] = func;
						if (isFunc) {
							object.prototype[methodName] = function () {
								var chainAll = this.__chain__;
								if (chain || chainAll) {
									var result = object(this.__wrapped__),
										actions = result.__actions__ = copyArray(this.__actions__);

									actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
									result.__chain__ = chainAll;
									return result;
								}
								return func.apply(object, arrayPush([this.value()], arguments));
							};
						}
					});

					return object;
				}

				/**
				 * Reverts the `_` variable to its previous value and returns a reference to
				 * the `lodash` function.
				 *
				 * @static
				 * @since 0.1.0
				 * @memberOf _
				 * @category Util
				 * @returns {Function} Returns the `lodash` function.
				 * @example
				 *
				 * var lodash = _.noConflict();
				 */
				function noConflict() {
					if (root._ === this) {
						root._ = oldDash;
					}
					return this;
				}

				/**
				 * This method returns `undefined`.
				 *
				 * @static
				 * @memberOf _
				 * @since 2.3.0
				 * @category Util
				 * @example
				 *
				 * _.times(2, _.noop);
				 * // => [undefined, undefined]
				 */
				function noop() {
					// No operation performed.
				}

				/**
				 * Creates a function that gets the argument at index `n`. If `n` is negative,
				 * the nth argument from the end is returned.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Util
				 * @param {number} [n=0] The index of the argument to return.
				 * @returns {Function} Returns the new pass-thru function.
				 * @example
				 *
				 * var func = _.nthArg(1);
				 * func('a', 'b', 'c', 'd');
				 * // => 'b'
				 *
				 * var func = _.nthArg(-2);
				 * func('a', 'b', 'c', 'd');
				 * // => 'c'
				 */
				function nthArg(n) {
					n = toInteger(n);
					return baseRest(function (args) {
						return baseNth(args, n);
					});
				}

				/**
				 * Creates a function that invokes `iteratees` with the arguments it receives
				 * and returns their results.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Util
				 * @param {...(Function|Function[])} [iteratees=[_.identity]]
				 *  The iteratees to invoke.
				 * @returns {Function} Returns the new function.
				 * @example
				 *
				 * var func = _.over([Math.max, Math.min]);
				 *
				 * func(1, 2, 3, 4);
				 * // => [4, 1]
				 */
				var over = createOver(arrayMap);

				/**
				 * Creates a function that checks if **all** of the `predicates` return
				 * truthy when invoked with the arguments it receives.
				 *
				 * Following shorthands are possible for providing predicates.
				 * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
				 * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Util
				 * @param {...(Function|Function[])} [predicates=[_.identity]]
				 *  The predicates to check.
				 * @returns {Function} Returns the new function.
				 * @example
				 *
				 * var func = _.overEvery([Boolean, isFinite]);
				 *
				 * func('1');
				 * // => true
				 *
				 * func(null);
				 * // => false
				 *
				 * func(NaN);
				 * // => false
				 */
				var overEvery = createOver(arrayEvery);

				/**
				 * Creates a function that checks if **any** of the `predicates` return
				 * truthy when invoked with the arguments it receives.
				 *
				 * Following shorthands are possible for providing predicates.
				 * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
				 * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Util
				 * @param {...(Function|Function[])} [predicates=[_.identity]]
				 *  The predicates to check.
				 * @returns {Function} Returns the new function.
				 * @example
				 *
				 * var func = _.overSome([Boolean, isFinite]);
				 *
				 * func('1');
				 * // => true
				 *
				 * func(null);
				 * // => true
				 *
				 * func(NaN);
				 * // => false
				 *
				 * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
				 * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
				 */
				var overSome = createOver(arraySome);

				/**
				 * Creates a function that returns the value at `path` of a given object.
				 *
				 * @static
				 * @memberOf _
				 * @since 2.4.0
				 * @category Util
				 * @param {Array|string} path The path of the property to get.
				 * @returns {Function} Returns the new accessor function.
				 * @example
				 *
				 * var objects = [
				 *   { 'a': { 'b': 2 } },
				 *   { 'a': { 'b': 1 } }
				 * ];
				 *
				 * _.map(objects, _.property('a.b'));
				 * // => [2, 1]
				 *
				 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
				 * // => [1, 2]
				 */
				function property(path) {
					return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
				}

				/**
				 * The opposite of `_.property`; this method creates a function that returns
				 * the value at a given path of `object`.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.0.0
				 * @category Util
				 * @param {Object} object The object to query.
				 * @returns {Function} Returns the new accessor function.
				 * @example
				 *
				 * var array = [0, 1, 2],
				 *     object = { 'a': array, 'b': array, 'c': array };
				 *
				 * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
				 * // => [2, 0]
				 *
				 * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
				 * // => [2, 0]
				 */
				function propertyOf(object) {
					return function (path) {
						return object == null ? undefined$1 : baseGet(object, path);
					};
				}

				/**
				 * Creates an array of numbers (positive and/or negative) progressing from
				 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
				 * `start` is specified without an `end` or `step`. If `end` is not specified,
				 * it's set to `start` with `start` then set to `0`.
				 *
				 * **Note:** JavaScript follows the IEEE-754 standard for resolving
				 * floating-point values which can produce unexpected results.
				 *
				 * @static
				 * @since 0.1.0
				 * @memberOf _
				 * @category Util
				 * @param {number} [start=0] The start of the range.
				 * @param {number} end The end of the range.
				 * @param {number} [step=1] The value to increment or decrement by.
				 * @returns {Array} Returns the range of numbers.
				 * @see _.inRange, _.rangeRight
				 * @example
				 *
				 * _.range(4);
				 * // => [0, 1, 2, 3]
				 *
				 * _.range(-4);
				 * // => [0, -1, -2, -3]
				 *
				 * _.range(1, 5);
				 * // => [1, 2, 3, 4]
				 *
				 * _.range(0, 20, 5);
				 * // => [0, 5, 10, 15]
				 *
				 * _.range(0, -4, -1);
				 * // => [0, -1, -2, -3]
				 *
				 * _.range(1, 4, 0);
				 * // => [1, 1, 1]
				 *
				 * _.range(0);
				 * // => []
				 */
				var range = createRange();

				/**
				 * This method is like `_.range` except that it populates values in
				 * descending order.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Util
				 * @param {number} [start=0] The start of the range.
				 * @param {number} end The end of the range.
				 * @param {number} [step=1] The value to increment or decrement by.
				 * @returns {Array} Returns the range of numbers.
				 * @see _.inRange, _.range
				 * @example
				 *
				 * _.rangeRight(4);
				 * // => [3, 2, 1, 0]
				 *
				 * _.rangeRight(-4);
				 * // => [-3, -2, -1, 0]
				 *
				 * _.rangeRight(1, 5);
				 * // => [4, 3, 2, 1]
				 *
				 * _.rangeRight(0, 20, 5);
				 * // => [15, 10, 5, 0]
				 *
				 * _.rangeRight(0, -4, -1);
				 * // => [-3, -2, -1, 0]
				 *
				 * _.rangeRight(1, 4, 0);
				 * // => [1, 1, 1]
				 *
				 * _.rangeRight(0);
				 * // => []
				 */
				var rangeRight = createRange(true);

				/**
				 * This method returns a new empty array.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.13.0
				 * @category Util
				 * @returns {Array} Returns the new empty array.
				 * @example
				 *
				 * var arrays = _.times(2, _.stubArray);
				 *
				 * console.log(arrays);
				 * // => [[], []]
				 *
				 * console.log(arrays[0] === arrays[1]);
				 * // => false
				 */
				function stubArray() {
					return [];
				}

				/**
				 * This method returns `false`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.13.0
				 * @category Util
				 * @returns {boolean} Returns `false`.
				 * @example
				 *
				 * _.times(2, _.stubFalse);
				 * // => [false, false]
				 */
				function stubFalse() {
					return false;
				}

				/**
				 * This method returns a new empty object.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.13.0
				 * @category Util
				 * @returns {Object} Returns the new empty object.
				 * @example
				 *
				 * var objects = _.times(2, _.stubObject);
				 *
				 * console.log(objects);
				 * // => [{}, {}]
				 *
				 * console.log(objects[0] === objects[1]);
				 * // => false
				 */
				function stubObject() {
					return {};
				}

				/**
				 * This method returns an empty string.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.13.0
				 * @category Util
				 * @returns {string} Returns the empty string.
				 * @example
				 *
				 * _.times(2, _.stubString);
				 * // => ['', '']
				 */
				function stubString() {
					return '';
				}

				/**
				 * This method returns `true`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.13.0
				 * @category Util
				 * @returns {boolean} Returns `true`.
				 * @example
				 *
				 * _.times(2, _.stubTrue);
				 * // => [true, true]
				 */
				function stubTrue() {
					return true;
				}

				/**
				 * Invokes the iteratee `n` times, returning an array of the results of
				 * each invocation. The iteratee is invoked with one argument; (index).
				 *
				 * @static
				 * @since 0.1.0
				 * @memberOf _
				 * @category Util
				 * @param {number} n The number of times to invoke `iteratee`.
				 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
				 * @returns {Array} Returns the array of results.
				 * @example
				 *
				 * _.times(3, String);
				 * // => ['0', '1', '2']
				 *
				 *  _.times(4, _.constant(0));
				 * // => [0, 0, 0, 0]
				 */
				function times(n, iteratee) {
					n = toInteger(n);
					if (n < 1 || n > MAX_SAFE_INTEGER) {
						return [];
					}
					var index = MAX_ARRAY_LENGTH,
						length = nativeMin(n, MAX_ARRAY_LENGTH);

					iteratee = getIteratee(iteratee);
					n -= MAX_ARRAY_LENGTH;

					var result = baseTimes(length, iteratee);
					while (++index < n) {
						iteratee(index);
					}
					return result;
				}

				/**
				 * Converts `value` to a property path array.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Util
				 * @param {*} value The value to convert.
				 * @returns {Array} Returns the new property path array.
				 * @example
				 *
				 * _.toPath('a.b.c');
				 * // => ['a', 'b', 'c']
				 *
				 * _.toPath('a[0].b.c');
				 * // => ['a', '0', 'b', 'c']
				 */
				function toPath(value) {
					if (isArray(value)) {
						return arrayMap(value, toKey);
					}
					return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
				}

				/**
				 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
				 *
				 * @static
				 * @since 0.1.0
				 * @memberOf _
				 * @category Util
				 * @param {string} [prefix=''] The value to prefix the ID with.
				 * @returns {string} Returns the unique ID.
				 * @example
				 *
				 * _.uniqueId('contact_');
				 * // => 'contact_104'
				 *
				 * _.uniqueId();
				 * // => '105'
				 */
				function uniqueId(prefix) {
					var id = ++idCounter;
					return toString(prefix) + id;
				}

				/*------------------------------------------------------------------------*/

				/**
				 * Adds two numbers.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.4.0
				 * @category Math
				 * @param {number} augend The first number in an addition.
				 * @param {number} addend The second number in an addition.
				 * @returns {number} Returns the total.
				 * @example
				 *
				 * _.add(6, 4);
				 * // => 10
				 */
				var add = createMathOperation(function (augend, addend) {
					return augend + addend;
				}, 0);

				/**
				 * Computes `number` rounded up to `precision`.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.10.0
				 * @category Math
				 * @param {number} number The number to round up.
				 * @param {number} [precision=0] The precision to round up to.
				 * @returns {number} Returns the rounded up number.
				 * @example
				 *
				 * _.ceil(4.006);
				 * // => 5
				 *
				 * _.ceil(6.004, 2);
				 * // => 6.01
				 *
				 * _.ceil(6040, -2);
				 * // => 6100
				 */
				var ceil = createRound('ceil');

				/**
				 * Divide two numbers.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.7.0
				 * @category Math
				 * @param {number} dividend The first number in a division.
				 * @param {number} divisor The second number in a division.
				 * @returns {number} Returns the quotient.
				 * @example
				 *
				 * _.divide(6, 4);
				 * // => 1.5
				 */
				var divide = createMathOperation(function (dividend, divisor) {
					return dividend / divisor;
				}, 1);

				/**
				 * Computes `number` rounded down to `precision`.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.10.0
				 * @category Math
				 * @param {number} number The number to round down.
				 * @param {number} [precision=0] The precision to round down to.
				 * @returns {number} Returns the rounded down number.
				 * @example
				 *
				 * _.floor(4.006);
				 * // => 4
				 *
				 * _.floor(0.046, 2);
				 * // => 0.04
				 *
				 * _.floor(4060, -2);
				 * // => 4000
				 */
				var floor = createRound('floor');

				/**
				 * Computes the maximum value of `array`. If `array` is empty or falsey,
				 * `undefined` is returned.
				 *
				 * @static
				 * @since 0.1.0
				 * @memberOf _
				 * @category Math
				 * @param {Array} array The array to iterate over.
				 * @returns {*} Returns the maximum value.
				 * @example
				 *
				 * _.max([4, 2, 8, 6]);
				 * // => 8
				 *
				 * _.max([]);
				 * // => undefined
				 */
				function max(array) {
					return (array && array.length)
						? baseExtremum(array, identity, baseGt)
						: undefined$1;
				}

				/**
				 * This method is like `_.max` except that it accepts `iteratee` which is
				 * invoked for each element in `array` to generate the criterion by which
				 * the value is ranked. The iteratee is invoked with one argument: (value).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Math
				 * @param {Array} array The array to iterate over.
				 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
				 * @returns {*} Returns the maximum value.
				 * @example
				 *
				 * var objects = [{ 'n': 1 }, { 'n': 2 }];
				 *
				 * _.maxBy(objects, function(o) { return o.n; });
				 * // => { 'n': 2 }
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.maxBy(objects, 'n');
				 * // => { 'n': 2 }
				 */
				function maxBy(array, iteratee) {
					return (array && array.length)
						? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
						: undefined$1;
				}

				/**
				 * Computes the mean of the values in `array`.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Math
				 * @param {Array} array The array to iterate over.
				 * @returns {number} Returns the mean.
				 * @example
				 *
				 * _.mean([4, 2, 8, 6]);
				 * // => 5
				 */
				function mean(array) {
					return baseMean(array, identity);
				}

				/**
				 * This method is like `_.mean` except that it accepts `iteratee` which is
				 * invoked for each element in `array` to generate the value to be averaged.
				 * The iteratee is invoked with one argument: (value).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.7.0
				 * @category Math
				 * @param {Array} array The array to iterate over.
				 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
				 * @returns {number} Returns the mean.
				 * @example
				 *
				 * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
				 *
				 * _.meanBy(objects, function(o) { return o.n; });
				 * // => 5
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.meanBy(objects, 'n');
				 * // => 5
				 */
				function meanBy(array, iteratee) {
					return baseMean(array, getIteratee(iteratee, 2));
				}

				/**
				 * Computes the minimum value of `array`. If `array` is empty or falsey,
				 * `undefined` is returned.
				 *
				 * @static
				 * @since 0.1.0
				 * @memberOf _
				 * @category Math
				 * @param {Array} array The array to iterate over.
				 * @returns {*} Returns the minimum value.
				 * @example
				 *
				 * _.min([4, 2, 8, 6]);
				 * // => 2
				 *
				 * _.min([]);
				 * // => undefined
				 */
				function min(array) {
					return (array && array.length)
						? baseExtremum(array, identity, baseLt)
						: undefined$1;
				}

				/**
				 * This method is like `_.min` except that it accepts `iteratee` which is
				 * invoked for each element in `array` to generate the criterion by which
				 * the value is ranked. The iteratee is invoked with one argument: (value).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Math
				 * @param {Array} array The array to iterate over.
				 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
				 * @returns {*} Returns the minimum value.
				 * @example
				 *
				 * var objects = [{ 'n': 1 }, { 'n': 2 }];
				 *
				 * _.minBy(objects, function(o) { return o.n; });
				 * // => { 'n': 1 }
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.minBy(objects, 'n');
				 * // => { 'n': 1 }
				 */
				function minBy(array, iteratee) {
					return (array && array.length)
						? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
						: undefined$1;
				}

				/**
				 * Multiply two numbers.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.7.0
				 * @category Math
				 * @param {number} multiplier The first number in a multiplication.
				 * @param {number} multiplicand The second number in a multiplication.
				 * @returns {number} Returns the product.
				 * @example
				 *
				 * _.multiply(6, 4);
				 * // => 24
				 */
				var multiply = createMathOperation(function (multiplier, multiplicand) {
					return multiplier * multiplicand;
				}, 1);

				/**
				 * Computes `number` rounded to `precision`.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.10.0
				 * @category Math
				 * @param {number} number The number to round.
				 * @param {number} [precision=0] The precision to round to.
				 * @returns {number} Returns the rounded number.
				 * @example
				 *
				 * _.round(4.006);
				 * // => 4
				 *
				 * _.round(4.006, 2);
				 * // => 4.01
				 *
				 * _.round(4060, -2);
				 * // => 4100
				 */
				var round = createRound('round');

				/**
				 * Subtract two numbers.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Math
				 * @param {number} minuend The first number in a subtraction.
				 * @param {number} subtrahend The second number in a subtraction.
				 * @returns {number} Returns the difference.
				 * @example
				 *
				 * _.subtract(6, 4);
				 * // => 2
				 */
				var subtract = createMathOperation(function (minuend, subtrahend) {
					return minuend - subtrahend;
				}, 0);

				/**
				 * Computes the sum of the values in `array`.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.4.0
				 * @category Math
				 * @param {Array} array The array to iterate over.
				 * @returns {number} Returns the sum.
				 * @example
				 *
				 * _.sum([4, 2, 8, 6]);
				 * // => 20
				 */
				function sum(array) {
					return (array && array.length)
						? baseSum(array, identity)
						: 0;
				}

				/**
				 * This method is like `_.sum` except that it accepts `iteratee` which is
				 * invoked for each element in `array` to generate the value to be summed.
				 * The iteratee is invoked with one argument: (value).
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Math
				 * @param {Array} array The array to iterate over.
				 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
				 * @returns {number} Returns the sum.
				 * @example
				 *
				 * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
				 *
				 * _.sumBy(objects, function(o) { return o.n; });
				 * // => 20
				 *
				 * // The `_.property` iteratee shorthand.
				 * _.sumBy(objects, 'n');
				 * // => 20
				 */
				function sumBy(array, iteratee) {
					return (array && array.length)
						? baseSum(array, getIteratee(iteratee, 2))
						: 0;
				}

				/*------------------------------------------------------------------------*/

				// Add methods that return wrapped values in chain sequences.
				lodash.after = after;
				lodash.ary = ary;
				lodash.assign = assign;
				lodash.assignIn = assignIn;
				lodash.assignInWith = assignInWith;
				lodash.assignWith = assignWith;
				lodash.at = at;
				lodash.before = before;
				lodash.bind = bind;
				lodash.bindAll = bindAll;
				lodash.bindKey = bindKey;
				lodash.castArray = castArray;
				lodash.chain = chain;
				lodash.chunk = chunk;
				lodash.compact = compact;
				lodash.concat = concat;
				lodash.cond = cond;
				lodash.conforms = conforms;
				lodash.constant = constant;
				lodash.countBy = countBy;
				lodash.create = create;
				lodash.curry = curry;
				lodash.curryRight = curryRight;
				lodash.debounce = debounce;
				lodash.defaults = defaults;
				lodash.defaultsDeep = defaultsDeep;
				lodash.defer = defer;
				lodash.delay = delay;
				lodash.difference = difference;
				lodash.differenceBy = differenceBy;
				lodash.differenceWith = differenceWith;
				lodash.drop = drop;
				lodash.dropRight = dropRight;
				lodash.dropRightWhile = dropRightWhile;
				lodash.dropWhile = dropWhile;
				lodash.fill = fill;
				lodash.filter = filter;
				lodash.flatMap = flatMap;
				lodash.flatMapDeep = flatMapDeep;
				lodash.flatMapDepth = flatMapDepth;
				lodash.flatten = flatten;
				lodash.flattenDeep = flattenDeep;
				lodash.flattenDepth = flattenDepth;
				lodash.flip = flip;
				lodash.flow = flow;
				lodash.flowRight = flowRight;
				lodash.fromPairs = fromPairs;
				lodash.functions = functions;
				lodash.functionsIn = functionsIn;
				lodash.groupBy = groupBy;
				lodash.initial = initial;
				lodash.intersection = intersection;
				lodash.intersectionBy = intersectionBy;
				lodash.intersectionWith = intersectionWith;
				lodash.invert = invert;
				lodash.invertBy = invertBy;
				lodash.invokeMap = invokeMap;
				lodash.iteratee = iteratee;
				lodash.keyBy = keyBy;
				lodash.keys = keys;
				lodash.keysIn = keysIn;
				lodash.map = map;
				lodash.mapKeys = mapKeys;
				lodash.mapValues = mapValues;
				lodash.matches = matches;
				lodash.matchesProperty = matchesProperty;
				lodash.memoize = memoize;
				lodash.merge = merge;
				lodash.mergeWith = mergeWith;
				lodash.method = method;
				lodash.methodOf = methodOf;
				lodash.mixin = mixin;
				lodash.negate = negate;
				lodash.nthArg = nthArg;
				lodash.omit = omit;
				lodash.omitBy = omitBy;
				lodash.once = once;
				lodash.orderBy = orderBy;
				lodash.over = over;
				lodash.overArgs = overArgs;
				lodash.overEvery = overEvery;
				lodash.overSome = overSome;
				lodash.partial = partial;
				lodash.partialRight = partialRight;
				lodash.partition = partition;
				lodash.pick = pick;
				lodash.pickBy = pickBy;
				lodash.property = property;
				lodash.propertyOf = propertyOf;
				lodash.pull = pull;
				lodash.pullAll = pullAll;
				lodash.pullAllBy = pullAllBy;
				lodash.pullAllWith = pullAllWith;
				lodash.pullAt = pullAt;
				lodash.range = range;
				lodash.rangeRight = rangeRight;
				lodash.rearg = rearg;
				lodash.reject = reject;
				lodash.remove = remove;
				lodash.rest = rest;
				lodash.reverse = reverse;
				lodash.sampleSize = sampleSize;
				lodash.set = set;
				lodash.setWith = setWith;
				lodash.shuffle = shuffle;
				lodash.slice = slice;
				lodash.sortBy = sortBy;
				lodash.sortedUniq = sortedUniq;
				lodash.sortedUniqBy = sortedUniqBy;
				lodash.split = split;
				lodash.spread = spread;
				lodash.tail = tail;
				lodash.take = take;
				lodash.takeRight = takeRight;
				lodash.takeRightWhile = takeRightWhile;
				lodash.takeWhile = takeWhile;
				lodash.tap = tap;
				lodash.throttle = throttle;
				lodash.thru = thru;
				lodash.toArray = toArray;
				lodash.toPairs = toPairs;
				lodash.toPairsIn = toPairsIn;
				lodash.toPath = toPath;
				lodash.toPlainObject = toPlainObject;
				lodash.transform = transform;
				lodash.unary = unary;
				lodash.union = union;
				lodash.unionBy = unionBy;
				lodash.unionWith = unionWith;
				lodash.uniq = uniq;
				lodash.uniqBy = uniqBy;
				lodash.uniqWith = uniqWith;
				lodash.unset = unset;
				lodash.unzip = unzip;
				lodash.unzipWith = unzipWith;
				lodash.update = update;
				lodash.updateWith = updateWith;
				lodash.values = values;
				lodash.valuesIn = valuesIn;
				lodash.without = without;
				lodash.words = words;
				lodash.wrap = wrap;
				lodash.xor = xor;
				lodash.xorBy = xorBy;
				lodash.xorWith = xorWith;
				lodash.zip = zip;
				lodash.zipObject = zipObject;
				lodash.zipObjectDeep = zipObjectDeep;
				lodash.zipWith = zipWith;

				// Add aliases.
				lodash.entries = toPairs;
				lodash.entriesIn = toPairsIn;
				lodash.extend = assignIn;
				lodash.extendWith = assignInWith;

				// Add methods to `lodash.prototype`.
				mixin(lodash, lodash);

				/*------------------------------------------------------------------------*/

				// Add methods that return unwrapped values in chain sequences.
				lodash.add = add;
				lodash.attempt = attempt;
				lodash.camelCase = camelCase;
				lodash.capitalize = capitalize;
				lodash.ceil = ceil;
				lodash.clamp = clamp;
				lodash.clone = clone;
				lodash.cloneDeep = cloneDeep;
				lodash.cloneDeepWith = cloneDeepWith;
				lodash.cloneWith = cloneWith;
				lodash.conformsTo = conformsTo;
				lodash.deburr = deburr;
				lodash.defaultTo = defaultTo;
				lodash.divide = divide;
				lodash.endsWith = endsWith;
				lodash.eq = eq;
				lodash.escape = escape;
				lodash.escapeRegExp = escapeRegExp;
				lodash.every = every;
				lodash.find = find;
				lodash.findIndex = findIndex;
				lodash.findKey = findKey;
				lodash.findLast = findLast;
				lodash.findLastIndex = findLastIndex;
				lodash.findLastKey = findLastKey;
				lodash.floor = floor;
				lodash.forEach = forEach;
				lodash.forEachRight = forEachRight;
				lodash.forIn = forIn;
				lodash.forInRight = forInRight;
				lodash.forOwn = forOwn;
				lodash.forOwnRight = forOwnRight;
				lodash.get = get;
				lodash.gt = gt;
				lodash.gte = gte;
				lodash.has = has;
				lodash.hasIn = hasIn;
				lodash.head = head;
				lodash.identity = identity;
				lodash.includes = includes;
				lodash.indexOf = indexOf;
				lodash.inRange = inRange;
				lodash.invoke = invoke;
				lodash.isArguments = isArguments;
				lodash.isArray = isArray;
				lodash.isArrayBuffer = isArrayBuffer;
				lodash.isArrayLike = isArrayLike;
				lodash.isArrayLikeObject = isArrayLikeObject;
				lodash.isBoolean = isBoolean;
				lodash.isBuffer = isBuffer;
				lodash.isDate = isDate;
				lodash.isElement = isElement;
				lodash.isEmpty = isEmpty;
				lodash.isEqual = isEqual;
				lodash.isEqualWith = isEqualWith;
				lodash.isError = isError;
				lodash.isFinite = isFinite;
				lodash.isFunction = isFunction;
				lodash.isInteger = isInteger;
				lodash.isLength = isLength;
				lodash.isMap = isMap;
				lodash.isMatch = isMatch;
				lodash.isMatchWith = isMatchWith;
				lodash.isNaN = isNaN;
				lodash.isNative = isNative;
				lodash.isNil = isNil;
				lodash.isNull = isNull;
				lodash.isNumber = isNumber;
				lodash.isObject = isObject;
				lodash.isObjectLike = isObjectLike;
				lodash.isPlainObject = isPlainObject;
				lodash.isRegExp = isRegExp;
				lodash.isSafeInteger = isSafeInteger;
				lodash.isSet = isSet;
				lodash.isString = isString;
				lodash.isSymbol = isSymbol;
				lodash.isTypedArray = isTypedArray;
				lodash.isUndefined = isUndefined;
				lodash.isWeakMap = isWeakMap;
				lodash.isWeakSet = isWeakSet;
				lodash.join = join;
				lodash.kebabCase = kebabCase;
				lodash.last = last;
				lodash.lastIndexOf = lastIndexOf;
				lodash.lowerCase = lowerCase;
				lodash.lowerFirst = lowerFirst;
				lodash.lt = lt;
				lodash.lte = lte;
				lodash.max = max;
				lodash.maxBy = maxBy;
				lodash.mean = mean;
				lodash.meanBy = meanBy;
				lodash.min = min;
				lodash.minBy = minBy;
				lodash.stubArray = stubArray;
				lodash.stubFalse = stubFalse;
				lodash.stubObject = stubObject;
				lodash.stubString = stubString;
				lodash.stubTrue = stubTrue;
				lodash.multiply = multiply;
				lodash.nth = nth;
				lodash.noConflict = noConflict;
				lodash.noop = noop;
				lodash.now = now;
				lodash.pad = pad;
				lodash.padEnd = padEnd;
				lodash.padStart = padStart;
				lodash.parseInt = parseInt;
				lodash.random = random;
				lodash.reduce = reduce;
				lodash.reduceRight = reduceRight;
				lodash.repeat = repeat;
				lodash.replace = replace;
				lodash.result = result;
				lodash.round = round;
				lodash.runInContext = runInContext;
				lodash.sample = sample;
				lodash.size = size;
				lodash.snakeCase = snakeCase;
				lodash.some = some;
				lodash.sortedIndex = sortedIndex;
				lodash.sortedIndexBy = sortedIndexBy;
				lodash.sortedIndexOf = sortedIndexOf;
				lodash.sortedLastIndex = sortedLastIndex;
				lodash.sortedLastIndexBy = sortedLastIndexBy;
				lodash.sortedLastIndexOf = sortedLastIndexOf;
				lodash.startCase = startCase;
				lodash.startsWith = startsWith;
				lodash.subtract = subtract;
				lodash.sum = sum;
				lodash.sumBy = sumBy;
				lodash.template = template;
				lodash.times = times;
				lodash.toFinite = toFinite;
				lodash.toInteger = toInteger;
				lodash.toLength = toLength;
				lodash.toLower = toLower;
				lodash.toNumber = toNumber;
				lodash.toSafeInteger = toSafeInteger;
				lodash.toString = toString;
				lodash.toUpper = toUpper;
				lodash.trim = trim;
				lodash.trimEnd = trimEnd;
				lodash.trimStart = trimStart;
				lodash.truncate = truncate;
				lodash.unescape = unescape;
				lodash.uniqueId = uniqueId;
				lodash.upperCase = upperCase;
				lodash.upperFirst = upperFirst;

				// Add aliases.
				lodash.each = forEach;
				lodash.eachRight = forEachRight;
				lodash.first = head;

				mixin(lodash, (function () {
					var source = {};
					baseForOwn(lodash, function (func, methodName) {
						if (!hasOwnProperty.call(lodash.prototype, methodName)) {
							source[methodName] = func;
						}
					});
					return source;
				}()), { 'chain': false });

				/*------------------------------------------------------------------------*/

				/**
				 * The semantic version number.
				 *
				 * @static
				 * @memberOf _
				 * @type {string}
				 */
				lodash.VERSION = VERSION;

				// Assign default placeholders.
				arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function (methodName) {
					lodash[methodName].placeholder = lodash;
				});

				// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
				arrayEach(['drop', 'take'], function (methodName, index) {
					LazyWrapper.prototype[methodName] = function (n) {
						n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);

						var result = (this.__filtered__ && !index)
							? new LazyWrapper(this)
							: this.clone();

						if (result.__filtered__) {
							result.__takeCount__ = nativeMin(n, result.__takeCount__);
						} else {
							result.__views__.push({
								'size': nativeMin(n, MAX_ARRAY_LENGTH),
								'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
							});
						}
						return result;
					};

					LazyWrapper.prototype[methodName + 'Right'] = function (n) {
						return this.reverse()[methodName](n).reverse();
					};
				});

				// Add `LazyWrapper` methods that accept an `iteratee` value.
				arrayEach(['filter', 'map', 'takeWhile'], function (methodName, index) {
					var type = index + 1,
						isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

					LazyWrapper.prototype[methodName] = function (iteratee) {
						var result = this.clone();
						result.__iteratees__.push({
							'iteratee': getIteratee(iteratee, 3),
							'type': type
						});
						result.__filtered__ = result.__filtered__ || isFilter;
						return result;
					};
				});

				// Add `LazyWrapper` methods for `_.head` and `_.last`.
				arrayEach(['head', 'last'], function (methodName, index) {
					var takeName = 'take' + (index ? 'Right' : '');

					LazyWrapper.prototype[methodName] = function () {
						return this[takeName](1).value()[0];
					};
				});

				// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
				arrayEach(['initial', 'tail'], function (methodName, index) {
					var dropName = 'drop' + (index ? '' : 'Right');

					LazyWrapper.prototype[methodName] = function () {
						return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
					};
				});

				LazyWrapper.prototype.compact = function () {
					return this.filter(identity);
				};

				LazyWrapper.prototype.find = function (predicate) {
					return this.filter(predicate).head();
				};

				LazyWrapper.prototype.findLast = function (predicate) {
					return this.reverse().find(predicate);
				};

				LazyWrapper.prototype.invokeMap = baseRest(function (path, args) {
					if (typeof path == 'function') {
						return new LazyWrapper(this);
					}
					return this.map(function (value) {
						return baseInvoke(value, path, args);
					});
				});

				LazyWrapper.prototype.reject = function (predicate) {
					return this.filter(negate(getIteratee(predicate)));
				};

				LazyWrapper.prototype.slice = function (start, end) {
					start = toInteger(start);

					var result = this;
					if (result.__filtered__ && (start > 0 || end < 0)) {
						return new LazyWrapper(result);
					}
					if (start < 0) {
						result = result.takeRight(-start);
					} else if (start) {
						result = result.drop(start);
					}
					if (end !== undefined$1) {
						end = toInteger(end);
						result = end < 0 ? result.dropRight(-end) : result.take(end - start);
					}
					return result;
				};

				LazyWrapper.prototype.takeRightWhile = function (predicate) {
					return this.reverse().takeWhile(predicate).reverse();
				};

				LazyWrapper.prototype.toArray = function () {
					return this.take(MAX_ARRAY_LENGTH);
				};

				// Add `LazyWrapper` methods to `lodash.prototype`.
				baseForOwn(LazyWrapper.prototype, function (func, methodName) {
					var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
						isTaker = /^(?:head|last)$/.test(methodName),
						lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
						retUnwrapped = isTaker || /^find/.test(methodName);

					if (!lodashFunc) {
						return;
					}
					lodash.prototype[methodName] = function () {
						var value = this.__wrapped__,
							args = isTaker ? [1] : arguments,
							isLazy = value instanceof LazyWrapper,
							iteratee = args[0],
							useLazy = isLazy || isArray(value);

						var interceptor = function (value) {
							var result = lodashFunc.apply(lodash, arrayPush([value], args));
							return (isTaker && chainAll) ? result[0] : result;
						};

						if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
							// Avoid lazy use if the iteratee has a "length" value other than `1`.
							isLazy = useLazy = false;
						}
						var chainAll = this.__chain__,
							isHybrid = !!this.__actions__.length,
							isUnwrapped = retUnwrapped && !chainAll,
							onlyLazy = isLazy && !isHybrid;

						if (!retUnwrapped && useLazy) {
							value = onlyLazy ? value : new LazyWrapper(this);
							var result = func.apply(value, args);
							result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined$1 });
							return new LodashWrapper(result, chainAll);
						}
						if (isUnwrapped && onlyLazy) {
							return func.apply(this, args);
						}
						result = this.thru(interceptor);
						return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
					};
				});

				// Add `Array` methods to `lodash.prototype`.
				arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function (methodName) {
					var func = arrayProto[methodName],
						chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
						retUnwrapped = /^(?:pop|shift)$/.test(methodName);

					lodash.prototype[methodName] = function () {
						var args = arguments;
						if (retUnwrapped && !this.__chain__) {
							var value = this.value();
							return func.apply(isArray(value) ? value : [], args);
						}
						return this[chainName](function (value) {
							return func.apply(isArray(value) ? value : [], args);
						});
					};
				});

				// Map minified method names to their real names.
				baseForOwn(LazyWrapper.prototype, function (func, methodName) {
					var lodashFunc = lodash[methodName];
					if (lodashFunc) {
						var key = lodashFunc.name + '';
						if (!hasOwnProperty.call(realNames, key)) {
							realNames[key] = [];
						}
						realNames[key].push({ 'name': methodName, 'func': lodashFunc });
					}
				});

				realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
					'name': 'wrapper',
					'func': undefined$1
				}];

				// Add methods to `LazyWrapper`.
				LazyWrapper.prototype.clone = lazyClone;
				LazyWrapper.prototype.reverse = lazyReverse;
				LazyWrapper.prototype.value = lazyValue;

				// Add chain sequence methods to the `lodash` wrapper.
				lodash.prototype.at = wrapperAt;
				lodash.prototype.chain = wrapperChain;
				lodash.prototype.commit = wrapperCommit;
				lodash.prototype.next = wrapperNext;
				lodash.prototype.plant = wrapperPlant;
				lodash.prototype.reverse = wrapperReverse;
				lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

				// Add lazy aliases.
				lodash.prototype.first = lodash.prototype.head;

				if (symIterator) {
					lodash.prototype[symIterator] = wrapperToIterator;
				}
				return lodash;
			});

			/*--------------------------------------------------------------------------*/

			// Export lodash.
			var _ = runInContext();

			// Some AMD build optimizers, like r.js, check for condition patterns like:
			if (freeModule) {
				// Export for Node.js.
				(freeModule.exports = _)._ = _;
				// Export for CommonJS support.
				freeExports._ = _;
			}
			else {
				// Export to the global object.
				root._ = _;
			}
		}.call(commonjsGlobal));
	}(lodash, lodashExports));

	var _ = lodashExports;

	/**
	 *  扩展函数,数据转换函数
	 *
	 * @exports DataTransform
	 * @alias DataTransform
	 */
	var DataTransform = {};

	/**
	 * 将数组转换为Geojson,暂时只转统一类型
	 * @param {Array} array 数组
	 * @param {Object} symbol 配置参数
	 * @param {Function} callback 回调函数，对symbold做特殊处理
	 * @returns {Object} geojson对象
	 */
	DataTransform.arrayToGeojson = function (array, symbol, callback, planeView) {
		planeView = SceneGIS.defaultValue(planeView, false);
		var featureCollection;
		if (planeView === true) {
			featureCollection = {
				type: "FeatureCollection",
				//增加坐标系，南京08
				crs: {
					type: "name",
					properties: {
						name: "nanjing:08"
					}
				},
			};
		} else {
			featureCollection = { type: "FeatureCollection" };
		}
		var features = new Array();
		for (let d of array) {

			let newSymbol = symbol;
			if (callback) {
				newSymbol = callback(d);
				if (!newSymbol) continue;
			}
			let positions = newSymbol.positions;
			var feature = { type: "Feature", id: d.id };
			feature.properties = d;
			var geometry = { type: "Point" };
			if (symbol.geoType == "Point") {
				geometry = { type: "Point" };
				if (positions.length < 2) {
					throw new CoreEX.DeveloperError("数组转geojson 点报错，数组长度小于2");
				}
				geometry.coordinates = [positions[0], positions[1]];
			} else if (symbol.geoType == "Polygon") {
				geometry = { type: "Polygon" };
				let coordinates = new Array();

				if (positions.length < 6) {
					throw new CoreEX.DeveloperError("数组转geojson 面报错，数组长度小于6");
				}
				for (let j = 0; j < positions.length; j += 2) {
					let arr = new Array();
					arr.push(positions[j], positions[j + 1]);
					coordinates.push(arr);
				}
				geometry.coordinates = new Array(coordinates);
			} else if (symbol.geoType == "LineString") {
				geometry = { type: "LineString" };
				let coordinates = new Array();
				if (positions.length < 4) {
					throw new CoreEX.DeveloperError("数组转geojson 线报错，数组长度小于4");
				}
				//let points = d.geo_polyLine;
				for (let j = 0; j < positions.length; j += 2) {
					coordinates.push([positions[j], positions[j + 1]]); //待数据验证
				}
				geometry.coordinates = coordinates.concat();
			}
			feature.geometry = geometry;
			features.push(feature);
		}
		featureCollection.features = features;

		return featureCollection;
	};

	/**
	 * 将数组转换为Czml
	 * @param {Array} array 数组
	 * @param {Function} callback 回调函数
	 * @returns {Object} czml对象
	 */
	DataTransform.arrayToCzml = function (array, symbol, callback) {
		let prefix = symbol.prefix;
		let czml = [];
		if (prefix) {
			czml.push(prefix);
		} else {
			czml.push({
				id: "document",
				name: "CZML Custom Properties",
				version: "1.0",
			});
		}
		for (var d of array) {
			//在这里拼接似乎有点怪，但是可以避免多次数组遍历
			let newSymbol = symbol;
			if (callback) {
				newSymbol = callback(d);
				if (!newSymbol) continue;
			}
			let czmlObj = newSymbol.czml;
			let d_ = _.cloneDeep(d);
			for (let key in d_) {
				if (d_[key] == undefined || d_[key] == null) {
					d_ = "";//cesium的原生bug，如果属性为null或者undefined，会导致czml报错
				}
				if (d_[key] == Infinity || d_[key] == -Infinity) {
					d_[key] = (d_[key] == Infinity) ? "Infinity" : "-Infinity";
				}
			}
			czmlObj.properties = d_;
			if (newSymbol.id) {
				czmlObj.id = newSymbol.id;
			}
			if (czmlObj instanceof Array) {
				//数组的特殊处理，目的是解决czml的特殊情况
				for (let i = 0; i < czmlObj.length; i++) {
					czmlObj[i].id = czmlObj[i].id + "&" + i.toString();
					czml.push(czmlObj[i]);
				}
			} else {
				czml.push(czmlObj);
			}
		}
		return czml;
	};

	/**
	 * 将数组转换为Echarts
	 * @param {Array} array 数组
	 * @param {Function} callback 回调函数
	 * @returns {Object} echarts对象
	 */
	DataTransform.arrayToEcharts = function (array, callback) { };
	/**
	 * 将geojson转成Czml
	 * @param {Object} geojson geojson对象
	 * @param {Function} callback 回调函数
	 * @returns {Object} czml对象
	 */
	DataTransform.geojosnToCzml = function (geojson, callback) { };

	/**
	 * 将geojson转成Echarts
	 * @param {Object} geojson geojson对象
	 * @param {Function} callback 回调函数
	 * @returns {Array} 数组对象
	 */
	DataTransform.geojosnToarray = function (geojson, callback) { };

	function DefaultValueEX(a, b) {
		if (a !== undefined && a !== null) {
			return a;
		}
		return b;
	}
	DefaultValueEX.EMPTY_OBJECT = Object.freeze({});

	/**
	 * 网格舞动类
	 * @class
	 */
	class DynamicGridEX {
		/**
		 * @param {SceneGIS.Viewer} viewer 
		 */
		constructor(viewer) {
			this.viewer = viewer;
			this.gridCollectionDynamic = null;
			this.timeStep = 30000;
		}

		/**
		 * 
		 * @param {string} jsonURL geojson的url
		 * @param {object} options 
		 * @param {SceneGIS.Color} [options.lowColor=SceneGIS.Color.GREEN] 最低处的颜色
		 * @param {SceneGIS.Color} [options.highColor=SceneGIS.Color.RED] 最高处的颜色
		 * @param {number} [options.maxValue=50] 最大高度
		 * @param {number} [options.minValue=5] 最小高度
		 */
		startDynamic(jsonURL, options) {
			const myRandom = function (min, max) {
				return Math.floor(Math.random() * (max - min) + min);
			};

			const defaultStyle = {
				lowColor: new SceneGIS.Color(0, 1, 0),
				highColor: new SceneGIS.Color(1, 0, 0),
				maxValue: 50,
				minValue: 5
			};

			options = options || {};

			options = { ...defaultStyle, ...options };

			this.options = options;

			const self = this;

			//1. polygonCollection
			if (this.gridCollectionDynamic) return;
			this.gridCollectionDynamic = new SceneGIS.CustomDataSource('dynamicGrid');
			this.viewer.dataSources.add(this.gridCollectionDynamic);

			//2. 时间配备
			const startTime = SceneGIS.JulianDate.now();
			const stopTime = SceneGIS.JulianDate.addSeconds(startTime, 11 * this.timeStep, new SceneGIS.JulianDate());
			this.viewer.clock.shouldAnimate = true;
			this.viewer.clock.startTime = startTime;
			this.viewer.clock.multiplier = 5000;
			this.viewer.clock.stopTime = stopTime;
			this.viewer.clock.currentTime = startTime;
			this.viewer.clock.clockRange = SceneGIS.ClockRange.LOOP_STOP;

			SceneGIS.GeoJsonDataSource.load(jsonURL).then(data => {
				const entities = data.entities.values;
				entities.forEach(entity => {
					const heightSample = new SceneGIS.SampledProperty(Number);
					heightSample.addSample(startTime, 10);
					for (let i = 0; i < 12; i++) {
						const value = myRandom(self.options.minValue, self.options.maxValue);
						const timestampNext = self.timeStep * i;
						const timeNext = SceneGIS.JulianDate.addSeconds(startTime, timestampNext, new SceneGIS.JulianDate());
						heightSample.addSample(timeNext, value);
					}

					const getColor = function () {
						const value = heightSample.getValue(self.viewer.clock.currentTime);
						const colorFactor = SceneGIS.Math.clamp((value - self.options.minValue) / (self.options.maxValue - self.options.minValue), 0, 1);
						return self.mixColor(self.options.lowColor, self.options.highColor, colorFactor);
						// const colorFactor = SceneGIS.Math.clamp(value/maxValue, 0, 1)*0.7+0.3;//优化渐变颜色
						// return new SceneGIS.Color(colorFactor, 0, 1-colorFactor, 1.0);
					};

					const positions = entity.polygon.hierarchy._value.positions;
					self.gridCollectionDynamic.entities.add({
						polygon: {
							hierarchy: new SceneGIS.PolygonHierarchy(positions),
							extrudedHeight: heightSample,
							shadows: SceneGIS.ShadowMode.ENABLED,
							material: new SceneGIS.ColorMaterialProperty(new SceneGIS.CallbackProperty(getColor, false)),
						},
					});
				});
			});
		}

		async clear() {
			this.viewer.clock.shouldAnimate = false;//先暂停
			//透明度动画消失
			this.gridCollectionDynamic.entities.removeAll();
		}

		mixColor(color1, color2, mixNum) {
			if (!color1 || !color2) {
				return;
			}
			mixNum = mixNum || 0;
			const newColor = new SceneGIS.Color(0, 0, 0);
			newColor.red = color1.red * (1.0 - mixNum) + color2.red * mixNum;
			newColor.green = color1.green * (1.0 - mixNum) + color2.green * mixNum;
			newColor.blue = color1.blue * (1.0 - mixNum) + color2.blue * mixNum;
			return newColor;
		}

		/**
		 * 销毁
		 */
		destroy() {
			this.clear();
			this.viewer.dataSources.remove(this.gridCollectionDynamic, true);
		}
	}

	class HeatMapRenderEX {
		constructor(viewer, data = {
			autoMaxMin: true,
			data: [],
		}, bbox = [-180, -90, 180, 90]
			, heatmapConfig = {}, autoRadiusConfig = {
				enabled: true,
				min: 6375000,
				max: 20000000,
				maxRadius: 400 * 2,
				minRadius: 5 * 2,
			}, canvasConfig = {
				totalArea: 360 * 2 * 720 * 2,
				autoResize: true,
			}, onlyRenderImage = false,
		) {
			if (typeof window == 'undefined') return;

			this.viewer = viewer;
			this.planeView = viewer.scene.planeView;
			this.bbox = bbox;
			this.autoRadiusConfig = autoRadiusConfig;
			this.max = undefined;
			this.min = undefined;
			this.onlyRenderImage = onlyRenderImage;

			// bbox计算基础信息
			const [left, bottom, right, top] = bbox;
			let height = top - bottom; let width = right - left;
			this.boxMeta = {
				top, left, height, width,
			};

			// 计算画布大小
			if (canvasConfig.autoResize) {
				if (!canvasConfig.totalArea) {
					throw 'specify totalArea if auto resize';
				}
				// w*h = totalArea
				// w:h = width/height
				if (this.planeView === true) {
					height /= 111320;
					width /= 111320;
				}
				const h = Math.floor(Math.sqrt(height * canvasConfig.totalArea));
				const w = Math.floor(h * width / height);
				this.canvasConfig = {
					...canvasConfig,
					width: w,
					height: h,
				};
			} else {
				if (!canvasConfig.width || !canvasConfig.height) {
					throw 'specify width and height if not auto resize';
				}
				this.canvasConfig = canvasConfig;
			}

			// 初始化heatmap
			const config = { ...heatmapConfig };
			if (!config.container) {
				this.mountPoint = newDiv({
					'position': `absolute`,
					'top': 0,
					'left': 0,
					'z-index': -100,
					'overflow': 'hidden',
					'width': 0,
					'height': 0,
				}, document.body);

				config.container = newDiv({
					width: this.canvasConfig.width,
					height: this.canvasConfig.height,
				}, this.mountPoint);
			}
			this.heatmapConfig = config;
			this.heatmap = h337.create(config);
			// console.log(config);
			// console.log(this.heatmap);
			this.useForModel = true;
			// 设置热力图数据
			let dataConfig;
			if (Array.isArray(data)) {
				dataConfig = {
					autoMaxMin: true,
					data,
				};
			} else {
				dataConfig = {
					...data,
				};
			}
			if (!dataConfig.autoMaxMin) {
				if (!dataConfig.min || !dataConfig.max) {
					throw 'need max and min when not auto';
				}
				this.min = dataConfig.min;
				this.max = dataConfig.max;
			}
			const newData = dataConfig.data.map((x) => {
				this.updateMaxMin(x.value);
				return this.convertData(x);
			});
			delete dataConfig.data;

			this.dataConfig = dataConfig;
			this.data = newData;
			const heatdata = {
				max: this.max,
				min: this.min,
				data: newData,
			};
			this.heatmap.setData(heatdata);

			// 更新到cesium
			this.updateCesium(autoRadiusConfig.enabled);
			this.cameraMoveEnd = () => { this.updateCesium(true); };
			autoRadiusConfig.enabled && this.viewer.camera.changed.addEventListener(this.cameraMoveEnd);
		}

		/**
		 * 增加一个或多个点
		 * @param {Object|Array} x
		 */
		addData(x) {
			if (Array.isArray(x)) {
				this.data = this.data.concat(x.map((y) => {
					this.updateMaxMin(y.value);
					return this.convertData(y);
				}));
			} else {
				this.updateMaxMin(x.value);
				this.data.push(this.convertData(x));
			}
			this.updateCesium(true);
		}

		/**
		 * 按当前的相机高度调整点的辐射（越高，越大）
		 */
		updateHeatmap() {
			if (!this.heatmap) {
				return;
			}
			const h = this.viewer.camera.getMagnitude();
			const { min, max, minRadius, maxRadius } = this.autoRadiusConfig;
			const newRadius = parseFloat(minRadius + (maxRadius - minRadius) * (h - min) / (max - min));
			if (newRadius < minRadius) return;
			this.heatmap.setData({
				max: this.max,
				min: this.min,
				data: this.data.map(({ x, y, value }) => {
					return {
						x, y, value, radius: newRadius,
					};
				}),
			});
		}

		/**
		   * 更新cesium显示
		   * @param {*} updateHeat
		   */
		updateCesium(updateHeat) {
			if (this.onlyRenderImage) {
				updateHeat && this.updateHeatmap();
				return;
			}
			if (this.useForModel) {
				if (this.primitive) {
					// this.viewer.entities.remove(this.layer);
					this.primitive.appearance.material = new SceneGIS.Material({
						fabric: {
							type: 'Image',
							uniforms: {
								image: this.heatmap._renderer.canvas,
							},
						},
					});
					updateHeat && this.updateHeatmap();
					return;
				}
				if (this.entity) {
					this.entity.rectangle.material.image = this.heatmap.getDataURL();
					return;
				}

				// groundprimitive
				const planeView = this.viewer.scene.planeView;
				const _geom = new SceneGIS.GeometryInstance({
					geometry: new SceneGIS.RectangleGeometry({
						// rectangle: this._rectangle,
						rectangle: planeView === true ? new SceneGIS.Rectangle(...this.bbox)
							: SceneGIS.Rectangle.fromDegrees(...this.bbox),
						vertexFormat: SceneGIS.MaterialAppearance.vertexFormat,
						planeView: planeView
					}),
				});
				const _primitive = new SceneGIS.GroundPrimitive({
					geometryInstances: _geom,
					classificationType: SceneGIS.ClassificationType.BOTH,
					appearance: new SceneGIS.MaterialAppearance({
						// translucent:true,
						material: new SceneGIS.Material({
							fabric: {
								type: 'Image',
								uniforms: {
									image: this.heatmap._renderer.canvas,
									// image: this.heatmap.getDataURL(),
								},
							},
						}),
					}),
				});
				this.primitive = this.viewer.scene.primitives.add(_primitive);
				updateHeat && this.updateHeatmap();
				return;
			}

			if (this.layer) {
				this.viewer.scene.imageryLayers.remove(this.layer);
			}
			updateHeat && this.updateHeatmap();

			const provider = new SceneGIS.SingleTileImageryProvider({
				url: this.heatmap.getDataURL(),
				rectangle: planeView === true ? new SceneGIS.Rectangle(...this.bbox)
					: SceneGIS.Rectangle.fromDegrees(...this.bbox),
			});
			this.layer = this.viewer.scene.imageryLayers.addImageryProvider(provider);
		}

		/**
		 * 转换坐标
		 * @param {*} param0
		 */
		convertData({ x, y, value }) {
			const [px, py] = this.gps2point([x, y]);
			return {
				x: px,
				y: py,
				value: value,
			};
		}

		/**
		 * 更新最大值最小值
		 * @param {number} value
		 */
		updateMaxMin(value) {
			if (this.max === undefined) {
				this.max = value;
			} else {
				this.max = Math.max(value, this.max);
			}
			if (this.min === undefined) {
				this.min = value;
			} else {
				this.min = Math.min(value, this.min);
			}
		}

		gps2point(gps = []) {
			const [x1, y1] = gps;
			const { top, left, height, width } = this.boxMeta;
			const canvasConfig = this.canvasConfig;

			const x = parseInt((x1 - left) / width * canvasConfig.width);
			const y = parseInt((top - y1) / height * canvasConfig.height);
			return [x, y];
		}

		/**
		 * 销毁
		 */
		destory() {
			this.viewer.camera.changed.removeEventListener(this.cameraMoveEnd);
			if (this.layer) {
				this.viewer.scene.imageryLayers.remove(this.layer);
			}
			if (this.primitive) {
				this.viewer.scene.primitives.remove(this.primitive);
				this.primitive = null;
			}
			if (this.mountPoint) {
				this.mountPoint.remove();
			}
		}
		/**
		 * 移除
		 */
		remove() {
			this.destory();
		}
	}
	/*
	 * 创建一个标签
	 * @param {*} style
	 * @param {*} parent
	 */
	function newDiv(style, parent) {
		const div = document.createElement('div');
		parent && parent.append(div);
		for (const k in style) {
			if (typeof style[k] === 'number') {
				div.style[k] = style[k] + 'px';
				continue;
			}
			div.style[k] = style[k];
		}
		return div;
	}

	/**
	 * 2D热力图
	 */
	class HeatMap2DEX {
		/**
		 * 2D热力图
		 * @param {SceneGIS.Viewer} viewer 
		 */
		constructor(viewer) {
			this._viewer = viewer;
			this._scene = viewer.scene;
			this.heatMap;
		}
		/**
		 * 添加数据
		 * @param {Array<object>} data
		 * @param {Array<Number>} rectangle 范围
		 * @param {Object} heatOption 热力配置
		 * @param {Object} autoRadiusConfig 半径配置
		 * @param {Object} canvasOptions 画布配置
		 * @param {Object} otherOptions 其他配置
		 */
		addData(data, rectangle, heatOption, autoRadiusConfig, canvasOptions, otherOptions) {
			this.heatMap = new HeatMapRenderEX(this._viewer,
				data,
				rectangle,
				// heatmap.js construction | heatmap.js的构造配置，不填默认如下，参考 https://www.patrick-wied.at/static/heatmapjs/docs.html
				heatOption || {
					gradient: {                   // the gradient used if not given in the heatmap options object
						'.3': 'blue',
						'.65': 'yellow',
						'.8': 'orange',
						'.95': 'red'
					},
				},
				// auto radius change with height | 自动按高度控制热点的辐射，默认值如下
				autoRadiusConfig || {
					enabled: true,  // 是否开启，关闭的话不会自动更新
					min: 6375000,   // 最低高度，对应高度的辐射为minRadius
					//max: 8375000,  // 最大高度，对应高度的辐射为maxRadius
					max: 9999000,  // 最大高度，对应高度的辐射为maxRadius
					//max: 10000000,  // 最大高度，对应高度的辐射为maxRadius
					//TODO 这里临时效果 乘了0.5
					maxRadius: maxRadius * 0.5,// 800 * 2,
					//minRadius: 5 * 2,
					minRadius: 6,
				},
				// auto resize canvas | 自动按bbox形状控制canvas形状，默认值如下，canvas面积越大越清晰，也越卡
				canvasOptions || {
					autoResize: true,   // 是否自动调整canvas
					///totalArea: 360 * 2 * 720 * 2,  // 总面积，如果自动，必填，如果不自动，无效//原始
					//TODO 调低
					totalArea: 360 * 2 * 720 * 0.8,  // 总面积，如果自动，必填，如果不自动，无效
					width: 720 * 2, // canvas宽度，如果不自动，必填，如果自动，无效
					height: 360 * 2, // canvas高度，如果不自动，必填，如果自动，无效
				}, false);
			return this.heatMap;
		}
		/**
		* 加载GeoJson 数据
		* @param {String|Object} dataUrl
		* @param {Array<Number>} rectangle 范围
		* @param {Object} heatOption 热力配置
		* @param {Object} autoRadiusConfig 半径配置
		* @param {Object} canvasOptions canvas配置
		*/
		loadGeoJsonData(dataUrl, rectangle, heatOption, autoRadiusConfig, canvasOptions) {
			if (!dataUrl) {
				return;
			}
			const planeView = this._viewer.scene.planeView;
			return SceneGIS.GeoJsonDataSource.load(dataUrl).then(data => {
				console.log("2D data:", data);
				const entities = data.entities.values;
				let _rectangle = rectangle;
				const tmpData = [];
				const cartesian3Data = [];
				let maxRadius = 0;
				entities.forEach(entity => {
					let position, cartoPos;
					if (planeView === true) {
						position = new SceneGIS.Cartesian3(entity.properties.lon._value, entity.properties.lat._value, 0);
						cartoPos = new SceneGIS.Cartographic(position.x, position.y, position.z);
					} else {
						position = entity.position._value;
						cartoPos = new SceneGIS.Cartographic.fromCartesian(position);
					}
					let properties = entity.properties;
					let height = (properties && properties.value && properties.value.getValue()) || parseInt(Math.random() * 200 + 20);
					let _maxRadius = (properties && properties.radius && properties.radius.getValue()) || 500;
					if (_maxRadius > maxRadius) {
						maxRadius = _maxRadius;
					}
					cartesian3Data.push(position);
					if (planeView === true) {
						tmpData.push({
							x: cartoPos.longitude,
							y: cartoPos.latitude,
							value: height,
						});
					} else {
						tmpData.push({
							x: SceneGIS.Math.toDegrees(cartoPos.longitude),
							y: SceneGIS.Math.toDegrees(cartoPos.latitude),
							value: height,
						});
					}
				});
				_rectangle || (_rectangle = SceneGIS.Rectangle.fromCartesianArray(cartesian3Data));
				if (autoRadiusConfig) {
					autoRadiusConfig.maxRadius = maxRadius;
				} else {
					autoRadiusConfig = {
						enabled: true,  // 是否开启，关闭的话不会自动更新
						min: 6375000,   // 最低高度，对应高度的辐射为minRadius
						max: 9999000,  // 最大高度，对应高度的辐射为maxRadius
						maxRadius: maxRadius * 0.5,// 800 * 2,
						minRadius: 6,
					};
				}
				let westDeg, southDeg, eastDeg, northDeg;
				if (this._viewer.scene.planeView === true) {
					westDeg = _rectangle.west - 8000;
					southDeg = _rectangle.south - 8000;
					eastDeg = _rectangle.east + 8000;
					northDeg = _rectangle.north + 8000;
				} else {
					westDeg = SceneGIS.Math.toDegrees(_rectangle.west - 0.0001);
					southDeg = SceneGIS.Math.toDegrees(_rectangle.south - 0.0001);
					eastDeg = SceneGIS.Math.toDegrees(_rectangle.east + 0.0001);
					northDeg = SceneGIS.Math.toDegrees(_rectangle.north + 0.0001);
				}
				this.addData(tmpData, [westDeg, southDeg, eastDeg, northDeg], heatOption, autoRadiusConfig, canvasOptions);

				return data;
			});
		}
		/**
		 * 移除
		 */
		remove() {
			this.heatMap && this.heatMap.destory();
			this.heatMap = null;
		}
		setVisible(val) {
			this.heatMap.primitive.show = val;
		}
	}

	/**
	 * 3D热力图
	 */
	class HeatMap3DEX {
		/**
		 * 3D热力图
		 * @param {SceneGIS.Viewer} viewer 
		 */
		constructor(viewer) {
			this._viewer = viewer;
			this._scene = viewer.scene;
		}
		/**
		 * 添加数据
		 * @param {Array<object>} data 
		 * @param {Array<Number>} rectangle 范围
		 * @param {Object} heatOption 热力配置
		 * @param {Object} autoRadiusConfig 半径配置
		 * @param {Object} canvasOptions 画布配置
		 */
		addData(data, rectangle, heatOption, autoRadiusConfig, canvasOptions) {
			if (!data || !rectangle) {
				return;
			}
			this.remove();
			this.heatMapColorImage = this._createHeatMapImage(data, rectangle, heatOption, autoRadiusConfig, canvasOptions);
			this.heatMapIntensityImage = this._createHeatMapImage(data, rectangle, {
				gradient: {
					'0.3': "rgb(0,0,0)",
					'0.65': "rgb(64,64,64)",
					'0.8': "rgb(128,128,128)",
					'0.95': "rgb(250,250,250)",
					'1.0': "rgb(255,255,255)",
				},
			}, autoRadiusConfig, canvasOptions);
			this.render();
		}
		/**
		 * 加载GeoJson 数据
		 * @param {String|Object} dataUrl
		 * @param {Array<Number>} rectangle 范围
		 * @param {Object} heatOption 热力配置
		 * @param {Object} autoRadiusConfig 半径配置
		 * @param {Object} canvasOptions canvas配置
		 * @param {Object} otherOptions  其他扩展参数配置
		 */
		loadGeoJsonData(dataUrl, rectangle, heatOption, autoRadiusConfig, canvasOptions, otherOptions) {
			if (!dataUrl) {
				return;
			}
			const planeView = this._viewer.scene.planeView;
			return SceneGIS.GeoJsonDataSource.load(dataUrl).then(data => {
				console.log("3D data:", data);
				const entities = data.entities.values;
				let _rectangle = rectangle;
				const tmpData = [];
				const cartesian3Data = [];
				let maxRadius = 0;
				entities.forEach(entity => {
					let position, cartoPos;
					if (planeView === true) {
						position = new SceneGIS.Cartesian3(entity.properties.lon._value, entity.properties.lat._value, 0);
						cartoPos = new SceneGIS.Cartographic(position.x, position.y, position.z);
					} else {
						position = entity.position._value;
						cartoPos = new SceneGIS.Cartographic.fromCartesian(position);
					}
					let properties = entity.properties;
					let height = (properties && properties.value && properties.value.getValue()) || parseInt(Math.random() * 200 + 20);
					let _maxRadius = (properties && properties.radius && properties.radius.getValue()) || 500;
					if (_maxRadius > maxRadius) {
						maxRadius = _maxRadius;
					}
					cartesian3Data.push(position);
					if (planeView === true) {
						tmpData.push({
							x: cartoPos.longitude,
							y: cartoPos.latitude,
							value: height,
						});
					} else {
						tmpData.push({
							x: SceneGIS.Math.toDegrees(cartoPos.longitude),
							y: SceneGIS.Math.toDegrees(cartoPos.latitude),
							value: height,
						});
					}
				});
				_rectangle || (_rectangle = SceneGIS.Rectangle.fromCartesianArray(cartesian3Data));
				if (autoRadiusConfig) {
					autoRadiusConfig.maxRadius = maxRadius;
				} else {
					autoRadiusConfig = {
						enabled: true,  // 是否开启，关闭的话不会自动更新
						min: 6375000,   // 最低高度，对应高度的辐射为minRadius
						max: 9999000,  // 最大高度，对应高度的辐射为maxRadius
						maxRadius: maxRadius * 0.5,// 800 * 2,
						minRadius: 6,
					};
				}
				this.rectangle = _rectangle;
				let westDeg, southDeg, eastDeg, northDeg;
				if (this._viewer.scene.planeView === true) {
					westDeg = _rectangle.west - 8000;
					southDeg = _rectangle.south - 8000;
					eastDeg = _rectangle.east + 8000;
					northDeg = _rectangle.north + 8000;
				} else {
					westDeg = SceneGIS.Math.toDegrees(_rectangle.west - 0.0001);
					southDeg = SceneGIS.Math.toDegrees(_rectangle.south - 0.0001);
					eastDeg = SceneGIS.Math.toDegrees(_rectangle.east + 0.0001);
					northDeg = SceneGIS.Math.toDegrees(_rectangle.north + 0.0001);
				}
				this.addData(tmpData, [westDeg, southDeg, eastDeg, northDeg], heatOption, autoRadiusConfig, canvasOptions);

				return data;
			});

		}
		/** @private */
		_createHeatMapImage(data, rectangle, heatOption, autoRadiusConfig, canvasOptions) {
			const heatMapImage = new HeatMapRenderEX(this._viewer,
				data,
				rectangle,
				// heatmap.js construction | heatmap.js的构造配置，不填默认如下，参考 https://www.patrick-wied.at/static/heatmapjs/docs.html
				heatOption || {
					gradient: {                   // the gradient used if not given in the heatmap options object
						'.3': 'blue',
						'.65': 'yellow',
						'.8': 'orange',
						'.95': 'red'
					},
				},
				// auto radius change with height | 自动按高度控制热点的辐射，默认值如下
				autoRadiusConfig || {
					enabled: true,  // 是否开启，关闭的话不会自动更新
					min: 6375000,   // 最低高度，对应高度的辐射为minRadius
					//max: 8375000,  // 最大高度，对应高度的辐射为maxRadius
					max: 9999000,  // 最大高度，对应高度的辐射为maxRadius
					//max: 10000000,  // 最大高度，对应高度的辐射为maxRadius
					//TODO 这里临时效果 乘了0.5
					maxRadius: maxRadius * 0.5,// 800 * 2,
					//minRadius: 5 * 2,
					minRadius: 6,
				},
				// auto resize canvas | 自动按bbox形状控制canvas形状，默认值如下，canvas面积越大越清晰，也越卡
				canvasOptions || {
					autoResize: true,   // 是否自动调整canvas
					///totalArea: 360 * 2 * 720 * 2,  // 总面积，如果自动，必填，如果不自动，无效//原始
					//TODO 调低
					totalArea: 360 * 2 * 720 * 0.8,  // 总面积，如果自动，必填，如果不自动，无效
					width: 720 * 2, // canvas宽度，如果不自动，必填，如果自动，无效
					height: 360 * 2, // canvas高度，如果不自动，必填，如果自动，无效
				}, true);
			return heatMapImage;
		}
		/** @private */
		render() {
			const primitives = this._scene.primitives;
			var HeatMapVS = "attribute vec3 position3DHigh;\n" +
				"attribute vec3 position3DLow;\n" +
				"attribute vec2 st;\n" +
				"attribute float batchId;\n" +
				"uniform sampler2D intensityImage_3;\n" +
				"uniform float heightScale_4;\n" +
				"varying vec3 v_positionMC;\n" +
				"varying vec3 v_positionEC;\n" +
				"varying vec2 v_st;\n" +
				"void main()\n" +
				"{\n" +
				"    vec4 pos = czm_computePosition();\n" +
				"  v_positionMC = position3DHigh + position3DLow;\n" +
				"  v_positionEC = (czm_modelViewRelativeToEye * pos).xyz;\n" +
				" v_st = st;\n" +
				"  vec4 intensity = texture2D(intensityImage_3, v_st);\n" +
				"  float centerIntensity = distance(vec3(0.0),intensity.rgb);\n" +
				"  vec3 upDir = normalize(v_positionMC.xyz);\n" +
				"  vec3 disPos = upDir * centerIntensity * heightScale_4;\n" +
				"  pos +=vec4(disPos,0.0);\n" +
				"  gl_Position = czm_modelViewProjectionRelativeToEye * pos;\n" +
				"}\n";
			var HeatMapFS = "varying vec3 v_positionMC;\n" +
				"varying vec3 v_positionEC;\n" +
				"varying vec2 v_st;\n" +
				"void main()\n" +
				"{\n" +
				"czm_materialInput materialInput;\n" +
				"vec3 normalEC = normalize(czm_normal3D * czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));\n" +
				"// 对应 材质里面设置的 faceForward\n" +
				"#ifdef FACE_FORWARD\n" +
				"normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n" +
				" #endif\n" +
				"materialInput.st = v_st;\n" +
				"materialInput.normalEC = normalEC;\n" +
				"materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, materialInput.normalEC);\n" +
				"vec3 positionToEyeEC = -v_positionEC;\n" +
				"materialInput.positionToEyeEC = positionToEyeEC;\n" +
				"czm_material material = czm_getMaterial(materialInput);\n" +
				"// 对应 材质里面设置的 flat\n" +
				"#ifdef FLAT\n" +
				"gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n" +
				"#else\n" +
				"gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n" +
				"#endif\n" +
				"// 避免闪白\n" +
				"if(gl_FragColor.r >0.99 && gl_FragColor.g >0.99 &&gl_FragColor.b >0.99 ){\n" +
				"gl_FragColor.a = 0.0;   \n" +
				"}\n" +
				"//FIXME: MRT\n" +
				" gl_FragData[1] = vec4(0.);\n" +
				"gl_FragData[2] = vec4(0.);\n" +
				"gl_FragData[3] = vec4(0.);\n" +
				"}\n";
			this.primitive = primitives.add(new SceneGIS.Primitive({
				geometryInstances: new SceneGIS.GeometryInstance({
					geometry: new SceneGIS.RectangleGeometry({
						ellipsoid: SceneGIS.Ellipsoid.WGS84,
						rectangle: this.rectangle,
						vertexFormat: SceneGIS.MaterialAppearance.vertexFormat,
						height: 10,
						granularity: Math.PI / 180 * 0.0005,
						planeView: this._scene.planeView
					})
				}),
				appearance: new SceneGIS.EllipsoidSurfaceAppearance({
					// aboveGround: true,
					// faceForward: true,
					// useVertex: true,
					material: new SceneGIS.Material({
						fabric: {
							uniforms: {
								image: this.heatMapColorImage.heatmap._renderer.canvas,
								repeat: new SceneGIS.Cartesian2(1, 1),
								color: new SceneGIS.Color(1, 1, 1, 1),
								intensityImage: this.heatMapIntensityImage.heatmap._renderer.canvas,
								heightScale: 1000
							},
							components: {
								diffuse: "texture2D(image, fract(repeat * materialInput.st)).rgb * color.rgb",
								alpha: "texture2D(image, fract(repeat * materialInput.st)).a"
							}
						},
						translucent: function () {
							return false;
						}
					}),
					vertexShaderSource: HeatMapVS,
					fragmentShaderSource: HeatMapFS
				})
			}));
			const that = this;
			this.cameraMoveEnd = () => {
				if (!that.primitive) {
					return;
				}
				that.heatMapColorImage && that.heatMapColorImage.updateHeatmap();
				that.heatMapIntensityImage && that.heatMapIntensityImage.updateHeatmap();
				that.primitive.appearance.material.uniforms.image = that.heatMapColorImage.heatmap.getDataURL();
				that.primitive.appearance.material.uniforms.intensityImage = that.heatMapIntensityImage.heatmap.getDataURL();
			};
			this._viewer.camera.changed.addEventListener(this.cameraMoveEnd);
			//this._viewer.clock.onTick.addEventListener(this.cameraMoveEnd);
		}
		/**
		 * 移除
		 */
		remove() {
			const primitives = this._scene.primitives;
			primitives.remove(this.primitive);
			this.heatMapColorImage && this.heatMapColorImage.destory();
			this.heatMapColorImage = null;
			this.heatMapIntensityImage && this.heatMapIntensityImage.destory();
			this.heatMapIntensityImage = null;
			this.cameraMoveEnd && this._viewer.camera.changed.removeEventListener(this.cameraMoveEnd);
		}
		setVisible(val) {
			this.primitive.show = val;
		}
	}

	/**
	 *  地图通用函数库
	 * @exports MapHelperEX
	 * @alias MapHelperEX
	 */
	var MapHelperEX = {};

	/**
	 * 获取当前地图中心点的经纬度
	 * @param {Viewer} viewer 地图视图
	 * @returns {Object} 经纬度对象
	 **/
	MapHelperEX.getCenterPosition = function getCenterPosition(viewer, planeView) {
		var result = viewer.camera.pickEllipsoid(
			new SceneGIS.Cartesian2(
				viewer.canvas.clientWidth / 2,
				viewer.canvas.clientHeight / 2
			)
		);
		if (!planeView) {
			var curPosition = SceneGIS.Ellipsoid.WGS84.cartesianToCartographic(result);
			var lon = (curPosition.longitude * 180) / Math.PI;
			var lat = (curPosition.latitude * 180) / Math.PI;

			var scene = viewer.scene;
			var ellipsoid = scene.globe.ellipsoid;
			var height = ellipsoid.cartesianToCartographic(
				viewer.camera.position
			).height;
			return {
				lon: lon,
				lat: lat,
				height: height,
			};
		}
	};

	const defaultRepeat$1 = new SceneGIS.Cartesian2(1, 1);
	const changeRepeat = new SceneGIS.Cartesian2(1, 1);
	const defaultTransparent$1 = false;
	const defaultColor$1 = SceneGIS.Color.WHITE;
	const defaultDuration$1 = 5000;
	const defaultShiness = 0; //发光强度 默认为0
	const defaultFlowAxisY = false;//默认的流动方向

	/**
	 * A {@link MaterialProperty} that maps to image {@link SceneGIS.Material} uniforms.
	 * @alias PolylineFlowImgMaterialProperty
	 * @constructor
	 *
	 * @param {Object} [options] Object with the following properties:
	 * @param {SceneGIS.Property} [options.image] A SceneGIS.Property specifying the Image, URL, Canvas, or Video.
	 * @param {SceneGIS.Property} [options.repeat=new SceneGIS.Cartesian2(1.0, 1.0)] A {@link SceneGIS.Cartesian2} SceneGIS.Property specifying the number of times the image repeats in each direction.
	 * @param {SceneGIS.Property} [options.color=SceneGIS.Color.WHITE] The color applied to the image
	 * @param {SceneGIS.Property} [options.transparent=false] Set to true when the image has transparency (for example, when a png has transparent sections)
	 */
	function PolylineFlowImgMaterialProperty(options) {
		this._scene = options.scene;
		this._meterLength = options.meterLength;
		this._definitionChanged = new SceneGIS.Event();
		this._image = undefined;
		this._imageSubscription = undefined;
		this._repeat = undefined;
		this._repeatSubscription = undefined;
		this._color = undefined;
		this._colorSubscription = undefined;
		this._transparent = undefined;
		this._transparentSubscription = undefined;
		this.image = options.image;
		this.repeat = options.repeat || defaultRepeat$1;
		this.color = options.color || defaultColor$1;
		this.transparent = options.transparent || defaultTransparent$1;
		this.shiness = defaultShiness;
		if (options.shiness !== undefined)
			this.shiness = options.shiness;

		this._time = (new Date()).getTime();
		this.duration = options.duration || defaultDuration$1;
		this.flowAxisY = options.flowAxisY || defaultFlowAxisY;
	}

	Object.defineProperties(PolylineFlowImgMaterialProperty.prototype, {
		/**
		 * Gets a value indicating if this property is constant.  A property is considered
		 * constant if getValue always returns the same result for the current definition.
		 * @memberof PolylineFlowImgMaterialProperty.prototype
		 *
		 * @type {Boolean}
		 * @readonly
		 */
		isConstant: {
			get: function () {
				return false;
			}
		},

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is considered to have changed if a call to getValue would return
		 * a different result for the same time.
		 * @memberof PolylineFlowImgMaterialProperty.prototype
		 *
		 * @type {SceneGIS.Event}
		 * @readonly
		 */
		definitionChanged: {
			get: function () {
				return this._definitionChanged;
			}
		},

		/**
		 * Gets or sets the SceneGIS.Property specifying Image, URL, Canvas, or Video to use.
		 * @memberof PolylineFlowImgMaterialProperty.prototype
		 * @type {SceneGIS.Property}
		 */
		image: SceneGIS.createPropertyDescriptor('image'),

		/**
		 * Gets or sets the {@link SceneGIS.Cartesian2} SceneGIS.Property specifying the number of times the image repeats in each direction.
		 * @memberof PolylineFlowImgMaterialProperty.prototype
		 * @type {SceneGIS.Property}
		 * @default new SceneGIS.Cartesian2(1, 1)
		 */
		repeat: SceneGIS.createPropertyDescriptor('repeat'),

		/**
		 * Gets or sets the SceneGIS.Color SceneGIS.Property specifying the desired color applied to the image.
		 * @memberof PolylineFlowImgMaterialProperty.prototype
		 * @type {SceneGIS.Property}
		 * @default 1.0
		 */
		color: SceneGIS.createPropertyDescriptor('color'),

		/**
		 * Gets or sets the Boolean SceneGIS.Property specifying whether the image has transparency
		 * @memberof PolylineFlowImgMaterialProperty.prototype
		 * @type {SceneGIS.Property}
		 * @default 1.0
		 */
		transparent: SceneGIS.createPropertyDescriptor('transparent')
	});

	/**
	 * Gets the {@link SceneGIS.Material} type at the provided time.
	 *
	 * @param {JulianDate} time The time for which to retrieve the type.
	 * @returns {String} The type of material.
	 */
	PolylineFlowImgMaterialProperty.prototype.getType = function (time) {
		return 'PolylineFlowImg';
	};

	/**
	 * Gets the value of the property at the provided time.
	 *
	 * @param {JulianDate} time The time for which to retrieve the value.
	 * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
	 * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
	 */
	PolylineFlowImgMaterialProperty.prototype.getValue = function (time, result) {
		if (!SceneGIS.defined(result)) {
			result = {};
		}

		result.image = SceneGIS.Property.getValueOrUndefined(this._image, time);
		//var repeat = this._repeat;
		var repeat = SceneGIS.Property.getValueOrClonedDefault(this._repeat, time, defaultRepeat$1, result.repeat); var ratio = 1.0;
		var duration = this.duration;
		if (this._scene && this._meterLength) {
			var pixelSize = this._computePixelSizeAtCoordinate();
			//console.warn(pixelSize);
			//console.warn(this._meterLength);
			var len = this._meterLength / pixelSize;
			//console.warn(this._repeat);

			if (this.flowAxisY) {
				var ratio = len / (this._repeat._value.y || 1);
				changeRepeat.x = this._repeat._value.x;
				changeRepeat.y = ratio;
			} else {
				var ratio = len / (this._repeat._value.x || 1);
				changeRepeat.x = ratio;
				changeRepeat.y = this._repeat._value.y;

			}
			duration = len * this.duration;

			repeat = changeRepeat;
		}
		// console.warn("this.duration"+this.duration);
		// console.warn("duration"+duration);

		result.repeat = repeat || new SceneGIS.Cartesian2(1, 1); //

		result.color = SceneGIS.Property.getValueOrClonedDefault(this._color, time, defaultColor$1, result.color);

		//算出来时一个百分比
		result.time = (((new Date()).getTime() - this._time) %
			duration) / duration;
		// result.time = (((new Date()).getTime() - this._time) %
		//     this.duration) / this.duration;
		//result.time /= ratio;
		result.shiness = this.shiness;
		result.flowAxisY = this.flowAxisY;
		return result;
	};
	/**
	 * 根据像素大小计算
	 * @private
	 */
	PolylineFlowImgMaterialProperty.prototype._computePixelSizeAtCoordinate = function () {
		var camera = this._scene.camera;
		var canvas = this._scene.canvas;
		var frustum = camera.frustum;
		var car = SceneGIS.Cartographic.fromCartesian(camera.position);
		var pixelSize = new SceneGIS.Cartesian2();
		var pixelDimensions = frustum.getPixelDimensions(canvas.clientWidth, canvas.clientHeight,
			car.height, this._scene.pixelRatio, pixelSize);
		return pixelDimensions.x;
	};
	/**
	 * Compares this property to the provided property and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {SceneGIS.Property} [other] The other property.
	 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	 */
	PolylineFlowImgMaterialProperty.prototype.equals = function (other) {
		return this === other ||
			(other instanceof PolylineFlowImgMaterialProperty &&
				SceneGIS.Property.equals(this._image, other._image) &&
				SceneGIS.Property.equals(this._color, other._color) &&
				SceneGIS.Property.equals(this._transparent, other._transparent) &&
				SceneGIS.Property.equals(this._repeat, other._repeat));
	};

	SceneGIS.Material.PolylineFlowImgType = 'PolylineFlowImg';
	SceneGIS.Material.PolylineShineImgSource =
		"czm_material czm_getMaterial(czm_materialInput materialInput)\n\
{\n\
    czm_material material = czm_getDefaultMaterial(materialInput);\n\
    vec2 st = materialInput.st;\n\
    vec2 newSt =vec2(fract(materialInput.st.s - time), materialInput.st.t);\n\
    \n\
    if(flowAxisY) \n\
    {\n\
       newSt =vec2(materialInput.st.s,fract(materialInput.st.t - time)); \n\
    }\n\
    material.diffuse = texture2D(image, fract(repeat * newSt)).rgb * color.rgb;\n\
    if (shiness<0.0001)\n\
    {\n\
        material.alpha = texture2D(image, fract(repeat * newSt)).a * color.a;\n\
        return material;\n\
    }\n\
    if(st.t<0.3)\n\
    {\n\
        material.alpha =st.t*shiness;\n\
    }\n\
    else if(st.t>0.7)\n\
    {\n\
        material.alpha =(1.0-st.t)*shiness;\n\
    }\n\
    else\n\
    {\n\
        material.alpha = texture2D(image, fract(repeat * vec2(fract(materialInput.st.s - time), materialInput.st.t))).a* color.a;\n\
    }\n\
    return material;\n\
}";
	SceneGIS.Material._materialCache.addMaterial(SceneGIS.Material.PolylineFlowImgType, {
		fabric: {
			type: SceneGIS.Material.PolylineFlowImgType,
			uniforms: {
				image: SceneGIS.Material.DefaultImageId,
				repeat: new SceneGIS.Cartesian2(1.0, 1.0),
				color: new SceneGIS.Color(1.0, 1.0, 1.0, 1.0),
				time: 0,
				shiness: 0.5,
				flowAxisY: false
			},
			source: SceneGIS.Material.PolylineShineImgSource,

		},
		translucent: function (material) {
			return true;
		}
	});

	/******************************/
	/***       流动纹理材质       ***/
	/******************************/

	const defaultRepeat = new SceneGIS.Cartesian2(1, 1);
	const defaultTransparent = false;
	const defaultColor = SceneGIS.Color.WHITE;
	const defaultPercent = 0.01;
	const defaultDuration = 5000;

	/**
	 * A {@link MaterialProperty} that maps to image {@link SceneGIS.Material} uniforms.
	 * @alias PolylineFlowTailMaterialProperty
	 * @constructor
	 *
	 * @param {Object} [options] Object with the following properties:
	 * @param {SceneGIS.Property} [options.image] A SceneGIS.Property specifying the Image, URL, Canvas, or Video.
	 * @param {SceneGIS.Property} [options.repeat=new SceneGIS.Cartesian2(1.0, 1.0)] A {@link SceneGIS.Cartesian2} SceneGIS.Property specifying the number of times the image repeats in each direction.
	 * @param {SceneGIS.Property} [options.color=SceneGIS.Color.WHITE] The color applied to the image
	 * @param {SceneGIS.Property} [options.transparent=false] Set to true when the image has transparency (for example, when a png has transparent sections)
	 */
	function PolylineFlowTailMaterialProperty(options) {
		this._definitionChanged = new SceneGIS.Event();
		this._image = undefined;
		this._imageSubscription = undefined;
		this._repeat = undefined;
		this._repeatSubscription = undefined;
		this._color = undefined;
		this._colorSubscription = undefined;
		this._percent = undefined;
		this._percentSubscription = undefined;
		this._transparent = undefined;
		this._transparentSubscription = undefined;
		this.image = options.image;
		this.repeat = options.repeat || defaultRepeat;
		this.color = options.color || defaultColor;
		this.percent = options.percent || defaultPercent;
		this.transparent = options.transparent || defaultTransparent;
		this._time = (new Date()).getTime();
		this.duration = options.duration || defaultDuration;
	}

	Object.defineProperties(PolylineFlowTailMaterialProperty.prototype, {
		/**
		 * Gets a value indicating if this property is constant.  A property is considered
		 * constant if getValue always returns the same result for the current definition.
		 * @memberof PolylineFlowTailMaterialProperty.prototype
		 *
		 * @type {Boolean}
		 * @readonly
		 */
		isConstant: {
			get: function () {
				return false;
			}
		},

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is considered to have changed if a call to getValue would return
		 * a different result for the same time.
		 * @memberof PolylineFlowTailMaterialProperty.prototype
		 *
		 * @type {SceneGIS.Event}
		 * @readonly
		 */
		definitionChanged: {
			get: function () {
				return this._definitionChanged;
			}
		},

		/**
		 * Gets or sets the SceneGIS.Property specifying Image, URL, Canvas, or Video to use.
		 * @memberof PolylineFlowTailMaterialProperty.prototype
		 * @type {SceneGIS.Property}
		 */
		image: SceneGIS.createPropertyDescriptor('image'),

		/**
		 * Gets or sets the {@link SceneGIS.Cartesian2} SceneGIS.Property specifying the number of times the image repeats in each direction.
		 * @memberof PolylineFlowTailMaterialProperty.prototype
		 * @type {SceneGIS.Property}
		 * @default new SceneGIS.Cartesian2(1, 1)
		 */
		repeat: SceneGIS.createPropertyDescriptor('repeat'),

		/**
		 * Gets or sets the SceneGIS.Color SceneGIS.Property specifying the desired color applied to the image.
		 * @memberof PolylineFlowTailMaterialProperty.prototype
		 * @type {SceneGIS.Property}
		 * @default 1.0
		 */
		color: SceneGIS.createPropertyDescriptor('color'),
		percent: SceneGIS.createPropertyDescriptor('percent'),

		/**
		 * Gets or sets the Boolean SceneGIS.Property specifying whether the image has transparency
		 * @memberof PolylineFlowTailMaterialProperty.prototype
		 * @type {SceneGIS.Property}
		 * @default 1.0
		 */
		transparent: SceneGIS.createPropertyDescriptor('transparent')
	});

	/**
	 * Gets the {@link SceneGIS.Material} type at the provided time.
	 *
	 * @param {JulianDate} time The time for which to retrieve the type.
	 * @returns {String} The type of material.
	 */
	PolylineFlowTailMaterialProperty.prototype.getType = function (time) {
		return 'PolylineFlowTail';
	};

	/**
	 * Gets the value of the property at the provided time.
	 *
	 * @param {JulianDate} time The time for which to retrieve the value.
	 * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
	 * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
	 */
	PolylineFlowTailMaterialProperty.prototype.getValue = function (time, result) {
		if (!SceneGIS.defined(result)) {
			result = {};
		}

		result.image = SceneGIS.Property.getValueOrUndefined(this._image, time);

		result.repeat = SceneGIS.Property.getValueOrClonedDefault(this._repeat, time, defaultRepeat, result.repeat);

		result.color = SceneGIS.Property.getValueOrClonedDefault(this._color, time, defaultColor, result.color);

		result.percent = SceneGIS.Property.getValueOrClonedDefault(this._percent, time, defaultPercent, result.percent);

		//算出来时一个百分比
		result.time = (((new Date()).getTime() - this._time) %
			this.duration) / this.duration;
		return result;
	};

	/**
	 * Compares this property to the provided property and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {SceneGIS.Property} [other] The other property.
	 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	 */
	PolylineFlowTailMaterialProperty.prototype.equals = function (other) {
		return this === other ||
			(other instanceof PolylineFlowTailMaterialProperty &&
				SceneGIS.Property.equals(this._image, other._image) &&
				SceneGIS.Property.equals(this._color, other._color) &&
				SceneGIS.Property.equals(this._percent, other._percent) &&
				SceneGIS.Property.equals(this._transparent, other._transparent) &&
				SceneGIS.Property.equals(this._repeat, other._repeat));
	};

	SceneGIS.Material.PolylineFlowTailType = 'PolylineFlowTail';
	SceneGIS.Material.PolylineShineImgSource =
		"czm_material czm_getMaterial(czm_materialInput materialInput)\n\
{\n\
    czm_material material = czm_getDefaultMaterial(materialInput);\n\
    vec2 st = materialInput.st;\n\
    if(time-materialInput.st.s<percent && time-materialInput.st.s>0.0)\n\
    {\n\
        float strongs1=1.0-abs(time-materialInput.st.s)/percent;\n\
        float strongs2=1.0-abs(materialInput.st.t-0.5);\n\
        material.diffuse = color.rgb*vec3(strongs1*strongs2*5.0);\n\
        material.alpha = strongs1*strongs2;\n\
    }\n\
    else\n\
    {\n\
        material.diffuse = color.rgb;\n\
        if(materialInput.st.t>0.25 && materialInput.st.t<0.75)\n\
        {\n\
            material.alpha = color.a;\n\
        }\n\
        else\n\
        {\n\
            material.alpha = color.a/10.0;\n\
        }\n\
    }\n\
    return material;\n\
}";
	SceneGIS.Material._materialCache.addMaterial(SceneGIS.Material.PolylineFlowTailType, {
		fabric: {
			type: SceneGIS.Material.PolylineFlowTailType,
			uniforms: {
				image: SceneGIS.Material.DefaultImageId,
				color: new SceneGIS.Color(1.0, 1.0, 1.0, 1.0),
				percent: 0.01,
				time: 0,
			},
			source: SceneGIS.Material.PolylineShineImgSource,

		},
		translucent: function (material) {
			return true;
		}
	});

	/**
	 * 动态线材质
	 *
	 * @alias PolylineTrailEX
	 * @constructor
	 * 
	 * @param {Object} [option] 接下来的属性对象:
	 * @param {String} [options.name]  名字
	 * @param {String | img} [options.img] 纹理图片
	 * @param {Color} [options.diffuseColor] 颜色
	 **/

	function PolylineTrailEX(option) {
		//添加到材质缓存中
		this.PolylineTrailLinkType = option.name;//'PolylineTrailLink';
		this.PolylineTrailLinkImage = option.img;
		this.PolylineTrailLinkSource = "czm_material czm_getMaterial(czm_materialInput materialInput)\n\
                                                {\n\
                                                    czm_material material = czm_getDefaultMaterial(materialInput);\n\
                                                    vec2 st = materialInput.st;\n\
                                                    vec4 colorImage = texture2D(image, vec2(fract(repeat*st.s - time), st.t));\n\
                                                    material.alpha = colorImage.a * color.a;\n\
                                                    material.diffuse = (colorImage.rgb+color.rgb)/2.0;\n\
                                                    vec4 fragColor;\n\
                                                    fragColor.rgb = (colorImage.rgb+color.rgb) / 1.0;\n\
                                                    fragColor = czm_gammaCorrect(fragColor);\n\
                                                    material.alpha = colorImage.a * color.a;\n\
                                                    material.emission = fragColor.rgb;return material;\n\
                                                }";

		SceneGIS.Material._materialCache.addMaterial(this.PolylineTrailLinkType, {
			fabric: {
				type: this.PolylineTrailLinkType,
				uniforms: {
					color: option.diffuseColor,
					image: this.PolylineTrailLinkImage,
					time: -1,
					repeat: option.repeat,
					diffuseColor: option.diffuseColor
				},
				source: this.PolylineTrailLinkSource
			},
			translucent: function (material) {
				return true;
			}
		});
	}

	Object.defineProperties(PolylineTrailEX.prototype, {
	});

	/**
	 * 动态线属性
	 *
	 * @alias PolylineTrailLinkMaterialPropertyEX
	 * @constructor
	 * 
	 * @param {Color} color  颜色
	 * @param {SceneGisPolylineTrail} PolylineTrail SceneGisPolylineTrail 对象
	 * @param {Number} duration 纹理运动时间
	 **/

	function PolylineTrailLinkMaterialPropertyEX(color, PolylineTrail, duration) {
		this._definitionChanged = new SceneGIS.Event();
		this._color = undefined;
		this._colorSubscription = undefined;
		this.color = color;
		this.duration = duration || 3000;
		this._time = (new Date()).getTime();



		this._PolylineTrail = PolylineTrail;
		//this._name=PolylineTrail.PolylineTrailLinkType

		this.isTranslucent = function () {
			return true;
		};
	}

	Object.defineProperties(PolylineTrailLinkMaterialPropertyEX.prototype, {
		isConstant: {
			get: function () {
				return true;
			}
		},
		definitionChanged: {
			get: function () {
				return this._definitionChanged;
			}
		},
		color: createPropertyDescriptor$1("color"),
		image: createPropertyDescriptor$1("image"),
		time: createPropertyDescriptor$1("time"),
		repeat: createPropertyDescriptor$1("repeat")
	});

	PolylineTrailLinkMaterialPropertyEX.prototype.getType = function (time) {
		return this._PolylineTrail.PolylineTrailLinkType;
	};
	PolylineTrailLinkMaterialPropertyEX.prototype.getValue = function (time, result) {

		if (!SceneGIS.defined(result)) {
			result = {};
		}
		result.color = SceneGIS.Property.getValueOrClonedDefault(this._color, time, SceneGIS.Color.WHITE, result.color);
		result.image = this._PolylineTrail.PolylineTrailLinkImage;
		result.time = (((new Date()).getTime() - this._time) % this.duration) / this.duration;

		return result;
	};
	PolylineTrailLinkMaterialPropertyEX.prototype.equals = function (other) {
		return this === other ||
			(other instanceof PolylineTrailLinkMaterialPropertyEX &&
				SceneGIS.Property.equals(this._color, other._color))
	};

	function commonjsRequire(path) {
		throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
	}

	var shpExports = {};
	var shp$1 = {
		get exports() { return shpExports; },
		set exports(v) { shpExports = v; },
	};

	(function (module, exports) {
		(function (f) { { module.exports = f(); } })(function () {
			return (function () { function r(e, n, t) { function o(i, f) { if (!n[i]) { if (!e[i]) { var c = "function" == typeof commonjsRequire && commonjsRequire; if (!f && c) return c(i, !0); if (u) return u(i, !0); var a = new Error("Cannot find module '" + i + "'"); throw a.code = "MODULE_NOT_FOUND", a } var p = n[i] = { exports: {} }; e[i][0].call(p.exports, function (r) { var n = e[i][1][r]; return o(n || r) }, p, p.exports, r, e, n, t); } return n[i].exports } for (var u = "function" == typeof commonjsRequire && commonjsRequire, i = 0; i < t.length; i++)o(t[i]); return o } return r })()({
				1: [function (require, module, exports) {
					const Promise = require('lie');
					const combine = require('./combine');
					const Buffer = require('buffer').Buffer;
					module.exports = binaryAjax;
					function binaryAjax(_url, type) {
						return new Promise(function (resolve, reject) {
							const url = combine(_url, type);
							const ajax = new XMLHttpRequest();
							ajax.open('GET', url, true);
							if (type !== 'prj' && type !== 'cpg') {
								ajax.responseType = 'arraybuffer';
							}
							ajax.addEventListener('load', function () {
								if (ajax.status > 399) {
									if (type === 'prj' || type === 'cpg') {
										return resolve(false);
									} else {
										return reject(new Error(ajax.status));
									}
								}
								if (type !== 'prj' && type !== 'cpg') {
									return resolve(Buffer.from(ajax.response));
								} else {
									return resolve(ajax.response);
								}
							}, false);
							ajax.send();
						});
					}

				}, { "./combine": 3, "buffer": 8, "lie": 12 }], 2: [function (require, module, exports) {
					(function (global) {
						(function () {
							const fallback = require('./binaryajax-browser');
							const combine = require('./combine');
							const Buffer = require('buffer').Buffer;
							module.exports = async function binaryAjax(_url, type) {
								if (!global.fetch) {
									return fallback(_url, type);
								}
								const url = combine(_url, type);
								const isOptionalTxt = type === 'prj' || type === 'cpg';
								try {
									const resp = await fetch(url);
									if (resp.status > 399) {
										throw new Error(resp.statusText);
									}
									if (isOptionalTxt) {
										return resp.text();
									}
									const parsed = await resp.arrayBuffer();
									return Buffer.from(parsed);
								} catch (e) {
									console.log('ERROR', e, type);
									if (isOptionalTxt || type === 'dbf') {
										return false;
									}
									throw e;
								}
							};

						}).call(this);
					}).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
				}, { "./binaryajax-browser": 1, "./combine": 3, "buffer": 8 }], 3: [function (require, module, exports) {
					(function (global) {
						(function () {
							const URL = global.URL;

							module.exports = (base, type) => {
								if (!type) {
									return base;
								}
								const url = new URL(base);
								url.pathname = `${url.pathname}.${type}`;
								return url.href;
							};

						}).call(this);
					}).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
				}, {}], 4: [function (require, module, exports) {

					function isClockWise(array) {
						let sum = 0;
						let i = 1;
						const len = array.length;
						let prev, cur;
						while (i < len) {
							prev = cur || array[0];
							cur = array[i];
							sum += ((cur[0] - prev[0]) * (cur[1] + prev[1]));
							i++;
						}
						return sum > 0;
					}

					function polyReduce(a, b) {
						if (isClockWise(b) || !a.length) {
							a.push([b]);
						} else {
							a[a.length - 1].push(b);
						}
						return a;
					}
					ParseShp.prototype.parsePoint = function (data) {
						return {
							type: 'Point',
							coordinates: this.parseCoord(data, 0)
						};
					};
					ParseShp.prototype.parseZPoint = function (data) {
						const pointXY = this.parsePoint(data);
						pointXY.coordinates.push(data.readDoubleLE(16));
						return pointXY;
					};
					ParseShp.prototype.parsePointArray = function (data, offset, num) {
						const out = [];
						let done = 0;
						while (done < num) {
							out.push(this.parseCoord(data, offset));
							offset += 16;
							done++;
						}
						return out;
					};
					ParseShp.prototype.parseZPointArray = function (data, zOffset, num, coordinates) {
						let i = 0;
						while (i < num) {
							coordinates[i].push(data.readDoubleLE(zOffset));
							i++;
							zOffset += 8;
						}
						return coordinates;
					};
					ParseShp.prototype.parseArrayGroup = function (data, offset, partOffset, num, tot) {
						const out = [];
						let done = 0;
						let curNum; let nextNum = 0;
						let pointNumber;
						while (done < num) {
							done++;
							partOffset += 4;
							curNum = nextNum;
							if (done === num) {
								nextNum = tot;
							} else {
								nextNum = data.readInt32LE(partOffset);
							}
							pointNumber = nextNum - curNum;
							if (!pointNumber) {
								continue;
							}
							out.push(this.parsePointArray(data, offset, pointNumber));
							offset += (pointNumber << 4);
						}
						return out;
					};
					ParseShp.prototype.parseZArrayGroup = function (data, zOffset, num, coordinates) {
						let i = 0;
						while (i < num) {
							coordinates[i] = this.parseZPointArray(data, zOffset, coordinates[i].length, coordinates[i]);
							zOffset += (coordinates[i].length << 3);
							i++;
						}
						return coordinates;
					};
					ParseShp.prototype.parseMultiPoint = function (data) {
						const out = {};
						const num = data.readInt32LE(32, true);
						if (!num) {
							return null;
						}
						const mins = this.parseCoord(data, 0);
						const maxs = this.parseCoord(data, 16);
						out.bbox = [
							mins[0],
							mins[1],
							maxs[0],
							maxs[1]
						];
						const offset = 36;
						if (num === 1) {
							out.type = 'Point';
							out.coordinates = this.parseCoord(data, offset);
						} else {
							out.type = 'MultiPoint';
							out.coordinates = this.parsePointArray(data, offset, num);
						}
						return out;
					};
					ParseShp.prototype.parseZMultiPoint = function (data) {
						const geoJson = this.parseMultiPoint(data);
						if (!geoJson) {
							return null;
						}
						let num;
						if (geoJson.type === 'Point') {
							geoJson.coordinates.push(data.readDoubleLE(72));
							return geoJson;
						} else {
							num = geoJson.coordinates.length;
						}
						const zOffset = 52 + (num << 4);
						geoJson.coordinates = this.parseZPointArray(data, zOffset, num, geoJson.coordinates);
						return geoJson;
					};
					ParseShp.prototype.parsePolyline = function (data) {
						const out = {};
						const numParts = data.readInt32LE(32);
						if (!numParts) {
							return null;
						}
						const mins = this.parseCoord(data, 0);
						const maxs = this.parseCoord(data, 16);
						out.bbox = [
							mins[0],
							mins[1],
							maxs[0],
							maxs[1]
						];
						const num = data.readInt32LE(36);
						let offset, partOffset;
						if (numParts === 1) {
							out.type = 'LineString';
							offset = 44;
							out.coordinates = this.parsePointArray(data, offset, num);
						} else {
							out.type = 'MultiLineString';
							offset = 40 + (numParts << 2);
							partOffset = 40;
							out.coordinates = this.parseArrayGroup(data, offset, partOffset, numParts, num);
						}
						return out;
					};
					ParseShp.prototype.parseZPolyline = function (data) {
						const geoJson = this.parsePolyline(data);
						if (!geoJson) {
							return null;
						}
						const num = geoJson.coordinates.length;
						let zOffset;
						if (geoJson.type === 'LineString') {
							zOffset = 60 + (num << 4);
							geoJson.coordinates = this.parseZPointArray(data, zOffset, num, geoJson.coordinates);
							return geoJson;
						} else {
							const totalPoints = geoJson.coordinates.reduce(function (a, v) {
								return a + v.length;
							}, 0);
							zOffset = 56 + (totalPoints << 4) + (num << 2);
							geoJson.coordinates = this.parseZArrayGroup(data, zOffset, num, geoJson.coordinates);
							return geoJson;
						}
					};
					ParseShp.prototype.polyFuncs = function (out) {
						if (!out) {
							return out;
						}
						if (out.type === 'LineString') {
							out.type = 'Polygon';
							out.coordinates = [out.coordinates];
							return out;
						} else {
							out.coordinates = out.coordinates.reduce(polyReduce, []);
							if (out.coordinates.length === 1) {
								out.type = 'Polygon';
								out.coordinates = out.coordinates[0];
								return out;
							} else {
								out.type = 'MultiPolygon';
								return out;
							}
						}
					};
					ParseShp.prototype.parsePolygon = function (data) {
						return this.polyFuncs(this.parsePolyline(data));
					};
					ParseShp.prototype.parseZPolygon = function (data) {
						return this.polyFuncs(this.parseZPolyline(data));
					};
					const shpFuncObj = {
						1: 'parsePoint',
						3: 'parsePolyline',
						5: 'parsePolygon',
						8: 'parseMultiPoint',
						11: 'parseZPoint',
						13: 'parseZPolyline',
						15: 'parseZPolygon',
						18: 'parseZMultiPoint'
					};

					function makeParseCoord(trans) {
						if (trans) {
							return function (data, offset) {
								const args = [data.readDoubleLE(offset), data.readDoubleLE(offset + 8)];
								return trans.inverse(args);
							};
						} else {
							return function (data, offset) {
								return [data.readDoubleLE(offset), data.readDoubleLE(offset + 8)];
							};
						}
					}

					function ParseShp(buffer, trans) {
						if (!(this instanceof ParseShp)) {
							return new ParseShp(buffer, trans);
						}
						this.buffer = buffer;
						this.headers = this.parseHeader();
						if (this.headers.length < this.buffer.byteLength) {
							this.buffer = this.buffer.slice(0, this.headers.length);
						}
						this.shpFuncs(trans);
						this.rows = this.getRows();
					}
					ParseShp.prototype.shpFuncs = function (tran) {
						let num = this.headers.shpCode;
						if (num > 20) {
							num -= 20;
						}
						if (!(num in shpFuncObj)) {
							throw new Error('I don\'t know that shp type');
						}
						this.parseFunc = this[shpFuncObj[num]];
						this.parseCoord = makeParseCoord(tran);
					};
					ParseShp.prototype.getShpCode = function () {
						return this.parseHeader().shpCode;
					};
					ParseShp.prototype.parseHeader = function () {
						const view = this.buffer.slice(0, 100);
						return {
							length: view.readInt32BE(6 << 2) << 1,
							version: view.readInt32LE(7 << 2),
							shpCode: view.readInt32LE(8 << 2),
							bbox: [
								view.readDoubleLE(9 << 2),
								view.readDoubleLE(11 << 2),
								view.readDoubleLE(13 << 2),
								view.readDoubleLE(13 << 2)
							]
						};
					};
					ParseShp.prototype.getRows = function () {
						let offset = 100;
						const len = this.buffer.byteLength;
						const out = [];
						let current;
						while (offset < len) {
							current = this.getRow(offset);
							if (!current) {
								break;
							}
							offset += 8;
							offset += current.len;
							if (current.type) {
								out.push(this.parseFunc(current.data));
							} else {
								out.push(null);
							}
						}
						return out;
					};
					ParseShp.prototype.getRow = function (offset) {
						const view = this.buffer.slice(offset, offset + 12);
						const len = view.readInt32BE(4) << 1;
						const id = view.readInt32BE(0);
						if (len === 0) {
							return {
								id: id,
								len: len,
								type: 0
							};
						}
						return {
							id: id,
							len: len,
							data: this.buffer.slice(offset + 12, offset + len + 8),
							type: view.readInt32LE(8)
						};
					};
					module.exports = function (buffer, trans) {
						return new ParseShp(buffer, trans).rows;
					};

				}, {}], 5: [function (require, module, exports) {

					const JSZip = require('jszip');
					module.exports = async (buffer) => {
						const zip = new JSZip();
						await zip.loadAsync(buffer);
						const files = zip.file(/.+/);
						const out = {};
						await Promise.all(files.map(async (a) => {
							let result;
							if (a.name.slice(-3).toLowerCase() === 'shp' || a.name.slice(-3).toLowerCase() === 'dbf') {
								result = await a.async('nodebuffer');
							} else {
								result = await a.async('text');
							}
							out[a.name] = result;
						}));
						return out;
					};

				}, { "jszip": 11 }], 6: [function (require, module, exports) {

					exports.byteLength = byteLength;
					exports.toByteArray = toByteArray;
					exports.fromByteArray = fromByteArray;

					var lookup = [];
					var revLookup = [];
					var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

					var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
					for (var i = 0, len = code.length; i < len; ++i) {
						lookup[i] = code[i];
						revLookup[code.charCodeAt(i)] = i;
					}

					// Support decoding URL-safe base64 strings, as Node.js does.
					// See: https://en.wikipedia.org/wiki/Base64#URL_applications
					revLookup['-'.charCodeAt(0)] = 62;
					revLookup['_'.charCodeAt(0)] = 63;

					function getLens(b64) {
						var len = b64.length;

						if (len % 4 > 0) {
							throw new Error('Invalid string. Length must be a multiple of 4')
						}

						// Trim off extra bytes after placeholder bytes are found
						// See: https://github.com/beatgammit/base64-js/issues/42
						var validLen = b64.indexOf('=');
						if (validLen === -1) validLen = len;

						var placeHoldersLen = validLen === len
							? 0
							: 4 - (validLen % 4);

						return [validLen, placeHoldersLen]
					}

					// base64 is 4/3 + up to two characters of the original data
					function byteLength(b64) {
						var lens = getLens(b64);
						var validLen = lens[0];
						var placeHoldersLen = lens[1];
						return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
					}

					function _byteLength(b64, validLen, placeHoldersLen) {
						return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
					}

					function toByteArray(b64) {
						var tmp;
						var lens = getLens(b64);
						var validLen = lens[0];
						var placeHoldersLen = lens[1];

						var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

						var curByte = 0;

						// if there are placeholders, only get up to the last complete 4 chars
						var len = placeHoldersLen > 0
							? validLen - 4
							: validLen;

						var i;
						for (i = 0; i < len; i += 4) {
							tmp =
								(revLookup[b64.charCodeAt(i)] << 18) |
								(revLookup[b64.charCodeAt(i + 1)] << 12) |
								(revLookup[b64.charCodeAt(i + 2)] << 6) |
								revLookup[b64.charCodeAt(i + 3)];
							arr[curByte++] = (tmp >> 16) & 0xFF;
							arr[curByte++] = (tmp >> 8) & 0xFF;
							arr[curByte++] = tmp & 0xFF;
						}

						if (placeHoldersLen === 2) {
							tmp =
								(revLookup[b64.charCodeAt(i)] << 2) |
								(revLookup[b64.charCodeAt(i + 1)] >> 4);
							arr[curByte++] = tmp & 0xFF;
						}

						if (placeHoldersLen === 1) {
							tmp =
								(revLookup[b64.charCodeAt(i)] << 10) |
								(revLookup[b64.charCodeAt(i + 1)] << 4) |
								(revLookup[b64.charCodeAt(i + 2)] >> 2);
							arr[curByte++] = (tmp >> 8) & 0xFF;
							arr[curByte++] = tmp & 0xFF;
						}

						return arr
					}

					function tripletToBase64(num) {
						return lookup[num >> 18 & 0x3F] +
							lookup[num >> 12 & 0x3F] +
							lookup[num >> 6 & 0x3F] +
							lookup[num & 0x3F]
					}

					function encodeChunk(uint8, start, end) {
						var tmp;
						var output = [];
						for (var i = start; i < end; i += 3) {
							tmp =
								((uint8[i] << 16) & 0xFF0000) +
								((uint8[i + 1] << 8) & 0xFF00) +
								(uint8[i + 2] & 0xFF);
							output.push(tripletToBase64(tmp));
						}
						return output.join('')
					}

					function fromByteArray(uint8) {
						var tmp;
						var len = uint8.length;
						var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
						var parts = [];
						var maxChunkLength = 16383; // must be multiple of 3

						// go through the array every three bytes, we'll deal with trailing stuff later
						for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
							parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
						}

						// pad the end with zeros, but make sure to not forget the extra bytes
						if (extraBytes === 1) {
							tmp = uint8[len - 1];
							parts.push(
								lookup[tmp >> 2] +
								lookup[(tmp << 4) & 0x3F] +
								'=='
							);
						} else if (extraBytes === 2) {
							tmp = (uint8[len - 2] << 8) + uint8[len - 1];
							parts.push(
								lookup[tmp >> 10] +
								lookup[(tmp >> 4) & 0x3F] +
								lookup[(tmp << 2) & 0x3F] +
								'='
							);
						}

						return parts.join('')
					}

				}, {}], 7: [function (require, module, exports) {

				}, {}], 8: [function (require, module, exports) {
					(function (Buffer) {
						(function () {

							var base64 = require('base64-js');
							var ieee754 = require('ieee754');

							exports.Buffer = Buffer;
							exports.SlowBuffer = SlowBuffer;
							exports.INSPECT_MAX_BYTES = 50;

							var K_MAX_LENGTH = 0x7fffffff;
							exports.kMaxLength = K_MAX_LENGTH;

							/**
							 * If `Buffer.TYPED_ARRAY_SUPPORT`:
							 *   === true    Use Uint8Array implementation (fastest)
							 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
							 *               implementation (most compatible, even IE6)
							 *
							 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
							 * Opera 11.6+, iOS 4.2+.
							 *
							 * We report that the browser does not support typed arrays if the are not subclassable
							 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
							 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
							 * for __proto__ and has a buggy typed array implementation.
							 */
							Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

							if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
								typeof console.error === 'function') {
								console.error(
									'This browser lacks typed array (Uint8Array) support which is required by ' +
									'`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
								);
							}

							function typedArraySupport() {
								// Can typed array instances can be augmented?
								try {
									var arr = new Uint8Array(1);
									arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } };
									return arr.foo() === 42
								} catch (e) {
									return false
								}
							}

							Object.defineProperty(Buffer.prototype, 'parent', {
								enumerable: true,
								get: function () {
									if (!Buffer.isBuffer(this)) return undefined
									return this.buffer
								}
							});

							Object.defineProperty(Buffer.prototype, 'offset', {
								enumerable: true,
								get: function () {
									if (!Buffer.isBuffer(this)) return undefined
									return this.byteOffset
								}
							});

							function createBuffer(length) {
								if (length > K_MAX_LENGTH) {
									throw new RangeError('The value "' + length + '" is invalid for option "size"')
								}
								// Return an augmented `Uint8Array` instance
								var buf = new Uint8Array(length);
								buf.__proto__ = Buffer.prototype;
								return buf
							}

							/**
							 * The Buffer constructor returns instances of `Uint8Array` that have their
							 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
							 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
							 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
							 * returns a single octet.
							 *
							 * The `Uint8Array` prototype remains unmodified.
							 */

							function Buffer(arg, encodingOrOffset, length) {
								// Common case.
								if (typeof arg === 'number') {
									if (typeof encodingOrOffset === 'string') {
										throw new TypeError(
											'The "string" argument must be of type string. Received type number'
										)
									}
									return allocUnsafe(arg)
								}
								return from(arg, encodingOrOffset, length)
							}

							// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
							if (typeof Symbol !== 'undefined' && Symbol.species != null &&
								Buffer[Symbol.species] === Buffer) {
								Object.defineProperty(Buffer, Symbol.species, {
									value: null,
									configurable: true,
									enumerable: false,
									writable: false
								});
							}

							Buffer.poolSize = 8192; // not used by this implementation

							function from(value, encodingOrOffset, length) {
								if (typeof value === 'string') {
									return fromString(value, encodingOrOffset)
								}

								if (ArrayBuffer.isView(value)) {
									return fromArrayLike(value)
								}

								if (value == null) {
									throw TypeError(
										'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
										'or Array-like Object. Received type ' + (typeof value)
									)
								}

								if (isInstance(value, ArrayBuffer) ||
									(value && isInstance(value.buffer, ArrayBuffer))) {
									return fromArrayBuffer(value, encodingOrOffset, length)
								}

								if (typeof value === 'number') {
									throw new TypeError(
										'The "value" argument must not be of type number. Received type number'
									)
								}

								var valueOf = value.valueOf && value.valueOf();
								if (valueOf != null && valueOf !== value) {
									return Buffer.from(valueOf, encodingOrOffset, length)
								}

								var b = fromObject(value);
								if (b) return b

								if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
									typeof value[Symbol.toPrimitive] === 'function') {
									return Buffer.from(
										value[Symbol.toPrimitive]('string'), encodingOrOffset, length
									)
								}

								throw new TypeError(
									'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
									'or Array-like Object. Received type ' + (typeof value)
								)
							}

							/**
							 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
							 * if value is a number.
							 * Buffer.from(str[, encoding])
							 * Buffer.from(array)
							 * Buffer.from(buffer)
							 * Buffer.from(arrayBuffer[, byteOffset[, length]])
							 **/
							Buffer.from = function (value, encodingOrOffset, length) {
								return from(value, encodingOrOffset, length)
							};

							// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
							// https://github.com/feross/buffer/pull/148
							Buffer.prototype.__proto__ = Uint8Array.prototype;
							Buffer.__proto__ = Uint8Array;

							function assertSize(size) {
								if (typeof size !== 'number') {
									throw new TypeError('"size" argument must be of type number')
								} else if (size < 0) {
									throw new RangeError('The value "' + size + '" is invalid for option "size"')
								}
							}

							function alloc(size, fill, encoding) {
								assertSize(size);
								if (size <= 0) {
									return createBuffer(size)
								}
								if (fill !== undefined) {
									// Only pay attention to encoding if it's a string. This
									// prevents accidentally sending in a number that would
									// be interpretted as a start offset.
									return typeof encoding === 'string'
										? createBuffer(size).fill(fill, encoding)
										: createBuffer(size).fill(fill)
								}
								return createBuffer(size)
							}

							/**
							 * Creates a new filled Buffer instance.
							 * alloc(size[, fill[, encoding]])
							 **/
							Buffer.alloc = function (size, fill, encoding) {
								return alloc(size, fill, encoding)
							};

							function allocUnsafe(size) {
								assertSize(size);
								return createBuffer(size < 0 ? 0 : checked(size) | 0)
							}

							/**
							 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
							 * */
							Buffer.allocUnsafe = function (size) {
								return allocUnsafe(size)
							};
							/**
							 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
							 */
							Buffer.allocUnsafeSlow = function (size) {
								return allocUnsafe(size)
							};

							function fromString(string, encoding) {
								if (typeof encoding !== 'string' || encoding === '') {
									encoding = 'utf8';
								}

								if (!Buffer.isEncoding(encoding)) {
									throw new TypeError('Unknown encoding: ' + encoding)
								}

								var length = byteLength(string, encoding) | 0;
								var buf = createBuffer(length);

								var actual = buf.write(string, encoding);

								if (actual !== length) {
									// Writing a hex string, for example, that contains invalid characters will
									// cause everything after the first invalid character to be ignored. (e.g.
									// 'abxxcd' will be treated as 'ab')
									buf = buf.slice(0, actual);
								}

								return buf
							}

							function fromArrayLike(array) {
								var length = array.length < 0 ? 0 : checked(array.length) | 0;
								var buf = createBuffer(length);
								for (var i = 0; i < length; i += 1) {
									buf[i] = array[i] & 255;
								}
								return buf
							}

							function fromArrayBuffer(array, byteOffset, length) {
								if (byteOffset < 0 || array.byteLength < byteOffset) {
									throw new RangeError('"offset" is outside of buffer bounds')
								}

								if (array.byteLength < byteOffset + (length || 0)) {
									throw new RangeError('"length" is outside of buffer bounds')
								}

								var buf;
								if (byteOffset === undefined && length === undefined) {
									buf = new Uint8Array(array);
								} else if (length === undefined) {
									buf = new Uint8Array(array, byteOffset);
								} else {
									buf = new Uint8Array(array, byteOffset, length);
								}

								// Return an augmented `Uint8Array` instance
								buf.__proto__ = Buffer.prototype;
								return buf
							}

							function fromObject(obj) {
								if (Buffer.isBuffer(obj)) {
									var len = checked(obj.length) | 0;
									var buf = createBuffer(len);

									if (buf.length === 0) {
										return buf
									}

									obj.copy(buf, 0, 0, len);
									return buf
								}

								if (obj.length !== undefined) {
									if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
										return createBuffer(0)
									}
									return fromArrayLike(obj)
								}

								if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
									return fromArrayLike(obj.data)
								}
							}

							function checked(length) {
								// Note: cannot use `length < K_MAX_LENGTH` here because that fails when
								// length is NaN (which is otherwise coerced to zero.)
								if (length >= K_MAX_LENGTH) {
									throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
										'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
								}
								return length | 0
							}

							function SlowBuffer(length) {
								if (+length != length) { // eslint-disable-line eqeqeq
									length = 0;
								}
								return Buffer.alloc(+length)
							}

							Buffer.isBuffer = function isBuffer(b) {
								return b != null && b._isBuffer === true &&
									b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
							};

							Buffer.compare = function compare(a, b) {
								if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
								if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
								if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
									throw new TypeError(
										'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
									)
								}

								if (a === b) return 0

								var x = a.length;
								var y = b.length;

								for (var i = 0, len = Math.min(x, y); i < len; ++i) {
									if (a[i] !== b[i]) {
										x = a[i];
										y = b[i];
										break
									}
								}

								if (x < y) return -1
								if (y < x) return 1
								return 0
							};

							Buffer.isEncoding = function isEncoding(encoding) {
								switch (String(encoding).toLowerCase()) {
									case 'hex':
									case 'utf8':
									case 'utf-8':
									case 'ascii':
									case 'latin1':
									case 'binary':
									case 'base64':
									case 'ucs2':
									case 'ucs-2':
									case 'utf16le':
									case 'utf-16le':
										return true
									default:
										return false
								}
							};

							Buffer.concat = function concat(list, length) {
								if (!Array.isArray(list)) {
									throw new TypeError('"list" argument must be an Array of Buffers')
								}

								if (list.length === 0) {
									return Buffer.alloc(0)
								}

								var i;
								if (length === undefined) {
									length = 0;
									for (i = 0; i < list.length; ++i) {
										length += list[i].length;
									}
								}

								var buffer = Buffer.allocUnsafe(length);
								var pos = 0;
								for (i = 0; i < list.length; ++i) {
									var buf = list[i];
									if (isInstance(buf, Uint8Array)) {
										buf = Buffer.from(buf);
									}
									if (!Buffer.isBuffer(buf)) {
										throw new TypeError('"list" argument must be an Array of Buffers')
									}
									buf.copy(buffer, pos);
									pos += buf.length;
								}
								return buffer
							};

							function byteLength(string, encoding) {
								if (Buffer.isBuffer(string)) {
									return string.length
								}
								if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
									return string.byteLength
								}
								if (typeof string !== 'string') {
									throw new TypeError(
										'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
										'Received type ' + typeof string
									)
								}

								var len = string.length;
								var mustMatch = (arguments.length > 2 && arguments[2] === true);
								if (!mustMatch && len === 0) return 0

								// Use a for loop to avoid recursion
								var loweredCase = false;
								for (; ;) {
									switch (encoding) {
										case 'ascii':
										case 'latin1':
										case 'binary':
											return len
										case 'utf8':
										case 'utf-8':
											return utf8ToBytes(string).length
										case 'ucs2':
										case 'ucs-2':
										case 'utf16le':
										case 'utf-16le':
											return len * 2
										case 'hex':
											return len >>> 1
										case 'base64':
											return base64ToBytes(string).length
										default:
											if (loweredCase) {
												return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
											}
											encoding = ('' + encoding).toLowerCase();
											loweredCase = true;
									}
								}
							}
							Buffer.byteLength = byteLength;

							function slowToString(encoding, start, end) {
								var loweredCase = false;

								// No need to verify that "this.length <= MAX_UINT32" since it's a read-only
								// property of a typed array.

								// This behaves neither like String nor Uint8Array in that we set start/end
								// to their upper/lower bounds if the value passed is out of range.
								// undefined is handled specially as per ECMA-262 6th Edition,
								// Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
								if (start === undefined || start < 0) {
									start = 0;
								}
								// Return early if start > this.length. Done here to prevent potential uint32
								// coercion fail below.
								if (start > this.length) {
									return ''
								}

								if (end === undefined || end > this.length) {
									end = this.length;
								}

								if (end <= 0) {
									return ''
								}

								// Force coersion to uint32. This will also coerce falsey/NaN values to 0.
								end >>>= 0;
								start >>>= 0;

								if (end <= start) {
									return ''
								}

								if (!encoding) encoding = 'utf8';

								while (true) {
									switch (encoding) {
										case 'hex':
											return hexSlice(this, start, end)

										case 'utf8':
										case 'utf-8':
											return utf8Slice(this, start, end)

										case 'ascii':
											return asciiSlice(this, start, end)

										case 'latin1':
										case 'binary':
											return latin1Slice(this, start, end)

										case 'base64':
											return base64Slice(this, start, end)

										case 'ucs2':
										case 'ucs-2':
										case 'utf16le':
										case 'utf-16le':
											return utf16leSlice(this, start, end)

										default:
											if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
											encoding = (encoding + '').toLowerCase();
											loweredCase = true;
									}
								}
							}

							// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
							// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
							// reliably in a browserify context because there could be multiple different
							// copies of the 'buffer' package in use. This method works even for Buffer
							// instances that were created from another copy of the `buffer` package.
							// See: https://github.com/feross/buffer/issues/154
							Buffer.prototype._isBuffer = true;

							function swap(b, n, m) {
								var i = b[n];
								b[n] = b[m];
								b[m] = i;
							}

							Buffer.prototype.swap16 = function swap16() {
								var len = this.length;
								if (len % 2 !== 0) {
									throw new RangeError('Buffer size must be a multiple of 16-bits')
								}
								for (var i = 0; i < len; i += 2) {
									swap(this, i, i + 1);
								}
								return this
							};

							Buffer.prototype.swap32 = function swap32() {
								var len = this.length;
								if (len % 4 !== 0) {
									throw new RangeError('Buffer size must be a multiple of 32-bits')
								}
								for (var i = 0; i < len; i += 4) {
									swap(this, i, i + 3);
									swap(this, i + 1, i + 2);
								}
								return this
							};

							Buffer.prototype.swap64 = function swap64() {
								var len = this.length;
								if (len % 8 !== 0) {
									throw new RangeError('Buffer size must be a multiple of 64-bits')
								}
								for (var i = 0; i < len; i += 8) {
									swap(this, i, i + 7);
									swap(this, i + 1, i + 6);
									swap(this, i + 2, i + 5);
									swap(this, i + 3, i + 4);
								}
								return this
							};

							Buffer.prototype.toString = function toString() {
								var length = this.length;
								if (length === 0) return ''
								if (arguments.length === 0) return utf8Slice(this, 0, length)
								return slowToString.apply(this, arguments)
							};

							Buffer.prototype.toLocaleString = Buffer.prototype.toString;

							Buffer.prototype.equals = function equals(b) {
								if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
								if (this === b) return true
								return Buffer.compare(this, b) === 0
							};

							Buffer.prototype.inspect = function inspect() {
								var str = '';
								var max = exports.INSPECT_MAX_BYTES;
								str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
								if (this.length > max) str += ' ... ';
								return '<Buffer ' + str + '>'
							};

							Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
								if (isInstance(target, Uint8Array)) {
									target = Buffer.from(target, target.offset, target.byteLength);
								}
								if (!Buffer.isBuffer(target)) {
									throw new TypeError(
										'The "target" argument must be one of type Buffer or Uint8Array. ' +
										'Received type ' + (typeof target)
									)
								}

								if (start === undefined) {
									start = 0;
								}
								if (end === undefined) {
									end = target ? target.length : 0;
								}
								if (thisStart === undefined) {
									thisStart = 0;
								}
								if (thisEnd === undefined) {
									thisEnd = this.length;
								}

								if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
									throw new RangeError('out of range index')
								}

								if (thisStart >= thisEnd && start >= end) {
									return 0
								}
								if (thisStart >= thisEnd) {
									return -1
								}
								if (start >= end) {
									return 1
								}

								start >>>= 0;
								end >>>= 0;
								thisStart >>>= 0;
								thisEnd >>>= 0;

								if (this === target) return 0

								var x = thisEnd - thisStart;
								var y = end - start;
								var len = Math.min(x, y);

								var thisCopy = this.slice(thisStart, thisEnd);
								var targetCopy = target.slice(start, end);

								for (var i = 0; i < len; ++i) {
									if (thisCopy[i] !== targetCopy[i]) {
										x = thisCopy[i];
										y = targetCopy[i];
										break
									}
								}

								if (x < y) return -1
								if (y < x) return 1
								return 0
							};

							// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
							// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
							//
							// Arguments:
							// - buffer - a Buffer to search
							// - val - a string, Buffer, or number
							// - byteOffset - an index into `buffer`; will be clamped to an int32
							// - encoding - an optional encoding, relevant is val is a string
							// - dir - true for indexOf, false for lastIndexOf
							function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
								// Empty buffer means no match
								if (buffer.length === 0) return -1

								// Normalize byteOffset
								if (typeof byteOffset === 'string') {
									encoding = byteOffset;
									byteOffset = 0;
								} else if (byteOffset > 0x7fffffff) {
									byteOffset = 0x7fffffff;
								} else if (byteOffset < -0x80000000) {
									byteOffset = -0x80000000;
								}
								byteOffset = +byteOffset; // Coerce to Number.
								if (numberIsNaN(byteOffset)) {
									// byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
									byteOffset = dir ? 0 : (buffer.length - 1);
								}

								// Normalize byteOffset: negative offsets start from the end of the buffer
								if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
								if (byteOffset >= buffer.length) {
									if (dir) return -1
									else byteOffset = buffer.length - 1;
								} else if (byteOffset < 0) {
									if (dir) byteOffset = 0;
									else return -1
								}

								// Normalize val
								if (typeof val === 'string') {
									val = Buffer.from(val, encoding);
								}

								// Finally, search either indexOf (if dir is true) or lastIndexOf
								if (Buffer.isBuffer(val)) {
									// Special case: looking for empty string/buffer always fails
									if (val.length === 0) {
										return -1
									}
									return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
								} else if (typeof val === 'number') {
									val = val & 0xFF; // Search for a byte value [0-255]
									if (typeof Uint8Array.prototype.indexOf === 'function') {
										if (dir) {
											return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
										} else {
											return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
										}
									}
									return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
								}

								throw new TypeError('val must be string, number or Buffer')
							}

							function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
								var indexSize = 1;
								var arrLength = arr.length;
								var valLength = val.length;

								if (encoding !== undefined) {
									encoding = String(encoding).toLowerCase();
									if (encoding === 'ucs2' || encoding === 'ucs-2' ||
										encoding === 'utf16le' || encoding === 'utf-16le') {
										if (arr.length < 2 || val.length < 2) {
											return -1
										}
										indexSize = 2;
										arrLength /= 2;
										valLength /= 2;
										byteOffset /= 2;
									}
								}

								function read(buf, i) {
									if (indexSize === 1) {
										return buf[i]
									} else {
										return buf.readUInt16BE(i * indexSize)
									}
								}

								var i;
								if (dir) {
									var foundIndex = -1;
									for (i = byteOffset; i < arrLength; i++) {
										if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
											if (foundIndex === -1) foundIndex = i;
											if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
										} else {
											if (foundIndex !== -1) i -= i - foundIndex;
											foundIndex = -1;
										}
									}
								} else {
									if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
									for (i = byteOffset; i >= 0; i--) {
										var found = true;
										for (var j = 0; j < valLength; j++) {
											if (read(arr, i + j) !== read(val, j)) {
												found = false;
												break
											}
										}
										if (found) return i
									}
								}

								return -1
							}

							Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
								return this.indexOf(val, byteOffset, encoding) !== -1
							};

							Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
								return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
							};

							Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
								return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
							};

							function hexWrite(buf, string, offset, length) {
								offset = Number(offset) || 0;
								var remaining = buf.length - offset;
								if (!length) {
									length = remaining;
								} else {
									length = Number(length);
									if (length > remaining) {
										length = remaining;
									}
								}

								var strLen = string.length;

								if (length > strLen / 2) {
									length = strLen / 2;
								}
								for (var i = 0; i < length; ++i) {
									var parsed = parseInt(string.substr(i * 2, 2), 16);
									if (numberIsNaN(parsed)) return i
									buf[offset + i] = parsed;
								}
								return i
							}

							function utf8Write(buf, string, offset, length) {
								return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
							}

							function asciiWrite(buf, string, offset, length) {
								return blitBuffer(asciiToBytes(string), buf, offset, length)
							}

							function latin1Write(buf, string, offset, length) {
								return asciiWrite(buf, string, offset, length)
							}

							function base64Write(buf, string, offset, length) {
								return blitBuffer(base64ToBytes(string), buf, offset, length)
							}

							function ucs2Write(buf, string, offset, length) {
								return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
							}

							Buffer.prototype.write = function write(string, offset, length, encoding) {
								// Buffer#write(string)
								if (offset === undefined) {
									encoding = 'utf8';
									length = this.length;
									offset = 0;
									// Buffer#write(string, encoding)
								} else if (length === undefined && typeof offset === 'string') {
									encoding = offset;
									length = this.length;
									offset = 0;
									// Buffer#write(string, offset[, length][, encoding])
								} else if (isFinite(offset)) {
									offset = offset >>> 0;
									if (isFinite(length)) {
										length = length >>> 0;
										if (encoding === undefined) encoding = 'utf8';
									} else {
										encoding = length;
										length = undefined;
									}
								} else {
									throw new Error(
										'Buffer.write(string, encoding, offset[, length]) is no longer supported'
									)
								}

								var remaining = this.length - offset;
								if (length === undefined || length > remaining) length = remaining;

								if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
									throw new RangeError('Attempt to write outside buffer bounds')
								}

								if (!encoding) encoding = 'utf8';

								var loweredCase = false;
								for (; ;) {
									switch (encoding) {
										case 'hex':
											return hexWrite(this, string, offset, length)

										case 'utf8':
										case 'utf-8':
											return utf8Write(this, string, offset, length)

										case 'ascii':
											return asciiWrite(this, string, offset, length)

										case 'latin1':
										case 'binary':
											return latin1Write(this, string, offset, length)

										case 'base64':
											// Warning: maxLength not taken into account in base64Write
											return base64Write(this, string, offset, length)

										case 'ucs2':
										case 'ucs-2':
										case 'utf16le':
										case 'utf-16le':
											return ucs2Write(this, string, offset, length)

										default:
											if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
											encoding = ('' + encoding).toLowerCase();
											loweredCase = true;
									}
								}
							};

							Buffer.prototype.toJSON = function toJSON() {
								return {
									type: 'Buffer',
									data: Array.prototype.slice.call(this._arr || this, 0)
								}
							};

							function base64Slice(buf, start, end) {
								if (start === 0 && end === buf.length) {
									return base64.fromByteArray(buf)
								} else {
									return base64.fromByteArray(buf.slice(start, end))
								}
							}

							function utf8Slice(buf, start, end) {
								end = Math.min(buf.length, end);
								var res = [];

								var i = start;
								while (i < end) {
									var firstByte = buf[i];
									var codePoint = null;
									var bytesPerSequence = (firstByte > 0xEF) ? 4
										: (firstByte > 0xDF) ? 3
											: (firstByte > 0xBF) ? 2
												: 1;

									if (i + bytesPerSequence <= end) {
										var secondByte, thirdByte, fourthByte, tempCodePoint;

										switch (bytesPerSequence) {
											case 1:
												if (firstByte < 0x80) {
													codePoint = firstByte;
												}
												break
											case 2:
												secondByte = buf[i + 1];
												if ((secondByte & 0xC0) === 0x80) {
													tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
													if (tempCodePoint > 0x7F) {
														codePoint = tempCodePoint;
													}
												}
												break
											case 3:
												secondByte = buf[i + 1];
												thirdByte = buf[i + 2];
												if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
													tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
													if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
														codePoint = tempCodePoint;
													}
												}
												break
											case 4:
												secondByte = buf[i + 1];
												thirdByte = buf[i + 2];
												fourthByte = buf[i + 3];
												if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
													tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
													if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
														codePoint = tempCodePoint;
													}
												}
										}
									}

									if (codePoint === null) {
										// we did not generate a valid codePoint so insert a
										// replacement char (U+FFFD) and advance only 1 byte
										codePoint = 0xFFFD;
										bytesPerSequence = 1;
									} else if (codePoint > 0xFFFF) {
										// encode to utf16 (surrogate pair dance)
										codePoint -= 0x10000;
										res.push(codePoint >>> 10 & 0x3FF | 0xD800);
										codePoint = 0xDC00 | codePoint & 0x3FF;
									}

									res.push(codePoint);
									i += bytesPerSequence;
								}

								return decodeCodePointsArray(res)
							}

							// Based on http://stackoverflow.com/a/22747272/680742, the browser with
							// the lowest limit is Chrome, with 0x10000 args.
							// We go 1 magnitude less, for safety
							var MAX_ARGUMENTS_LENGTH = 0x1000;

							function decodeCodePointsArray(codePoints) {
								var len = codePoints.length;
								if (len <= MAX_ARGUMENTS_LENGTH) {
									return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
								}

								// Decode in chunks to avoid "call stack size exceeded".
								var res = '';
								var i = 0;
								while (i < len) {
									res += String.fromCharCode.apply(
										String,
										codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
									);
								}
								return res
							}

							function asciiSlice(buf, start, end) {
								var ret = '';
								end = Math.min(buf.length, end);

								for (var i = start; i < end; ++i) {
									ret += String.fromCharCode(buf[i] & 0x7F);
								}
								return ret
							}

							function latin1Slice(buf, start, end) {
								var ret = '';
								end = Math.min(buf.length, end);

								for (var i = start; i < end; ++i) {
									ret += String.fromCharCode(buf[i]);
								}
								return ret
							}

							function hexSlice(buf, start, end) {
								var len = buf.length;

								if (!start || start < 0) start = 0;
								if (!end || end < 0 || end > len) end = len;

								var out = '';
								for (var i = start; i < end; ++i) {
									out += toHex(buf[i]);
								}
								return out
							}

							function utf16leSlice(buf, start, end) {
								var bytes = buf.slice(start, end);
								var res = '';
								for (var i = 0; i < bytes.length; i += 2) {
									res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));
								}
								return res
							}

							Buffer.prototype.slice = function slice(start, end) {
								var len = this.length;
								start = ~~start;
								end = end === undefined ? len : ~~end;

								if (start < 0) {
									start += len;
									if (start < 0) start = 0;
								} else if (start > len) {
									start = len;
								}

								if (end < 0) {
									end += len;
									if (end < 0) end = 0;
								} else if (end > len) {
									end = len;
								}

								if (end < start) end = start;

								var newBuf = this.subarray(start, end);
								// Return an augmented `Uint8Array` instance
								newBuf.__proto__ = Buffer.prototype;
								return newBuf
							};

							/*
							 * Need to make sure that buffer isn't trying to write out of bounds.
							 */
							function checkOffset(offset, ext, length) {
								if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
								if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
							}

							Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
								offset = offset >>> 0;
								byteLength = byteLength >>> 0;
								if (!noAssert) checkOffset(offset, byteLength, this.length);

								var val = this[offset];
								var mul = 1;
								var i = 0;
								while (++i < byteLength && (mul *= 0x100)) {
									val += this[offset + i] * mul;
								}

								return val
							};

							Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
								offset = offset >>> 0;
								byteLength = byteLength >>> 0;
								if (!noAssert) {
									checkOffset(offset, byteLength, this.length);
								}

								var val = this[offset + --byteLength];
								var mul = 1;
								while (byteLength > 0 && (mul *= 0x100)) {
									val += this[offset + --byteLength] * mul;
								}

								return val
							};

							Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
								offset = offset >>> 0;
								if (!noAssert) checkOffset(offset, 1, this.length);
								return this[offset]
							};

							Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
								offset = offset >>> 0;
								if (!noAssert) checkOffset(offset, 2, this.length);
								return this[offset] | (this[offset + 1] << 8)
							};

							Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
								offset = offset >>> 0;
								if (!noAssert) checkOffset(offset, 2, this.length);
								return (this[offset] << 8) | this[offset + 1]
							};

							Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
								offset = offset >>> 0;
								if (!noAssert) checkOffset(offset, 4, this.length);

								return ((this[offset]) |
									(this[offset + 1] << 8) |
									(this[offset + 2] << 16)) +
									(this[offset + 3] * 0x1000000)
							};

							Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
								offset = offset >>> 0;
								if (!noAssert) checkOffset(offset, 4, this.length);

								return (this[offset] * 0x1000000) +
									((this[offset + 1] << 16) |
										(this[offset + 2] << 8) |
										this[offset + 3])
							};

							Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
								offset = offset >>> 0;
								byteLength = byteLength >>> 0;
								if (!noAssert) checkOffset(offset, byteLength, this.length);

								var val = this[offset];
								var mul = 1;
								var i = 0;
								while (++i < byteLength && (mul *= 0x100)) {
									val += this[offset + i] * mul;
								}
								mul *= 0x80;

								if (val >= mul) val -= Math.pow(2, 8 * byteLength);

								return val
							};

							Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
								offset = offset >>> 0;
								byteLength = byteLength >>> 0;
								if (!noAssert) checkOffset(offset, byteLength, this.length);

								var i = byteLength;
								var mul = 1;
								var val = this[offset + --i];
								while (i > 0 && (mul *= 0x100)) {
									val += this[offset + --i] * mul;
								}
								mul *= 0x80;

								if (val >= mul) val -= Math.pow(2, 8 * byteLength);

								return val
							};

							Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
								offset = offset >>> 0;
								if (!noAssert) checkOffset(offset, 1, this.length);
								if (!(this[offset] & 0x80)) return (this[offset])
								return ((0xff - this[offset] + 1) * -1)
							};

							Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
								offset = offset >>> 0;
								if (!noAssert) checkOffset(offset, 2, this.length);
								var val = this[offset] | (this[offset + 1] << 8);
								return (val & 0x8000) ? val | 0xFFFF0000 : val
							};

							Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
								offset = offset >>> 0;
								if (!noAssert) checkOffset(offset, 2, this.length);
								var val = this[offset + 1] | (this[offset] << 8);
								return (val & 0x8000) ? val | 0xFFFF0000 : val
							};

							Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
								offset = offset >>> 0;
								if (!noAssert) checkOffset(offset, 4, this.length);

								return (this[offset]) |
									(this[offset + 1] << 8) |
									(this[offset + 2] << 16) |
									(this[offset + 3] << 24)
							};

							Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
								offset = offset >>> 0;
								if (!noAssert) checkOffset(offset, 4, this.length);

								return (this[offset] << 24) |
									(this[offset + 1] << 16) |
									(this[offset + 2] << 8) |
									(this[offset + 3])
							};

							Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
								offset = offset >>> 0;
								if (!noAssert) checkOffset(offset, 4, this.length);
								return ieee754.read(this, offset, true, 23, 4)
							};

							Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
								offset = offset >>> 0;
								if (!noAssert) checkOffset(offset, 4, this.length);
								return ieee754.read(this, offset, false, 23, 4)
							};

							Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
								offset = offset >>> 0;
								if (!noAssert) checkOffset(offset, 8, this.length);
								return ieee754.read(this, offset, true, 52, 8)
							};

							Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
								offset = offset >>> 0;
								if (!noAssert) checkOffset(offset, 8, this.length);
								return ieee754.read(this, offset, false, 52, 8)
							};

							function checkInt(buf, value, offset, ext, max, min) {
								if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
								if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
								if (offset + ext > buf.length) throw new RangeError('Index out of range')
							}

							Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
								value = +value;
								offset = offset >>> 0;
								byteLength = byteLength >>> 0;
								if (!noAssert) {
									var maxBytes = Math.pow(2, 8 * byteLength) - 1;
									checkInt(this, value, offset, byteLength, maxBytes, 0);
								}

								var mul = 1;
								var i = 0;
								this[offset] = value & 0xFF;
								while (++i < byteLength && (mul *= 0x100)) {
									this[offset + i] = (value / mul) & 0xFF;
								}

								return offset + byteLength
							};

							Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
								value = +value;
								offset = offset >>> 0;
								byteLength = byteLength >>> 0;
								if (!noAssert) {
									var maxBytes = Math.pow(2, 8 * byteLength) - 1;
									checkInt(this, value, offset, byteLength, maxBytes, 0);
								}

								var i = byteLength - 1;
								var mul = 1;
								this[offset + i] = value & 0xFF;
								while (--i >= 0 && (mul *= 0x100)) {
									this[offset + i] = (value / mul) & 0xFF;
								}

								return offset + byteLength
							};

							Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
								value = +value;
								offset = offset >>> 0;
								if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
								this[offset] = (value & 0xff);
								return offset + 1
							};

							Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
								value = +value;
								offset = offset >>> 0;
								if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
								this[offset] = (value & 0xff);
								this[offset + 1] = (value >>> 8);
								return offset + 2
							};

							Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
								value = +value;
								offset = offset >>> 0;
								if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
								this[offset] = (value >>> 8);
								this[offset + 1] = (value & 0xff);
								return offset + 2
							};

							Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
								value = +value;
								offset = offset >>> 0;
								if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
								this[offset + 3] = (value >>> 24);
								this[offset + 2] = (value >>> 16);
								this[offset + 1] = (value >>> 8);
								this[offset] = (value & 0xff);
								return offset + 4
							};

							Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
								value = +value;
								offset = offset >>> 0;
								if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
								this[offset] = (value >>> 24);
								this[offset + 1] = (value >>> 16);
								this[offset + 2] = (value >>> 8);
								this[offset + 3] = (value & 0xff);
								return offset + 4
							};

							Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
								value = +value;
								offset = offset >>> 0;
								if (!noAssert) {
									var limit = Math.pow(2, (8 * byteLength) - 1);

									checkInt(this, value, offset, byteLength, limit - 1, -limit);
								}

								var i = 0;
								var mul = 1;
								var sub = 0;
								this[offset] = value & 0xFF;
								while (++i < byteLength && (mul *= 0x100)) {
									if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
										sub = 1;
									}
									this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
								}

								return offset + byteLength
							};

							Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
								value = +value;
								offset = offset >>> 0;
								if (!noAssert) {
									var limit = Math.pow(2, (8 * byteLength) - 1);

									checkInt(this, value, offset, byteLength, limit - 1, -limit);
								}

								var i = byteLength - 1;
								var mul = 1;
								var sub = 0;
								this[offset + i] = value & 0xFF;
								while (--i >= 0 && (mul *= 0x100)) {
									if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
										sub = 1;
									}
									this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
								}

								return offset + byteLength
							};

							Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
								value = +value;
								offset = offset >>> 0;
								if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
								if (value < 0) value = 0xff + value + 1;
								this[offset] = (value & 0xff);
								return offset + 1
							};

							Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
								value = +value;
								offset = offset >>> 0;
								if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
								this[offset] = (value & 0xff);
								this[offset + 1] = (value >>> 8);
								return offset + 2
							};

							Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
								value = +value;
								offset = offset >>> 0;
								if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
								this[offset] = (value >>> 8);
								this[offset + 1] = (value & 0xff);
								return offset + 2
							};

							Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
								value = +value;
								offset = offset >>> 0;
								if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
								this[offset] = (value & 0xff);
								this[offset + 1] = (value >>> 8);
								this[offset + 2] = (value >>> 16);
								this[offset + 3] = (value >>> 24);
								return offset + 4
							};

							Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
								value = +value;
								offset = offset >>> 0;
								if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
								if (value < 0) value = 0xffffffff + value + 1;
								this[offset] = (value >>> 24);
								this[offset + 1] = (value >>> 16);
								this[offset + 2] = (value >>> 8);
								this[offset + 3] = (value & 0xff);
								return offset + 4
							};

							function checkIEEE754(buf, value, offset, ext, max, min) {
								if (offset + ext > buf.length) throw new RangeError('Index out of range')
								if (offset < 0) throw new RangeError('Index out of range')
							}

							function writeFloat(buf, value, offset, littleEndian, noAssert) {
								value = +value;
								offset = offset >>> 0;
								if (!noAssert) {
									checkIEEE754(buf, value, offset, 4);
								}
								ieee754.write(buf, value, offset, littleEndian, 23, 4);
								return offset + 4
							}

							Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
								return writeFloat(this, value, offset, true, noAssert)
							};

							Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
								return writeFloat(this, value, offset, false, noAssert)
							};

							function writeDouble(buf, value, offset, littleEndian, noAssert) {
								value = +value;
								offset = offset >>> 0;
								if (!noAssert) {
									checkIEEE754(buf, value, offset, 8);
								}
								ieee754.write(buf, value, offset, littleEndian, 52, 8);
								return offset + 8
							}

							Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
								return writeDouble(this, value, offset, true, noAssert)
							};

							Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
								return writeDouble(this, value, offset, false, noAssert)
							};

							// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
							Buffer.prototype.copy = function copy(target, targetStart, start, end) {
								if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
								if (!start) start = 0;
								if (!end && end !== 0) end = this.length;
								if (targetStart >= target.length) targetStart = target.length;
								if (!targetStart) targetStart = 0;
								if (end > 0 && end < start) end = start;

								// Copy 0 bytes; we're done
								if (end === start) return 0
								if (target.length === 0 || this.length === 0) return 0

								// Fatal error conditions
								if (targetStart < 0) {
									throw new RangeError('targetStart out of bounds')
								}
								if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
								if (end < 0) throw new RangeError('sourceEnd out of bounds')

								// Are we oob?
								if (end > this.length) end = this.length;
								if (target.length - targetStart < end - start) {
									end = target.length - targetStart + start;
								}

								var len = end - start;

								if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
									// Use built-in when available, missing from IE11
									this.copyWithin(targetStart, start, end);
								} else if (this === target && start < targetStart && targetStart < end) {
									// descending copy from end
									for (var i = len - 1; i >= 0; --i) {
										target[i + targetStart] = this[i + start];
									}
								} else {
									Uint8Array.prototype.set.call(
										target,
										this.subarray(start, end),
										targetStart
									);
								}

								return len
							};

							// Usage:
							//    buffer.fill(number[, offset[, end]])
							//    buffer.fill(buffer[, offset[, end]])
							//    buffer.fill(string[, offset[, end]][, encoding])
							Buffer.prototype.fill = function fill(val, start, end, encoding) {
								// Handle string cases:
								if (typeof val === 'string') {
									if (typeof start === 'string') {
										encoding = start;
										start = 0;
										end = this.length;
									} else if (typeof end === 'string') {
										encoding = end;
										end = this.length;
									}
									if (encoding !== undefined && typeof encoding !== 'string') {
										throw new TypeError('encoding must be a string')
									}
									if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
										throw new TypeError('Unknown encoding: ' + encoding)
									}
									if (val.length === 1) {
										var code = val.charCodeAt(0);
										if ((encoding === 'utf8' && code < 128) ||
											encoding === 'latin1') {
											// Fast path: If `val` fits into a single byte, use that numeric value.
											val = code;
										}
									}
								} else if (typeof val === 'number') {
									val = val & 255;
								}

								// Invalid ranges are not set to a default, so can range check early.
								if (start < 0 || this.length < start || this.length < end) {
									throw new RangeError('Out of range index')
								}

								if (end <= start) {
									return this
								}

								start = start >>> 0;
								end = end === undefined ? this.length : end >>> 0;

								if (!val) val = 0;

								var i;
								if (typeof val === 'number') {
									for (i = start; i < end; ++i) {
										this[i] = val;
									}
								} else {
									var bytes = Buffer.isBuffer(val)
										? val
										: Buffer.from(val, encoding);
									var len = bytes.length;
									if (len === 0) {
										throw new TypeError('The value "' + val +
											'" is invalid for argument "value"')
									}
									for (i = 0; i < end - start; ++i) {
										this[i + start] = bytes[i % len];
									}
								}

								return this
							};

							// HELPER FUNCTIONS
							// ================

							var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

							function base64clean(str) {
								// Node takes equal signs as end of the Base64 encoding
								str = str.split('=')[0];
								// Node strips out invalid characters like \n and \t from the string, base64-js does not
								str = str.trim().replace(INVALID_BASE64_RE, '');
								// Node converts strings with length < 2 to ''
								if (str.length < 2) return ''
								// Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
								while (str.length % 4 !== 0) {
									str = str + '=';
								}
								return str
							}

							function toHex(n) {
								if (n < 16) return '0' + n.toString(16)
								return n.toString(16)
							}

							function utf8ToBytes(string, units) {
								units = units || Infinity;
								var codePoint;
								var length = string.length;
								var leadSurrogate = null;
								var bytes = [];

								for (var i = 0; i < length; ++i) {
									codePoint = string.charCodeAt(i);

									// is surrogate component
									if (codePoint > 0xD7FF && codePoint < 0xE000) {
										// last char was a lead
										if (!leadSurrogate) {
											// no lead yet
											if (codePoint > 0xDBFF) {
												// unexpected trail
												if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
												continue
											} else if (i + 1 === length) {
												// unpaired lead
												if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
												continue
											}

											// valid lead
											leadSurrogate = codePoint;

											continue
										}

										// 2 leads in a row
										if (codePoint < 0xDC00) {
											if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
											leadSurrogate = codePoint;
											continue
										}

										// valid surrogate pair
										codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
									} else if (leadSurrogate) {
										// valid bmp char, but last char was a lead
										if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
									}

									leadSurrogate = null;

									// encode utf8
									if (codePoint < 0x80) {
										if ((units -= 1) < 0) break
										bytes.push(codePoint);
									} else if (codePoint < 0x800) {
										if ((units -= 2) < 0) break
										bytes.push(
											codePoint >> 0x6 | 0xC0,
											codePoint & 0x3F | 0x80
										);
									} else if (codePoint < 0x10000) {
										if ((units -= 3) < 0) break
										bytes.push(
											codePoint >> 0xC | 0xE0,
											codePoint >> 0x6 & 0x3F | 0x80,
											codePoint & 0x3F | 0x80
										);
									} else if (codePoint < 0x110000) {
										if ((units -= 4) < 0) break
										bytes.push(
											codePoint >> 0x12 | 0xF0,
											codePoint >> 0xC & 0x3F | 0x80,
											codePoint >> 0x6 & 0x3F | 0x80,
											codePoint & 0x3F | 0x80
										);
									} else {
										throw new Error('Invalid code point')
									}
								}

								return bytes
							}

							function asciiToBytes(str) {
								var byteArray = [];
								for (var i = 0; i < str.length; ++i) {
									// Node's code seems to be doing this and not & 0x7F..
									byteArray.push(str.charCodeAt(i) & 0xFF);
								}
								return byteArray
							}

							function utf16leToBytes(str, units) {
								var c, hi, lo;
								var byteArray = [];
								for (var i = 0; i < str.length; ++i) {
									if ((units -= 2) < 0) break

									c = str.charCodeAt(i);
									hi = c >> 8;
									lo = c % 256;
									byteArray.push(lo);
									byteArray.push(hi);
								}

								return byteArray
							}

							function base64ToBytes(str) {
								return base64.toByteArray(base64clean(str))
							}

							function blitBuffer(src, dst, offset, length) {
								for (var i = 0; i < length; ++i) {
									if ((i + offset >= dst.length) || (i >= src.length)) break
									dst[i + offset] = src[i];
								}
								return i
							}

							// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
							// the `instanceof` check but they should be treated as of that type.
							// See: https://github.com/feross/buffer/issues/166
							function isInstance(obj, type) {
								return obj instanceof type ||
									(obj != null && obj.constructor != null && obj.constructor.name != null &&
										obj.constructor.name === type.name)
							}
							function numberIsNaN(obj) {
								// For IE11 support
								return obj !== obj // eslint-disable-line no-self-compare
							}

						}).call(this);
					}).call(this, require("buffer").Buffer);
				}, { "base64-js": 6, "buffer": 8, "ieee754": 9 }], 9: [function (require, module, exports) {
					/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
					exports.read = function (buffer, offset, isLE, mLen, nBytes) {
						var e, m;
						var eLen = (nBytes * 8) - mLen - 1;
						var eMax = (1 << eLen) - 1;
						var eBias = eMax >> 1;
						var nBits = -7;
						var i = isLE ? (nBytes - 1) : 0;
						var d = isLE ? -1 : 1;
						var s = buffer[offset + i];

						i += d;

						e = s & ((1 << (-nBits)) - 1);
						s >>= (-nBits);
						nBits += eLen;
						for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) { }

						m = e & ((1 << (-nBits)) - 1);
						e >>= (-nBits);
						nBits += mLen;
						for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) { }

						if (e === 0) {
							e = 1 - eBias;
						} else if (e === eMax) {
							return m ? NaN : ((s ? -1 : 1) * Infinity)
						} else {
							m = m + Math.pow(2, mLen);
							e = e - eBias;
						}
						return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
					};

					exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
						var e, m, c;
						var eLen = (nBytes * 8) - mLen - 1;
						var eMax = (1 << eLen) - 1;
						var eBias = eMax >> 1;
						var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
						var i = isLE ? 0 : (nBytes - 1);
						var d = isLE ? 1 : -1;
						var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

						value = Math.abs(value);

						if (isNaN(value) || value === Infinity) {
							m = isNaN(value) ? 1 : 0;
							e = eMax;
						} else {
							e = Math.floor(Math.log(value) / Math.LN2);
							if (value * (c = Math.pow(2, -e)) < 1) {
								e--;
								c *= 2;
							}
							if (e + eBias >= 1) {
								value += rt / c;
							} else {
								value += rt * Math.pow(2, 1 - eBias);
							}
							if (value * c >= 2) {
								e++;
								c /= 2;
							}

							if (e + eBias >= eMax) {
								m = 0;
								e = eMax;
							} else if (e + eBias >= 1) {
								m = ((value * c) - 1) * Math.pow(2, mLen);
								e = e + eBias;
							} else {
								m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
								e = 0;
							}
						}

						for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) { }

						e = (e << mLen) | m;
						eLen += mLen;
						for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) { }

						buffer[offset + i - d] |= s * 128;
					};

				}, {}], 10: [function (require, module, exports) {
					(function (global) {
						(function () {
							var Mutation = global.MutationObserver || global.WebKitMutationObserver;

							var scheduleDrain;

							{
								if (Mutation) {
									var called = 0;
									var observer = new Mutation(nextTick);
									var element = global.document.createTextNode('');
									observer.observe(element, {
										characterData: true
									});
									scheduleDrain = function () {
										element.data = (called = ++called % 2);
									};
								} else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
									var channel = new global.MessageChannel();
									channel.port1.onmessage = nextTick;
									scheduleDrain = function () {
										channel.port2.postMessage(0);
									};
								} else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
									scheduleDrain = function () {

										// Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
										// into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
										var scriptEl = global.document.createElement('script');
										scriptEl.onreadystatechange = function () {
											nextTick();

											scriptEl.onreadystatechange = null;
											scriptEl.parentNode.removeChild(scriptEl);
											scriptEl = null;
										};
										global.document.documentElement.appendChild(scriptEl);
									};
								} else {
									scheduleDrain = function () {
										setTimeout(nextTick, 0);
									};
								}
							}

							var draining;
							var queue = [];
							//named nextTick for less confusing stack traces
							function nextTick() {
								draining = true;
								var i, oldQueue;
								var len = queue.length;
								while (len) {
									oldQueue = queue;
									queue = [];
									i = -1;
									while (++i < len) {
										oldQueue[i]();
									}
									len = queue.length;
								}
								draining = false;
							}

							module.exports = immediate;
							function immediate(task) {
								if (queue.push(task) === 1 && !draining) {
									scheduleDrain();
								}
							}

						}).call(this);
					}).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
				}, {}], 11: [function (require, module, exports) {
					(function (global, Buffer, setImmediate) {
						(function () {
							/*!
					
							JSZip v3.6.0 - A JavaScript class for generating and reading zip files
							<http://stuartk.com/jszip>
					
							(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
							Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.
					
							JSZip uses the library pako released under the MIT license :
							https://github.com/nodeca/pako/blob/master/LICENSE
							*/

							!function (e) { if ("object" == typeof exports && "undefined" != typeof module) module.exports = e(); else { ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).JSZip = e(); } }(function () { return function s(a, o, u) { function h(r, e) { if (!o[r]) { if (!a[r]) { var t = "function" == typeof require && require; if (!e && t) return t(r, !0); if (f) return f(r, !0); var n = new Error("Cannot find module '" + r + "'"); throw n.code = "MODULE_NOT_FOUND", n } var i = o[r] = { exports: {} }; a[r][0].call(i.exports, function (e) { var t = a[r][1][e]; return h(t || e) }, i, i.exports, s, a, o, u); } return o[r].exports } for (var f = "function" == typeof require && require, e = 0; e < u.length; e++)h(u[e]); return h }({ 1: [function (l, t, n) { (function (r) { !function (e) { "object" == typeof n && void 0 !== t ? t.exports = e() : ("undefined" != typeof window ? window : void 0 !== r ? r : "undefined" != typeof self ? self : this).JSZip = e(); }(function () { return function s(a, o, u) { function h(t, e) { if (!o[t]) { if (!a[t]) { var r = "function" == typeof l && l; if (!e && r) return r(t, !0); if (f) return f(t, !0); var n = new Error("Cannot find module '" + t + "'"); throw n.code = "MODULE_NOT_FOUND", n } var i = o[t] = { exports: {} }; a[t][0].call(i.exports, function (e) { return h(a[t][1][e] || e) }, i, i.exports, s, a, o, u); } return o[t].exports } for (var f = "function" == typeof l && l, e = 0; e < u.length; e++)h(u[e]); return h }({ 1: [function (l, t, n) { (function (r) { !function (e) { "object" == typeof n && void 0 !== t ? t.exports = e() : ("undefined" != typeof window ? window : void 0 !== r ? r : "undefined" != typeof self ? self : this).JSZip = e(); }(function () { return function s(a, o, u) { function h(t, e) { if (!o[t]) { if (!a[t]) { var r = "function" == typeof l && l; if (!e && r) return r(t, !0); if (f) return f(t, !0); var n = new Error("Cannot find module '" + t + "'"); throw n.code = "MODULE_NOT_FOUND", n } var i = o[t] = { exports: {} }; a[t][0].call(i.exports, function (e) { return h(a[t][1][e] || e) }, i, i.exports, s, a, o, u); } return o[t].exports } for (var f = "function" == typeof l && l, e = 0; e < u.length; e++)h(u[e]); return h }({ 1: [function (l, t, n) { (function (r) { !function (e) { "object" == typeof n && void 0 !== t ? t.exports = e() : ("undefined" != typeof window ? window : void 0 !== r ? r : "undefined" != typeof self ? self : this).JSZip = e(); }(function () { return function s(a, o, u) { function h(t, e) { if (!o[t]) { if (!a[t]) { var r = "function" == typeof l && l; if (!e && r) return r(t, !0); if (f) return f(t, !0); var n = new Error("Cannot find module '" + t + "'"); throw n.code = "MODULE_NOT_FOUND", n } var i = o[t] = { exports: {} }; a[t][0].call(i.exports, function (e) { return h(a[t][1][e] || e) }, i, i.exports, s, a, o, u); } return o[t].exports } for (var f = "function" == typeof l && l, e = 0; e < u.length; e++)h(u[e]); return h }({ 1: [function (l, t, n) { (function (r) { !function (e) { "object" == typeof n && void 0 !== t ? t.exports = e() : ("undefined" != typeof window ? window : void 0 !== r ? r : "undefined" != typeof self ? self : this).JSZip = e(); }(function () { return function s(a, o, u) { function h(t, e) { if (!o[t]) { if (!a[t]) { var r = "function" == typeof l && l; if (!e && r) return r(t, !0); if (f) return f(t, !0); var n = new Error("Cannot find module '" + t + "'"); throw n.code = "MODULE_NOT_FOUND", n } var i = o[t] = { exports: {} }; a[t][0].call(i.exports, function (e) { return h(a[t][1][e] || e) }, i, i.exports, s, a, o, u); } return o[t].exports } for (var f = "function" == typeof l && l, e = 0; e < u.length; e++)h(u[e]); return h }({ 1: [function (l, t, n) { (function (r) { !function (e) { "object" == typeof n && void 0 !== t ? t.exports = e() : ("undefined" != typeof window ? window : void 0 !== r ? r : "undefined" != typeof self ? self : this).JSZip = e(); }(function () { return function s(a, o, u) { function h(t, e) { if (!o[t]) { if (!a[t]) { var r = "function" == typeof l && l; if (!e && r) return r(t, !0); if (f) return f(t, !0); var n = new Error("Cannot find module '" + t + "'"); throw n.code = "MODULE_NOT_FOUND", n } var i = o[t] = { exports: {} }; a[t][0].call(i.exports, function (e) { return h(a[t][1][e] || e) }, i, i.exports, s, a, o, u); } return o[t].exports } for (var f = "function" == typeof l && l, e = 0; e < u.length; e++)h(u[e]); return h }({ 1: [function (e, t, r) { var c = e("./utils"), l = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; r.encode = function (e) { for (var t, r, n, i, s, a, o, u = [], h = 0, f = e.length, l = f, d = "string" !== c.getTypeOf(e); h < e.length;)l = f - h, n = d ? (t = e[h++], r = h < f ? e[h++] : 0, h < f ? e[h++] : 0) : (t = e.charCodeAt(h++), r = h < f ? e.charCodeAt(h++) : 0, h < f ? e.charCodeAt(h++) : 0), i = t >> 2, s = (3 & t) << 4 | r >> 4, a = 1 < l ? (15 & r) << 2 | n >> 6 : 64, o = 2 < l ? 63 & n : 64, u.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o)); return u.join("") }, r.decode = function (e) { var t, r, n, i, s, a, o = 0, u = 0; if ("data:" === e.substr(0, "data:".length)) throw new Error("Invalid base64 input, it looks like a data url."); var h, f = 3 * (e = e.replace(/[^A-Za-z0-9\+\/\=]/g, "")).length / 4; if (e.charAt(e.length - 1) === p.charAt(64) && f--, e.charAt(e.length - 2) === p.charAt(64) && f--, f % 1 != 0) throw new Error("Invalid base64 input, bad content length."); for (h = l.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e.length;)t = p.indexOf(e.charAt(o++)) << 2 | (i = p.indexOf(e.charAt(o++))) >> 4, r = (15 & i) << 4 | (s = p.indexOf(e.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e.charAt(o++))), h[u++] = t, 64 !== s && (h[u++] = r), 64 !== a && (h[u++] = n); return h }; }, { "./support": 30, "./utils": 32 }], 2: [function (e, t, r) { var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe"); function o(e, t, r, n, i) { this.compressedSize = e, this.uncompressedSize = t, this.crc32 = r, this.compression = n, this.compressedContent = i; } o.prototype = { getContentWorker: function () { var e = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t = this; return e.on("end", function () { if (this.streamInfo.data_length !== t.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch") }), e }, getCompressedWorker: function () { return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression) } }, o.createWorkerFrom = function (e, t, r) { return e.pipe(new s).pipe(new a("uncompressedSize")).pipe(t.compressWorker(r)).pipe(new a("compressedSize")).withStreamInfo("compression", t) }, t.exports = o; }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function (e, t, r) { var n = e("./stream/GenericWorker"); r.STORE = { magic: "\0\0", compressWorker: function (e) { return new n("STORE compression") }, uncompressWorker: function () { return new n("STORE decompression") } }, r.DEFLATE = e("./flate"); }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function (e, t, r) { var n = e("./utils"), a = function () { for (var e, t = [], r = 0; r < 256; r++) { e = r; for (var n = 0; n < 8; n++)e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1; t[r] = e; } return t }(); t.exports = function (e, t) { return void 0 !== e && e.length ? "string" !== n.getTypeOf(e) ? function (e, t, r) { var n = a, i = 0 + r; e ^= -1; for (var s = 0; s < i; s++)e = e >>> 8 ^ n[255 & (e ^ t[s])]; return -1 ^ e }(0 | t, e, e.length) : function (e, t, r) { var n = a, i = 0 + r; e ^= -1; for (var s = 0; s < i; s++)e = e >>> 8 ^ n[255 & (e ^ t.charCodeAt(s))]; return -1 ^ e }(0 | t, e, e.length) : 0 }; }, { "./utils": 32 }], 5: [function (e, t, r) { r.base64 = !1, r.binary = !1, r.dir = !1, r.createFolders = !0, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null; }, {}], 6: [function (e, t, r) { var n; n = "undefined" != typeof Promise ? Promise : e("lie"), t.exports = { Promise: n }; }, { lie: 37 }], 7: [function (e, t, r) { var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array"; function u(e, t) { a.call(this, "FlateWorker/" + e), this._pako = null, this._pakoAction = e, this._pakoOptions = t, this.meta = {}; } r.magic = "\b\0", s.inherits(u, a), u.prototype.processChunk = function (e) { this.meta = e.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e.data), !1); }, u.prototype.flush = function () { a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], !0); }, u.prototype.cleanUp = function () { a.prototype.cleanUp.call(this), this._pako = null; }, u.prototype._createPako = function () { this._pako = new i[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 }); var t = this; this._pako.onData = function (e) { t.push({ data: e, meta: t.meta }); }; }, r.compressWorker = function (e) { return new u("Deflate", e) }, r.uncompressWorker = function () { return new u("Inflate", {}) }; }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function (e, t, r) { function I(e, t) { var r, n = ""; for (r = 0; r < t; r++)n += String.fromCharCode(255 & e), e >>>= 8; return n } function i(e, t, r, n, i, s) { var a, o, u = e.file, h = e.compression, f = s !== B.utf8encode, l = O.transformTo("string", s(u.name)), d = O.transformTo("string", B.utf8encode(u.name)), c = u.comment, p = O.transformTo("string", s(c)), m = O.transformTo("string", B.utf8encode(c)), _ = d.length !== u.name.length, g = m.length !== c.length, v = "", b = "", w = "", y = u.dir, k = u.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 }; t && !r || (x.crc32 = e.crc32, x.compressedSize = e.compressedSize, x.uncompressedSize = e.uncompressedSize); var S = 0; t && (S |= 8), f || !_ && !g || (S |= 2048); var z, E = 0, C = 0; y && (E |= 16), "UNIX" === i ? (C = 798, E |= ((z = u.unixPermissions) || (z = y ? 16893 : 33204), (65535 & z) << 16)) : (C = 20, E |= 63 & (u.dosPermissions || 0)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v += "up" + I((b = I(1, 1) + I(T(l), 4) + d).length, 2) + b), g && (v += "uc" + I((w = I(1, 1) + I(T(p), 4) + m).length, 2) + w); var A = ""; return A += "\n\0", A += I(S, 2), A += h.magic, A += I(a, 2), A += I(o, 2), A += I(x.crc32, 4), A += I(x.compressedSize, 4), A += I(x.uncompressedSize, 4), A += I(l.length, 2), A += I(v.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + A + l + v, dirRecord: R.CENTRAL_FILE_HEADER + I(C, 2) + A + I(p.length, 2) + "\0\0\0\0" + I(E, 4) + I(n, 4) + l + v + p } } var O = e("../utils"), s = e("../stream/GenericWorker"), B = e("../utf8"), T = e("../crc32"), R = e("../signature"); function n(e, t, r, n) { s.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t, this.zipPlatform = r, this.encodeFileName = n, this.streamFiles = e, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = []; } O.inherits(n, s), n.prototype.push = function (e) { var t = e.meta.percent || 0, r = this.entriesCount, n = this._sources.length; this.accumulate ? this.contentBuffer.push(e) : (this.bytesWritten += e.data.length, s.prototype.push.call(this, { data: e.data, meta: { currentFile: this.currentFile, percent: r ? (t + 100 * (r - n - 1)) / r : 100 } })); }, n.prototype.openedSource = function (e) { this.currentSourceOffset = this.bytesWritten, this.currentFile = e.file.name; var t = this.streamFiles && !e.file.dir; if (t) { var r = i(e, t, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName); this.push({ data: r.fileRecord, meta: { percent: 0 } }); } else this.accumulate = !0; }, n.prototype.closedSource = function (e) { this.accumulate = !1; var t, r = this.streamFiles && !e.file.dir, n = i(e, r, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName); if (this.dirRecords.push(n.dirRecord), r) this.push({ data: (t = e, R.DATA_DESCRIPTOR + I(t.crc32, 4) + I(t.compressedSize, 4) + I(t.uncompressedSize, 4)), meta: { percent: 100 } }); else for (this.push({ data: n.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length;)this.push(this.contentBuffer.shift()); this.currentFile = null; }, n.prototype.flush = function () { for (var e = this.bytesWritten, t = 0; t < this.dirRecords.length; t++)this.push({ data: this.dirRecords[t], meta: { percent: 100 } }); var r, n, i, s, a, o, u = this.bytesWritten - e, h = (r = this.dirRecords.length, n = u, i = e, s = this.zipComment, a = this.encodeFileName, o = O.transformTo("string", a(s)), R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + I(r, 2) + I(r, 2) + I(n, 4) + I(i, 4) + I(o.length, 2) + o); this.push({ data: h, meta: { percent: 100 } }); }, n.prototype.prepareNextSource = function () { this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume(); }, n.prototype.registerPrevious = function (e) { this._sources.push(e); var t = this; return e.on("data", function (e) { t.processChunk(e); }), e.on("end", function () { t.closedSource(t.previous.streamInfo), t._sources.length ? t.prepareNextSource() : t.end(); }), e.on("error", function (e) { t.error(e); }), this }, n.prototype.resume = function () { return !!s.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0)) }, n.prototype.error = function (e) { var t = this._sources; if (!s.prototype.error.call(this, e)) return !1; for (var r = 0; r < t.length; r++)try { t[r].error(e); } catch (e) { } return !0 }, n.prototype.lock = function () { s.prototype.lock.call(this); for (var e = this._sources, t = 0; t < e.length; t++)e[t].lock(); }, t.exports = n; }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function (e, t, r) { var h = e("../compressions"), n = e("./ZipFileWorker"); r.generateWorker = function (e, a, t) { var o = new n(a.streamFiles, t, a.platform, a.encodeFileName), u = 0; try { e.forEach(function (e, t) { u++; var r = function (e, t) { var r = e || t, n = h[r]; if (!n) throw new Error(r + " is not a valid compression method !"); return n }(t.options.compression, a.compression), n = t.options.compressionOptions || a.compressionOptions || {}, i = t.dir, s = t.date; t._compressWorker(r, n).withStreamInfo("file", { name: e, dir: i, date: s, comment: t.comment || "", unixPermissions: t.unixPermissions, dosPermissions: t.dosPermissions }).pipe(o); }), o.entriesCount = u; } catch (e) { o.error(e); } return o }; }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function (e, t, r) { function n() { if (!(this instanceof n)) return new n; if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide."); this.files = {}, this.comment = null, this.root = "", this.clone = function () { var e = new n; for (var t in this) "function" != typeof this[t] && (e[t] = this[t]); return e }; } (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.5.0", n.loadAsync = function (e, t) { return (new n).loadAsync(e, t) }, n.external = e("./external"), t.exports = n; }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function (e, t, r) { var n = e("./utils"), i = e("./external"), o = e("./utf8"), u = e("./zipEntries"), s = e("./stream/Crc32Probe"), h = e("./nodejsUtils"); function f(n) { return new i.Promise(function (e, t) { var r = n.decompressed.getContentWorker().pipe(new s); r.on("error", function (e) { t(e); }).on("end", function () { r.streamInfo.crc32 !== n.decompressed.crc32 ? t(new Error("Corrupted zip : CRC32 mismatch")) : e(); }).resume(); }) } t.exports = function (e, s) { var a = this; return s = n.extend(s || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: o.utf8decode }), h.isNode && h.isStream(e) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : n.prepareContent("the loaded zip file", e, !0, s.optimizedBinaryString, s.base64).then(function (e) { var t = new u(s); return t.load(e), t }).then(function (e) { var t = [i.Promise.resolve(e)], r = e.files; if (s.checkCRC32) for (var n = 0; n < r.length; n++)t.push(f(r[n])); return i.Promise.all(t) }).then(function (e) { for (var t = e.shift(), r = t.files, n = 0; n < r.length; n++) { var i = r[n]; a.file(i.fileNameStr, i.decompressed, { binary: !0, optimizedBinaryString: !0, date: i.date, dir: i.dir, comment: i.fileCommentStr.length ? i.fileCommentStr : null, unixPermissions: i.unixPermissions, dosPermissions: i.dosPermissions, createFolders: s.createFolders }); } return t.zipComment.length && (a.comment = t.zipComment), a }) }; }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function (e, t, r) { var n = e("../utils"), i = e("../stream/GenericWorker"); function s(e, t) { i.call(this, "Nodejs stream input adapter for " + e), this._upstreamEnded = !1, this._bindStream(t); } n.inherits(s, i), s.prototype._bindStream = function (e) { var t = this; (this._stream = e).pause(), e.on("data", function (e) { t.push({ data: e, meta: { percent: 0 } }); }).on("error", function (e) { t.isPaused ? this.generatedError = e : t.error(e); }).on("end", function () { t.isPaused ? t._upstreamEnded = !0 : t.end(); }); }, s.prototype.pause = function () { return !!i.prototype.pause.call(this) && (this._stream.pause(), !0) }, s.prototype.resume = function () { return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0) }, t.exports = s; }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function (e, t, r) { var i = e("readable-stream").Readable; function n(e, t, r) { i.call(this, t), this._helper = e; var n = this; e.on("data", function (e, t) { n.push(e) || n._helper.pause(), r && r(t); }).on("error", function (e) { n.emit("error", e); }).on("end", function () { n.push(null); }); } e("../utils").inherits(n, i), n.prototype._read = function () { this._helper.resume(); }, t.exports = n; }, { "../utils": 32, "readable-stream": 16 }], 14: [function (e, t, r) { t.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function (e, t) { if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(e, t); if ("number" == typeof e) throw new Error('The "data" argument must not be a number'); return new Buffer(e, t) }, allocBuffer: function (e) { if (Buffer.alloc) return Buffer.alloc(e); var t = new Buffer(e); return t.fill(0), t }, isBuffer: function (e) { return Buffer.isBuffer(e) }, isStream: function (e) { return e && "function" == typeof e.on && "function" == typeof e.pause && "function" == typeof e.resume } }; }, {}], 15: [function (e, t, r) { function s(e, t, r) { var n, i = f.getTypeOf(t), s = f.extend(r || {}, d); s.date = s.date || new Date, null !== s.compression && (s.compression = s.compression.toUpperCase()), "string" == typeof s.unixPermissions && (s.unixPermissions = parseInt(s.unixPermissions, 8)), s.unixPermissions && 16384 & s.unixPermissions && (s.dir = !0), s.dosPermissions && 16 & s.dosPermissions && (s.dir = !0), s.dir && (e = h(e)), s.createFolders && (n = function (e) { "/" === e.slice(-1) && (e = e.substring(0, e.length - 1)); var t = e.lastIndexOf("/"); return 0 < t ? e.substring(0, t) : "" }(e)) && g.call(this, n, !0); var a, o = "string" === i && !1 === s.binary && !1 === s.base64; r && void 0 !== r.binary || (s.binary = !o), (t instanceof c && 0 === t.uncompressedSize || s.dir || !t || 0 === t.length) && (s.base64 = !1, s.binary = !0, t = "", s.compression = "STORE", i = "string"), a = t instanceof c || t instanceof l ? t : m.isNode && m.isStream(t) ? new _(e, t) : f.prepareContent(e, t, s.binary, s.optimizedBinaryString, s.base64); var u = new p(e, a, s); this.files[e] = u; } function h(e) { return "/" !== e.slice(-1) && (e += "/"), e } var i = e("./utf8"), f = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), d = e("./defaults"), c = e("./compressedObject"), p = e("./zipObject"), o = e("./generate"), m = e("./nodejsUtils"), _ = e("./nodejs/NodejsStreamInputAdapter"), g = function (e, t) { return t = void 0 !== t ? t : d.createFolders, e = h(e), this.files[e] || s.call(this, e, null, { dir: !0, createFolders: t }), this.files[e] }; function u(e) { return "[object RegExp]" === Object.prototype.toString.call(e) } var n = { load: function () { throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.") }, forEach: function (e) { var t, r, n; for (t in this.files) this.files.hasOwnProperty(t) && (n = this.files[t], (r = t.slice(this.root.length, t.length)) && t.slice(0, this.root.length) === this.root && e(r, n)); }, filter: function (r) { var n = []; return this.forEach(function (e, t) { r(e, t) && n.push(t); }), n }, file: function (e, t, r) { if (1 !== arguments.length) return e = this.root + e, s.call(this, e, t, r), this; if (u(e)) { var n = e; return this.filter(function (e, t) { return !t.dir && n.test(e) }) } var i = this.files[this.root + e]; return i && !i.dir ? i : null }, folder: function (r) { if (!r) return this; if (u(r)) return this.filter(function (e, t) { return t.dir && r.test(e) }); var e = this.root + r, t = g.call(this, e), n = this.clone(); return n.root = t.name, n }, remove: function (r) { r = this.root + r; var e = this.files[r]; if (e || ("/" !== r.slice(-1) && (r += "/"), e = this.files[r]), e && !e.dir) delete this.files[r]; else for (var t = this.filter(function (e, t) { return t.name.slice(0, r.length) === r }), n = 0; n < t.length; n++)delete this.files[t[n].name]; return this }, generate: function (e) { throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.") }, generateInternalStream: function (e) { var t, r = {}; try { if ((r = f.extend(e || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r.type.toLowerCase(), r.compression = r.compression.toUpperCase(), "binarystring" === r.type && (r.type = "string"), !r.type) throw new Error("No output type specified."); f.checkSupport(r.type), "darwin" !== r.platform && "freebsd" !== r.platform && "linux" !== r.platform && "sunos" !== r.platform || (r.platform = "UNIX"), "win32" === r.platform && (r.platform = "DOS"); var n = r.comment || this.comment || ""; t = o.generateWorker(this, r, n); } catch (e) { (t = new l("error")).error(e); } return new a(t, r.type || "string", r.mimeType) }, generateAsync: function (e, t) { return this.generateInternalStream(e).accumulate(t) }, generateNodeStream: function (e, t) { return (e = e || {}).type || (e.type = "nodebuffer"), this.generateInternalStream(e).toNodejsStream(t) } }; t.exports = n; }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function (e, t, r) { t.exports = e("stream"); }, { stream: void 0 }], 17: [function (e, t, r) { var n = e("./DataReader"); function i(e) { n.call(this, e); for (var t = 0; t < this.data.length; t++)e[t] = 255 & e[t]; } e("../utils").inherits(i, n), i.prototype.byteAt = function (e) { return this.data[this.zero + e] }, i.prototype.lastIndexOfSignature = function (e) { for (var t = e.charCodeAt(0), r = e.charCodeAt(1), n = e.charCodeAt(2), i = e.charCodeAt(3), s = this.length - 4; 0 <= s; --s)if (this.data[s] === t && this.data[s + 1] === r && this.data[s + 2] === n && this.data[s + 3] === i) return s - this.zero; return -1 }, i.prototype.readAndCheckSignature = function (e) { var t = e.charCodeAt(0), r = e.charCodeAt(1), n = e.charCodeAt(2), i = e.charCodeAt(3), s = this.readData(4); return t === s[0] && r === s[1] && n === s[2] && i === s[3] }, i.prototype.readData = function (e) { if (this.checkOffset(e), 0 === e) return []; var t = this.data.slice(this.zero + this.index, this.zero + this.index + e); return this.index += e, t }, t.exports = i; }, { "../utils": 32, "./DataReader": 18 }], 18: [function (e, t, r) { var n = e("../utils"); function i(e) { this.data = e, this.length = e.length, this.index = 0, this.zero = 0; } i.prototype = { checkOffset: function (e) { this.checkIndex(this.index + e); }, checkIndex: function (e) { if (this.length < this.zero + e || e < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e + "). Corrupted zip ?") }, setIndex: function (e) { this.checkIndex(e), this.index = e; }, skip: function (e) { this.setIndex(this.index + e); }, byteAt: function (e) { }, readInt: function (e) { var t, r = 0; for (this.checkOffset(e), t = this.index + e - 1; t >= this.index; t--)r = (r << 8) + this.byteAt(t); return this.index += e, r }, readString: function (e) { return n.transformTo("string", this.readData(e)) }, readData: function (e) { }, lastIndexOfSignature: function (e) { }, readAndCheckSignature: function (e) { }, readDate: function () { var e = this.readInt(4); return new Date(Date.UTC(1980 + (e >> 25 & 127), (e >> 21 & 15) - 1, e >> 16 & 31, e >> 11 & 31, e >> 5 & 63, (31 & e) << 1)) } }, t.exports = i; }, { "../utils": 32 }], 19: [function (e, t, r) { var n = e("./Uint8ArrayReader"); function i(e) { n.call(this, e); } e("../utils").inherits(i, n), i.prototype.readData = function (e) { this.checkOffset(e); var t = this.data.slice(this.zero + this.index, this.zero + this.index + e); return this.index += e, t }, t.exports = i; }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function (e, t, r) { var n = e("./DataReader"); function i(e) { n.call(this, e); } e("../utils").inherits(i, n), i.prototype.byteAt = function (e) { return this.data.charCodeAt(this.zero + e) }, i.prototype.lastIndexOfSignature = function (e) { return this.data.lastIndexOf(e) - this.zero }, i.prototype.readAndCheckSignature = function (e) { return e === this.readData(4) }, i.prototype.readData = function (e) { this.checkOffset(e); var t = this.data.slice(this.zero + this.index, this.zero + this.index + e); return this.index += e, t }, t.exports = i; }, { "../utils": 32, "./DataReader": 18 }], 21: [function (e, t, r) { var n = e("./ArrayReader"); function i(e) { n.call(this, e); } e("../utils").inherits(i, n), i.prototype.readData = function (e) { if (this.checkOffset(e), 0 === e) return new Uint8Array(0); var t = this.data.subarray(this.zero + this.index, this.zero + this.index + e); return this.index += e, t }, t.exports = i; }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function (e, t, r) { var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), u = e("./Uint8ArrayReader"); t.exports = function (e) { var t = n.getTypeOf(e); return n.checkSupport(t), "string" !== t || i.uint8array ? "nodebuffer" === t ? new o(e) : i.uint8array ? new u(n.transformTo("uint8array", e)) : new s(n.transformTo("array", e)) : new a(e) }; }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function (e, t, r) { r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\b"; }, {}], 24: [function (e, t, r) { var n = e("./GenericWorker"), i = e("../utils"); function s(e) { n.call(this, "ConvertWorker to " + e), this.destType = e; } i.inherits(s, n), s.prototype.processChunk = function (e) { this.push({ data: i.transformTo(this.destType, e.data), meta: e.meta }); }, t.exports = s; }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function (e, t, r) { var n = e("./GenericWorker"), i = e("../crc32"); function s() { n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0); } e("../utils").inherits(s, n), s.prototype.processChunk = function (e) { this.streamInfo.crc32 = i(e.data, this.streamInfo.crc32 || 0), this.push(e); }, t.exports = s; }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function (e, t, r) { var n = e("../utils"), i = e("./GenericWorker"); function s(e) { i.call(this, "DataLengthProbe for " + e), this.propName = e, this.withStreamInfo(e, 0); } n.inherits(s, i), s.prototype.processChunk = function (e) { if (e) { var t = this.streamInfo[this.propName] || 0; this.streamInfo[this.propName] = t + e.data.length; } i.prototype.processChunk.call(this, e); }, t.exports = s; }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function (e, t, r) { var n = e("../utils"), i = e("./GenericWorker"); function s(e) { i.call(this, "DataWorker"); var t = this; this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, e.then(function (e) { t.dataIsReady = !0, t.data = e, t.max = e && e.length || 0, t.type = n.getTypeOf(e), t.isPaused || t._tickAndRepeat(); }, function (e) { t.error(e); }); } n.inherits(s, i), s.prototype.cleanUp = function () { i.prototype.cleanUp.call(this), this.data = null; }, s.prototype.resume = function () { return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, n.delay(this._tickAndRepeat, [], this)), !0) }, s.prototype._tickAndRepeat = function () { this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0)); }, s.prototype._tick = function () { if (this.isPaused || this.isFinished) return !1; var e = null, t = Math.min(this.max, this.index + 16384); if (this.index >= this.max) return this.end(); switch (this.type) { case "string": e = this.data.substring(this.index, t); break; case "uint8array": e = this.data.subarray(this.index, t); break; case "array": case "nodebuffer": e = this.data.slice(this.index, t); }return this.index = t, this.push({ data: e, meta: { percent: this.max ? this.index / this.max * 100 : 0 } }) }, t.exports = s; }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function (e, t, r) { function n(e) { this.name = e || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null; } n.prototype = { push: function (e) { this.emit("data", e); }, end: function () { if (this.isFinished) return !1; this.flush(); try { this.emit("end"), this.cleanUp(), this.isFinished = !0; } catch (e) { this.emit("error", e); } return !0 }, error: function (e) { return !this.isFinished && (this.isPaused ? this.generatedError = e : (this.isFinished = !0, this.emit("error", e), this.previous && this.previous.error(e), this.cleanUp()), !0) }, on: function (e, t) { return this._listeners[e].push(t), this }, cleanUp: function () { this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = []; }, emit: function (e, t) { if (this._listeners[e]) for (var r = 0; r < this._listeners[e].length; r++)this._listeners[e][r].call(this, t); }, pipe: function (e) { return e.registerPrevious(this) }, registerPrevious: function (e) { if (this.isLocked) throw new Error("The stream '" + this + "' has already been used."); this.streamInfo = e.streamInfo, this.mergeStreamInfo(), this.previous = e; var t = this; return e.on("data", function (e) { t.processChunk(e); }), e.on("end", function () { t.end(); }), e.on("error", function (e) { t.error(e); }), this }, pause: function () { return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0) }, resume: function () { if (!this.isPaused || this.isFinished) return !1; var e = this.isPaused = !1; return this.generatedError && (this.error(this.generatedError), e = !0), this.previous && this.previous.resume(), !e }, flush: function () { }, processChunk: function (e) { this.push(e); }, withStreamInfo: function (e, t) { return this.extraStreamInfo[e] = t, this.mergeStreamInfo(), this }, mergeStreamInfo: function () { for (var e in this.extraStreamInfo) this.extraStreamInfo.hasOwnProperty(e) && (this.streamInfo[e] = this.extraStreamInfo[e]); }, lock: function () { if (this.isLocked) throw new Error("The stream '" + this + "' has already been used."); this.isLocked = !0, this.previous && this.previous.lock(); }, toString: function () { var e = "Worker " + this.name; return this.previous ? this.previous + " -> " + e : e } }, t.exports = n; }, {}], 29: [function (e, t, r) { var h = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), f = e("../base64"), n = e("../support"), a = e("../external"), o = null; if (n.nodestream) try { o = e("../nodejs/NodejsStreamOutputAdapter"); } catch (e) { } function u(e, t, r) { var n = t; switch (t) { case "blob": case "arraybuffer": n = "uint8array"; break; case "base64": n = "string"; }try { this._internalType = n, this._outputType = t, this._mimeType = r, h.checkSupport(n), this._worker = e.pipe(new i(n)), e.lock(); } catch (e) { this._worker = new s("error"), this._worker.error(e); } } u.prototype = { accumulate: function (e) { return o = this, u = e, new a.Promise(function (t, r) { var n = [], i = o._internalType, s = o._outputType, a = o._mimeType; o.on("data", function (e, t) { n.push(e), u && u(t); }).on("error", function (e) { n = [], r(e); }).on("end", function () { try { var e = function (e, t, r) { switch (e) { case "blob": return h.newBlob(h.transformTo("arraybuffer", t), r); case "base64": return f.encode(t); default: return h.transformTo(e, t) } }(s, function (e, t) { var r, n = 0, i = null, s = 0; for (r = 0; r < t.length; r++)s += t[r].length; switch (e) { case "string": return t.join(""); case "array": return Array.prototype.concat.apply([], t); case "uint8array": for (i = new Uint8Array(s), r = 0; r < t.length; r++)i.set(t[r], n), n += t[r].length; return i; case "nodebuffer": return Buffer.concat(t); default: throw new Error("concat : unsupported type '" + e + "'") } }(i, n), a); t(e); } catch (e) { r(e); } n = []; }).resume(); }); var o, u; }, on: function (e, t) { var r = this; return "data" === e ? this._worker.on(e, function (e) { t.call(r, e.data, e.meta); }) : this._worker.on(e, function () { h.delay(t, arguments, r); }), this }, resume: function () { return h.delay(this._worker.resume, [], this._worker), this }, pause: function () { return this._worker.pause(), this }, toNodejsStream: function (e) { if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType) throw new Error(this._outputType + " is not supported by this method"); return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e) } }, t.exports = u; }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function (e, t, r) { if (r.base64 = !0, r.array = !0, r.string = !0, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer) r.blob = !1; else { var n = new ArrayBuffer(0); try { r.blob = 0 === new Blob([n], { type: "application/zip" }).size; } catch (e) { try { var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder); i.append(n), r.blob = 0 === i.getBlob("application/zip").size; } catch (e) { r.blob = !1; } } } try { r.nodestream = !!e("readable-stream").Readable; } catch (e) { r.nodestream = !1; } }, { "readable-stream": 16 }], 31: [function (e, t, s) { for (var o = e("./utils"), u = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), h = new Array(256), i = 0; i < 256; i++)h[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1; function a() { n.call(this, "utf-8 decode"), this.leftOver = null; } function f() { n.call(this, "utf-8 encode"); } h[254] = h[254] = 1, s.utf8encode = function (e) { return u.nodebuffer ? r.newBufferFrom(e, "utf-8") : function (e) { var t, r, n, i, s, a = e.length, o = 0; for (i = 0; i < a; i++)55296 == (64512 & (r = e.charCodeAt(i))) && i + 1 < a && 56320 == (64512 & (n = e.charCodeAt(i + 1))) && (r = 65536 + (r - 55296 << 10) + (n - 56320), i++), o += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4; for (t = u.uint8array ? new Uint8Array(o) : new Array(o), i = s = 0; s < o; i++)55296 == (64512 & (r = e.charCodeAt(i))) && i + 1 < a && 56320 == (64512 & (n = e.charCodeAt(i + 1))) && (r = 65536 + (r - 55296 << 10) + (n - 56320), i++), r < 128 ? t[s++] = r : (r < 2048 ? t[s++] = 192 | r >>> 6 : (r < 65536 ? t[s++] = 224 | r >>> 12 : (t[s++] = 240 | r >>> 18, t[s++] = 128 | r >>> 12 & 63), t[s++] = 128 | r >>> 6 & 63), t[s++] = 128 | 63 & r); return t }(e) }, s.utf8decode = function (e) { return u.nodebuffer ? o.transformTo("nodebuffer", e).toString("utf-8") : function (e) { var t, r, n, i, s = e.length, a = new Array(2 * s); for (t = r = 0; t < s;)if ((n = e[t++]) < 128) a[r++] = n; else if (4 < (i = h[n])) a[r++] = 65533, t += i - 1; else { for (n &= 2 === i ? 31 : 3 === i ? 15 : 7; 1 < i && t < s;)n = n << 6 | 63 & e[t++], i--; 1 < i ? a[r++] = 65533 : n < 65536 ? a[r++] = n : (n -= 65536, a[r++] = 55296 | n >> 10 & 1023, a[r++] = 56320 | 1023 & n); } return a.length !== r && (a.subarray ? a = a.subarray(0, r) : a.length = r), o.applyFromCharCode(a) }(e = o.transformTo(u.uint8array ? "uint8array" : "array", e)) }, o.inherits(a, n), a.prototype.processChunk = function (e) { var t = o.transformTo(u.uint8array ? "uint8array" : "array", e.data); if (this.leftOver && this.leftOver.length) { if (u.uint8array) { var r = t; (t = new Uint8Array(r.length + this.leftOver.length)).set(this.leftOver, 0), t.set(r, this.leftOver.length); } else t = this.leftOver.concat(t); this.leftOver = null; } var n = function (e, t) { var r; for ((t = t || e.length) > e.length && (t = e.length), r = t - 1; 0 <= r && 128 == (192 & e[r]);)r--; return r < 0 ? t : 0 === r ? t : r + h[e[r]] > t ? r : t }(t), i = t; n !== t.length && (u.uint8array ? (i = t.subarray(0, n), this.leftOver = t.subarray(n, t.length)) : (i = t.slice(0, n), this.leftOver = t.slice(n, t.length))), this.push({ data: s.utf8decode(i), meta: e.meta }); }, a.prototype.flush = function () { this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null); }, s.Utf8DecodeWorker = a, o.inherits(f, n), f.prototype.processChunk = function (e) { this.push({ data: s.utf8encode(e.data), meta: e.meta }); }, s.Utf8EncodeWorker = f; }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function (e, t, o) { var u = e("./support"), h = e("./base64"), r = e("./nodejsUtils"), n = e("set-immediate-shim"), f = e("./external"); function i(e) { return e } function l(e, t) { for (var r = 0; r < e.length; ++r)t[r] = 255 & e.charCodeAt(r); return t } o.newBlob = function (t, r) { o.checkSupport("blob"); try { return new Blob([t], { type: r }) } catch (e) { try { var n = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder); return n.append(t), n.getBlob(r) } catch (e) { throw new Error("Bug : can't construct the Blob.") } } }; var s = { stringifyByChunk: function (e, t, r) { var n = [], i = 0, s = e.length; if (s <= r) return String.fromCharCode.apply(null, e); for (; i < s;)"array" === t || "nodebuffer" === t ? n.push(String.fromCharCode.apply(null, e.slice(i, Math.min(i + r, s)))) : n.push(String.fromCharCode.apply(null, e.subarray(i, Math.min(i + r, s)))), i += r; return n.join("") }, stringifyByChar: function (e) { for (var t = "", r = 0; r < e.length; r++)t += String.fromCharCode(e[r]); return t }, applyCanBeUsed: { uint8array: function () { try { return u.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length } catch (e) { return !1 } }(), nodebuffer: function () { try { return u.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length } catch (e) { return !1 } }() } }; function a(e) { var t = 65536, r = o.getTypeOf(e), n = !0; if ("uint8array" === r ? n = s.applyCanBeUsed.uint8array : "nodebuffer" === r && (n = s.applyCanBeUsed.nodebuffer), n) for (; 1 < t;)try { return s.stringifyByChunk(e, r, t) } catch (e) { t = Math.floor(t / 2); } return s.stringifyByChar(e) } function d(e, t) { for (var r = 0; r < e.length; r++)t[r] = e[r]; return t } o.applyFromCharCode = a; var c = {}; c.string = { string: i, array: function (e) { return l(e, new Array(e.length)) }, arraybuffer: function (e) { return c.string.uint8array(e).buffer }, uint8array: function (e) { return l(e, new Uint8Array(e.length)) }, nodebuffer: function (e) { return l(e, r.allocBuffer(e.length)) } }, c.array = { string: a, array: i, arraybuffer: function (e) { return new Uint8Array(e).buffer }, uint8array: function (e) { return new Uint8Array(e) }, nodebuffer: function (e) { return r.newBufferFrom(e) } }, c.arraybuffer = { string: function (e) { return a(new Uint8Array(e)) }, array: function (e) { return d(new Uint8Array(e), new Array(e.byteLength)) }, arraybuffer: i, uint8array: function (e) { return new Uint8Array(e) }, nodebuffer: function (e) { return r.newBufferFrom(new Uint8Array(e)) } }, c.uint8array = { string: a, array: function (e) { return d(e, new Array(e.length)) }, arraybuffer: function (e) { return e.buffer }, uint8array: i, nodebuffer: function (e) { return r.newBufferFrom(e) } }, c.nodebuffer = { string: a, array: function (e) { return d(e, new Array(e.length)) }, arraybuffer: function (e) { return c.nodebuffer.uint8array(e).buffer }, uint8array: function (e) { return d(e, new Uint8Array(e.length)) }, nodebuffer: i }, o.transformTo = function (e, t) { if (t = t || "", !e) return t; o.checkSupport(e); var r = o.getTypeOf(t); return c[r][e](t) }, o.getTypeOf = function (e) { return "string" == typeof e ? "string" : "[object Array]" === Object.prototype.toString.call(e) ? "array" : u.nodebuffer && r.isBuffer(e) ? "nodebuffer" : u.uint8array && e instanceof Uint8Array ? "uint8array" : u.arraybuffer && e instanceof ArrayBuffer ? "arraybuffer" : void 0 }, o.checkSupport = function (e) { if (!u[e.toLowerCase()]) throw new Error(e + " is not supported by this platform") }, o.MAX_VALUE_16BITS = 65535, o.MAX_VALUE_32BITS = -1, o.pretty = function (e) { var t, r, n = ""; for (r = 0; r < (e || "").length; r++)n += "\\x" + ((t = e.charCodeAt(r)) < 16 ? "0" : "") + t.toString(16).toUpperCase(); return n }, o.delay = function (e, t, r) { n(function () { e.apply(r || null, t || []); }); }, o.inherits = function (e, t) { function r() { } r.prototype = t.prototype, e.prototype = new r; }, o.extend = function () { var e, t, r = {}; for (e = 0; e < arguments.length; e++)for (t in arguments[e]) arguments[e].hasOwnProperty(t) && void 0 === r[t] && (r[t] = arguments[e][t]); return r }, o.prepareContent = function (n, e, i, s, a) { return f.Promise.resolve(e).then(function (n) { return u.blob && (n instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n))) && "undefined" != typeof FileReader ? new f.Promise(function (t, r) { var e = new FileReader; e.onload = function (e) { t(e.target.result); }, e.onerror = function (e) { r(e.target.error); }, e.readAsArrayBuffer(n); }) : n }).then(function (e) { var t, r = o.getTypeOf(e); return r ? ("arraybuffer" === r ? e = o.transformTo("uint8array", e) : "string" === r && (a ? e = h.decode(e) : i && !0 !== s && (e = l(t = e, u.uint8array ? new Uint8Array(t.length) : new Array(t.length)))), e) : f.Promise.reject(new Error("Can't read the data of '" + n + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")) }) }; }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, "set-immediate-shim": 54 }], 33: [function (e, t, r) { var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = (e("./utf8"), e("./support")); function u(e) { this.files = [], this.loadOptions = e; } u.prototype = { checkSignature: function (e) { if (!this.reader.readAndCheckSignature(e)) { this.reader.index -= 4; var t = this.reader.readString(4); throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t) + ", expected " + i.pretty(e) + ")") } }, isSignature: function (e, t) { var r = this.reader.index; this.reader.setIndex(e); var n = this.reader.readString(4) === t; return this.reader.setIndex(r), n }, readBlockEndOfCentral: function () { this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2); var e = this.reader.readData(this.zipCommentLength), t = o.uint8array ? "uint8array" : "array", r = i.transformTo(t, e); this.zipComment = this.loadOptions.decodeFileName(r); }, readBlockZip64EndOfCentral: function () { this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {}; for (var e, t, r, n = this.zip64EndOfCentralSize - 44; 0 < n;)e = this.reader.readInt(2), t = this.reader.readInt(4), r = this.reader.readData(t), this.zip64ExtensibleData[e] = { id: e, length: t, value: r }; }, readBlockZip64EndOfCentralLocator: function () { if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported") }, readLocalFiles: function () { var e, t; for (e = 0; e < this.files.length; e++)t = this.files[e], this.reader.setIndex(t.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t.readLocalPart(this.reader), t.handleUTF8(), t.processAttributes(); }, readCentralDir: function () { var e; for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER);)(e = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e); if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length) }, readEndOfCentral: function () { var e = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END); if (e < 0) throw this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html"); this.reader.setIndex(e); var t = e; if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) { if (this.zip64 = !0, (e = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator"); if (this.reader.setIndex(e), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory"); this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral(); } var r = this.centralDirOffset + this.centralDirSize; this.zip64 && (r += 20, r += 12 + this.zip64EndOfCentralSize); var n = t - r; if (0 < n) this.isSignature(t, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n); else if (n < 0) throw new Error("Corrupted zip: missing " + Math.abs(n) + " bytes.") }, prepareReader: function (e) { this.reader = n(e); }, load: function (e) { this.prepareReader(e), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles(); } }, t.exports = u; }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utf8": 31, "./utils": 32, "./zipEntry": 34 }], 34: [function (e, t, r) { var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), u = e("./compressions"), h = e("./support"); function f(e, t) { this.options = e, this.loadOptions = t; } f.prototype = { isEncrypted: function () { return 1 == (1 & this.bitFlag) }, useUTF8: function () { return 2048 == (2048 & this.bitFlag) }, readLocalPart: function (e) { var t, r; if (e.skip(22), this.fileNameLength = e.readInt(2), r = e.readInt(2), this.fileName = e.readData(this.fileNameLength), e.skip(r), -1 === this.compressedSize || -1 === this.uncompressedSize) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)"); if (null === (t = function (e) { for (var t in u) if (u.hasOwnProperty(t) && u[t].magic === e) return u[t]; return null }(this.compressionMethod))) throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")"); this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t, e.readData(this.compressedSize)); }, readCentralPart: function (e) { this.versionMadeBy = e.readInt(2), e.skip(2), this.bitFlag = e.readInt(2), this.compressionMethod = e.readString(2), this.date = e.readDate(), this.crc32 = e.readInt(4), this.compressedSize = e.readInt(4), this.uncompressedSize = e.readInt(4); var t = e.readInt(2); if (this.extraFieldsLength = e.readInt(2), this.fileCommentLength = e.readInt(2), this.diskNumberStart = e.readInt(2), this.internalFileAttributes = e.readInt(2), this.externalFileAttributes = e.readInt(4), this.localHeaderOffset = e.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported"); e.skip(t), this.readExtraFields(e), this.parseZIP64ExtraField(e), this.fileComment = e.readData(this.fileCommentLength); }, processAttributes: function () { this.unixPermissions = null, this.dosPermissions = null; var e = this.versionMadeBy >> 8; this.dir = !!(16 & this.externalFileAttributes), 0 == e && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = !0); }, parseZIP64ExtraField: function (e) { if (this.extraFields[1]) { var t = n(this.extraFields[1].value); this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = t.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = t.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = t.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = t.readInt(4)); } }, readExtraFields: function (e) { var t, r, n, i = e.index + this.extraFieldsLength; for (this.extraFields || (this.extraFields = {}); e.index + 4 < i;)t = e.readInt(2), r = e.readInt(2), n = e.readData(r), this.extraFields[t] = { id: t, length: r, value: n }; e.setIndex(i); }, handleUTF8: function () { var e = h.uint8array ? "uint8array" : "array"; if (this.useUTF8()) this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment); else { var t = this.findExtraFieldUnicodePath(); if (null !== t) this.fileNameStr = t; else { var r = s.transformTo(e, this.fileName); this.fileNameStr = this.loadOptions.decodeFileName(r); } var n = this.findExtraFieldUnicodeComment(); if (null !== n) this.fileCommentStr = n; else { var i = s.transformTo(e, this.fileComment); this.fileCommentStr = this.loadOptions.decodeFileName(i); } } }, findExtraFieldUnicodePath: function () { var e = this.extraFields[28789]; if (e) { var t = n(e.value); return 1 !== t.readInt(1) ? null : a(this.fileName) !== t.readInt(4) ? null : o.utf8decode(t.readData(e.length - 5)) } return null }, findExtraFieldUnicodeComment: function () { var e = this.extraFields[25461]; if (e) { var t = n(e.value); return 1 !== t.readInt(1) ? null : a(this.fileComment) !== t.readInt(4) ? null : o.utf8decode(t.readData(e.length - 5)) } return null } }, t.exports = f; }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function (e, t, r) { function n(e, t, r) { this.name = e, this.dir = r.dir, this.date = r.date, this.comment = r.comment, this.unixPermissions = r.unixPermissions, this.dosPermissions = r.dosPermissions, this._data = t, this._dataBinary = r.binary, this.options = { compression: r.compression, compressionOptions: r.compressionOptions }; } var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), u = e("./stream/GenericWorker"); n.prototype = { internalStream: function (e) { var t = null, r = "string"; try { if (!e) throw new Error("No output type specified."); var n = "string" === (r = e.toLowerCase()) || "text" === r; "binarystring" !== r && "text" !== r || (r = "string"), t = this._decompressWorker(); var i = !this._dataBinary; i && !n && (t = t.pipe(new a.Utf8EncodeWorker)), !i && n && (t = t.pipe(new a.Utf8DecodeWorker)); } catch (e) { (t = new u("error")).error(e); } return new s(t, r, "") }, async: function (e, t) { return this.internalStream(e).accumulate(t) }, nodeStream: function (e, t) { return this.internalStream(e || "nodebuffer").toNodejsStream(t) }, _compressWorker: function (e, t) { if (this._data instanceof o && this._data.compression.magic === e.magic) return this._data.getCompressedWorker(); var r = this._decompressWorker(); return this._dataBinary || (r = r.pipe(new a.Utf8EncodeWorker)), o.createWorkerFrom(r, e, t) }, _decompressWorker: function () { return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof u ? this._data : new i(this._data) } }; for (var h = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], f = function () { throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.") }, l = 0; l < h.length; l++)n.prototype[h[l]] = f; t.exports = n; }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function (e, f, t) { (function (t) { var r, n, e = t.MutationObserver || t.WebKitMutationObserver; if (e) { var i = 0, s = new e(h), a = t.document.createTextNode(""); s.observe(a, { characterData: !0 }), r = function () { a.data = i = ++i % 2; }; } else if (t.setImmediate || void 0 === t.MessageChannel) r = "document" in t && "onreadystatechange" in t.document.createElement("script") ? function () { var e = t.document.createElement("script"); e.onreadystatechange = function () { h(), e.onreadystatechange = null, e.parentNode.removeChild(e), e = null; }, t.document.documentElement.appendChild(e); } : function () { setTimeout(h, 0); }; else { var o = new t.MessageChannel; o.port1.onmessage = h, r = function () { o.port2.postMessage(0); }; } var u = []; function h() { var e, t; n = !0; for (var r = u.length; r;) { for (t = u, u = [], e = -1; ++e < r;)t[e](); r = u.length; } n = !1; } f.exports = function (e) { 1 !== u.push(e) || n || r(); }; }).call(this, void 0 !== r ? r : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}); }, {}], 37: [function (e, t, r) { var i = e("immediate"); function h() { } var f = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"]; function o(e) { if ("function" != typeof e) throw new TypeError("resolver must be a function"); this.state = n, this.queue = [], this.outcome = void 0, e !== h && c(this, e); } function u(e, t, r) { this.promise = e, "function" == typeof t && (this.onFulfilled = t, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r && (this.onRejected = r, this.callRejected = this.otherCallRejected); } function l(t, r, n) { i(function () { var e; try { e = r(n); } catch (e) { return f.reject(t, e) } e === t ? f.reject(t, new TypeError("Cannot resolve promise with itself")) : f.resolve(t, e); }); } function d(e) { var t = e && e.then; if (e && ("object" == typeof e || "function" == typeof e) && "function" == typeof t) return function () { t.apply(e, arguments); } } function c(t, e) { var r = !1; function n(e) { r || (r = !0, f.reject(t, e)); } function i(e) { r || (r = !0, f.resolve(t, e)); } var s = p(function () { e(i, n); }); "error" === s.status && n(s.value); } function p(e, t) { var r = {}; try { r.value = e(t), r.status = "success"; } catch (e) { r.status = "error", r.value = e; } return r } (t.exports = o).prototype.finally = function (t) { if ("function" != typeof t) return this; var r = this.constructor; return this.then(function (e) { return r.resolve(t()).then(function () { return e }) }, function (e) { return r.resolve(t()).then(function () { throw e }) }) }, o.prototype.catch = function (e) { return this.then(null, e) }, o.prototype.then = function (e, t) { if ("function" != typeof e && this.state === a || "function" != typeof t && this.state === s) return this; var r = new this.constructor(h); return this.state !== n ? l(r, this.state === a ? e : t, this.outcome) : this.queue.push(new u(r, e, t)), r }, u.prototype.callFulfilled = function (e) { f.resolve(this.promise, e); }, u.prototype.otherCallFulfilled = function (e) { l(this.promise, this.onFulfilled, e); }, u.prototype.callRejected = function (e) { f.reject(this.promise, e); }, u.prototype.otherCallRejected = function (e) { l(this.promise, this.onRejected, e); }, f.resolve = function (e, t) { var r = p(d, t); if ("error" === r.status) return f.reject(e, r.value); var n = r.value; if (n) c(e, n); else { e.state = a, e.outcome = t; for (var i = -1, s = e.queue.length; ++i < s;)e.queue[i].callFulfilled(t); } return e }, f.reject = function (e, t) { e.state = s, e.outcome = t; for (var r = -1, n = e.queue.length; ++r < n;)e.queue[r].callRejected(t); return e }, o.resolve = function (e) { return e instanceof this ? e : f.resolve(new this(h), e) }, o.reject = function (e) { var t = new this(h); return f.reject(t, e) }, o.all = function (e) { var r = this; if ("[object Array]" !== Object.prototype.toString.call(e)) return this.reject(new TypeError("must be an array")); var n = e.length, i = !1; if (!n) return this.resolve([]); for (var s = new Array(n), a = 0, t = -1, o = new this(h); ++t < n;)u(e[t], t); return o; function u(e, t) { r.resolve(e).then(function (e) { s[t] = e, ++a !== n || i || (i = !0, f.resolve(o, s)); }, function (e) { i || (i = !0, f.reject(o, e)); }); } }, o.race = function (e) { if ("[object Array]" !== Object.prototype.toString.call(e)) return this.reject(new TypeError("must be an array")); var t = e.length, r = !1; if (!t) return this.resolve([]); for (var n, i = -1, s = new this(h); ++i < t;)n = e[i], this.resolve(n).then(function (e) { r || (r = !0, f.resolve(s, e)); }, function (e) { r || (r = !0, f.reject(s, e)); }); return s }; }, { immediate: 36 }], 38: [function (e, t, r) { var n = {}; (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t.exports = n; }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function (e, t, r) { var a = e("./zlib/deflate"), o = e("./utils/common"), u = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), h = Object.prototype.toString, f = 0, l = -1, d = 0, c = 8; function p(e) { if (!(this instanceof p)) return new p(e); this.options = o.assign({ level: l, method: c, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: d, to: "" }, e || {}); var t = this.options; t.raw && 0 < t.windowBits ? t.windowBits = -t.windowBits : t.gzip && 0 < t.windowBits && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new s, this.strm.avail_out = 0; var r = a.deflateInit2(this.strm, t.level, t.method, t.windowBits, t.memLevel, t.strategy); if (r !== f) throw new Error(i[r]); if (t.header && a.deflateSetHeader(this.strm, t.header), t.dictionary) { var n; if (n = "string" == typeof t.dictionary ? u.string2buf(t.dictionary) : "[object ArrayBuffer]" === h.call(t.dictionary) ? new Uint8Array(t.dictionary) : t.dictionary, (r = a.deflateSetDictionary(this.strm, n)) !== f) throw new Error(i[r]); this._dict_set = !0; } } function n(e, t) { var r = new p(t); if (r.push(e, !0), r.err) throw r.msg || i[r.err]; return r.result } p.prototype.push = function (e, t) { var r, n, i = this.strm, s = this.options.chunkSize; if (this.ended) return !1; n = t === ~~t ? t : !0 === t ? 4 : 0, "string" == typeof e ? i.input = u.string2buf(e) : "[object ArrayBuffer]" === h.call(e) ? i.input = new Uint8Array(e) : i.input = e, i.next_in = 0, i.avail_in = i.input.length; do { if (0 === i.avail_out && (i.output = new o.Buf8(s), i.next_out = 0, i.avail_out = s), 1 !== (r = a.deflate(i, n)) && r !== f) return this.onEnd(r), !(this.ended = !0); 0 !== i.avail_out && (0 !== i.avail_in || 4 !== n && 2 !== n) || ("string" === this.options.to ? this.onData(u.buf2binstring(o.shrinkBuf(i.output, i.next_out))) : this.onData(o.shrinkBuf(i.output, i.next_out))); } while ((0 < i.avail_in || 0 === i.avail_out) && 1 !== r); return 4 === n ? (r = a.deflateEnd(this.strm), this.onEnd(r), this.ended = !0, r === f) : 2 !== n || (this.onEnd(f), !(i.avail_out = 0)) }, p.prototype.onData = function (e) { this.chunks.push(e); }, p.prototype.onEnd = function (e) { e === f && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg; }, r.Deflate = p, r.deflate = n, r.deflateRaw = function (e, t) { return (t = t || {}).raw = !0, n(e, t) }, r.gzip = function (e, t) { return (t = t || {}).gzip = !0, n(e, t) }; }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function (e, t, r) { var d = e("./zlib/inflate"), c = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString; function a(e) { if (!(this instanceof a)) return new a(e); this.options = c.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e || {}); var t = this.options; t.raw && 0 <= t.windowBits && t.windowBits < 16 && (t.windowBits = -t.windowBits, 0 === t.windowBits && (t.windowBits = -15)), !(0 <= t.windowBits && t.windowBits < 16) || e && e.windowBits || (t.windowBits += 32), 15 < t.windowBits && t.windowBits < 48 && 0 == (15 & t.windowBits) && (t.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new i, this.strm.avail_out = 0; var r = d.inflateInit2(this.strm, t.windowBits); if (r !== m.Z_OK) throw new Error(n[r]); this.header = new s, d.inflateGetHeader(this.strm, this.header); } function o(e, t) { var r = new a(t); if (r.push(e, !0), r.err) throw r.msg || n[r.err]; return r.result } a.prototype.push = function (e, t) { var r, n, i, s, a, o, u = this.strm, h = this.options.chunkSize, f = this.options.dictionary, l = !1; if (this.ended) return !1; n = t === ~~t ? t : !0 === t ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e ? u.input = p.binstring2buf(e) : "[object ArrayBuffer]" === _.call(e) ? u.input = new Uint8Array(e) : u.input = e, u.next_in = 0, u.avail_in = u.input.length; do { if (0 === u.avail_out && (u.output = new c.Buf8(h), u.next_out = 0, u.avail_out = h), (r = d.inflate(u, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && f && (o = "string" == typeof f ? p.string2buf(f) : "[object ArrayBuffer]" === _.call(f) ? new Uint8Array(f) : f, r = d.inflateSetDictionary(this.strm, o)), r === m.Z_BUF_ERROR && !0 === l && (r = m.Z_OK, l = !1), r !== m.Z_STREAM_END && r !== m.Z_OK) return this.onEnd(r), !(this.ended = !0); u.next_out && (0 !== u.avail_out && r !== m.Z_STREAM_END && (0 !== u.avail_in || n !== m.Z_FINISH && n !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i = p.utf8border(u.output, u.next_out), s = u.next_out - i, a = p.buf2string(u.output, i), u.next_out = s, u.avail_out = h - s, s && c.arraySet(u.output, u.output, i, s, 0), this.onData(a)) : this.onData(c.shrinkBuf(u.output, u.next_out)))), 0 === u.avail_in && 0 === u.avail_out && (l = !0); } while ((0 < u.avail_in || 0 === u.avail_out) && r !== m.Z_STREAM_END); return r === m.Z_STREAM_END && (n = m.Z_FINISH), n === m.Z_FINISH ? (r = d.inflateEnd(this.strm), this.onEnd(r), this.ended = !0, r === m.Z_OK) : n !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(u.avail_out = 0)) }, a.prototype.onData = function (e) { this.chunks.push(e); }, a.prototype.onEnd = function (e) { e === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = c.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg; }, r.Inflate = a, r.inflate = o, r.inflateRaw = function (e, t) { return (t = t || {}).raw = !0, o(e, t) }, r.ungzip = o; }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function (e, t, r) { var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array; r.assign = function (e) { for (var t = Array.prototype.slice.call(arguments, 1); t.length;) { var r = t.shift(); if (r) { if ("object" != typeof r) throw new TypeError(r + "must be non-object"); for (var n in r) r.hasOwnProperty(n) && (e[n] = r[n]); } } return e }, r.shrinkBuf = function (e, t) { return e.length === t ? e : e.subarray ? e.subarray(0, t) : (e.length = t, e) }; var i = { arraySet: function (e, t, r, n, i) { if (t.subarray && e.subarray) e.set(t.subarray(r, r + n), i); else for (var s = 0; s < n; s++)e[i + s] = t[r + s]; }, flattenChunks: function (e) { var t, r, n, i, s, a; for (t = n = 0, r = e.length; t < r; t++)n += e[t].length; for (a = new Uint8Array(n), t = i = 0, r = e.length; t < r; t++)s = e[t], a.set(s, i), i += s.length; return a } }, s = { arraySet: function (e, t, r, n, i) { for (var s = 0; s < n; s++)e[i + s] = t[r + s]; }, flattenChunks: function (e) { return [].concat.apply([], e) } }; r.setTyped = function (e) { e ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s)); }, r.setTyped(n); }, {}], 42: [function (e, t, r) { var u = e("./common"), i = !0, s = !0; try { String.fromCharCode.apply(null, [0]); } catch (e) { i = !1; } try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (e) { s = !1; } for (var h = new u.Buf8(256), n = 0; n < 256; n++)h[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1; function f(e, t) { if (t < 65537 && (e.subarray && s || !e.subarray && i)) return String.fromCharCode.apply(null, u.shrinkBuf(e, t)); for (var r = "", n = 0; n < t; n++)r += String.fromCharCode(e[n]); return r } h[254] = h[254] = 1, r.string2buf = function (e) { var t, r, n, i, s, a = e.length, o = 0; for (i = 0; i < a; i++)55296 == (64512 & (r = e.charCodeAt(i))) && i + 1 < a && 56320 == (64512 & (n = e.charCodeAt(i + 1))) && (r = 65536 + (r - 55296 << 10) + (n - 56320), i++), o += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4; for (t = new u.Buf8(o), i = s = 0; s < o; i++)55296 == (64512 & (r = e.charCodeAt(i))) && i + 1 < a && 56320 == (64512 & (n = e.charCodeAt(i + 1))) && (r = 65536 + (r - 55296 << 10) + (n - 56320), i++), r < 128 ? t[s++] = r : (r < 2048 ? t[s++] = 192 | r >>> 6 : (r < 65536 ? t[s++] = 224 | r >>> 12 : (t[s++] = 240 | r >>> 18, t[s++] = 128 | r >>> 12 & 63), t[s++] = 128 | r >>> 6 & 63), t[s++] = 128 | 63 & r); return t }, r.buf2binstring = function (e) { return f(e, e.length) }, r.binstring2buf = function (e) { for (var t = new u.Buf8(e.length), r = 0, n = t.length; r < n; r++)t[r] = e.charCodeAt(r); return t }, r.buf2string = function (e, t) { var r, n, i, s, a = t || e.length, o = new Array(2 * a); for (r = n = 0; r < a;)if ((i = e[r++]) < 128) o[n++] = i; else if (4 < (s = h[i])) o[n++] = 65533, r += s - 1; else { for (i &= 2 === s ? 31 : 3 === s ? 15 : 7; 1 < s && r < a;)i = i << 6 | 63 & e[r++], s--; 1 < s ? o[n++] = 65533 : i < 65536 ? o[n++] = i : (i -= 65536, o[n++] = 55296 | i >> 10 & 1023, o[n++] = 56320 | 1023 & i); } return f(o, n) }, r.utf8border = function (e, t) { var r; for ((t = t || e.length) > e.length && (t = e.length), r = t - 1; 0 <= r && 128 == (192 & e[r]);)r--; return r < 0 ? t : 0 === r ? t : r + h[e[r]] > t ? r : t }; }, { "./common": 41 }], 43: [function (e, t, r) { t.exports = function (e, t, r, n) { for (var i = 65535 & e | 0, s = e >>> 16 & 65535 | 0, a = 0; 0 !== r;) { for (r -= a = 2e3 < r ? 2e3 : r; s = s + (i = i + t[n++] | 0) | 0, --a;); i %= 65521, s %= 65521; } return i | s << 16 | 0 }; }, {}], 44: [function (e, t, r) { t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 }; }, {}], 45: [function (e, t, r) { var o = function () { for (var e, t = [], r = 0; r < 256; r++) { e = r; for (var n = 0; n < 8; n++)e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1; t[r] = e; } return t }(); t.exports = function (e, t, r, n) { var i = o, s = n + r; e ^= -1; for (var a = n; a < s; a++)e = e >>> 8 ^ i[255 & (e ^ t[a])]; return -1 ^ e }; }, {}], 46: [function (e, t, r) { var u, d = e("../utils/common"), h = e("./trees"), c = e("./adler32"), p = e("./crc32"), n = e("./messages"), f = 0, l = 0, m = -2, i = 2, _ = 8, s = 286, a = 30, o = 19, g = 2 * s + 1, v = 15, b = 3, w = 258, y = w + b + 1, k = 42, x = 113; function S(e, t) { return e.msg = n[t], t } function z(e) { return (e << 1) - (4 < e ? 9 : 0) } function E(e) { for (var t = e.length; 0 <= --t;)e[t] = 0; } function C(e) { var t = e.state, r = t.pending; r > e.avail_out && (r = e.avail_out), 0 !== r && (d.arraySet(e.output, t.pending_buf, t.pending_out, r, e.next_out), e.next_out += r, t.pending_out += r, e.total_out += r, e.avail_out -= r, t.pending -= r, 0 === t.pending && (t.pending_out = 0)); } function A(e, t) { h._tr_flush_block(e, 0 <= e.block_start ? e.block_start : -1, e.strstart - e.block_start, t), e.block_start = e.strstart, C(e.strm); } function I(e, t) { e.pending_buf[e.pending++] = t; } function O(e, t) { e.pending_buf[e.pending++] = t >>> 8 & 255, e.pending_buf[e.pending++] = 255 & t; } function B(e, t) { var r, n, i = e.max_chain_length, s = e.strstart, a = e.prev_length, o = e.nice_match, u = e.strstart > e.w_size - y ? e.strstart - (e.w_size - y) : 0, h = e.window, f = e.w_mask, l = e.prev, d = e.strstart + w, c = h[s + a - 1], p = h[s + a]; e.prev_length >= e.good_match && (i >>= 2), o > e.lookahead && (o = e.lookahead); do { if (h[(r = t) + a] === p && h[r + a - 1] === c && h[r] === h[s] && h[++r] === h[s + 1]) { s += 2, r++; do { } while (h[++s] === h[++r] && h[++s] === h[++r] && h[++s] === h[++r] && h[++s] === h[++r] && h[++s] === h[++r] && h[++s] === h[++r] && h[++s] === h[++r] && h[++s] === h[++r] && s < d); if (n = w - (d - s), s = d - w, a < n) { if (e.match_start = t, o <= (a = n)) break; c = h[s + a - 1], p = h[s + a]; } } } while ((t = l[t & f]) > u && 0 != --i); return a <= e.lookahead ? a : e.lookahead } function T(e) { var t, r, n, i, s, a, o, u, h, f, l = e.w_size; do { if (i = e.window_size - e.lookahead - e.strstart, e.strstart >= l + (l - y)) { for (d.arraySet(e.window, e.window, l, l, 0), e.match_start -= l, e.strstart -= l, e.block_start -= l, t = r = e.hash_size; n = e.head[--t], e.head[t] = l <= n ? n - l : 0, --r;); for (t = r = l; n = e.prev[--t], e.prev[t] = l <= n ? n - l : 0, --r;); i += l; } if (0 === e.strm.avail_in) break; if (a = e.strm, o = e.window, u = e.strstart + e.lookahead, f = void 0, (h = i) < (f = a.avail_in) && (f = h), r = 0 === f ? 0 : (a.avail_in -= f, d.arraySet(o, a.input, a.next_in, f, u), 1 === a.state.wrap ? a.adler = c(a.adler, o, f, u) : 2 === a.state.wrap && (a.adler = p(a.adler, o, f, u)), a.next_in += f, a.total_in += f, f), e.lookahead += r, e.lookahead + e.insert >= b) for (s = e.strstart - e.insert, e.ins_h = e.window[s], e.ins_h = (e.ins_h << e.hash_shift ^ e.window[s + 1]) & e.hash_mask; e.insert && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[s + b - 1]) & e.hash_mask, e.prev[s & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = s, s++, e.insert--, !(e.lookahead + e.insert < b));); } while (e.lookahead < y && 0 !== e.strm.avail_in) } function R(e, t) { for (var r, n; ;) { if (e.lookahead < y) { if (T(e), e.lookahead < y && t === f) return 1; if (0 === e.lookahead) break } if (r = 0, e.lookahead >= b && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + b - 1]) & e.hash_mask, r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), 0 !== r && e.strstart - r <= e.w_size - y && (e.match_length = B(e, r)), e.match_length >= b) if (n = h._tr_tally(e, e.strstart - e.match_start, e.match_length - b), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= b) { for (e.match_length--; e.strstart++, e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + b - 1]) & e.hash_mask, r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart, 0 != --e.match_length;); e.strstart++; } else e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + 1]) & e.hash_mask; else n = h._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++; if (n && (A(e, !1), 0 === e.strm.avail_out)) return 1 } return e.insert = e.strstart < b - 1 ? e.strstart : b - 1, 4 === t ? (A(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.last_lit && (A(e, !1), 0 === e.strm.avail_out) ? 1 : 2 } function D(e, t) { for (var r, n, i; ;) { if (e.lookahead < y) { if (T(e), e.lookahead < y && t === f) return 1; if (0 === e.lookahead) break } if (r = 0, e.lookahead >= b && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + b - 1]) & e.hash_mask, r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = b - 1, 0 !== r && e.prev_length < e.max_lazy_match && e.strstart - r <= e.w_size - y && (e.match_length = B(e, r), e.match_length <= 5 && (1 === e.strategy || e.match_length === b && 4096 < e.strstart - e.match_start) && (e.match_length = b - 1)), e.prev_length >= b && e.match_length <= e.prev_length) { for (i = e.strstart + e.lookahead - b, n = h._tr_tally(e, e.strstart - 1 - e.prev_match, e.prev_length - b), e.lookahead -= e.prev_length - 1, e.prev_length -= 2; ++e.strstart <= i && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + b - 1]) & e.hash_mask, r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), 0 != --e.prev_length;); if (e.match_available = 0, e.match_length = b - 1, e.strstart++, n && (A(e, !1), 0 === e.strm.avail_out)) return 1 } else if (e.match_available) { if ((n = h._tr_tally(e, 0, e.window[e.strstart - 1])) && A(e, !1), e.strstart++, e.lookahead--, 0 === e.strm.avail_out) return 1 } else e.match_available = 1, e.strstart++, e.lookahead--; } return e.match_available && (n = h._tr_tally(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < b - 1 ? e.strstart : b - 1, 4 === t ? (A(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.last_lit && (A(e, !1), 0 === e.strm.avail_out) ? 1 : 2 } function F(e, t, r, n, i) { this.good_length = e, this.max_lazy = t, this.nice_length = r, this.max_chain = n, this.func = i; } function N() { this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = _, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new d.Buf16(2 * g), this.dyn_dtree = new d.Buf16(2 * (2 * a + 1)), this.bl_tree = new d.Buf16(2 * (2 * o + 1)), E(this.dyn_ltree), E(this.dyn_dtree), E(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new d.Buf16(v + 1), this.heap = new d.Buf16(2 * s + 1), E(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new d.Buf16(2 * s + 1), E(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0; } function U(e) { var t; return e && e.state ? (e.total_in = e.total_out = 0, e.data_type = i, (t = e.state).pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = t.wrap ? k : x, e.adler = 2 === t.wrap ? 0 : 1, t.last_flush = f, h._tr_init(t), l) : S(e, m) } function P(e) { var t, r = U(e); return r === l && ((t = e.state).window_size = 2 * t.w_size, E(t.head), t.max_lazy_match = u[t.level].max_lazy, t.good_match = u[t.level].good_length, t.nice_match = u[t.level].nice_length, t.max_chain_length = u[t.level].max_chain, t.strstart = 0, t.block_start = 0, t.lookahead = 0, t.insert = 0, t.match_length = t.prev_length = b - 1, t.match_available = 0, t.ins_h = 0), r } function L(e, t, r, n, i, s) { if (!e) return m; var a = 1; if (-1 === t && (t = 6), n < 0 ? (a = 0, n = -n) : 15 < n && (a = 2, n -= 16), i < 1 || 9 < i || r !== _ || n < 8 || 15 < n || t < 0 || 9 < t || s < 0 || 4 < s) return S(e, m); 8 === n && (n = 9); var o = new N; return (e.state = o).strm = e, o.wrap = a, o.gzhead = null, o.w_bits = n, o.w_size = 1 << o.w_bits, o.w_mask = o.w_size - 1, o.hash_bits = i + 7, o.hash_size = 1 << o.hash_bits, o.hash_mask = o.hash_size - 1, o.hash_shift = ~~((o.hash_bits + b - 1) / b), o.window = new d.Buf8(2 * o.w_size), o.head = new d.Buf16(o.hash_size), o.prev = new d.Buf16(o.w_size), o.lit_bufsize = 1 << i + 6, o.pending_buf_size = 4 * o.lit_bufsize, o.pending_buf = new d.Buf8(o.pending_buf_size), o.d_buf = 1 * o.lit_bufsize, o.l_buf = 3 * o.lit_bufsize, o.level = t, o.strategy = s, o.method = r, P(e) } u = [new F(0, 0, 0, 0, function (e, t) { var r = 65535; for (r > e.pending_buf_size - 5 && (r = e.pending_buf_size - 5); ;) { if (e.lookahead <= 1) { if (T(e), 0 === e.lookahead && t === f) return 1; if (0 === e.lookahead) break } e.strstart += e.lookahead, e.lookahead = 0; var n = e.block_start + r; if ((0 === e.strstart || e.strstart >= n) && (e.lookahead = e.strstart - n, e.strstart = n, A(e, !1), 0 === e.strm.avail_out)) return 1; if (e.strstart - e.block_start >= e.w_size - y && (A(e, !1), 0 === e.strm.avail_out)) return 1 } return e.insert = 0, 4 === t ? (A(e, !0), 0 === e.strm.avail_out ? 3 : 4) : (e.strstart > e.block_start && (A(e, !1), e.strm.avail_out), 1) }), new F(4, 4, 8, 4, R), new F(4, 5, 16, 8, R), new F(4, 6, 32, 32, R), new F(4, 4, 16, 16, D), new F(8, 16, 32, 32, D), new F(8, 16, 128, 128, D), new F(8, 32, 128, 256, D), new F(32, 128, 258, 1024, D), new F(32, 258, 258, 4096, D)], r.deflateInit = function (e, t) { return L(e, t, _, 15, 8, 0) }, r.deflateInit2 = L, r.deflateReset = P, r.deflateResetKeep = U, r.deflateSetHeader = function (e, t) { return e && e.state ? 2 !== e.state.wrap ? m : (e.state.gzhead = t, l) : m }, r.deflate = function (e, t) { var r, n, i, s; if (!e || !e.state || 5 < t || t < 0) return e ? S(e, m) : m; if (n = e.state, !e.output || !e.input && 0 !== e.avail_in || 666 === n.status && 4 !== t) return S(e, 0 === e.avail_out ? -5 : m); if (n.strm = e, r = n.last_flush, n.last_flush = t, n.status === k) if (2 === n.wrap) e.adler = 0, I(n, 31), I(n, 139), I(n, 8), n.gzhead ? (I(n, (n.gzhead.text ? 1 : 0) + (n.gzhead.hcrc ? 2 : 0) + (n.gzhead.extra ? 4 : 0) + (n.gzhead.name ? 8 : 0) + (n.gzhead.comment ? 16 : 0)), I(n, 255 & n.gzhead.time), I(n, n.gzhead.time >> 8 & 255), I(n, n.gzhead.time >> 16 & 255), I(n, n.gzhead.time >> 24 & 255), I(n, 9 === n.level ? 2 : 2 <= n.strategy || n.level < 2 ? 4 : 0), I(n, 255 & n.gzhead.os), n.gzhead.extra && n.gzhead.extra.length && (I(n, 255 & n.gzhead.extra.length), I(n, n.gzhead.extra.length >> 8 & 255)), n.gzhead.hcrc && (e.adler = p(e.adler, n.pending_buf, n.pending, 0)), n.gzindex = 0, n.status = 69) : (I(n, 0), I(n, 0), I(n, 0), I(n, 0), I(n, 0), I(n, 9 === n.level ? 2 : 2 <= n.strategy || n.level < 2 ? 4 : 0), I(n, 3), n.status = x); else { var a = _ + (n.w_bits - 8 << 4) << 8; a |= (2 <= n.strategy || n.level < 2 ? 0 : n.level < 6 ? 1 : 6 === n.level ? 2 : 3) << 6, 0 !== n.strstart && (a |= 32), a += 31 - a % 31, n.status = x, O(n, a), 0 !== n.strstart && (O(n, e.adler >>> 16), O(n, 65535 & e.adler)), e.adler = 1; } if (69 === n.status) if (n.gzhead.extra) { for (i = n.pending; n.gzindex < (65535 & n.gzhead.extra.length) && (n.pending !== n.pending_buf_size || (n.gzhead.hcrc && n.pending > i && (e.adler = p(e.adler, n.pending_buf, n.pending - i, i)), C(e), i = n.pending, n.pending !== n.pending_buf_size));)I(n, 255 & n.gzhead.extra[n.gzindex]), n.gzindex++; n.gzhead.hcrc && n.pending > i && (e.adler = p(e.adler, n.pending_buf, n.pending - i, i)), n.gzindex === n.gzhead.extra.length && (n.gzindex = 0, n.status = 73); } else n.status = 73; if (73 === n.status) if (n.gzhead.name) { i = n.pending; do { if (n.pending === n.pending_buf_size && (n.gzhead.hcrc && n.pending > i && (e.adler = p(e.adler, n.pending_buf, n.pending - i, i)), C(e), i = n.pending, n.pending === n.pending_buf_size)) { s = 1; break } s = n.gzindex < n.gzhead.name.length ? 255 & n.gzhead.name.charCodeAt(n.gzindex++) : 0, I(n, s); } while (0 !== s); n.gzhead.hcrc && n.pending > i && (e.adler = p(e.adler, n.pending_buf, n.pending - i, i)), 0 === s && (n.gzindex = 0, n.status = 91); } else n.status = 91; if (91 === n.status) if (n.gzhead.comment) { i = n.pending; do { if (n.pending === n.pending_buf_size && (n.gzhead.hcrc && n.pending > i && (e.adler = p(e.adler, n.pending_buf, n.pending - i, i)), C(e), i = n.pending, n.pending === n.pending_buf_size)) { s = 1; break } s = n.gzindex < n.gzhead.comment.length ? 255 & n.gzhead.comment.charCodeAt(n.gzindex++) : 0, I(n, s); } while (0 !== s); n.gzhead.hcrc && n.pending > i && (e.adler = p(e.adler, n.pending_buf, n.pending - i, i)), 0 === s && (n.status = 103); } else n.status = 103; if (103 === n.status && (n.gzhead.hcrc ? (n.pending + 2 > n.pending_buf_size && C(e), n.pending + 2 <= n.pending_buf_size && (I(n, 255 & e.adler), I(n, e.adler >> 8 & 255), e.adler = 0, n.status = x)) : n.status = x), 0 !== n.pending) { if (C(e), 0 === e.avail_out) return n.last_flush = -1, l } else if (0 === e.avail_in && z(t) <= z(r) && 4 !== t) return S(e, -5); if (666 === n.status && 0 !== e.avail_in) return S(e, -5); if (0 !== e.avail_in || 0 !== n.lookahead || t !== f && 666 !== n.status) { var o = 2 === n.strategy ? function (e, t) { for (var r; ;) { if (0 === e.lookahead && (T(e), 0 === e.lookahead)) { if (t === f) return 1; break } if (e.match_length = 0, r = h._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, r && (A(e, !1), 0 === e.strm.avail_out)) return 1 } return e.insert = 0, 4 === t ? (A(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.last_lit && (A(e, !1), 0 === e.strm.avail_out) ? 1 : 2 }(n, t) : 3 === n.strategy ? function (e, t) { for (var r, n, i, s, a = e.window; ;) { if (e.lookahead <= w) { if (T(e), e.lookahead <= w && t === f) return 1; if (0 === e.lookahead) break } if (e.match_length = 0, e.lookahead >= b && 0 < e.strstart && (n = a[i = e.strstart - 1]) === a[++i] && n === a[++i] && n === a[++i]) { s = e.strstart + w; do { } while (n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && i < s); e.match_length = w - (s - i), e.match_length > e.lookahead && (e.match_length = e.lookahead); } if (e.match_length >= b ? (r = h._tr_tally(e, 1, e.match_length - b), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (r = h._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), r && (A(e, !1), 0 === e.strm.avail_out)) return 1 } return e.insert = 0, 4 === t ? (A(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.last_lit && (A(e, !1), 0 === e.strm.avail_out) ? 1 : 2 }(n, t) : u[n.level].func(n, t); if (3 !== o && 4 !== o || (n.status = 666), 1 === o || 3 === o) return 0 === e.avail_out && (n.last_flush = -1), l; if (2 === o && (1 === t ? h._tr_align(n) : 5 !== t && (h._tr_stored_block(n, 0, 0, !1), 3 === t && (E(n.head), 0 === n.lookahead && (n.strstart = 0, n.block_start = 0, n.insert = 0))), C(e), 0 === e.avail_out)) return n.last_flush = -1, l } return 4 !== t ? l : n.wrap <= 0 ? 1 : (2 === n.wrap ? (I(n, 255 & e.adler), I(n, e.adler >> 8 & 255), I(n, e.adler >> 16 & 255), I(n, e.adler >> 24 & 255), I(n, 255 & e.total_in), I(n, e.total_in >> 8 & 255), I(n, e.total_in >> 16 & 255), I(n, e.total_in >> 24 & 255)) : (O(n, e.adler >>> 16), O(n, 65535 & e.adler)), C(e), 0 < n.wrap && (n.wrap = -n.wrap), 0 !== n.pending ? l : 1) }, r.deflateEnd = function (e) { var t; return e && e.state ? (t = e.state.status) !== k && 69 !== t && 73 !== t && 91 !== t && 103 !== t && t !== x && 666 !== t ? S(e, m) : (e.state = null, t === x ? S(e, -3) : l) : m }, r.deflateSetDictionary = function (e, t) { var r, n, i, s, a, o, u, h, f = t.length; if (!e || !e.state) return m; if (2 === (s = (r = e.state).wrap) || 1 === s && r.status !== k || r.lookahead) return m; for (1 === s && (e.adler = c(e.adler, t, f, 0)), r.wrap = 0, f >= r.w_size && (0 === s && (E(r.head), r.strstart = 0, r.block_start = 0, r.insert = 0), h = new d.Buf8(r.w_size), d.arraySet(h, t, f - r.w_size, r.w_size, 0), t = h, f = r.w_size), a = e.avail_in, o = e.next_in, u = e.input, e.avail_in = f, e.next_in = 0, e.input = t, T(r); r.lookahead >= b;) { for (n = r.strstart, i = r.lookahead - (b - 1); r.ins_h = (r.ins_h << r.hash_shift ^ r.window[n + b - 1]) & r.hash_mask, r.prev[n & r.w_mask] = r.head[r.ins_h], r.head[r.ins_h] = n, n++, --i;); r.strstart = n, r.lookahead = b - 1, T(r); } return r.strstart += r.lookahead, r.block_start = r.strstart, r.insert = r.lookahead, r.lookahead = 0, r.match_length = r.prev_length = b - 1, r.match_available = 0, e.next_in = o, e.input = u, e.avail_in = a, r.wrap = s, l }, r.deflateInfo = "pako deflate (from Nodeca project)"; }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function (e, t, r) { t.exports = function () { this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1; }; }, {}], 48: [function (e, t, r) { t.exports = function (e, t) { var r, n, i, s, a, o, u, h, f, l, d, c, p, m, _, g, v, b, w, y, k, x, S, z, E; r = e.state, n = e.next_in, z = e.input, i = n + (e.avail_in - 5), s = e.next_out, E = e.output, a = s - (t - e.avail_out), o = s + (e.avail_out - 257), u = r.dmax, h = r.wsize, f = r.whave, l = r.wnext, d = r.window, c = r.hold, p = r.bits, m = r.lencode, _ = r.distcode, g = (1 << r.lenbits) - 1, v = (1 << r.distbits) - 1; e: do { p < 15 && (c += z[n++] << p, p += 8, c += z[n++] << p, p += 8), b = m[c & g]; t: for (; ;) { if (c >>>= w = b >>> 24, p -= w, 0 == (w = b >>> 16 & 255)) E[s++] = 65535 & b; else { if (!(16 & w)) { if (0 == (64 & w)) { b = m[(65535 & b) + (c & (1 << w) - 1)]; continue t } if (32 & w) { r.mode = 12; break e } e.msg = "invalid literal/length code", r.mode = 30; break e } y = 65535 & b, (w &= 15) && (p < w && (c += z[n++] << p, p += 8), y += c & (1 << w) - 1, c >>>= w, p -= w), p < 15 && (c += z[n++] << p, p += 8, c += z[n++] << p, p += 8), b = _[c & v]; r: for (; ;) { if (c >>>= w = b >>> 24, p -= w, !(16 & (w = b >>> 16 & 255))) { if (0 == (64 & w)) { b = _[(65535 & b) + (c & (1 << w) - 1)]; continue r } e.msg = "invalid distance code", r.mode = 30; break e } if (k = 65535 & b, p < (w &= 15) && (c += z[n++] << p, (p += 8) < w && (c += z[n++] << p, p += 8)), u < (k += c & (1 << w) - 1)) { e.msg = "invalid distance too far back", r.mode = 30; break e } if (c >>>= w, p -= w, (w = s - a) < k) { if (f < (w = k - w) && r.sane) { e.msg = "invalid distance too far back", r.mode = 30; break e } if (S = d, (x = 0) === l) { if (x += h - w, w < y) { for (y -= w; E[s++] = d[x++], --w;); x = s - k, S = E; } } else if (l < w) { if (x += h + l - w, (w -= l) < y) { for (y -= w; E[s++] = d[x++], --w;); if (x = 0, l < y) { for (y -= w = l; E[s++] = d[x++], --w;); x = s - k, S = E; } } } else if (x += l - w, w < y) { for (y -= w; E[s++] = d[x++], --w;); x = s - k, S = E; } for (; 2 < y;)E[s++] = S[x++], E[s++] = S[x++], E[s++] = S[x++], y -= 3; y && (E[s++] = S[x++], 1 < y && (E[s++] = S[x++])); } else { for (x = s - k; E[s++] = E[x++], E[s++] = E[x++], E[s++] = E[x++], 2 < (y -= 3);); y && (E[s++] = E[x++], 1 < y && (E[s++] = E[x++])); } break } } break } } while (n < i && s < o); n -= y = p >> 3, c &= (1 << (p -= y << 3)) - 1, e.next_in = n, e.next_out = s, e.avail_in = n < i ? i - n + 5 : 5 - (n - i), e.avail_out = s < o ? o - s + 257 : 257 - (s - o), r.hold = c, r.bits = p; }; }, {}], 49: [function (e, t, r) { var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), T = e("./inffast"), R = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n = 852, i = 592; function L(e) { return (e >>> 24 & 255) + (e >>> 8 & 65280) + ((65280 & e) << 8) + ((255 & e) << 24) } function s() { this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0; } function a(e) { var t; return e && e.state ? (t = e.state, e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = 1 & t.wrap), t.mode = P, t.last = 0, t.havedict = 0, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new I.Buf32(n), t.distcode = t.distdyn = new I.Buf32(i), t.sane = 1, t.back = -1, N) : U } function o(e) { var t; return e && e.state ? ((t = e.state).wsize = 0, t.whave = 0, t.wnext = 0, a(e)) : U } function u(e, t) { var r, n; return e && e.state ? (n = e.state, t < 0 ? (r = 0, t = -t) : (r = 1 + (t >> 4), t < 48 && (t &= 15)), t && (t < 8 || 15 < t) ? U : (null !== n.window && n.wbits !== t && (n.window = null), n.wrap = r, n.wbits = t, o(e))) : U } function h(e, t) { var r, n; return e ? (n = new s, (e.state = n).window = null, (r = u(e, t)) !== N && (e.state = null), r) : U } var f, l, d = !0; function j(e) { if (d) { var t; for (f = new I.Buf32(512), l = new I.Buf32(32), t = 0; t < 144;)e.lens[t++] = 8; for (; t < 256;)e.lens[t++] = 9; for (; t < 280;)e.lens[t++] = 7; for (; t < 288;)e.lens[t++] = 8; for (R(D, e.lens, 0, 288, f, 0, e.work, { bits: 9 }), t = 0; t < 32;)e.lens[t++] = 5; R(F, e.lens, 0, 32, l, 0, e.work, { bits: 5 }), d = !1; } e.lencode = f, e.lenbits = 9, e.distcode = l, e.distbits = 5; } function Z(e, t, r, n) { var i, s = e.state; return null === s.window && (s.wsize = 1 << s.wbits, s.wnext = 0, s.whave = 0, s.window = new I.Buf8(s.wsize)), n >= s.wsize ? (I.arraySet(s.window, t, r - s.wsize, s.wsize, 0), s.wnext = 0, s.whave = s.wsize) : (n < (i = s.wsize - s.wnext) && (i = n), I.arraySet(s.window, t, r - n, i, s.wnext), (n -= i) ? (I.arraySet(s.window, t, r - n, n, 0), s.wnext = n, s.whave = s.wsize) : (s.wnext += i, s.wnext === s.wsize && (s.wnext = 0), s.whave < s.wsize && (s.whave += i))), 0 } r.inflateReset = o, r.inflateReset2 = u, r.inflateResetKeep = a, r.inflateInit = function (e) { return h(e, 15) }, r.inflateInit2 = h, r.inflate = function (e, t) { var r, n, i, s, a, o, u, h, f, l, d, c, p, m, _, g, v, b, w, y, k, x, S, z, E = 0, C = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]; if (!e || !e.state || !e.output || !e.input && 0 !== e.avail_in) return U; 12 === (r = e.state).mode && (r.mode = 13), a = e.next_out, i = e.output, u = e.avail_out, s = e.next_in, n = e.input, o = e.avail_in, h = r.hold, f = r.bits, l = o, d = u, x = N; e: for (; ;)switch (r.mode) { case P: if (0 === r.wrap) { r.mode = 13; break } for (; f < 16;) { if (0 === o) break e; o--, h += n[s++] << f, f += 8; } if (2 & r.wrap && 35615 === h) { C[r.check = 0] = 255 & h, C[1] = h >>> 8 & 255, r.check = B(r.check, C, 2, 0), f = h = 0, r.mode = 2; break } if (r.flags = 0, r.head && (r.head.done = !1), !(1 & r.wrap) || (((255 & h) << 8) + (h >> 8)) % 31) { e.msg = "incorrect header check", r.mode = 30; break } if (8 != (15 & h)) { e.msg = "unknown compression method", r.mode = 30; break } if (f -= 4, k = 8 + (15 & (h >>>= 4)), 0 === r.wbits) r.wbits = k; else if (k > r.wbits) { e.msg = "invalid window size", r.mode = 30; break } r.dmax = 1 << k, e.adler = r.check = 1, r.mode = 512 & h ? 10 : 12, f = h = 0; break; case 2: for (; f < 16;) { if (0 === o) break e; o--, h += n[s++] << f, f += 8; } if (r.flags = h, 8 != (255 & r.flags)) { e.msg = "unknown compression method", r.mode = 30; break } if (57344 & r.flags) { e.msg = "unknown header flags set", r.mode = 30; break } r.head && (r.head.text = h >> 8 & 1), 512 & r.flags && (C[0] = 255 & h, C[1] = h >>> 8 & 255, r.check = B(r.check, C, 2, 0)), f = h = 0, r.mode = 3; case 3: for (; f < 32;) { if (0 === o) break e; o--, h += n[s++] << f, f += 8; } r.head && (r.head.time = h), 512 & r.flags && (C[0] = 255 & h, C[1] = h >>> 8 & 255, C[2] = h >>> 16 & 255, C[3] = h >>> 24 & 255, r.check = B(r.check, C, 4, 0)), f = h = 0, r.mode = 4; case 4: for (; f < 16;) { if (0 === o) break e; o--, h += n[s++] << f, f += 8; } r.head && (r.head.xflags = 255 & h, r.head.os = h >> 8), 512 & r.flags && (C[0] = 255 & h, C[1] = h >>> 8 & 255, r.check = B(r.check, C, 2, 0)), f = h = 0, r.mode = 5; case 5: if (1024 & r.flags) { for (; f < 16;) { if (0 === o) break e; o--, h += n[s++] << f, f += 8; } r.length = h, r.head && (r.head.extra_len = h), 512 & r.flags && (C[0] = 255 & h, C[1] = h >>> 8 & 255, r.check = B(r.check, C, 2, 0)), f = h = 0; } else r.head && (r.head.extra = null); r.mode = 6; case 6: if (1024 & r.flags && (o < (c = r.length) && (c = o), c && (r.head && (k = r.head.extra_len - r.length, r.head.extra || (r.head.extra = new Array(r.head.extra_len)), I.arraySet(r.head.extra, n, s, c, k)), 512 & r.flags && (r.check = B(r.check, n, c, s)), o -= c, s += c, r.length -= c), r.length)) break e; r.length = 0, r.mode = 7; case 7: if (2048 & r.flags) { if (0 === o) break e; for (c = 0; k = n[s + c++], r.head && k && r.length < 65536 && (r.head.name += String.fromCharCode(k)), k && c < o;); if (512 & r.flags && (r.check = B(r.check, n, c, s)), o -= c, s += c, k) break e } else r.head && (r.head.name = null); r.length = 0, r.mode = 8; case 8: if (4096 & r.flags) { if (0 === o) break e; for (c = 0; k = n[s + c++], r.head && k && r.length < 65536 && (r.head.comment += String.fromCharCode(k)), k && c < o;); if (512 & r.flags && (r.check = B(r.check, n, c, s)), o -= c, s += c, k) break e } else r.head && (r.head.comment = null); r.mode = 9; case 9: if (512 & r.flags) { for (; f < 16;) { if (0 === o) break e; o--, h += n[s++] << f, f += 8; } if (h !== (65535 & r.check)) { e.msg = "header crc mismatch", r.mode = 30; break } f = h = 0; } r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = !0), e.adler = r.check = 0, r.mode = 12; break; case 10: for (; f < 32;) { if (0 === o) break e; o--, h += n[s++] << f, f += 8; } e.adler = r.check = L(h), f = h = 0, r.mode = 11; case 11: if (0 === r.havedict) return e.next_out = a, e.avail_out = u, e.next_in = s, e.avail_in = o, r.hold = h, r.bits = f, 2; e.adler = r.check = 1, r.mode = 12; case 12: if (5 === t || 6 === t) break e; case 13: if (r.last) { h >>>= 7 & f, f -= 7 & f, r.mode = 27; break } for (; f < 3;) { if (0 === o) break e; o--, h += n[s++] << f, f += 8; } switch (r.last = 1 & h, f -= 1, 3 & (h >>>= 1)) { case 0: r.mode = 14; break; case 1: if (j(r), r.mode = 20, 6 !== t) break; h >>>= 2, f -= 2; break e; case 2: r.mode = 17; break; case 3: e.msg = "invalid block type", r.mode = 30; }h >>>= 2, f -= 2; break; case 14: for (h >>>= 7 & f, f -= 7 & f; f < 32;) { if (0 === o) break e; o--, h += n[s++] << f, f += 8; } if ((65535 & h) != (h >>> 16 ^ 65535)) { e.msg = "invalid stored block lengths", r.mode = 30; break } if (r.length = 65535 & h, f = h = 0, r.mode = 15, 6 === t) break e; case 15: r.mode = 16; case 16: if (c = r.length) { if (o < c && (c = o), u < c && (c = u), 0 === c) break e; I.arraySet(i, n, s, c, a), o -= c, s += c, u -= c, a += c, r.length -= c; break } r.mode = 12; break; case 17: for (; f < 14;) { if (0 === o) break e; o--, h += n[s++] << f, f += 8; } if (r.nlen = 257 + (31 & h), h >>>= 5, f -= 5, r.ndist = 1 + (31 & h), h >>>= 5, f -= 5, r.ncode = 4 + (15 & h), h >>>= 4, f -= 4, 286 < r.nlen || 30 < r.ndist) { e.msg = "too many length or distance symbols", r.mode = 30; break } r.have = 0, r.mode = 18; case 18: for (; r.have < r.ncode;) { for (; f < 3;) { if (0 === o) break e; o--, h += n[s++] << f, f += 8; } r.lens[A[r.have++]] = 7 & h, h >>>= 3, f -= 3; } for (; r.have < 19;)r.lens[A[r.have++]] = 0; if (r.lencode = r.lendyn, r.lenbits = 7, S = { bits: r.lenbits }, x = R(0, r.lens, 0, 19, r.lencode, 0, r.work, S), r.lenbits = S.bits, x) { e.msg = "invalid code lengths set", r.mode = 30; break } r.have = 0, r.mode = 19; case 19: for (; r.have < r.nlen + r.ndist;) { for (; g = (E = r.lencode[h & (1 << r.lenbits) - 1]) >>> 16 & 255, v = 65535 & E, !((_ = E >>> 24) <= f);) { if (0 === o) break e; o--, h += n[s++] << f, f += 8; } if (v < 16) h >>>= _, f -= _, r.lens[r.have++] = v; else { if (16 === v) { for (z = _ + 2; f < z;) { if (0 === o) break e; o--, h += n[s++] << f, f += 8; } if (h >>>= _, f -= _, 0 === r.have) { e.msg = "invalid bit length repeat", r.mode = 30; break } k = r.lens[r.have - 1], c = 3 + (3 & h), h >>>= 2, f -= 2; } else if (17 === v) { for (z = _ + 3; f < z;) { if (0 === o) break e; o--, h += n[s++] << f, f += 8; } f -= _, k = 0, c = 3 + (7 & (h >>>= _)), h >>>= 3, f -= 3; } else { for (z = _ + 7; f < z;) { if (0 === o) break e; o--, h += n[s++] << f, f += 8; } f -= _, k = 0, c = 11 + (127 & (h >>>= _)), h >>>= 7, f -= 7; } if (r.have + c > r.nlen + r.ndist) { e.msg = "invalid bit length repeat", r.mode = 30; break } for (; c--;)r.lens[r.have++] = k; } } if (30 === r.mode) break; if (0 === r.lens[256]) { e.msg = "invalid code -- missing end-of-block", r.mode = 30; break } if (r.lenbits = 9, S = { bits: r.lenbits }, x = R(D, r.lens, 0, r.nlen, r.lencode, 0, r.work, S), r.lenbits = S.bits, x) { e.msg = "invalid literal/lengths set", r.mode = 30; break } if (r.distbits = 6, r.distcode = r.distdyn, S = { bits: r.distbits }, x = R(F, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, S), r.distbits = S.bits, x) { e.msg = "invalid distances set", r.mode = 30; break } if (r.mode = 20, 6 === t) break e; case 20: r.mode = 21; case 21: if (6 <= o && 258 <= u) { e.next_out = a, e.avail_out = u, e.next_in = s, e.avail_in = o, r.hold = h, r.bits = f, T(e, d), a = e.next_out, i = e.output, u = e.avail_out, s = e.next_in, n = e.input, o = e.avail_in, h = r.hold, f = r.bits, 12 === r.mode && (r.back = -1); break } for (r.back = 0; g = (E = r.lencode[h & (1 << r.lenbits) - 1]) >>> 16 & 255, v = 65535 & E, !((_ = E >>> 24) <= f);) { if (0 === o) break e; o--, h += n[s++] << f, f += 8; } if (g && 0 == (240 & g)) { for (b = _, w = g, y = v; g = (E = r.lencode[y + ((h & (1 << b + w) - 1) >> b)]) >>> 16 & 255, v = 65535 & E, !(b + (_ = E >>> 24) <= f);) { if (0 === o) break e; o--, h += n[s++] << f, f += 8; } h >>>= b, f -= b, r.back += b; } if (h >>>= _, f -= _, r.back += _, r.length = v, 0 === g) { r.mode = 26; break } if (32 & g) { r.back = -1, r.mode = 12; break } if (64 & g) { e.msg = "invalid literal/length code", r.mode = 30; break } r.extra = 15 & g, r.mode = 22; case 22: if (r.extra) { for (z = r.extra; f < z;) { if (0 === o) break e; o--, h += n[s++] << f, f += 8; } r.length += h & (1 << r.extra) - 1, h >>>= r.extra, f -= r.extra, r.back += r.extra; } r.was = r.length, r.mode = 23; case 23: for (; g = (E = r.distcode[h & (1 << r.distbits) - 1]) >>> 16 & 255, v = 65535 & E, !((_ = E >>> 24) <= f);) { if (0 === o) break e; o--, h += n[s++] << f, f += 8; } if (0 == (240 & g)) { for (b = _, w = g, y = v; g = (E = r.distcode[y + ((h & (1 << b + w) - 1) >> b)]) >>> 16 & 255, v = 65535 & E, !(b + (_ = E >>> 24) <= f);) { if (0 === o) break e; o--, h += n[s++] << f, f += 8; } h >>>= b, f -= b, r.back += b; } if (h >>>= _, f -= _, r.back += _, 64 & g) { e.msg = "invalid distance code", r.mode = 30; break } r.offset = v, r.extra = 15 & g, r.mode = 24; case 24: if (r.extra) { for (z = r.extra; f < z;) { if (0 === o) break e; o--, h += n[s++] << f, f += 8; } r.offset += h & (1 << r.extra) - 1, h >>>= r.extra, f -= r.extra, r.back += r.extra; } if (r.offset > r.dmax) { e.msg = "invalid distance too far back", r.mode = 30; break } r.mode = 25; case 25: if (0 === u) break e; if (c = d - u, r.offset > c) { if ((c = r.offset - c) > r.whave && r.sane) { e.msg = "invalid distance too far back", r.mode = 30; break } p = c > r.wnext ? (c -= r.wnext, r.wsize - c) : r.wnext - c, c > r.length && (c = r.length), m = r.window; } else m = i, p = a - r.offset, c = r.length; for (u < c && (c = u), u -= c, r.length -= c; i[a++] = m[p++], --c;); 0 === r.length && (r.mode = 21); break; case 26: if (0 === u) break e; i[a++] = r.length, u--, r.mode = 21; break; case 27: if (r.wrap) { for (; f < 32;) { if (0 === o) break e; o--, h |= n[s++] << f, f += 8; } if (d -= u, e.total_out += d, r.total += d, d && (e.adler = r.check = r.flags ? B(r.check, i, d, a - d) : O(r.check, i, d, a - d)), d = u, (r.flags ? h : L(h)) !== r.check) { e.msg = "incorrect data check", r.mode = 30; break } f = h = 0; } r.mode = 28; case 28: if (r.wrap && r.flags) { for (; f < 32;) { if (0 === o) break e; o--, h += n[s++] << f, f += 8; } if (h !== (4294967295 & r.total)) { e.msg = "incorrect length check", r.mode = 30; break } f = h = 0; } r.mode = 29; case 29: x = 1; break e; case 30: x = -3; break e; case 31: return -4; case 32: default: return U }return e.next_out = a, e.avail_out = u, e.next_in = s, e.avail_in = o, r.hold = h, r.bits = f, (r.wsize || d !== e.avail_out && r.mode < 30 && (r.mode < 27 || 4 !== t)) && Z(e, e.output, e.next_out, d - e.avail_out) ? (r.mode = 31, -4) : (l -= e.avail_in, d -= e.avail_out, e.total_in += l, e.total_out += d, r.total += d, r.wrap && d && (e.adler = r.check = r.flags ? B(r.check, i, d, e.next_out - d) : O(r.check, i, d, e.next_out - d)), e.data_type = r.bits + (r.last ? 64 : 0) + (12 === r.mode ? 128 : 0) + (20 === r.mode || 15 === r.mode ? 256 : 0), (0 == l && 0 === d || 4 === t) && x === N && (x = -5), x) }, r.inflateEnd = function (e) { if (!e || !e.state) return U; var t = e.state; return t.window && (t.window = null), e.state = null, N }, r.inflateGetHeader = function (e, t) { var r; return e && e.state ? 0 == (2 & (r = e.state).wrap) ? U : ((r.head = t).done = !1, N) : U }, r.inflateSetDictionary = function (e, t) { var r, n = t.length; return e && e.state ? 0 !== (r = e.state).wrap && 11 !== r.mode ? U : 11 === r.mode && O(1, t, n, 0) !== r.check ? -3 : Z(e, t, n, n) ? (r.mode = 31, -4) : (r.havedict = 1, N) : U }, r.inflateInfo = "pako inflate (from Nodeca project)"; }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function (e, t, r) { var D = e("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]; t.exports = function (e, t, r, n, i, s, a, o) { var u, h, f, l, d, c, p, m, _, g = o.bits, v = 0, b = 0, w = 0, y = 0, k = 0, x = 0, S = 0, z = 0, E = 0, C = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), T = null, R = 0; for (v = 0; v <= 15; v++)O[v] = 0; for (b = 0; b < n; b++)O[t[r + b]]++; for (k = g, y = 15; 1 <= y && 0 === O[y]; y--); if (y < k && (k = y), 0 === y) return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0; for (w = 1; w < y && 0 === O[w]; w++); for (k < w && (k = w), v = z = 1; v <= 15; v++)if (z <<= 1, (z -= O[v]) < 0) return -1; if (0 < z && (0 === e || 1 !== y)) return -1; for (B[1] = 0, v = 1; v < 15; v++)B[v + 1] = B[v] + O[v]; for (b = 0; b < n; b++)0 !== t[r + b] && (a[B[t[r + b]]++] = b); if (c = 0 === e ? (A = T = a, 19) : 1 === e ? (A = F, I -= 257, T = N, R -= 257, 256) : (A = U, T = P, -1), v = w, d = s, S = b = C = 0, f = -1, l = (E = 1 << (x = k)) - 1, 1 === e && 852 < E || 2 === e && 592 < E) return 1; for (; ;) { for (p = v - S, _ = a[b] < c ? (m = 0, a[b]) : a[b] > c ? (m = T[R + a[b]], A[I + a[b]]) : (m = 96, 0), u = 1 << v - S, w = h = 1 << x; i[d + (C >> S) + (h -= u)] = p << 24 | m << 16 | _ | 0, 0 !== h;); for (u = 1 << v - 1; C & u;)u >>= 1; if (0 !== u ? (C &= u - 1, C += u) : C = 0, b++, 0 == --O[v]) { if (v === y) break; v = t[r + a[b]]; } if (k < v && (C & l) !== f) { for (0 === S && (S = k), d += w, z = 1 << (x = v - S); x + S < y && !((z -= O[x + S]) <= 0);)x++, z <<= 1; if (E += 1 << x, 1 === e && 852 < E || 2 === e && 592 < E) return 1; i[f = C & l] = k << 24 | x << 16 | d - s | 0; } } return 0 !== C && (i[d + C] = v - S << 24 | 64 << 16 | 0), o.bits = k, 0 }; }, { "../utils/common": 41 }], 51: [function (e, t, r) { t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" }; }, {}], 52: [function (e, t, r) { var o = e("../utils/common"); function n(e) { for (var t = e.length; 0 <= --t;)e[t] = 0; } var _ = 15, i = 16, u = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], h = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], f = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], l = new Array(576); n(l); var d = new Array(60); n(d); var c = new Array(512); n(c); var p = new Array(256); n(p); var m = new Array(29); n(m); var g, v, b, w = new Array(30); function y(e, t, r, n, i) { this.static_tree = e, this.extra_bits = t, this.extra_base = r, this.elems = n, this.max_length = i, this.has_stree = e && e.length; } function s(e, t) { this.dyn_tree = e, this.max_code = 0, this.stat_desc = t; } function k(e) { return e < 256 ? c[e] : c[256 + (e >>> 7)] } function x(e, t) { e.pending_buf[e.pending++] = 255 & t, e.pending_buf[e.pending++] = t >>> 8 & 255; } function S(e, t, r) { e.bi_valid > i - r ? (e.bi_buf |= t << e.bi_valid & 65535, x(e, e.bi_buf), e.bi_buf = t >> i - e.bi_valid, e.bi_valid += r - i) : (e.bi_buf |= t << e.bi_valid & 65535, e.bi_valid += r); } function z(e, t, r) { S(e, r[2 * t], r[2 * t + 1]); } function E(e, t) { for (var r = 0; r |= 1 & e, e >>>= 1, r <<= 1, 0 < --t;); return r >>> 1 } function C(e, t, r) { var n, i, s = new Array(_ + 1), a = 0; for (n = 1; n <= _; n++)s[n] = a = a + r[n - 1] << 1; for (i = 0; i <= t; i++) { var o = e[2 * i + 1]; 0 !== o && (e[2 * i] = E(s[o]++, o)); } } function A(e) { var t; for (t = 0; t < 286; t++)e.dyn_ltree[2 * t] = 0; for (t = 0; t < 30; t++)e.dyn_dtree[2 * t] = 0; for (t = 0; t < 19; t++)e.bl_tree[2 * t] = 0; e.dyn_ltree[512] = 1, e.opt_len = e.static_len = 0, e.last_lit = e.matches = 0; } function I(e) { 8 < e.bi_valid ? x(e, e.bi_buf) : 0 < e.bi_valid && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0; } function O(e, t, r, n) { var i = 2 * t, s = 2 * r; return e[i] < e[s] || e[i] === e[s] && n[t] <= n[r] } function B(e, t, r) { for (var n = e.heap[r], i = r << 1; i <= e.heap_len && (i < e.heap_len && O(t, e.heap[i + 1], e.heap[i], e.depth) && i++, !O(t, n, e.heap[i], e.depth));)e.heap[r] = e.heap[i], r = i, i <<= 1; e.heap[r] = n; } function T(e, t, r) { var n, i, s, a, o = 0; if (0 !== e.last_lit) for (; n = e.pending_buf[e.d_buf + 2 * o] << 8 | e.pending_buf[e.d_buf + 2 * o + 1], i = e.pending_buf[e.l_buf + o], o++, 0 === n ? z(e, i, t) : (z(e, (s = p[i]) + 256 + 1, t), 0 !== (a = u[s]) && S(e, i -= m[s], a), z(e, s = k(--n), r), 0 !== (a = h[s]) && S(e, n -= w[s], a)), o < e.last_lit;); z(e, 256, t); } function R(e, t) { var r, n, i, s = t.dyn_tree, a = t.stat_desc.static_tree, o = t.stat_desc.has_stree, u = t.stat_desc.elems, h = -1; for (e.heap_len = 0, e.heap_max = 573, r = 0; r < u; r++)0 !== s[2 * r] ? (e.heap[++e.heap_len] = h = r, e.depth[r] = 0) : s[2 * r + 1] = 0; for (; e.heap_len < 2;)s[2 * (i = e.heap[++e.heap_len] = h < 2 ? ++h : 0)] = 1, e.depth[i] = 0, e.opt_len--, o && (e.static_len -= a[2 * i + 1]); for (t.max_code = h, r = e.heap_len >> 1; 1 <= r; r--)B(e, s, r); for (i = u; r = e.heap[1], e.heap[1] = e.heap[e.heap_len--], B(e, s, 1), n = e.heap[1], e.heap[--e.heap_max] = r, e.heap[--e.heap_max] = n, s[2 * i] = s[2 * r] + s[2 * n], e.depth[i] = (e.depth[r] >= e.depth[n] ? e.depth[r] : e.depth[n]) + 1, s[2 * r + 1] = s[2 * n + 1] = i, e.heap[1] = i++, B(e, s, 1), 2 <= e.heap_len;); e.heap[--e.heap_max] = e.heap[1], function (e, t) { var r, n, i, s, a, o, u = t.dyn_tree, h = t.max_code, f = t.stat_desc.static_tree, l = t.stat_desc.has_stree, d = t.stat_desc.extra_bits, c = t.stat_desc.extra_base, p = t.stat_desc.max_length, m = 0; for (s = 0; s <= _; s++)e.bl_count[s] = 0; for (u[2 * e.heap[e.heap_max] + 1] = 0, r = e.heap_max + 1; r < 573; r++)p < (s = u[2 * u[2 * (n = e.heap[r]) + 1] + 1] + 1) && (s = p, m++), u[2 * n + 1] = s, h < n || (e.bl_count[s]++, a = 0, c <= n && (a = d[n - c]), o = u[2 * n], e.opt_len += o * (s + a), l && (e.static_len += o * (f[2 * n + 1] + a))); if (0 !== m) { do { for (s = p - 1; 0 === e.bl_count[s];)s--; e.bl_count[s]--, e.bl_count[s + 1] += 2, e.bl_count[p]--, m -= 2; } while (0 < m); for (s = p; 0 !== s; s--)for (n = e.bl_count[s]; 0 !== n;)h < (i = e.heap[--r]) || (u[2 * i + 1] !== s && (e.opt_len += (s - u[2 * i + 1]) * u[2 * i], u[2 * i + 1] = s), n--); } }(e, t), C(s, h, e.bl_count); } function D(e, t, r) { var n, i, s = -1, a = t[1], o = 0, u = 7, h = 4; for (0 === a && (u = 138, h = 3), t[2 * (r + 1) + 1] = 65535, n = 0; n <= r; n++)i = a, a = t[2 * (n + 1) + 1], ++o < u && i === a || (o < h ? e.bl_tree[2 * i] += o : 0 !== i ? (i !== s && e.bl_tree[2 * i]++, e.bl_tree[32]++) : o <= 10 ? e.bl_tree[34]++ : e.bl_tree[36]++, s = i, h = (o = 0) === a ? (u = 138, 3) : i === a ? (u = 6, 3) : (u = 7, 4)); } function F(e, t, r) { var n, i, s = -1, a = t[1], o = 0, u = 7, h = 4; for (0 === a && (u = 138, h = 3), n = 0; n <= r; n++)if (i = a, a = t[2 * (n + 1) + 1], !(++o < u && i === a)) { if (o < h) for (; z(e, i, e.bl_tree), 0 != --o;); else 0 !== i ? (i !== s && (z(e, i, e.bl_tree), o--), z(e, 16, e.bl_tree), S(e, o - 3, 2)) : o <= 10 ? (z(e, 17, e.bl_tree), S(e, o - 3, 3)) : (z(e, 18, e.bl_tree), S(e, o - 11, 7)); s = i, h = (o = 0) === a ? (u = 138, 3) : i === a ? (u = 6, 3) : (u = 7, 4); } } n(w); var N = !1; function U(e, t, r, n) { var i, s, a; S(e, 0 + (n ? 1 : 0), 3), s = t, a = r, I(i = e), x(i, a), x(i, ~a), o.arraySet(i.pending_buf, i.window, s, a, i.pending), i.pending += a; } r._tr_init = function (e) { N || (function () { var e, t, r, n, i, s = new Array(_ + 1); for (n = r = 0; n < 28; n++)for (m[n] = r, e = 0; e < 1 << u[n]; e++)p[r++] = n; for (p[r - 1] = n, n = i = 0; n < 16; n++)for (w[n] = i, e = 0; e < 1 << h[n]; e++)c[i++] = n; for (i >>= 7; n < 30; n++)for (w[n] = i << 7, e = 0; e < 1 << h[n] - 7; e++)c[256 + i++] = n; for (t = 0; t <= _; t++)s[t] = 0; for (e = 0; e <= 143;)l[2 * e + 1] = 8, e++, s[8]++; for (; e <= 255;)l[2 * e + 1] = 9, e++, s[9]++; for (; e <= 279;)l[2 * e + 1] = 7, e++, s[7]++; for (; e <= 287;)l[2 * e + 1] = 8, e++, s[8]++; for (C(l, 287, s), e = 0; e < 30; e++)d[2 * e + 1] = 5, d[2 * e] = E(e, 5); g = new y(l, u, 257, 286, _), v = new y(d, h, 0, 30, _), b = new y(new Array(0), a, 0, 19, 7); }(), N = !0), e.l_desc = new s(e.dyn_ltree, g), e.d_desc = new s(e.dyn_dtree, v), e.bl_desc = new s(e.bl_tree, b), e.bi_buf = 0, e.bi_valid = 0, A(e); }, r._tr_stored_block = U, r._tr_flush_block = function (e, t, r, n) { var i, s, a = 0; 0 < e.level ? (2 === e.strm.data_type && (e.strm.data_type = function (e) { var t, r = 4093624447; for (t = 0; t <= 31; t++, r >>>= 1)if (1 & r && 0 !== e.dyn_ltree[2 * t]) return 0; if (0 !== e.dyn_ltree[18] || 0 !== e.dyn_ltree[20] || 0 !== e.dyn_ltree[26]) return 1; for (t = 32; t < 256; t++)if (0 !== e.dyn_ltree[2 * t]) return 1; return 0 }(e)), R(e, e.l_desc), R(e, e.d_desc), a = function (e) { var t; for (D(e, e.dyn_ltree, e.l_desc.max_code), D(e, e.dyn_dtree, e.d_desc.max_code), R(e, e.bl_desc), t = 18; 3 <= t && 0 === e.bl_tree[2 * f[t] + 1]; t--); return e.opt_len += 3 * (t + 1) + 5 + 5 + 4, t }(e), i = e.opt_len + 3 + 7 >>> 3, (s = e.static_len + 3 + 7 >>> 3) <= i && (i = s)) : i = s = r + 5, r + 4 <= i && -1 !== t ? U(e, t, r, n) : 4 === e.strategy || s === i ? (S(e, 2 + (n ? 1 : 0), 3), T(e, l, d)) : (S(e, 4 + (n ? 1 : 0), 3), function (e, t, r, n) { var i; for (S(e, t - 257, 5), S(e, r - 1, 5), S(e, n - 4, 4), i = 0; i < n; i++)S(e, e.bl_tree[2 * f[i] + 1], 3); F(e, e.dyn_ltree, t - 1), F(e, e.dyn_dtree, r - 1); }(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, a + 1), T(e, e.dyn_ltree, e.dyn_dtree)), A(e), n && I(e); }, r._tr_tally = function (e, t, r) { return e.pending_buf[e.d_buf + 2 * e.last_lit] = t >>> 8 & 255, e.pending_buf[e.d_buf + 2 * e.last_lit + 1] = 255 & t, e.pending_buf[e.l_buf + e.last_lit] = 255 & r, e.last_lit++, 0 === t ? e.dyn_ltree[2 * r]++ : (e.matches++, t--, e.dyn_ltree[2 * (p[r] + 256 + 1)]++, e.dyn_dtree[2 * k(t)]++), e.last_lit === e.lit_bufsize - 1 }, r._tr_align = function (e) { var t; S(e, 2, 3), z(e, 256, l), 16 === (t = e).bi_valid ? (x(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : 8 <= t.bi_valid && (t.pending_buf[t.pending++] = 255 & t.bi_buf, t.bi_buf >>= 8, t.bi_valid -= 8); }; }, { "../utils/common": 41 }], 53: [function (e, t, r) { t.exports = function () { this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0; }; }, {}], 54: [function (e, t, r) { t.exports = "function" == typeof setImmediate ? setImmediate : function () { var e = [].slice.apply(arguments); e.splice(1, 0, 0), setTimeout.apply(null, e); }; }, {}] }, {}, [10])(10) }); }).call(this, void 0 !== r ? r : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}); }, {}] }, {}, [1])(1) }); }).call(this, void 0 !== r ? r : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}); }, {}] }, {}, [1])(1) }); }).call(this, void 0 !== r ? r : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}); }, {}] }, {}, [1])(1) }); }).call(this, void 0 !== r ? r : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}); }, {}] }, {}, [1])(1) }); }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}); }, {}] }, {}, [1])(1) });
						}).call(this);
					}).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require("buffer").Buffer, require("timers").setImmediate);
				}, { "buffer": 8, "timers": 22 }], 12: [function (require, module, exports) {
					var immediate = require('immediate');

					/* istanbul ignore next */
					function INTERNAL() { }

					var handlers = {};

					var REJECTED = ['REJECTED'];
					var FULFILLED = ['FULFILLED'];
					var PENDING = ['PENDING'];

					module.exports = Promise;

					function Promise(resolver) {
						if (typeof resolver !== 'function') {
							throw new TypeError('resolver must be a function');
						}
						this.state = PENDING;
						this.queue = [];
						this.outcome = void 0;
						if (resolver !== INTERNAL) {
							safelyResolveThenable(this, resolver);
						}
					}

					Promise.prototype["finally"] = function (callback) {
						if (typeof callback !== 'function') {
							return this;
						}
						var p = this.constructor;
						return this.then(resolve, reject);

						function resolve(value) {
							function yes() {
								return value;
							}
							return p.resolve(callback()).then(yes);
						}
						function reject(reason) {
							function no() {
								throw reason;
							}
							return p.resolve(callback()).then(no);
						}
					};
					Promise.prototype["catch"] = function (onRejected) {
						return this.then(null, onRejected);
					};
					Promise.prototype.then = function (onFulfilled, onRejected) {
						if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
							typeof onRejected !== 'function' && this.state === REJECTED) {
							return this;
						}
						var promise = new this.constructor(INTERNAL);
						if (this.state !== PENDING) {
							var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
							unwrap(promise, resolver, this.outcome);
						} else {
							this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
						}

						return promise;
					};
					function QueueItem(promise, onFulfilled, onRejected) {
						this.promise = promise;
						if (typeof onFulfilled === 'function') {
							this.onFulfilled = onFulfilled;
							this.callFulfilled = this.otherCallFulfilled;
						}
						if (typeof onRejected === 'function') {
							this.onRejected = onRejected;
							this.callRejected = this.otherCallRejected;
						}
					}
					QueueItem.prototype.callFulfilled = function (value) {
						handlers.resolve(this.promise, value);
					};
					QueueItem.prototype.otherCallFulfilled = function (value) {
						unwrap(this.promise, this.onFulfilled, value);
					};
					QueueItem.prototype.callRejected = function (value) {
						handlers.reject(this.promise, value);
					};
					QueueItem.prototype.otherCallRejected = function (value) {
						unwrap(this.promise, this.onRejected, value);
					};

					function unwrap(promise, func, value) {
						immediate(function () {
							var returnValue;
							try {
								returnValue = func(value);
							} catch (e) {
								return handlers.reject(promise, e);
							}
							if (returnValue === promise) {
								handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
							} else {
								handlers.resolve(promise, returnValue);
							}
						});
					}

					handlers.resolve = function (self, value) {
						var result = tryCatch(getThen, value);
						if (result.status === 'error') {
							return handlers.reject(self, result.value);
						}
						var thenable = result.value;

						if (thenable) {
							safelyResolveThenable(self, thenable);
						} else {
							self.state = FULFILLED;
							self.outcome = value;
							var i = -1;
							var len = self.queue.length;
							while (++i < len) {
								self.queue[i].callFulfilled(value);
							}
						}
						return self;
					};
					handlers.reject = function (self, error) {
						self.state = REJECTED;
						self.outcome = error;
						var i = -1;
						var len = self.queue.length;
						while (++i < len) {
							self.queue[i].callRejected(error);
						}
						return self;
					};

					function getThen(obj) {
						// Make sure we only access the accessor once as required by the spec
						var then = obj && obj.then;
						if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
							return function appyThen() {
								then.apply(obj, arguments);
							};
						}
					}

					function safelyResolveThenable(self, thenable) {
						// Either fulfill, reject or reject with error
						var called = false;
						function onError(value) {
							if (called) {
								return;
							}
							called = true;
							handlers.reject(self, value);
						}

						function onSuccess(value) {
							if (called) {
								return;
							}
							called = true;
							handlers.resolve(self, value);
						}

						function tryToUnwrap() {
							thenable(onSuccess, onError);
						}

						var result = tryCatch(tryToUnwrap);
						if (result.status === 'error') {
							onError(result.value);
						}
					}

					function tryCatch(func, value) {
						var out = {};
						try {
							out.value = func(value);
							out.status = 'success';
						} catch (e) {
							out.status = 'error';
							out.value = e;
						}
						return out;
					}

					Promise.resolve = resolve;
					function resolve(value) {
						if (value instanceof this) {
							return value;
						}
						return handlers.resolve(new this(INTERNAL), value);
					}

					Promise.reject = reject;
					function reject(reason) {
						var promise = new this(INTERNAL);
						return handlers.reject(promise, reason);
					}

					Promise.all = all;
					function all(iterable) {
						var self = this;
						if (Object.prototype.toString.call(iterable) !== '[object Array]') {
							return this.reject(new TypeError('must be an array'));
						}

						var len = iterable.length;
						var called = false;
						if (!len) {
							return this.resolve([]);
						}

						var values = new Array(len);
						var resolved = 0;
						var i = -1;
						var promise = new this(INTERNAL);

						while (++i < len) {
							allResolver(iterable[i], i);
						}
						return promise;
						function allResolver(value, i) {
							self.resolve(value).then(resolveFromAll, function (error) {
								if (!called) {
									called = true;
									handlers.reject(promise, error);
								}
							});
							function resolveFromAll(outValue) {
								values[i] = outValue;
								if (++resolved === len && !called) {
									called = true;
									handlers.resolve(promise, values);
								}
							}
						}
					}

					Promise.race = race;
					function race(iterable) {
						var self = this;
						if (Object.prototype.toString.call(iterable) !== '[object Array]') {
							return this.reject(new TypeError('must be an array'));
						}

						var len = iterable.length;
						var called = false;
						if (!len) {
							return this.resolve([]);
						}

						var i = -1;
						var promise = new this(INTERNAL);

						while (++i < len) {
							resolver(iterable[i]);
						}
						return promise;
						function resolver(value) {
							self.resolve(value).then(function (response) {
								if (!called) {
									called = true;
									handlers.resolve(promise, response);
								}
							}, function (error) {
								if (!called) {
									called = true;
									handlers.reject(promise, error);
								}
							});
						}
					}

				}, { "immediate": 10 }], 13: [function (require, module, exports) {
					(function () { // closure for web browsers

						if (typeof module === 'object' && module.exports) {
							module.exports = LRUCache;
						} else {
							// just set the global for non-node platforms.
							this.LRUCache = LRUCache;
						}

						function hOP(obj, key) {
							return Object.prototype.hasOwnProperty.call(obj, key)
						}

						function naiveLength() { return 1 }

						var didTypeWarning = false;
						function typeCheckKey(key) {
							if (!didTypeWarning && typeof key !== 'string' && typeof key !== 'number') {
								didTypeWarning = true;
								console.error(new TypeError("LRU: key must be a string or number. Almost certainly a bug! " + typeof key).stack);
							}
						}

						function LRUCache(options) {
							if (!(this instanceof LRUCache))
								return new LRUCache(options)

							if (typeof options === 'number')
								options = { max: options };

							if (!options)
								options = {};

							this._max = options.max;
							// Kind of weird to have a default max of Infinity, but oh well.
							if (!this._max || !(typeof this._max === "number") || this._max <= 0)
								this._max = Infinity;

							this._lengthCalculator = options.length || naiveLength;
							if (typeof this._lengthCalculator !== "function")
								this._lengthCalculator = naiveLength;

							this._allowStale = options.stale || false;
							this._maxAge = options.maxAge || null;
							this._dispose = options.dispose;
							this.reset();
						}

						// resize the cache when the max changes.
						Object.defineProperty(LRUCache.prototype, "max",
							{
								set: function (mL) {
									if (!mL || !(typeof mL === "number") || mL <= 0) mL = Infinity;
									this._max = mL;
									if (this._length > this._max) trim(this);
								}
								, get: function () { return this._max }
								, enumerable: true
							});

						// resize the cache when the lengthCalculator changes.
						Object.defineProperty(LRUCache.prototype, "lengthCalculator",
							{
								set: function (lC) {
									if (typeof lC !== "function") {
										this._lengthCalculator = naiveLength;
										this._length = this._itemCount;
										for (var key in this._cache) {
											this._cache[key].length = 1;
										}
									} else {
										this._lengthCalculator = lC;
										this._length = 0;
										for (var key in this._cache) {
											this._cache[key].length = this._lengthCalculator(this._cache[key].value);
											this._length += this._cache[key].length;
										}
									}

									if (this._length > this._max) trim(this);
								}
								, get: function () { return this._lengthCalculator }
								, enumerable: true
							});

						Object.defineProperty(LRUCache.prototype, "length",
							{
								get: function () { return this._length }
								, enumerable: true
							});


						Object.defineProperty(LRUCache.prototype, "itemCount",
							{
								get: function () { return this._itemCount }
								, enumerable: true
							});

						LRUCache.prototype.forEach = function (fn, thisp) {
							thisp = thisp || this;
							var i = 0;
							var itemCount = this._itemCount;

							for (var k = this._mru - 1; k >= 0 && i < itemCount; k--) if (this._lruList[k]) {
								i++;
								var hit = this._lruList[k];
								if (isStale(this, hit)) {
									del(this, hit);
									if (!this._allowStale) hit = undefined;
								}
								if (hit) {
									fn.call(thisp, hit.value, hit.key, this);
								}
							}
						};

						LRUCache.prototype.keys = function () {
							var keys = new Array(this._itemCount);
							var i = 0;
							for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
								var hit = this._lruList[k];
								keys[i++] = hit.key;
							}
							return keys
						};

						LRUCache.prototype.values = function () {
							var values = new Array(this._itemCount);
							var i = 0;
							for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
								var hit = this._lruList[k];
								values[i++] = hit.value;
							}
							return values
						};

						LRUCache.prototype.reset = function () {
							if (this._dispose && this._cache) {
								for (var k in this._cache) {
									this._dispose(k, this._cache[k].value);
								}
							}

							this._cache = Object.create(null); // hash of items by key
							this._lruList = Object.create(null); // list of items in order of use recency
							this._mru = 0; // most recently used
							this._lru = 0; // least recently used
							this._length = 0; // number of items in the list
							this._itemCount = 0;
						};

						LRUCache.prototype.dump = function () {
							var arr = [];
							var i = 0;

							for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
								var hit = this._lruList[k];
								if (!isStale(this, hit)) {
									//Do not store staled hits
									++i;
									arr.push({
										k: hit.key,
										v: hit.value,
										e: hit.now + (hit.maxAge || 0)
									});
								}
							}
							//arr has the most read first
							return arr
						};

						LRUCache.prototype.dumpLru = function () {
							return this._lruList
						};

						LRUCache.prototype.set = function (key, value, maxAge) {
							maxAge = maxAge || this._maxAge;
							typeCheckKey(key);

							var now = maxAge ? Date.now() : 0;
							var len = this._lengthCalculator(value);

							if (hOP(this._cache, key)) {
								if (len > this._max) {
									del(this, this._cache[key]);
									return false
								}
								// dispose of the old one before overwriting
								if (this._dispose)
									this._dispose(key, this._cache[key].value);

								this._cache[key].now = now;
								this._cache[key].maxAge = maxAge;
								this._cache[key].value = value;
								this._length += (len - this._cache[key].length);
								this._cache[key].length = len;
								this.get(key);

								if (this._length > this._max)
									trim(this);

								return true
							}

							var hit = new Entry(key, value, this._mru++, len, now, maxAge);

							// oversized objects fall out of cache automatically.
							if (hit.length > this._max) {
								if (this._dispose) this._dispose(key, value);
								return false
							}

							this._length += hit.length;
							this._lruList[hit.lu] = this._cache[key] = hit;
							this._itemCount++;

							if (this._length > this._max)
								trim(this);

							return true
						};

						LRUCache.prototype.has = function (key) {
							typeCheckKey(key);
							if (!hOP(this._cache, key)) return false
							var hit = this._cache[key];
							if (isStale(this, hit)) {
								return false
							}
							return true
						};

						LRUCache.prototype.get = function (key) {
							typeCheckKey(key);
							return get(this, key, true)
						};

						LRUCache.prototype.peek = function (key) {
							typeCheckKey(key);
							return get(this, key, false)
						};

						LRUCache.prototype.pop = function () {
							var hit = this._lruList[this._lru];
							del(this, hit);
							return hit || null
						};

						LRUCache.prototype.del = function (key) {
							typeCheckKey(key);
							del(this, this._cache[key]);
						};

						LRUCache.prototype.load = function (arr) {
							//reset the cache
							this.reset();

							var now = Date.now();
							//A previous serialized cache has the most recent items first
							for (var l = arr.length - 1; l >= 0; l--) {
								var hit = arr[l];
								typeCheckKey(hit.k);
								var expiresAt = hit.e || 0;
								if (expiresAt === 0) {
									//the item was created without expiration in a non aged cache
									this.set(hit.k, hit.v);
								} else {
									var maxAge = expiresAt - now;
									//dont add already expired items
									if (maxAge > 0) this.set(hit.k, hit.v, maxAge);
								}
							}
						};

						function get(self, key, doUse) {
							typeCheckKey(key);
							var hit = self._cache[key];
							if (hit) {
								if (isStale(self, hit)) {
									del(self, hit);
									if (!self._allowStale) hit = undefined;
								} else {
									if (doUse) use(self, hit);
								}
								if (hit) hit = hit.value;
							}
							return hit
						}

						function isStale(self, hit) {
							if (!hit || (!hit.maxAge && !self._maxAge)) return false
							var stale = false;
							var diff = Date.now() - hit.now;
							if (hit.maxAge) {
								stale = diff > hit.maxAge;
							} else {
								stale = self._maxAge && (diff > self._maxAge);
							}
							return stale;
						}

						function use(self, hit) {
							shiftLU(self, hit);
							hit.lu = self._mru++;
							self._lruList[hit.lu] = hit;
						}

						function trim(self) {
							while (self._lru < self._mru && self._length > self._max)
								del(self, self._lruList[self._lru]);
						}

						function shiftLU(self, hit) {
							delete self._lruList[hit.lu];
							while (self._lru < self._mru && !self._lruList[self._lru]) self._lru++;
						}

						function del(self, hit) {
							if (hit) {
								if (self._dispose) self._dispose(hit.key, hit.value);
								self._length -= hit.length;
								self._itemCount--;
								delete self._cache[hit.key];
								shiftLU(self, hit);
							}
						}

						// classy, since V8 prefers predictable objects.
						function Entry(key, value, lu, length, now, maxAge) {
							this.key = key;
							this.value = value;
							this.lu = lu;
							this.length = length;
							this.now = now;
							if (maxAge) this.maxAge = maxAge;
						}

					})();

				}, {}], 14: [function (require, module, exports) {
					require('text-encoding-polyfill');
					var StringDecoder = require('string_decoder').StringDecoder;
					function defaultDecoder(data) {
						var decoder = new StringDecoder();
						var out = decoder.write(data) + decoder.end();
						return out.replace(/\0/g, '').trim();
					}
					module.exports = createDecoder;
					var regex = /^(?:ANSI\s)?(\d+)$/m;
					function createDecoder(encoding, second) {
						if (!encoding) {
							return defaultDecoder;
						}
						try {
							new TextDecoder(encoding.trim());
						} catch (e) {
							var match = regex.exec(encoding);
							if (match && !second) {
								return createDecoder('windows-' + match[1], true);
							} else {
								return defaultDecoder;
							}
						}
						return browserDecoder;
						function browserDecoder(buffer) {
							var decoder = new TextDecoder(encoding);
							var out = decoder.decode(buffer, {
								stream: true
							}) + decoder.decode();
							return out.replace(/\0/g, '').trim();
						}
					}

				}, { "string_decoder": 19, "text-encoding-polyfill": 20 }], 15: [function (require, module, exports) {
					var createDecoder = require('./decoder');
					function dbfHeader(data) {
						var out = {};
						out.lastUpdated = new Date(data.readUInt8(1) + 1900, data.readUInt8(2), data.readUInt8(3));
						out.records = data.readUInt32LE(4);
						out.headerLen = data.readUInt16LE(8);
						out.recLen = data.readUInt16LE(10);
						return out;
					}

					function dbfRowHeader(data, headerLen, decoder) {
						var out = [];
						var offset = 32;
						while (offset < headerLen) {
							out.push({
								name: decoder(data.slice(offset, offset + 11)),
								dataType: String.fromCharCode(data.readUInt8(offset + 11)),
								len: data.readUInt8(offset + 16),
								decimal: data.readUInt8(offset + 17)
							});
							if (data.readUInt8(offset + 32) === 13) {
								break;
							} else {
								offset += 32;
							}
						}
						return out;
					}

					function rowFuncs(buffer, offset, len, type, decoder) {
						var data = buffer.slice(offset, offset + len);
						var textData = decoder(data);
						switch (type) {
							case 'N':
							case 'F':
							case 'O':
								return parseFloat(textData, 10);
							case 'D':
								return new Date(textData.slice(0, 4), parseInt(textData.slice(4, 6), 10) - 1, textData.slice(6, 8));
							case 'L':
								return textData.toLowerCase() === 'y' || textData.toLowerCase() === 't';
							default:
								return textData;
						}
					}

					function parseRow(buffer, offset, rowHeaders, decoder) {
						var out = {};
						var i = 0;
						var len = rowHeaders.length;
						var field;
						var header;
						while (i < len) {
							header = rowHeaders[i];
							field = rowFuncs(buffer, offset, header.len, header.dataType, decoder);
							offset += header.len;
							if (typeof field !== 'undefined') {
								out[header.name] = field;
							}
							i++;
						}
						return out;
					}

					module.exports = function (buffer, encoding) {
						var decoder = createDecoder(encoding);
						var header = dbfHeader(buffer);
						var rowHeaders = dbfRowHeader(buffer, header.headerLen - 1, decoder);

						var offset = ((rowHeaders.length + 1) << 5) + 2;
						var recLen = header.recLen;
						var records = header.records;
						var out = [];
						while (records) {
							out.push(parseRow(buffer, offset, rowHeaders, decoder));
							offset += recLen;
							records--;
						}
						return out;
					};

				}, { "./decoder": 14 }], 16: [function (require, module, exports) {
					// shim for using process in browser
					var process = module.exports = {};

					// cached from whatever global is present so that test runners that stub it
					// don't break things.  But we need to wrap it in a try catch in case it is
					// wrapped in strict mode code which doesn't define any globals.  It's inside a
					// function because try/catches deoptimize in certain engines.

					var cachedSetTimeout;
					var cachedClearTimeout;

					function defaultSetTimout() {
						throw new Error('setTimeout has not been defined');
					}
					function defaultClearTimeout() {
						throw new Error('clearTimeout has not been defined');
					}
					(function () {
						try {
							if (typeof setTimeout === 'function') {
								cachedSetTimeout = setTimeout;
							} else {
								cachedSetTimeout = defaultSetTimout;
							}
						} catch (e) {
							cachedSetTimeout = defaultSetTimout;
						}
						try {
							if (typeof clearTimeout === 'function') {
								cachedClearTimeout = clearTimeout;
							} else {
								cachedClearTimeout = defaultClearTimeout;
							}
						} catch (e) {
							cachedClearTimeout = defaultClearTimeout;
						}
					}());
					function runTimeout(fun) {
						if (cachedSetTimeout === setTimeout) {
							//normal enviroments in sane situations
							return setTimeout(fun, 0);
						}
						// if setTimeout wasn't available but was latter defined
						if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
							cachedSetTimeout = setTimeout;
							return setTimeout(fun, 0);
						}
						try {
							// when when somebody has screwed with setTimeout but no I.E. maddness
							return cachedSetTimeout(fun, 0);
						} catch (e) {
							try {
								// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
								return cachedSetTimeout.call(null, fun, 0);
							} catch (e) {
								// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
								return cachedSetTimeout.call(this, fun, 0);
							}
						}


					}
					function runClearTimeout(marker) {
						if (cachedClearTimeout === clearTimeout) {
							//normal enviroments in sane situations
							return clearTimeout(marker);
						}
						// if clearTimeout wasn't available but was latter defined
						if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
							cachedClearTimeout = clearTimeout;
							return clearTimeout(marker);
						}
						try {
							// when when somebody has screwed with setTimeout but no I.E. maddness
							return cachedClearTimeout(marker);
						} catch (e) {
							try {
								// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
								return cachedClearTimeout.call(null, marker);
							} catch (e) {
								// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
								// Some versions of I.E. have different rules for clearTimeout vs setTimeout
								return cachedClearTimeout.call(this, marker);
							}
						}



					}
					var queue = [];
					var draining = false;
					var currentQueue;
					var queueIndex = -1;

					function cleanUpNextTick() {
						if (!draining || !currentQueue) {
							return;
						}
						draining = false;
						if (currentQueue.length) {
							queue = currentQueue.concat(queue);
						} else {
							queueIndex = -1;
						}
						if (queue.length) {
							drainQueue();
						}
					}

					function drainQueue() {
						if (draining) {
							return;
						}
						var timeout = runTimeout(cleanUpNextTick);
						draining = true;

						var len = queue.length;
						while (len) {
							currentQueue = queue;
							queue = [];
							while (++queueIndex < len) {
								if (currentQueue) {
									currentQueue[queueIndex].run();
								}
							}
							queueIndex = -1;
							len = queue.length;
						}
						currentQueue = null;
						draining = false;
						runClearTimeout(timeout);
					}

					process.nextTick = function (fun) {
						var args = new Array(arguments.length - 1);
						if (arguments.length > 1) {
							for (var i = 1; i < arguments.length; i++) {
								args[i - 1] = arguments[i];
							}
						}
						queue.push(new Item(fun, args));
						if (queue.length === 1 && !draining) {
							runTimeout(drainQueue);
						}
					};

					// v8 likes predictible objects
					function Item(fun, array) {
						this.fun = fun;
						this.array = array;
					}
					Item.prototype.run = function () {
						this.fun.apply(null, this.array);
					};
					process.title = 'browser';
					process.browser = true;
					process.env = {};
					process.argv = [];
					process.version = ''; // empty string to avoid regexp issues
					process.versions = {};

					function noop() { }

					process.on = noop;
					process.addListener = noop;
					process.once = noop;
					process.off = noop;
					process.removeListener = noop;
					process.removeAllListeners = noop;
					process.emit = noop;
					process.prependListener = noop;
					process.prependOnceListener = noop;

					process.listeners = function (name) { return [] };

					process.binding = function (name) {
						throw new Error('process.binding is not supported');
					};

					process.cwd = function () { return '/' };
					process.chdir = function (dir) {
						throw new Error('process.chdir is not supported');
					};
					process.umask = function () { return 0; };

				}, {}], 17: [function (require, module, exports) {
					(function (global, factory) {
						typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
							(global.proj4 = factory());
					}(this, (function () {
						var globals = function (defs) {
							defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
							defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
							defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");

							defs.WGS84 = defs['EPSG:4326'];
							defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
							defs.GOOGLE = defs['EPSG:3857'];
							defs['EPSG:900913'] = defs['EPSG:3857'];
							defs['EPSG:102113'] = defs['EPSG:3857'];
						};

						var PJD_3PARAM = 1;
						var PJD_7PARAM = 2;
						var PJD_GRIDSHIFT = 3;
						var PJD_WGS84 = 4; // WGS84 or equivalent
						var PJD_NODATUM = 5; // WGS84 or equivalent
						var SRS_WGS84_SEMIMAJOR = 6378137.0;  // only used in grid shift transforms
						var SRS_WGS84_SEMIMINOR = 6356752.314;  // only used in grid shift transforms
						var SRS_WGS84_ESQUARED = 0.0066943799901413165; // only used in grid shift transforms
						var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
						var HALF_PI = Math.PI / 2;
						// ellipoid pj_set_ell.c
						var SIXTH = 0.1666666666666666667;
						/* 1/6 */
						var RA4 = 0.04722222222222222222;
						/* 17/360 */
						var RA6 = 0.02215608465608465608;
						var EPSLN = 1.0e-10;
						// you'd think you could use Number.EPSILON above but that makes
						// Mollweide get into an infinate loop.

						var D2R = 0.01745329251994329577;
						var R2D = 57.29577951308232088;
						var FORTPI = Math.PI / 4;
						var TWO_PI = Math.PI * 2;
						// SPI is slightly greater than Math.PI, so values that exceed the -180..180
						// degree range by a tiny amount don't get wrapped. This prevents points that
						// have drifted from their original location along the 180th meridian (due to
						// floating point error) from changing their sign.
						var SPI = 3.14159265359;

						var exports$1 = {};
						exports$1.greenwich = 0.0; //"0dE",
						exports$1.lisbon = -9.131906111111; //"9d07'54.862\"W",
						exports$1.paris = 2.337229166667; //"2d20'14.025\"E",
						exports$1.bogota = -74.080916666667; //"74d04'51.3\"W",
						exports$1.madrid = -3.687938888889; //"3d41'16.58\"W",
						exports$1.rome = 12.452333333333; //"12d27'8.4\"E",
						exports$1.bern = 7.439583333333; //"7d26'22.5\"E",
						exports$1.jakarta = 106.807719444444; //"106d48'27.79\"E",
						exports$1.ferro = -17.666666666667; //"17d40'W",
						exports$1.brussels = 4.367975; //"4d22'4.71\"E",
						exports$1.stockholm = 18.058277777778; //"18d3'29.8\"E",
						exports$1.athens = 23.7163375; //"23d42'58.815\"E",
						exports$1.oslo = 10.722916666667; //"10d43'22.5\"E"

						var units = {
							ft: { to_meter: 0.3048 },
							'us-ft': { to_meter: 1200 / 3937 }
						};

						var ignoredChar = /[\s_\-\/\(\)]/g;
						function match(obj, key) {
							if (obj[key]) {
								return obj[key];
							}
							var keys = Object.keys(obj);
							var lkey = key.toLowerCase().replace(ignoredChar, '');
							var i = -1;
							var testkey, processedKey;
							while (++i < keys.length) {
								testkey = keys[i];
								processedKey = testkey.toLowerCase().replace(ignoredChar, '');
								if (processedKey === lkey) {
									return obj[testkey];
								}
							}
						}

						var parseProj = function (defData) {
							var self = {};
							var paramObj = defData.split('+').map(function (v) {
								return v.trim();
							}).filter(function (a) {
								return a;
							}).reduce(function (p, a) {
								var split = a.split('=');
								split.push(true);
								p[split[0].toLowerCase()] = split[1];
								return p;
							}, {});
							var paramName, paramVal, paramOutname;
							var params = {
								proj: 'projName',
								datum: 'datumCode',
								rf: function (v) {
									self.rf = parseFloat(v);
								},
								lat_0: function (v) {
									self.lat0 = v * D2R;
								},
								lat_1: function (v) {
									self.lat1 = v * D2R;
								},
								lat_2: function (v) {
									self.lat2 = v * D2R;
								},
								lat_ts: function (v) {
									self.lat_ts = v * D2R;
								},
								lon_0: function (v) {
									self.long0 = v * D2R;
								},
								lon_1: function (v) {
									self.long1 = v * D2R;
								},
								lon_2: function (v) {
									self.long2 = v * D2R;
								},
								alpha: function (v) {
									self.alpha = parseFloat(v) * D2R;
								},
								gamma: function (v) {
									self.rectified_grid_angle = parseFloat(v);
								},
								lonc: function (v) {
									self.longc = v * D2R;
								},
								x_0: function (v) {
									self.x0 = parseFloat(v);
								},
								y_0: function (v) {
									self.y0 = parseFloat(v);
								},
								k_0: function (v) {
									self.k0 = parseFloat(v);
								},
								k: function (v) {
									self.k0 = parseFloat(v);
								},
								a: function (v) {
									self.a = parseFloat(v);
								},
								b: function (v) {
									self.b = parseFloat(v);
								},
								r_a: function () {
									self.R_A = true;
								},
								zone: function (v) {
									self.zone = parseInt(v, 10);
								},
								south: function () {
									self.utmSouth = true;
								},
								towgs84: function (v) {
									self.datum_params = v.split(",").map(function (a) {
										return parseFloat(a);
									});
								},
								to_meter: function (v) {
									self.to_meter = parseFloat(v);
								},
								units: function (v) {
									self.units = v;
									var unit = match(units, v);
									if (unit) {
										self.to_meter = unit.to_meter;
									}
								},
								from_greenwich: function (v) {
									self.from_greenwich = v * D2R;
								},
								pm: function (v) {
									var pm = match(exports$1, v);
									self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;
								},
								nadgrids: function (v) {
									if (v === '@null') {
										self.datumCode = 'none';
									}
									else {
										self.nadgrids = v;
									}
								},
								axis: function (v) {
									var legalAxis = "ewnsud";
									if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
										self.axis = v;
									}
								},
								approx: function () {
									self.approx = true;
								}
							};
							for (paramName in paramObj) {
								paramVal = paramObj[paramName];
								if (paramName in params) {
									paramOutname = params[paramName];
									if (typeof paramOutname === 'function') {
										paramOutname(paramVal);
									}
									else {
										self[paramOutname] = paramVal;
									}
								}
								else {
									self[paramName] = paramVal;
								}
							}
							if (typeof self.datumCode === 'string' && self.datumCode !== "WGS84") {
								self.datumCode = self.datumCode.toLowerCase();
							}
							return self;
						};

						var NEUTRAL = 1;
						var KEYWORD = 2;
						var NUMBER = 3;
						var QUOTED = 4;
						var AFTERQUOTE = 5;
						var ENDED = -1;
						var whitespace = /\s/;
						var latin = /[A-Za-z]/;
						var keyword = /[A-Za-z84]/;
						var endThings = /[,\]]/;
						var digets = /[\d\.E\-\+]/;
						// const ignoredChar = /[\s_\-\/\(\)]/g;
						function Parser(text) {
							if (typeof text !== 'string') {
								throw new Error('not a string');
							}
							this.text = text.trim();
							this.level = 0;
							this.place = 0;
							this.root = null;
							this.stack = [];
							this.currentObject = null;
							this.state = NEUTRAL;
						}
						Parser.prototype.readCharicter = function () {
							var char = this.text[this.place++];
							if (this.state !== QUOTED) {
								while (whitespace.test(char)) {
									if (this.place >= this.text.length) {
										return;
									}
									char = this.text[this.place++];
								}
							}
							switch (this.state) {
								case NEUTRAL:
									return this.neutral(char);
								case KEYWORD:
									return this.keyword(char)
								case QUOTED:
									return this.quoted(char);
								case AFTERQUOTE:
									return this.afterquote(char);
								case NUMBER:
									return this.number(char);
								case ENDED:
									return;
							}
						};
						Parser.prototype.afterquote = function (char) {
							if (char === '"') {
								this.word += '"';
								this.state = QUOTED;
								return;
							}
							if (endThings.test(char)) {
								this.word = this.word.trim();
								this.afterItem(char);
								return;
							}
							throw new Error('havn\'t handled "' + char + '" in afterquote yet, index ' + this.place);
						};
						Parser.prototype.afterItem = function (char) {
							if (char === ',') {
								if (this.word !== null) {
									this.currentObject.push(this.word);
								}
								this.word = null;
								this.state = NEUTRAL;
								return;
							}
							if (char === ']') {
								this.level--;
								if (this.word !== null) {
									this.currentObject.push(this.word);
									this.word = null;
								}
								this.state = NEUTRAL;
								this.currentObject = this.stack.pop();
								if (!this.currentObject) {
									this.state = ENDED;
								}

								return;
							}
						};
						Parser.prototype.number = function (char) {
							if (digets.test(char)) {
								this.word += char;
								return;
							}
							if (endThings.test(char)) {
								this.word = parseFloat(this.word);
								this.afterItem(char);
								return;
							}
							throw new Error('havn\'t handled "' + char + '" in number yet, index ' + this.place);
						};
						Parser.prototype.quoted = function (char) {
							if (char === '"') {
								this.state = AFTERQUOTE;
								return;
							}
							this.word += char;
							return;
						};
						Parser.prototype.keyword = function (char) {
							if (keyword.test(char)) {
								this.word += char;
								return;
							}
							if (char === '[') {
								var newObjects = [];
								newObjects.push(this.word);
								this.level++;
								if (this.root === null) {
									this.root = newObjects;
								} else {
									this.currentObject.push(newObjects);
								}
								this.stack.push(this.currentObject);
								this.currentObject = newObjects;
								this.state = NEUTRAL;
								return;
							}
							if (endThings.test(char)) {
								this.afterItem(char);
								return;
							}
							throw new Error('havn\'t handled "' + char + '" in keyword yet, index ' + this.place);
						};
						Parser.prototype.neutral = function (char) {
							if (latin.test(char)) {
								this.word = char;
								this.state = KEYWORD;
								return;
							}
							if (char === '"') {
								this.word = '';
								this.state = QUOTED;
								return;
							}
							if (digets.test(char)) {
								this.word = char;
								this.state = NUMBER;
								return;
							}
							if (endThings.test(char)) {
								this.afterItem(char);
								return;
							}
							throw new Error('havn\'t handled "' + char + '" in neutral yet, index ' + this.place);
						};
						Parser.prototype.output = function () {
							while (this.place < this.text.length) {
								this.readCharicter();
							}
							if (this.state === ENDED) {
								return this.root;
							}
							throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
						};

						function parseString(txt) {
							var parser = new Parser(txt);
							return parser.output();
						}

						function mapit(obj, key, value) {
							if (Array.isArray(key)) {
								value.unshift(key);
								key = null;
							}
							var thing = key ? {} : obj;

							var out = value.reduce(function (newObj, item) {
								sExpr(item, newObj);
								return newObj
							}, thing);
							if (key) {
								obj[key] = out;
							}
						}

						function sExpr(v, obj) {
							if (!Array.isArray(v)) {
								obj[v] = true;
								return;
							}
							var key = v.shift();
							if (key === 'PARAMETER') {
								key = v.shift();
							}
							if (v.length === 1) {
								if (Array.isArray(v[0])) {
									obj[key] = {};
									sExpr(v[0], obj[key]);
									return;
								}
								obj[key] = v[0];
								return;
							}
							if (!v.length) {
								obj[key] = true;
								return;
							}
							if (key === 'TOWGS84') {
								obj[key] = v;
								return;
							}
							if (key === 'AXIS') {
								if (!(key in obj)) {
									obj[key] = [];
								}
								obj[key].push(v);
								return;
							}
							if (!Array.isArray(key)) {
								obj[key] = {};
							}

							var i;
							switch (key) {
								case 'UNIT':
								case 'PRIMEM':
								case 'VERT_DATUM':
									obj[key] = {
										name: v[0].toLowerCase(),
										convert: v[1]
									};
									if (v.length === 3) {
										sExpr(v[2], obj[key]);
									}
									return;
								case 'SPHEROID':
								case 'ELLIPSOID':
									obj[key] = {
										name: v[0],
										a: v[1],
										rf: v[2]
									};
									if (v.length === 4) {
										sExpr(v[3], obj[key]);
									}
									return;
								case 'PROJECTEDCRS':
								case 'PROJCRS':
								case 'GEOGCS':
								case 'GEOCCS':
								case 'PROJCS':
								case 'LOCAL_CS':
								case 'GEODCRS':
								case 'GEODETICCRS':
								case 'GEODETICDATUM':
								case 'EDATUM':
								case 'ENGINEERINGDATUM':
								case 'VERT_CS':
								case 'VERTCRS':
								case 'VERTICALCRS':
								case 'COMPD_CS':
								case 'COMPOUNDCRS':
								case 'ENGINEERINGCRS':
								case 'ENGCRS':
								case 'FITTED_CS':
								case 'LOCAL_DATUM':
								case 'DATUM':
									v[0] = ['name', v[0]];
									mapit(obj, key, v);
									return;
								default:
									i = -1;
									while (++i < v.length) {
										if (!Array.isArray(v[i])) {
											return sExpr(v, obj[key]);
										}
									}
									return mapit(obj, key, v);
							}
						}

						var D2R$1 = 0.01745329251994329577;
						function rename(obj, params) {
							var outName = params[0];
							var inName = params[1];
							if (!(outName in obj) && (inName in obj)) {
								obj[outName] = obj[inName];
								if (params.length === 3) {
									obj[outName] = params[2](obj[outName]);
								}
							}
						}

						function d2r(input) {
							return input * D2R$1;
						}

						function cleanWKT(wkt) {
							if (wkt.type === 'GEOGCS') {
								wkt.projName = 'longlat';
							} else if (wkt.type === 'LOCAL_CS') {
								wkt.projName = 'identity';
								wkt.local = true;
							} else {
								if (typeof wkt.PROJECTION === 'object') {
									wkt.projName = Object.keys(wkt.PROJECTION)[0];
								} else {
									wkt.projName = wkt.PROJECTION;
								}
							}
							if (wkt.AXIS) {
								var axisOrder = '';
								for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
									var axis = [wkt.AXIS[i][0].toLowerCase(), wkt.AXIS[i][1].toLowerCase()];
									if (axis[0].indexOf('north') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'north')) {
										axisOrder += 'n';
									} else if (axis[0].indexOf('south') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'south')) {
										axisOrder += 's';
									} else if (axis[0].indexOf('east') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'east')) {
										axisOrder += 'e';
									} else if (axis[0].indexOf('west') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'west')) {
										axisOrder += 'w';
									}
								}
								if (axisOrder.length === 2) {
									axisOrder += 'u';
								}
								if (axisOrder.length === 3) {
									wkt.axis = axisOrder;
								}
							}
							if (wkt.UNIT) {
								wkt.units = wkt.UNIT.name.toLowerCase();
								if (wkt.units === 'metre') {
									wkt.units = 'meter';
								}
								if (wkt.UNIT.convert) {
									if (wkt.type === 'GEOGCS') {
										if (wkt.DATUM && wkt.DATUM.SPHEROID) {
											wkt.to_meter = wkt.UNIT.convert * wkt.DATUM.SPHEROID.a;
										}
									} else {
										wkt.to_meter = wkt.UNIT.convert;
									}
								}
							}
							var geogcs = wkt.GEOGCS;
							if (wkt.type === 'GEOGCS') {
								geogcs = wkt;
							}
							if (geogcs) {
								//if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
								//  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
								//}
								if (geogcs.DATUM) {
									wkt.datumCode = geogcs.DATUM.name.toLowerCase();
								} else {
									wkt.datumCode = geogcs.name.toLowerCase();
								}
								if (wkt.datumCode.slice(0, 2) === 'd_') {
									wkt.datumCode = wkt.datumCode.slice(2);
								}
								if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
									wkt.datumCode = 'nzgd49';
								}
								if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {
									if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
										wkt.sphere = true;
									}
									wkt.datumCode = 'wgs84';
								}
								if (wkt.datumCode.slice(-6) === '_ferro') {
									wkt.datumCode = wkt.datumCode.slice(0, - 6);
								}
								if (wkt.datumCode.slice(-8) === '_jakarta') {
									wkt.datumCode = wkt.datumCode.slice(0, - 8);
								}
								if (~wkt.datumCode.indexOf('belge')) {
									wkt.datumCode = 'rnb72';
								}
								if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
									wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
									if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
										wkt.ellps = 'intl';
									}

									wkt.a = geogcs.DATUM.SPHEROID.a;
									wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
								}

								if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
									wkt.datum_params = geogcs.DATUM.TOWGS84;
								}
								if (~wkt.datumCode.indexOf('osgb_1936')) {
									wkt.datumCode = 'osgb36';
								}
								if (~wkt.datumCode.indexOf('osni_1952')) {
									wkt.datumCode = 'osni52';
								}
								if (~wkt.datumCode.indexOf('tm65')
									|| ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {
									wkt.datumCode = 'ire65';
								}
								if (wkt.datumCode === 'ch1903+') {
									wkt.datumCode = 'ch1903';
								}
								if (~wkt.datumCode.indexOf('israel')) {
									wkt.datumCode = 'isr93';
								}
							}
							if (wkt.b && !isFinite(wkt.b)) {
								wkt.b = wkt.a;
							}

							function toMeter(input) {
								var ratio = wkt.to_meter || 1;
								return input * ratio;
							}
							var renamer = function (a) {
								return rename(wkt, a);
							};
							var list = [
								['standard_parallel_1', 'Standard_Parallel_1'],
								['standard_parallel_1', 'Latitude of 1st standard parallel'],
								['standard_parallel_2', 'Standard_Parallel_2'],
								['standard_parallel_2', 'Latitude of 2nd standard parallel'],
								['false_easting', 'False_Easting'],
								['false_easting', 'False easting'],
								['false-easting', 'Easting at false origin'],
								['false_northing', 'False_Northing'],
								['false_northing', 'False northing'],
								['false_northing', 'Northing at false origin'],
								['central_meridian', 'Central_Meridian'],
								['central_meridian', 'Longitude of natural origin'],
								['central_meridian', 'Longitude of false origin'],
								['latitude_of_origin', 'Latitude_Of_Origin'],
								['latitude_of_origin', 'Central_Parallel'],
								['latitude_of_origin', 'Latitude of natural origin'],
								['latitude_of_origin', 'Latitude of false origin'],
								['scale_factor', 'Scale_Factor'],
								['k0', 'scale_factor'],
								['latitude_of_center', 'Latitude_Of_Center'],
								['latitude_of_center', 'Latitude_of_center'],
								['lat0', 'latitude_of_center', d2r],
								['longitude_of_center', 'Longitude_Of_Center'],
								['longitude_of_center', 'Longitude_of_center'],
								['longc', 'longitude_of_center', d2r],
								['x0', 'false_easting', toMeter],
								['y0', 'false_northing', toMeter],
								['long0', 'central_meridian', d2r],
								['lat0', 'latitude_of_origin', d2r],
								['lat0', 'standard_parallel_1', d2r],
								['lat1', 'standard_parallel_1', d2r],
								['lat2', 'standard_parallel_2', d2r],
								['azimuth', 'Azimuth'],
								['alpha', 'azimuth', d2r],
								['srsCode', 'name']
							];
							list.forEach(renamer);
							if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
								wkt.long0 = wkt.longc;
							}
							if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
								wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
								wkt.lat_ts = wkt.lat1;
							}
						}
						var wkt = function (wkt) {
							var lisp = parseString(wkt);
							var type = lisp.shift();
							var name = lisp.shift();
							lisp.unshift(['name', name]);
							lisp.unshift(['type', type]);
							var obj = {};
							sExpr(lisp, obj);
							cleanWKT(obj);
							return obj;
						};

						function defs(name) {
							/*global console*/
							var that = this;
							if (arguments.length === 2) {
								var def = arguments[1];
								if (typeof def === 'string') {
									if (def.charAt(0) === '+') {
										defs[name] = parseProj(arguments[1]);
									}
									else {
										defs[name] = wkt(arguments[1]);
									}
								} else {
									defs[name] = def;
								}
							}
							else if (arguments.length === 1) {
								if (Array.isArray(name)) {
									return name.map(function (v) {
										if (Array.isArray(v)) {
											defs.apply(that, v);
										}
										else {
											defs(v);
										}
									});
								}
								else if (typeof name === 'string') {
									if (name in defs) {
										return defs[name];
									}
								}
								else if ('EPSG' in name) {
									defs['EPSG:' + name.EPSG] = name;
								}
								else if ('ESRI' in name) {
									defs['ESRI:' + name.ESRI] = name;
								}
								else if ('IAU2000' in name) {
									defs['IAU2000:' + name.IAU2000] = name;
								}
								else {
									console.log(name);
								}
								return;
							}


						}
						globals(defs);

						function testObj(code) {
							return typeof code === 'string';
						}
						function testDef(code) {
							return code in defs;
						}
						var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS', 'GEOCCS', 'PROJCS', 'LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS'];
						function testWKT(code) {
							return codeWords.some(function (word) {
								return code.indexOf(word) > -1;
							});
						}
						var codes = ['3857', '900913', '3785', '102113'];
						function checkMercator(item) {
							var auth = match(item, 'authority');
							if (!auth) {
								return;
							}
							var code = match(auth, 'epsg');
							return code && codes.indexOf(code) > -1;
						}
						function checkProjStr(item) {
							var ext = match(item, 'extension');
							if (!ext) {
								return;
							}
							return match(ext, 'proj4');
						}
						function testProj(code) {
							return code[0] === '+';
						}
						function parse(code) {
							if (testObj(code)) {
								//check to see if this is a WKT string
								if (testDef(code)) {
									return defs[code];
								}
								if (testWKT(code)) {
									var out = wkt(code);
									// test of spetial case, due to this being a very common and often malformed
									if (checkMercator(out)) {
										return defs['EPSG:3857'];
									}
									var maybeProjStr = checkProjStr(out);
									if (maybeProjStr) {
										return parseProj(maybeProjStr);
									}
									return out;
								}
								if (testProj(code)) {
									return parseProj(code);
								}
							} else {
								return code;
							}
						}

						var extend = function (destination, source) {
							destination = destination || {};
							var value, property;
							if (!source) {
								return destination;
							}
							for (property in source) {
								value = source[property];
								if (value !== undefined) {
									destination[property] = value;
								}
							}
							return destination;
						};

						var msfnz = function (eccent, sinphi, cosphi) {
							var con = eccent * sinphi;
							return cosphi / (Math.sqrt(1 - con * con));
						};

						var sign = function (x) {
							return x < 0 ? -1 : 1;
						};

						var adjust_lon = function (x) {
							return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));
						};

						var tsfnz = function (eccent, phi, sinphi) {
							var con = eccent * sinphi;
							var com = 0.5 * eccent;
							con = Math.pow(((1 - con) / (1 + con)), com);
							return (Math.tan(0.5 * (HALF_PI - phi)) / con);
						};

						var phi2z = function (eccent, ts) {
							var eccnth = 0.5 * eccent;
							var con, dphi;
							var phi = HALF_PI - 2 * Math.atan(ts);
							for (var i = 0; i <= 15; i++) {
								con = eccent * Math.sin(phi);
								dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
								phi += dphi;
								if (Math.abs(dphi) <= 0.0000000001) {
									return phi;
								}
							}
							//console.log("phi2z has NoConvergence");
							return -9999;
						};

						function init() {
							var con = this.b / this.a;
							this.es = 1 - con * con;
							if (!('x0' in this)) {
								this.x0 = 0;
							}
							if (!('y0' in this)) {
								this.y0 = 0;
							}
							this.e = Math.sqrt(this.es);
							if (this.lat_ts) {
								if (this.sphere) {
									this.k0 = Math.cos(this.lat_ts);
								}
								else {
									this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
								}
							}
							else {
								if (!this.k0) {
									if (this.k) {
										this.k0 = this.k;
									}
									else {
										this.k0 = 1;
									}
								}
							}
						}

						/* Mercator forward equations--mapping lat,long to x,y
						  --------------------------------------------------*/

						function forward(p) {
							var lon = p.x;
							var lat = p.y;
							// convert to radians
							if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
								return null;
							}

							var x, y;
							if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
								return null;
							}
							else {
								if (this.sphere) {
									x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
									y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
								}
								else {
									var sinphi = Math.sin(lat);
									var ts = tsfnz(this.e, lat, sinphi);
									x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
									y = this.y0 - this.a * this.k0 * Math.log(ts);
								}
								p.x = x;
								p.y = y;
								return p;
							}
						}

						/* Mercator inverse equations--mapping x,y to lat/long
						  --------------------------------------------------*/
						function inverse(p) {

							var x = p.x - this.x0;
							var y = p.y - this.y0;
							var lon, lat;

							if (this.sphere) {
								lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
							}
							else {
								var ts = Math.exp(-y / (this.a * this.k0));
								lat = phi2z(this.e, ts);
								if (lat === -9999) {
									return null;
								}
							}
							lon = adjust_lon(this.long0 + x / (this.a * this.k0));

							p.x = lon;
							p.y = lat;
							return p;
						}

						var names$1 = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
						var merc = {
							init: init,
							forward: forward,
							inverse: inverse,
							names: names$1
						};

						function init$1() {
							//no-op for longlat
						}

						function identity(pt) {
							return pt;
						}
						var names$2 = ["longlat", "identity"];
						var longlat = {
							init: init$1,
							forward: identity,
							inverse: identity,
							names: names$2
						};

						var projs = [merc, longlat];
						var names = {};
						var projStore = [];

						function add(proj, i) {
							var len = projStore.length;
							if (!proj.names) {
								console.log(i);
								return true;
							}
							projStore[len] = proj;
							proj.names.forEach(function (n) {
								names[n.toLowerCase()] = len;
							});
							return this;
						}

						function get(name) {
							if (!name) {
								return false;
							}
							var n = name.toLowerCase();
							if (typeof names[n] !== 'undefined' && projStore[names[n]]) {
								return projStore[names[n]];
							}
						}

						function start() {
							projs.forEach(add);
						}
						var projections = {
							start: start,
							add: add,
							get: get
						};

						var exports$2 = {};
						exports$2.MERIT = {
							a: 6378137.0,
							rf: 298.257,
							ellipseName: "MERIT 1983"
						};

						exports$2.SGS85 = {
							a: 6378136.0,
							rf: 298.257,
							ellipseName: "Soviet Geodetic System 85"
						};

						exports$2.GRS80 = {
							a: 6378137.0,
							rf: 298.257222101,
							ellipseName: "GRS 1980(IUGG, 1980)"
						};

						exports$2.IAU76 = {
							a: 6378140.0,
							rf: 298.257,
							ellipseName: "IAU 1976"
						};

						exports$2.airy = {
							a: 6377563.396,
							b: 6356256.910,
							ellipseName: "Airy 1830"
						};

						exports$2.APL4 = {
							a: 6378137,
							rf: 298.25,
							ellipseName: "Appl. Physics. 1965"
						};

						exports$2.NWL9D = {
							a: 6378145.0,
							rf: 298.25,
							ellipseName: "Naval Weapons Lab., 1965"
						};

						exports$2.mod_airy = {
							a: 6377340.189,
							b: 6356034.446,
							ellipseName: "Modified Airy"
						};

						exports$2.andrae = {
							a: 6377104.43,
							rf: 300.0,
							ellipseName: "Andrae 1876 (Den., Iclnd.)"
						};

						exports$2.aust_SA = {
							a: 6378160.0,
							rf: 298.25,
							ellipseName: "Australian Natl & S. Amer. 1969"
						};

						exports$2.GRS67 = {
							a: 6378160.0,
							rf: 298.2471674270,
							ellipseName: "GRS 67(IUGG 1967)"
						};

						exports$2.bessel = {
							a: 6377397.155,
							rf: 299.1528128,
							ellipseName: "Bessel 1841"
						};

						exports$2.bess_nam = {
							a: 6377483.865,
							rf: 299.1528128,
							ellipseName: "Bessel 1841 (Namibia)"
						};

						exports$2.clrk66 = {
							a: 6378206.4,
							b: 6356583.8,
							ellipseName: "Clarke 1866"
						};

						exports$2.clrk80 = {
							a: 6378249.145,
							rf: 293.4663,
							ellipseName: "Clarke 1880 mod."
						};

						exports$2.clrk58 = {
							a: 6378293.645208759,
							rf: 294.2606763692654,
							ellipseName: "Clarke 1858"
						};

						exports$2.CPM = {
							a: 6375738.7,
							rf: 334.29,
							ellipseName: "Comm. des Poids et Mesures 1799"
						};

						exports$2.delmbr = {
							a: 6376428.0,
							rf: 311.5,
							ellipseName: "Delambre 1810 (Belgium)"
						};

						exports$2.engelis = {
							a: 6378136.05,
							rf: 298.2566,
							ellipseName: "Engelis 1985"
						};

						exports$2.evrst30 = {
							a: 6377276.345,
							rf: 300.8017,
							ellipseName: "Everest 1830"
						};

						exports$2.evrst48 = {
							a: 6377304.063,
							rf: 300.8017,
							ellipseName: "Everest 1948"
						};

						exports$2.evrst56 = {
							a: 6377301.243,
							rf: 300.8017,
							ellipseName: "Everest 1956"
						};

						exports$2.evrst69 = {
							a: 6377295.664,
							rf: 300.8017,
							ellipseName: "Everest 1969"
						};

						exports$2.evrstSS = {
							a: 6377298.556,
							rf: 300.8017,
							ellipseName: "Everest (Sabah & Sarawak)"
						};

						exports$2.fschr60 = {
							a: 6378166.0,
							rf: 298.3,
							ellipseName: "Fischer (Mercury Datum) 1960"
						};

						exports$2.fschr60m = {
							a: 6378155.0,
							rf: 298.3,
							ellipseName: "Fischer 1960"
						};

						exports$2.fschr68 = {
							a: 6378150.0,
							rf: 298.3,
							ellipseName: "Fischer 1968"
						};

						exports$2.helmert = {
							a: 6378200.0,
							rf: 298.3,
							ellipseName: "Helmert 1906"
						};

						exports$2.hough = {
							a: 6378270.0,
							rf: 297.0,
							ellipseName: "Hough"
						};

						exports$2.intl = {
							a: 6378388.0,
							rf: 297.0,
							ellipseName: "International 1909 (Hayford)"
						};

						exports$2.kaula = {
							a: 6378163.0,
							rf: 298.24,
							ellipseName: "Kaula 1961"
						};

						exports$2.lerch = {
							a: 6378139.0,
							rf: 298.257,
							ellipseName: "Lerch 1979"
						};

						exports$2.mprts = {
							a: 6397300.0,
							rf: 191.0,
							ellipseName: "Maupertius 1738"
						};

						exports$2.new_intl = {
							a: 6378157.5,
							b: 6356772.2,
							ellipseName: "New International 1967"
						};

						exports$2.plessis = {
							a: 6376523.0,
							rf: 6355863.0,
							ellipseName: "Plessis 1817 (France)"
						};

						exports$2.krass = {
							a: 6378245.0,
							rf: 298.3,
							ellipseName: "Krassovsky, 1942"
						};

						exports$2.SEasia = {
							a: 6378155.0,
							b: 6356773.3205,
							ellipseName: "Southeast Asia"
						};

						exports$2.walbeck = {
							a: 6376896.0,
							b: 6355834.8467,
							ellipseName: "Walbeck"
						};

						exports$2.WGS60 = {
							a: 6378165.0,
							rf: 298.3,
							ellipseName: "WGS 60"
						};

						exports$2.WGS66 = {
							a: 6378145.0,
							rf: 298.25,
							ellipseName: "WGS 66"
						};

						exports$2.WGS7 = {
							a: 6378135.0,
							rf: 298.26,
							ellipseName: "WGS 72"
						};

						var WGS84 = exports$2.WGS84 = {
							a: 6378137.0,
							rf: 298.257223563,
							ellipseName: "WGS 84"
						};

						exports$2.sphere = {
							a: 6370997.0,
							b: 6370997.0,
							ellipseName: "Normal Sphere (r=6370997)"
						};

						function eccentricity(a, b, rf, R_A) {
							var a2 = a * a; // used in geocentric
							var b2 = b * b; // used in geocentric
							var es = (a2 - b2) / a2; // e ^ 2
							var e = 0;
							if (R_A) {
								a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
								a2 = a * a;
								es = 0;
							} else {
								e = Math.sqrt(es); // eccentricity
							}
							var ep2 = (a2 - b2) / b2; // used in geocentric
							return {
								es: es,
								e: e,
								ep2: ep2
							};
						}
						function sphere(a, b, rf, ellps, sphere) {
							if (!a) { // do we have an ellipsoid?
								var ellipse = match(exports$2, ellps);
								if (!ellipse) {
									ellipse = WGS84;
								}
								a = ellipse.a;
								b = ellipse.b;
								rf = ellipse.rf;
							}

							if (rf && !b) {
								b = (1.0 - 1.0 / rf) * a;
							}
							if (rf === 0 || Math.abs(a - b) < EPSLN) {
								sphere = true;
								b = a;
							}
							return {
								a: a,
								b: b,
								rf: rf,
								sphere: sphere
							};
						}

						var exports$3 = {};
						exports$3.wgs84 = {
							towgs84: "0,0,0",
							ellipse: "WGS84",
							datumName: "WGS84"
						};

						exports$3.ch1903 = {
							towgs84: "674.374,15.056,405.346",
							ellipse: "bessel",
							datumName: "swiss"
						};

						exports$3.ggrs87 = {
							towgs84: "-199.87,74.79,246.62",
							ellipse: "GRS80",
							datumName: "Greek_Geodetic_Reference_System_1987"
						};

						exports$3.nad83 = {
							towgs84: "0,0,0",
							ellipse: "GRS80",
							datumName: "North_American_Datum_1983"
						};

						exports$3.nad27 = {
							nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
							ellipse: "clrk66",
							datumName: "North_American_Datum_1927"
						};

						exports$3.potsdam = {
							towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
							ellipse: "bessel",
							datumName: "Potsdam Rauenberg 1950 DHDN"
						};

						exports$3.carthage = {
							towgs84: "-263.0,6.0,431.0",
							ellipse: "clark80",
							datumName: "Carthage 1934 Tunisia"
						};

						exports$3.hermannskogel = {
							towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
							ellipse: "bessel",
							datumName: "Hermannskogel"
						};

						exports$3.osni52 = {
							towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
							ellipse: "airy",
							datumName: "Irish National"
						};

						exports$3.ire65 = {
							towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
							ellipse: "mod_airy",
							datumName: "Ireland 1965"
						};

						exports$3.rassadiran = {
							towgs84: "-133.63,-157.5,-158.62",
							ellipse: "intl",
							datumName: "Rassadiran"
						};

						exports$3.nzgd49 = {
							towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
							ellipse: "intl",
							datumName: "New Zealand Geodetic Datum 1949"
						};

						exports$3.osgb36 = {
							towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
							ellipse: "airy",
							datumName: "Airy 1830"
						};

						exports$3.s_jtsk = {
							towgs84: "589,76,480",
							ellipse: 'bessel',
							datumName: 'S-JTSK (Ferro)'
						};

						exports$3.beduaram = {
							towgs84: '-106,-87,188',
							ellipse: 'clrk80',
							datumName: 'Beduaram'
						};

						exports$3.gunung_segara = {
							towgs84: '-403,684,41',
							ellipse: 'bessel',
							datumName: 'Gunung Segara Jakarta'
						};

						exports$3.rnb72 = {
							towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
							ellipse: "intl",
							datumName: "Reseau National Belge 1972"
						};

						function datum(datumCode, datum_params, a, b, es, ep2, nadgrids) {
							var out = {};

							if (datumCode === undefined || datumCode === 'none') {
								out.datum_type = PJD_NODATUM;
							} else {
								out.datum_type = PJD_WGS84;
							}

							if (datum_params) {
								out.datum_params = datum_params.map(parseFloat);
								if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
									out.datum_type = PJD_3PARAM;
								}
								if (out.datum_params.length > 3) {
									if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
										out.datum_type = PJD_7PARAM;
										out.datum_params[3] *= SEC_TO_RAD;
										out.datum_params[4] *= SEC_TO_RAD;
										out.datum_params[5] *= SEC_TO_RAD;
										out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;
									}
								}
							}

							if (nadgrids) {
								out.datum_type = PJD_GRIDSHIFT;
								out.grids = nadgrids;
							}
							out.a = a; //datum object also uses these values
							out.b = b;
							out.es = es;
							out.ep2 = ep2;
							return out;
						}

						/**
						 * Resources for details of NTv2 file formats:
						 * - https://web.archive.org/web/20140127204822if_/http://www.mgs.gov.on.ca:80/stdprodconsume/groups/content/@mgs/@iandit/documents/resourcelist/stel02_047447.pdf
						 * - http://mimaka.com/help/gs/html/004_NTV2%20Data%20Format.htm
						 */

						var loadedNadgrids = {};

						/**
						 * Load a binary NTv2 file (.gsb) to a key that can be used in a proj string like +nadgrids=<key>. Pass the NTv2 file
						 * as an ArrayBuffer.
						 */
						function nadgrid(key, data) {
							var view = new DataView(data);
							var isLittleEndian = detectLittleEndian(view);
							var header = readHeader(view, isLittleEndian);
							if (header.nSubgrids > 1) {
								console.log('Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored');
							}
							var subgrids = readSubgrids(view, header, isLittleEndian);
							var nadgrid = { header: header, subgrids: subgrids };
							loadedNadgrids[key] = nadgrid;
							return nadgrid;
						}

						/**
						 * Given a proj4 value for nadgrids, return an array of loaded grids
						 */
						function getNadgrids(nadgrids) {
							// Format details: http://proj.maptools.org/gen_parms.html
							if (nadgrids === undefined) { return null; }
							var grids = nadgrids.split(',');
							return grids.map(parseNadgridString);
						}

						function parseNadgridString(value) {
							if (value.length === 0) {
								return null;
							}
							var optional = value[0] === '@';
							if (optional) {
								value = value.slice(1);
							}
							if (value === 'null') {
								return { name: 'null', mandatory: !optional, grid: null, isNull: true };
							}
							return {
								name: value,
								mandatory: !optional,
								grid: loadedNadgrids[value] || null,
								isNull: false
							};
						}

						function secondsToRadians(seconds) {
							return (seconds / 3600) * Math.PI / 180;
						}

						function detectLittleEndian(view) {
							var nFields = view.getInt32(8, false);
							if (nFields === 11) {
								return false;
							}
							nFields = view.getInt32(8, true);
							if (nFields !== 11) {
								console.warn('Failed to detect nadgrid endian-ness, defaulting to little-endian');
							}
							return true;
						}

						function readHeader(view, isLittleEndian) {
							return {
								nFields: view.getInt32(8, isLittleEndian),
								nSubgridFields: view.getInt32(24, isLittleEndian),
								nSubgrids: view.getInt32(40, isLittleEndian),
								shiftType: decodeString(view, 56, 56 + 8).trim(),
								fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
								fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
								toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
								toSemiMinorAxis: view.getFloat64(168, isLittleEndian),
							};
						}

						function decodeString(view, start, end) {
							return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start, end)));
						}

						function readSubgrids(view, header, isLittleEndian) {
							var gridOffset = 176;
							var grids = [];
							for (var i = 0; i < header.nSubgrids; i++) {
								var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
								var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);
								var lngColumnCount = Math.round(
									1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval);
								var latColumnCount = Math.round(
									1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval);
								// Proj4 operates on radians whereas the coordinates are in seconds in the grid
								grids.push({
									ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
									del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
									lim: [lngColumnCount, latColumnCount],
									count: subHeader.gridNodeCount,
									cvs: mapNodes(nodes)
								});
							}
							return grids;
						}

						function mapNodes(nodes) {
							return nodes.map(function (r) { return [secondsToRadians(r.longitudeShift), secondsToRadians(r.latitudeShift)]; });
						}

						function readGridHeader(view, offset, isLittleEndian) {
							return {
								name: decodeString(view, offset + 8, offset + 16).trim(),
								parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
								lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
								upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
								lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
								upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
								latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
								longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
								gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
							};
						}

						function readGridNodes(view, offset, gridHeader, isLittleEndian) {
							var nodesOffset = offset + 176;
							var gridRecordLength = 16;
							var gridShiftRecords = [];
							for (var i = 0; i < gridHeader.gridNodeCount; i++) {
								var record = {
									latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),
									longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian),
									latitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian),
									longitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian),
								};
								gridShiftRecords.push(record);
							}
							return gridShiftRecords;
						}

						function Projection(srsCode, callback) {
							if (!(this instanceof Projection)) {
								return new Projection(srsCode);
							}
							callback = callback || function (error) {
								if (error) {
									throw error;
								}
							};
							var json = parse(srsCode);
							if (typeof json !== 'object') {
								callback(srsCode);
								return;
							}
							var ourProj = Projection.projections.get(json.projName);
							if (!ourProj) {
								callback(srsCode);
								return;
							}
							if (json.datumCode && json.datumCode !== 'none') {
								var datumDef = match(exports$3, json.datumCode);
								if (datumDef) {
									json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(',') : null);
									json.ellps = datumDef.ellipse;
									json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
								}
							}
							json.k0 = json.k0 || 1.0;
							json.axis = json.axis || 'enu';
							json.ellps = json.ellps || 'wgs84';
							json.lat1 = json.lat1 || json.lat0; // Lambert_Conformal_Conic_1SP, for example, needs this

							var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
							var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
							var nadgrids = getNadgrids(json.nadgrids);
							var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2,
								nadgrids);

							extend(this, json); // transfer everything over from the projection because we don't know what we'll need
							extend(this, ourProj); // transfer all the methods from the projection

							// copy the 4 things over we calulated in deriveConstants.sphere
							this.a = sphere_.a;
							this.b = sphere_.b;
							this.rf = sphere_.rf;
							this.sphere = sphere_.sphere;

							// copy the 3 things we calculated in deriveConstants.eccentricity
							this.es = ecc.es;
							this.e = ecc.e;
							this.ep2 = ecc.ep2;

							// add in the datum object
							this.datum = datumObj;

							// init the projection
							this.init();

							// legecy callback from back in the day when it went to spatialreference.org
							callback(null, this);

						}
						Projection.projections = projections;
						Projection.projections.start();
						function compareDatums(source, dest) {
							if (source.datum_type !== dest.datum_type) {
								return false; // false, datums are not equal
							} else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
								// the tolerance for es is to ensure that GRS80 and WGS84
								// are considered identical
								return false;
							} else if (source.datum_type === PJD_3PARAM) {
								return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);
							} else if (source.datum_type === PJD_7PARAM) {
								return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);
							} else {
								return true; // datums are equal
							}
						} // cs_compare_datums()

						/*
						 * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
						 * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
						 * according to the current ellipsoid parameters.
						 *
						 *    Latitude  : Geodetic latitude in radians                     (input)
						 *    Longitude : Geodetic longitude in radians                    (input)
						 *    Height    : Geodetic height, in meters                       (input)
						 *    X         : Calculated Geocentric X coordinate, in meters    (output)
						 *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
						 *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
						 *
						 */
						function geodeticToGeocentric(p, es, a) {
							var Longitude = p.x;
							var Latitude = p.y;
							var Height = p.z ? p.z : 0; //Z value not always supplied

							var Rn; /*  Earth radius at location  */
							var Sin_Lat; /*  Math.sin(Latitude)  */
							var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
							var Cos_Lat; /*  Math.cos(Latitude)  */

							/*
							 ** Don't blow up if Latitude is just a little out of the value
							 ** range as it may just be a rounding issue.  Also removed longitude
							 ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
							 */
							if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
								Latitude = -HALF_PI;
							} else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
								Latitude = HALF_PI;
							} else if (Latitude < -HALF_PI) {
								/* Latitude out of range */
								//..reportError('geocent:lat out of range:' + Latitude);
								return { x: -Infinity, y: -Infinity, z: p.z };
							} else if (Latitude > HALF_PI) {
								/* Latitude out of range */
								return { x: Infinity, y: Infinity, z: p.z };
							}

							if (Longitude > Math.PI) {
								Longitude -= (2 * Math.PI);
							}
							Sin_Lat = Math.sin(Latitude);
							Cos_Lat = Math.cos(Latitude);
							Sin2_Lat = Sin_Lat * Sin_Lat;
							Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));
							return {
								x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
								y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
								z: ((Rn * (1 - es)) + Height) * Sin_Lat
							};
						} // cs_geodetic_to_geocentric()

						function geocentricToGeodetic(p, es, a, b) {
							/* local defintions and variables */
							/* end-criterium of loop, accuracy of sin(Latitude) */
							var genau = 1e-12;
							var genau2 = (genau * genau);
							var maxiter = 30;

							var P; /* distance between semi-minor axis and location */
							var RR; /* distance between center and location */
							var CT; /* sin of geocentric latitude */
							var ST; /* cos of geocentric latitude */
							var RX;
							var RK;
							var RN; /* Earth radius at location */
							var CPHI0; /* cos of start or old geodetic latitude in iterations */
							var SPHI0; /* sin of start or old geodetic latitude in iterations */
							var CPHI; /* cos of searched geodetic latitude */
							var SPHI; /* sin of searched geodetic latitude */
							var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
							var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

							var X = p.x;
							var Y = p.y;
							var Z = p.z ? p.z : 0.0; //Z value not always supplied
							var Longitude;
							var Latitude;
							var Height;

							P = Math.sqrt(X * X + Y * Y);
							RR = Math.sqrt(X * X + Y * Y + Z * Z);

							/*      special cases for latitude and longitude */
							if (P / a < genau) {

								/*  special case, if P=0. (X=0., Y=0.) */
								Longitude = 0.0;

								/*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
								 *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
								if (RR / a < genau) {
									Latitude = HALF_PI;
									Height = -b;
									return {
										x: p.x,
										y: p.y,
										z: p.z
									};
								}
							} else {
								/*  ellipsoidal (geodetic) longitude
								 *  interval: -PI < Longitude <= +PI */
								Longitude = Math.atan2(Y, X);
							}

							/* --------------------------------------------------------------
							 * Following iterative algorithm was developped by
							 * "Institut for Erdmessung", University of Hannover, July 1988.
							 * Internet: www.ife.uni-hannover.de
							 * Iterative computation of CPHI,SPHI and Height.
							 * Iteration of CPHI and SPHI to 10**-12 radian resp.
							 * 2*10**-7 arcsec.
							 * --------------------------------------------------------------
							 */
							CT = Z / RR;
							ST = P / RR;
							RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
							CPHI0 = ST * (1.0 - es) * RX;
							SPHI0 = CT * RX;
							iter = 0;

							/* loop to find sin(Latitude) resp. Latitude
							 * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
							do {
								iter++;
								RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);

								/*  ellipsoidal (geodetic) height */
								Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);

								RK = es * RN / (RN + Height);
								RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
								CPHI = ST * (1.0 - RK) * RX;
								SPHI = CT * RX;
								SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
								CPHI0 = CPHI;
								SPHI0 = SPHI;
							}
							while (SDPHI * SDPHI > genau2 && iter < maxiter);

							/*      ellipsoidal (geodetic) latitude */
							Latitude = Math.atan(SPHI / Math.abs(CPHI));
							return {
								x: Longitude,
								y: Latitude,
								z: Height
							};
						} // cs_geocentric_to_geodetic()

						/****************************************************************/
						// pj_geocentic_to_wgs84( p )
						//  p = point to transform in geocentric coordinates (x,y,z)


						/** point object, nothing fancy, just allows values to be
							passed back and forth by reference rather than by value.
							Other point classes may be used as long as they have
							x and y properties, which will get modified in the transform method.
						*/
						function geocentricToWgs84(p, datum_type, datum_params) {

							if (datum_type === PJD_3PARAM) {
								// if( x[io] === HUGE_VAL )
								//    continue;
								return {
									x: p.x + datum_params[0],
									y: p.y + datum_params[1],
									z: p.z + datum_params[2],
								};
							} else if (datum_type === PJD_7PARAM) {
								var Dx_BF = datum_params[0];
								var Dy_BF = datum_params[1];
								var Dz_BF = datum_params[2];
								var Rx_BF = datum_params[3];
								var Ry_BF = datum_params[4];
								var Rz_BF = datum_params[5];
								var M_BF = datum_params[6];
								// if( x[io] === HUGE_VAL )
								//    continue;
								return {
									x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
									y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
									z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
								};
							}
						} // cs_geocentric_to_wgs84

						/****************************************************************/
						// pj_geocentic_from_wgs84()
						//  coordinate system definition,
						//  point to transform in geocentric coordinates (x,y,z)
						function geocentricFromWgs84(p, datum_type, datum_params) {

							if (datum_type === PJD_3PARAM) {
								//if( x[io] === HUGE_VAL )
								//    continue;
								return {
									x: p.x - datum_params[0],
									y: p.y - datum_params[1],
									z: p.z - datum_params[2],
								};

							} else if (datum_type === PJD_7PARAM) {
								var Dx_BF = datum_params[0];
								var Dy_BF = datum_params[1];
								var Dz_BF = datum_params[2];
								var Rx_BF = datum_params[3];
								var Ry_BF = datum_params[4];
								var Rz_BF = datum_params[5];
								var M_BF = datum_params[6];
								var x_tmp = (p.x - Dx_BF) / M_BF;
								var y_tmp = (p.y - Dy_BF) / M_BF;
								var z_tmp = (p.z - Dz_BF) / M_BF;
								//if( x[io] === HUGE_VAL )
								//    continue;

								return {
									x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
									y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
									z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
								};
							} //cs_geocentric_from_wgs84()
						}

						function checkParams(type) {
							return (type === PJD_3PARAM || type === PJD_7PARAM);
						}

						var datum_transform = function (source, dest, point) {
							// Short cut if the datums are identical.
							if (compareDatums(source, dest)) {
								return point; // in this case, zero is sucess,
								// whereas cs_compare_datums returns 1 to indicate TRUE
								// confusing, should fix this
							}

							// Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
							if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
								return point;
							}

							// If this datum requires grid shifts, then apply it to geodetic coordinates.
							var source_a = source.a;
							var source_es = source.es;
							if (source.datum_type === PJD_GRIDSHIFT) {
								var gridShiftCode = applyGridShift(source, false, point);
								if (gridShiftCode !== 0) {
									return undefined;
								}
								source_a = SRS_WGS84_SEMIMAJOR;
								source_es = SRS_WGS84_ESQUARED;
							}

							var dest_a = dest.a;
							var dest_b = dest.b;
							var dest_es = dest.es;
							if (dest.datum_type === PJD_GRIDSHIFT) {
								dest_a = SRS_WGS84_SEMIMAJOR;
								dest_b = SRS_WGS84_SEMIMINOR;
								dest_es = SRS_WGS84_ESQUARED;
							}

							// Do we need to go through geocentric coordinates?
							if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {
								return point;
							}

							// Convert to geocentric coordinates.
							point = geodeticToGeocentric(point, source_es, source_a);
							// Convert between datums
							if (checkParams(source.datum_type)) {
								point = geocentricToWgs84(point, source.datum_type, source.datum_params);
							}
							if (checkParams(dest.datum_type)) {
								point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
							}
							point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);

							if (dest.datum_type === PJD_GRIDSHIFT) {
								var destGridShiftResult = applyGridShift(dest, true, point);
								if (destGridShiftResult !== 0) {
									return undefined;
								}
							}

							return point;
						};

						function applyGridShift(source, inverse, point) {
							if (source.grids === null || source.grids.length === 0) {
								console.log('Grid shift grids not found');
								return -1;
							}
							var input = { x: -point.x, y: point.y };
							var output = { x: Number.NaN, y: Number.NaN };
							var attemptedGrids = [];
							for (var i = 0; i < source.grids.length; i++) {
								var grid = source.grids[i];
								attemptedGrids.push(grid.name);
								if (grid.isNull) {
									output = input;
									break;
								}
								if (grid.grid === null) {
									if (grid.mandatory) {
										console.log("Unable to find mandatory grid '" + grid.name + "'");
										return -1;
									}
									continue;
								}
								var subgrid = grid.grid.subgrids[0];
								// skip tables that don't match our point at all
								var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;
								var minX = subgrid.ll[0] - epsilon;
								var minY = subgrid.ll[1] - epsilon;
								var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;
								var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;
								if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) {
									continue;
								}
								output = applySubgridShift(input, inverse, subgrid);
								if (!isNaN(output.x)) {
									break;
								}
							}
							if (isNaN(output.x)) {
								console.log("Failed to find a grid shift table for location '" +
									-input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
								return -1;
							}
							point.x = -output.x;
							point.y = output.y;
							return 0;
						}

						function applySubgridShift(pin, inverse, ct) {
							var val = { x: Number.NaN, y: Number.NaN };
							if (isNaN(pin.x)) { return val; }
							var tb = { x: pin.x, y: pin.y };
							tb.x -= ct.ll[0];
							tb.y -= ct.ll[1];
							tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;
							var t = nadInterpolate(tb, ct);
							if (inverse) {
								if (isNaN(t.x)) {
									return val;
								}
								t.x = tb.x - t.x;
								t.y = tb.y - t.y;
								var i = 9, tol = 1e-12;
								var dif, del;
								do {
									del = nadInterpolate(t, ct);
									if (isNaN(del.x)) {
										console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
										break;
									}
									dif = { x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y) };
									t.x += dif.x;
									t.y += dif.y;
								} while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
								if (i < 0) {
									console.log("Inverse grid shift iterator failed to converge.");
									return val;
								}
								val.x = adjust_lon(t.x + ct.ll[0]);
								val.y = t.y + ct.ll[1];
							} else {
								if (!isNaN(t.x)) {
									val.x = pin.x + t.x;
									val.y = pin.y + t.y;
								}
							}
							return val;
						}

						function nadInterpolate(pin, ct) {
							var t = { x: pin.x / ct.del[0], y: pin.y / ct.del[1] };
							var indx = { x: Math.floor(t.x), y: Math.floor(t.y) };
							var frct = { x: t.x - 1.0 * indx.x, y: t.y - 1.0 * indx.y };
							var val = { x: Number.NaN, y: Number.NaN };
							var inx;
							if (indx.x < 0 || indx.x >= ct.lim[0]) {
								return val;
							}
							if (indx.y < 0 || indx.y >= ct.lim[1]) {
								return val;
							}
							inx = (indx.y * ct.lim[0]) + indx.x;
							var f00 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
							inx++;
							var f10 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
							inx += ct.lim[0];
							var f11 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
							inx--;
							var f01 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
							var m11 = frct.x * frct.y, m10 = frct.x * (1.0 - frct.y),
								m00 = (1.0 - frct.x) * (1.0 - frct.y), m01 = (1.0 - frct.x) * frct.y;
							val.x = (m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x);
							val.y = (m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y);
							return val;
						}

						var adjust_axis = function (crs, denorm, point) {
							var xin = point.x,
								yin = point.y,
								zin = point.z || 0.0;
							var v, t, i;
							var out = {};
							for (i = 0; i < 3; i++) {
								if (denorm && i === 2 && point.z === undefined) {
									continue;
								}
								if (i === 0) {
									v = xin;
									if ("ew".indexOf(crs.axis[i]) !== -1) {
										t = 'x';
									} else {
										t = 'y';
									}

								}
								else if (i === 1) {
									v = yin;
									if ("ns".indexOf(crs.axis[i]) !== -1) {
										t = 'y';
									} else {
										t = 'x';
									}
								}
								else {
									v = zin;
									t = 'z';
								}
								switch (crs.axis[i]) {
									case 'e':
										out[t] = v;
										break;
									case 'w':
										out[t] = -v;
										break;
									case 'n':
										out[t] = v;
										break;
									case 's':
										out[t] = -v;
										break;
									case 'u':
										if (point[t] !== undefined) {
											out.z = v;
										}
										break;
									case 'd':
										if (point[t] !== undefined) {
											out.z = -v;
										}
										break;
									default:
										//console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
										return null;
								}
							}
							return out;
						};

						var toPoint = function (array) {
							var out = {
								x: array[0],
								y: array[1]
							};
							if (array.length > 2) {
								out.z = array[2];
							}
							if (array.length > 3) {
								out.m = array[3];
							}
							return out;
						};

						var checkSanity = function (point) {
							checkCoord(point.x);
							checkCoord(point.y);
						};
						function checkCoord(num) {
							if (typeof Number.isFinite === 'function') {
								if (Number.isFinite(num)) {
									return;
								}
								throw new TypeError('coordinates must be finite numbers');
							}
							if (typeof num !== 'number' || num !== num || !isFinite(num)) {
								throw new TypeError('coordinates must be finite numbers');
							}
						}

						function checkNotWGS(source, dest) {
							return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84');
						}

						function transform(source, dest, point) {
							var wgs84;
							if (Array.isArray(point)) {
								point = toPoint(point);
							}
							checkSanity(point);
							// Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
							if (source.datum && dest.datum && checkNotWGS(source, dest)) {
								wgs84 = new Projection('WGS84');
								point = transform(source, wgs84, point);
								source = wgs84;
							}
							// DGR, 2010/11/12
							if (source.axis !== 'enu') {
								point = adjust_axis(source, false, point);
							}
							// Transform source points to long/lat, if they aren't already.
							if (source.projName === 'longlat') {
								point = {
									x: point.x * D2R,
									y: point.y * D2R,
									z: point.z || 0
								};
							} else {
								if (source.to_meter) {
									point = {
										x: point.x * source.to_meter,
										y: point.y * source.to_meter,
										z: point.z || 0
									};
								}
								point = source.inverse(point); // Convert Cartesian to longlat
								if (!point) {
									return;
								}
							}
							// Adjust for the prime meridian if necessary
							if (source.from_greenwich) {
								point.x += source.from_greenwich;
							}

							// Convert datums if needed, and if possible.
							point = datum_transform(source.datum, dest.datum, point);
							if (!point) {
								return;
							}

							// Adjust for the prime meridian if necessary
							if (dest.from_greenwich) {
								point = {
									x: point.x - dest.from_greenwich,
									y: point.y,
									z: point.z || 0
								};
							}

							if (dest.projName === 'longlat') {
								// convert radians to decimal degrees
								point = {
									x: point.x * R2D,
									y: point.y * R2D,
									z: point.z || 0
								};
							} else { // else project
								point = dest.forward(point);
								if (dest.to_meter) {
									point = {
										x: point.x / dest.to_meter,
										y: point.y / dest.to_meter,
										z: point.z || 0
									};
								}
							}

							// DGR, 2010/11/12
							if (dest.axis !== 'enu') {
								return adjust_axis(dest, true, point);
							}

							return point;
						}

						var wgs84 = Projection('WGS84');

						function transformer(from, to, coords) {
							var transformedArray, out, keys;
							if (Array.isArray(coords)) {
								transformedArray = transform(from, to, coords) || { x: NaN, y: NaN };
								if (coords.length > 2) {
									if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
										if (typeof transformedArray.z === 'number') {
											return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
										} else {
											return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
										}
									} else {
										return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
									}
								} else {
									return [transformedArray.x, transformedArray.y];
								}
							} else {
								out = transform(from, to, coords);
								keys = Object.keys(coords);
								if (keys.length === 2) {
									return out;
								}
								keys.forEach(function (key) {
									if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
										if (key === 'x' || key === 'y' || key === 'z') {
											return;
										}
									} else {
										if (key === 'x' || key === 'y') {
											return;
										}
									}
									out[key] = coords[key];
								});
								return out;
							}
						}

						function checkProj(item) {
							if (item instanceof Projection) {
								return item;
							}
							if (item.oProj) {
								return item.oProj;
							}
							return Projection(item);
						}

						function proj4$1(fromProj, toProj, coord) {
							fromProj = checkProj(fromProj);
							var single = false;
							var obj;
							if (typeof toProj === 'undefined') {
								toProj = fromProj;
								fromProj = wgs84;
								single = true;
							} else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
								coord = toProj;
								toProj = fromProj;
								fromProj = wgs84;
								single = true;
							}
							toProj = checkProj(toProj);
							if (coord) {
								return transformer(fromProj, toProj, coord);
							} else {
								obj = {
									forward: function (coords) {
										return transformer(fromProj, toProj, coords);
									},
									inverse: function (coords) {
										return transformer(toProj, fromProj, coords);
									}
								};
								if (single) {
									obj.oProj = toProj;
								}
								return obj;
							}
						}

						/**
						 * UTM zones are grouped, and assigned to one of a group of 6
						 * sets.
						 *
						 * {int} @private
						 */
						var NUM_100K_SETS = 6;

						/**
						 * The column letters (for easting) of the lower left value, per
						 * set.
						 *
						 * {string} @private
						 */
						var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';

						/**
						 * The row letters (for northing) of the lower left value, per
						 * set.
						 *
						 * {string} @private
						 */
						var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';

						var A = 65; // A
						var I = 73; // I
						var O = 79; // O
						var V = 86; // V
						var Z = 90; // Z
						var mgrs = {
							forward: forward$1,
							inverse: inverse$1,
							toPoint: toPoint$1
						};
						/**
						 * Conversion of lat/lon to MGRS.
						 *
						 * @param {object} ll Object literal with lat and lon properties on a
						 *     WGS84 ellipsoid.
						 * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
						 *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
						 * @return {string} the MGRS string for the given location and accuracy.
						 */
						function forward$1(ll, accuracy) {
							accuracy = accuracy || 5; // default accuracy 1m
							return encode(LLtoUTM({
								lat: ll[1],
								lon: ll[0]
							}), accuracy);
						}

						/**
						 * Conversion of MGRS to lat/lon.
						 *
						 * @param {string} mgrs MGRS string.
						 * @return {array} An array with left (longitude), bottom (latitude), right
						 *     (longitude) and top (latitude) values in WGS84, representing the
						 *     bounding box for the provided MGRS reference.
						 */
						function inverse$1(mgrs) {
							var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
							if (bbox.lat && bbox.lon) {
								return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
							}
							return [bbox.left, bbox.bottom, bbox.right, bbox.top];
						}

						function toPoint$1(mgrs) {
							var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
							if (bbox.lat && bbox.lon) {
								return [bbox.lon, bbox.lat];
							}
							return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
						}
						/**
						 * Conversion from degrees to radians.
						 *
						 * @private
						 * @param {number} deg the angle in degrees.
						 * @return {number} the angle in radians.
						 */
						function degToRad(deg) {
							return (deg * (Math.PI / 180.0));
						}

						/**
						 * Conversion from radians to degrees.
						 *
						 * @private
						 * @param {number} rad the angle in radians.
						 * @return {number} the angle in degrees.
						 */
						function radToDeg(rad) {
							return (180.0 * (rad / Math.PI));
						}

						/**
						 * Converts a set of Longitude and Latitude co-ordinates to UTM
						 * using the WGS84 ellipsoid.
						 *
						 * @private
						 * @param {object} ll Object literal with lat and lon properties
						 *     representing the WGS84 coordinate to be converted.
						 * @return {object} Object literal containing the UTM value with easting,
						 *     northing, zoneNumber and zoneLetter properties, and an optional
						 *     accuracy property in digits. Returns null if the conversion failed.
						 */
						function LLtoUTM(ll) {
							var Lat = ll.lat;
							var Long = ll.lon;
							var a = 6378137.0; //ellip.radius;
							var eccSquared = 0.00669438; //ellip.eccsq;
							var k0 = 0.9996;
							var LongOrigin;
							var eccPrimeSquared;
							var N, T, C, A, M;
							var LatRad = degToRad(Lat);
							var LongRad = degToRad(Long);
							var LongOriginRad;
							var ZoneNumber;
							// (int)
							ZoneNumber = Math.floor((Long + 180) / 6) + 1;

							//Make sure the longitude 180.00 is in Zone 60
							if (Long === 180) {
								ZoneNumber = 60;
							}

							// Special zone for Norway
							if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
								ZoneNumber = 32;
							}

							// Special zones for Svalbard
							if (Lat >= 72.0 && Lat < 84.0) {
								if (Long >= 0.0 && Long < 9.0) {
									ZoneNumber = 31;
								}
								else if (Long >= 9.0 && Long < 21.0) {
									ZoneNumber = 33;
								}
								else if (Long >= 21.0 && Long < 33.0) {
									ZoneNumber = 35;
								}
								else if (Long >= 33.0 && Long < 42.0) {
									ZoneNumber = 37;
								}
							}

							LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
							// in middle of
							// zone
							LongOriginRad = degToRad(LongOrigin);

							eccPrimeSquared = (eccSquared) / (1 - eccSquared);

							N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
							T = Math.tan(LatRad) * Math.tan(LatRad);
							C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
							A = Math.cos(LatRad) * (LongRad - LongOriginRad);

							M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));

							var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);

							var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));
							if (Lat < 0.0) {
								UTMNorthing += 10000000.0; //10000000 meter offset for
								// southern hemisphere
							}

							return {
								northing: Math.round(UTMNorthing),
								easting: Math.round(UTMEasting),
								zoneNumber: ZoneNumber,
								zoneLetter: getLetterDesignator(Lat)
							};
						}

						/**
						 * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
						 * class where the Zone can be specified as a single string eg."60N" which
						 * is then broken down into the ZoneNumber and ZoneLetter.
						 *
						 * @private
						 * @param {object} utm An object literal with northing, easting, zoneNumber
						 *     and zoneLetter properties. If an optional accuracy property is
						 *     provided (in meters), a bounding box will be returned instead of
						 *     latitude and longitude.
						 * @return {object} An object literal containing either lat and lon values
						 *     (if no accuracy was provided), or top, right, bottom and left values
						 *     for the bounding box calculated according to the provided accuracy.
						 *     Returns null if the conversion failed.
						 */
						function UTMtoLL(utm) {

							var UTMNorthing = utm.northing;
							var UTMEasting = utm.easting;
							var zoneLetter = utm.zoneLetter;
							var zoneNumber = utm.zoneNumber;
							// check the ZoneNummber is valid
							if (zoneNumber < 0 || zoneNumber > 60) {
								return null;
							}

							var k0 = 0.9996;
							var a = 6378137.0; //ellip.radius;
							var eccSquared = 0.00669438; //ellip.eccsq;
							var eccPrimeSquared;
							var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
							var N1, T1, C1, R1, D, M;
							var LongOrigin;
							var mu, phi1Rad;

							// remove 500,000 meter offset for longitude
							var x = UTMEasting - 500000.0;
							var y = UTMNorthing;

							// We must know somehow if we are in the Northern or Southern
							// hemisphere, this is the only time we use the letter So even
							// if the Zone letter isn't exactly correct it should indicate
							// the hemisphere correctly
							if (zoneLetter < 'N') {
								y -= 10000000.0; // remove 10,000,000 meter offset used
								// for southern hemisphere
							}

							// There are 60 zones with zone 1 being at West -180 to -174
							LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
							// in middle of
							// zone

							eccPrimeSquared = (eccSquared) / (1 - eccSquared);

							M = y / k0;
							mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));

							phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);
							// double phi1 = ProjMath.radToDeg(phi1Rad);

							N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
							T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
							C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
							R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
							D = x / (N1 * k0);

							var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
							lat = radToDeg(lat);

							var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
							lon = LongOrigin + radToDeg(lon);

							var result;
							if (utm.accuracy) {
								var topRight = UTMtoLL({
									northing: utm.northing + utm.accuracy,
									easting: utm.easting + utm.accuracy,
									zoneLetter: utm.zoneLetter,
									zoneNumber: utm.zoneNumber
								});
								result = {
									top: topRight.lat,
									right: topRight.lon,
									bottom: lat,
									left: lon
								};
							}
							else {
								result = {
									lat: lat,
									lon: lon
								};
							}
							return result;
						}

						/**
						 * Calculates the MGRS letter designator for the given latitude.
						 *
						 * @private
						 * @param {number} lat The latitude in WGS84 to get the letter designator
						 *     for.
						 * @return {char} The letter designator.
						 */
						function getLetterDesignator(lat) {
							//This is here as an error flag to show that the Latitude is
							//outside MGRS limits
							var LetterDesignator = 'Z';

							if ((84 >= lat) && (lat >= 72)) {
								LetterDesignator = 'X';
							}
							else if ((72 > lat) && (lat >= 64)) {
								LetterDesignator = 'W';
							}
							else if ((64 > lat) && (lat >= 56)) {
								LetterDesignator = 'V';
							}
							else if ((56 > lat) && (lat >= 48)) {
								LetterDesignator = 'U';
							}
							else if ((48 > lat) && (lat >= 40)) {
								LetterDesignator = 'T';
							}
							else if ((40 > lat) && (lat >= 32)) {
								LetterDesignator = 'S';
							}
							else if ((32 > lat) && (lat >= 24)) {
								LetterDesignator = 'R';
							}
							else if ((24 > lat) && (lat >= 16)) {
								LetterDesignator = 'Q';
							}
							else if ((16 > lat) && (lat >= 8)) {
								LetterDesignator = 'P';
							}
							else if ((8 > lat) && (lat >= 0)) {
								LetterDesignator = 'N';
							}
							else if ((0 > lat) && (lat >= -8)) {
								LetterDesignator = 'M';
							}
							else if ((-8 > lat) && (lat >= -16)) {
								LetterDesignator = 'L';
							}
							else if ((-16 > lat) && (lat >= -24)) {
								LetterDesignator = 'K';
							}
							else if ((-24 > lat) && (lat >= -32)) {
								LetterDesignator = 'J';
							}
							else if ((-32 > lat) && (lat >= -40)) {
								LetterDesignator = 'H';
							}
							else if ((-40 > lat) && (lat >= -48)) {
								LetterDesignator = 'G';
							}
							else if ((-48 > lat) && (lat >= -56)) {
								LetterDesignator = 'F';
							}
							else if ((-56 > lat) && (lat >= -64)) {
								LetterDesignator = 'E';
							}
							else if ((-64 > lat) && (lat >= -72)) {
								LetterDesignator = 'D';
							}
							else if ((-72 > lat) && (lat >= -80)) {
								LetterDesignator = 'C';
							}
							return LetterDesignator;
						}

						/**
						 * Encodes a UTM location as MGRS string.
						 *
						 * @private
						 * @param {object} utm An object literal with easting, northing,
						 *     zoneLetter, zoneNumber
						 * @param {number} accuracy Accuracy in digits (1-5).
						 * @return {string} MGRS string for the given UTM location.
						 */
						function encode(utm, accuracy) {
							// prepend with leading zeroes
							var seasting = "00000" + utm.easting,
								snorthing = "00000" + utm.northing;

							return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
						}

						/**
						 * Get the two letter 100k designator for a given UTM easting,
						 * northing and zone number value.
						 *
						 * @private
						 * @param {number} easting
						 * @param {number} northing
						 * @param {number} zoneNumber
						 * @return the two letter 100k designator for the given UTM location.
						 */
						function get100kID(easting, northing, zoneNumber) {
							var setParm = get100kSetForZone(zoneNumber);
							var setColumn = Math.floor(easting / 100000);
							var setRow = Math.floor(northing / 100000) % 20;
							return getLetter100kID(setColumn, setRow, setParm);
						}

						/**
						 * Given a UTM zone number, figure out the MGRS 100K set it is in.
						 *
						 * @private
						 * @param {number} i An UTM zone number.
						 * @return {number} the 100k set the UTM zone is in.
						 */
						function get100kSetForZone(i) {
							var setParm = i % NUM_100K_SETS;
							if (setParm === 0) {
								setParm = NUM_100K_SETS;
							}

							return setParm;
						}

						/**
						 * Get the two-letter MGRS 100k designator given information
						 * translated from the UTM northing, easting and zone number.
						 *
						 * @private
						 * @param {number} column the column index as it relates to the MGRS
						 *        100k set spreadsheet, created from the UTM easting.
						 *        Values are 1-8.
						 * @param {number} row the row index as it relates to the MGRS 100k set
						 *        spreadsheet, created from the UTM northing value. Values
						 *        are from 0-19.
						 * @param {number} parm the set block, as it relates to the MGRS 100k set
						 *        spreadsheet, created from the UTM zone. Values are from
						 *        1-60.
						 * @return two letter MGRS 100k code.
						 */
						function getLetter100kID(column, row, parm) {
							// colOrigin and rowOrigin are the letters at the origin of the set
							var index = parm - 1;
							var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
							var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);

							// colInt and rowInt are the letters to build to return
							var colInt = colOrigin + column - 1;
							var rowInt = rowOrigin + row;
							var rollover = false;

							if (colInt > Z) {
								colInt = colInt - Z + A - 1;
								rollover = true;
							}

							if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {
								colInt++;
							}

							if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {
								colInt++;

								if (colInt === I) {
									colInt++;
								}
							}

							if (colInt > Z) {
								colInt = colInt - Z + A - 1;
							}

							if (rowInt > V) {
								rowInt = rowInt - V + A - 1;
								rollover = true;
							}
							else {
								rollover = false;
							}

							if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {
								rowInt++;
							}

							if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {
								rowInt++;

								if (rowInt === I) {
									rowInt++;
								}
							}

							if (rowInt > V) {
								rowInt = rowInt - V + A - 1;
							}

							var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
							return twoLetter;
						}

						/**
						 * Decode the UTM parameters from a MGRS string.
						 *
						 * @private
						 * @param {string} mgrsString an UPPERCASE coordinate string is expected.
						 * @return {object} An object literal with easting, northing, zoneLetter,
						 *     zoneNumber and accuracy (in meters) properties.
						 */
						function decode(mgrsString) {

							if (mgrsString && mgrsString.length === 0) {
								throw ("MGRSPoint coverting from nothing");
							}

							var length = mgrsString.length;

							var hunK = null;
							var sb = "";
							var testChar;
							var i = 0;

							// get Zone number
							while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {
								if (i >= 2) {
									throw ("MGRSPoint bad conversion from: " + mgrsString);
								}
								sb += testChar;
								i++;
							}

							var zoneNumber = parseInt(sb, 10);

							if (i === 0 || i + 3 > length) {
								// A good MGRS string has to be 4-5 digits long,
								// ##AAA/#AAA at least.
								throw ("MGRSPoint bad conversion from: " + mgrsString);
							}

							var zoneLetter = mgrsString.charAt(i++);

							// Should we check the zone letter here? Why not.
							if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
								throw ("MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString);
							}

							hunK = mgrsString.substring(i, i += 2);

							var set = get100kSetForZone(zoneNumber);

							var east100k = getEastingFromChar(hunK.charAt(0), set);
							var north100k = getNorthingFromChar(hunK.charAt(1), set);

							// We have a bug where the northing may be 2000000 too low.
							// How
							// do we know when to roll over?

							while (north100k < getMinNorthing(zoneLetter)) {
								north100k += 2000000;
							}

							// calculate the char index for easting/northing separator
							var remainder = length - i;

							if (remainder % 2 !== 0) {
								throw ("MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString);
							}

							var sep = remainder / 2;

							var sepEasting = 0.0;
							var sepNorthing = 0.0;
							var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
							if (sep > 0) {
								accuracyBonus = 100000.0 / Math.pow(10, sep);
								sepEastingString = mgrsString.substring(i, i + sep);
								sepEasting = parseFloat(sepEastingString) * accuracyBonus;
								sepNorthingString = mgrsString.substring(i + sep);
								sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
							}

							easting = sepEasting + east100k;
							northing = sepNorthing + north100k;

							return {
								easting: easting,
								northing: northing,
								zoneLetter: zoneLetter,
								zoneNumber: zoneNumber,
								accuracy: accuracyBonus
							};
						}

						/**
						 * Given the first letter from a two-letter MGRS 100k zone, and given the
						 * MGRS table set for the zone number, figure out the easting value that
						 * should be added to the other, secondary easting value.
						 *
						 * @private
						 * @param {char} e The first letter from a two-letter MGRS 100´k zone.
						 * @param {number} set The MGRS table set for the zone number.
						 * @return {number} The easting value for the given letter and set.
						 */
						function getEastingFromChar(e, set) {
							// colOrigin is the letter at the origin of the set for the
							// column
							var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
							var eastingValue = 100000.0;
							var rewindMarker = false;

							while (curCol !== e.charCodeAt(0)) {
								curCol++;
								if (curCol === I) {
									curCol++;
								}
								if (curCol === O) {
									curCol++;
								}
								if (curCol > Z) {
									if (rewindMarker) {
										throw ("Bad character: " + e);
									}
									curCol = A;
									rewindMarker = true;
								}
								eastingValue += 100000.0;
							}

							return eastingValue;
						}

						/**
						 * Given the second letter from a two-letter MGRS 100k zone, and given the
						 * MGRS table set for the zone number, figure out the northing value that
						 * should be added to the other, secondary northing value. You have to
						 * remember that Northings are determined from the equator, and the vertical
						 * cycle of letters mean a 2000000 additional northing meters. This happens
						 * approx. every 18 degrees of latitude. This method does *NOT* count any
						 * additional northings. You have to figure out how many 2000000 meters need
						 * to be added for the zone letter of the MGRS coordinate.
						 *
						 * @private
						 * @param {char} n Second letter of the MGRS 100k zone
						 * @param {number} set The MGRS table set number, which is dependent on the
						 *     UTM zone number.
						 * @return {number} The northing value for the given letter and set.
						 */
						function getNorthingFromChar(n, set) {

							if (n > 'V') {
								throw ("MGRSPoint given invalid Northing " + n);
							}

							// rowOrigin is the letter at the origin of the set for the
							// column
							var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
							var northingValue = 0.0;
							var rewindMarker = false;

							while (curRow !== n.charCodeAt(0)) {
								curRow++;
								if (curRow === I) {
									curRow++;
								}
								if (curRow === O) {
									curRow++;
								}
								// fixing a bug making whole application hang in this loop
								// when 'n' is a wrong character
								if (curRow > V) {
									if (rewindMarker) { // making sure that this loop ends
										throw ("Bad character: " + n);
									}
									curRow = A;
									rewindMarker = true;
								}
								northingValue += 100000.0;
							}

							return northingValue;
						}

						/**
						 * The function getMinNorthing returns the minimum northing value of a MGRS
						 * zone.
						 *
						 * Ported from Geotrans' c Lattitude_Band_Value structure table.
						 *
						 * @private
						 * @param {char} zoneLetter The MGRS zone to get the min northing for.
						 * @return {number}
						 */
						function getMinNorthing(zoneLetter) {
							var northing;
							switch (zoneLetter) {
								case 'C':
									northing = 1100000.0;
									break;
								case 'D':
									northing = 2000000.0;
									break;
								case 'E':
									northing = 2800000.0;
									break;
								case 'F':
									northing = 3700000.0;
									break;
								case 'G':
									northing = 4600000.0;
									break;
								case 'H':
									northing = 5500000.0;
									break;
								case 'J':
									northing = 6400000.0;
									break;
								case 'K':
									northing = 7300000.0;
									break;
								case 'L':
									northing = 8200000.0;
									break;
								case 'M':
									northing = 9100000.0;
									break;
								case 'N':
									northing = 0.0;
									break;
								case 'P':
									northing = 800000.0;
									break;
								case 'Q':
									northing = 1700000.0;
									break;
								case 'R':
									northing = 2600000.0;
									break;
								case 'S':
									northing = 3500000.0;
									break;
								case 'T':
									northing = 4400000.0;
									break;
								case 'U':
									northing = 5300000.0;
									break;
								case 'V':
									northing = 6200000.0;
									break;
								case 'W':
									northing = 7000000.0;
									break;
								case 'X':
									northing = 7900000.0;
									break;
								default:
									northing = -1.0;
							}
							if (northing >= 0.0) {
								return northing;
							}
							else {
								throw ("Invalid zone letter: " + zoneLetter);
							}

						}

						function Point(x, y, z) {
							if (!(this instanceof Point)) {
								return new Point(x, y, z);
							}
							if (Array.isArray(x)) {
								this.x = x[0];
								this.y = x[1];
								this.z = x[2] || 0.0;
							} else if (typeof x === 'object') {
								this.x = x.x;
								this.y = x.y;
								this.z = x.z || 0.0;
							} else if (typeof x === 'string' && typeof y === 'undefined') {
								var coords = x.split(',');
								this.x = parseFloat(coords[0], 10);
								this.y = parseFloat(coords[1], 10);
								this.z = parseFloat(coords[2], 10) || 0.0;
							} else {
								this.x = x;
								this.y = y;
								this.z = z || 0.0;
							}
							console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
						}

						Point.fromMGRS = function (mgrsStr) {
							return new Point(toPoint$1(mgrsStr));
						};
						Point.prototype.toMGRS = function (accuracy) {
							return forward$1([this.x, this.y], accuracy);
						};

						var C00 = 1;
						var C02 = 0.25;
						var C04 = 0.046875;
						var C06 = 0.01953125;
						var C08 = 0.01068115234375;
						var C22 = 0.75;
						var C44 = 0.46875;
						var C46 = 0.01302083333333333333;
						var C48 = 0.00712076822916666666;
						var C66 = 0.36458333333333333333;
						var C68 = 0.00569661458333333333;
						var C88 = 0.3076171875;

						var pj_enfn = function (es) {
							var en = [];
							en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
							en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
							var t = es * es;
							en[2] = t * (C44 - es * (C46 + es * C48));
							t *= es;
							en[3] = t * (C66 - es * C68);
							en[4] = t * es * C88;
							return en;
						};

						var pj_mlfn = function (phi, sphi, cphi, en) {
							cphi *= sphi;
							sphi *= sphi;
							return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
						};

						var MAX_ITER = 20;

						var pj_inv_mlfn = function (arg, es, en) {
							var k = 1 / (1 - es);
							var phi = arg;
							for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */
								var s = Math.sin(phi);
								var t = 1 - es * s * s;
								//t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
								//phi -= t * (t * Math.sqrt(t)) * k;
								t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
								phi -= t;
								if (Math.abs(t) < EPSLN) {
									return phi;
								}
							}
							//..reportError("cass:pj_inv_mlfn: Convergence error");
							return phi;
						};

						// Heavily based on this tmerc projection implementation
						// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/tmerc.js

						function init$2() {
							this.x0 = this.x0 !== undefined ? this.x0 : 0;
							this.y0 = this.y0 !== undefined ? this.y0 : 0;
							this.long0 = this.long0 !== undefined ? this.long0 : 0;
							this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

							if (this.es) {
								this.en = pj_enfn(this.es);
								this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
							}
						}

						/**
							Transverse Mercator Forward  - long/lat to x/y
							long/lat in radians
						  */
						function forward$2(p) {
							var lon = p.x;
							var lat = p.y;

							var delta_lon = adjust_lon(lon - this.long0);
							var con;
							var x, y;
							var sin_phi = Math.sin(lat);
							var cos_phi = Math.cos(lat);

							if (!this.es) {
								var b = cos_phi * Math.sin(delta_lon);

								if ((Math.abs(Math.abs(b) - 1)) < EPSLN) {
									return (93);
								}
								else {
									x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
									y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
									b = Math.abs(y);

									if (b >= 1) {
										if ((b - 1) > EPSLN) {
											return (93);
										}
										else {
											y = 0;
										}
									}
									else {
										y = Math.acos(y);
									}

									if (lat < 0) {
										y = -y;
									}

									y = this.a * this.k0 * (y - this.lat0) + this.y0;
								}
							}
							else {
								var al = cos_phi * delta_lon;
								var als = Math.pow(al, 2);
								var c = this.ep2 * Math.pow(cos_phi, 2);
								var cs = Math.pow(c, 2);
								var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
								var t = Math.pow(tq, 2);
								var ts = Math.pow(t, 2);
								con = 1 - this.es * Math.pow(sin_phi, 2);
								al = al / Math.sqrt(con);
								var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);

								x = this.a * (this.k0 * al * (1 +
									als / 6 * (1 - t + c +
										als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +
											als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +
									this.x0;

								y = this.a * (this.k0 * (ml - this.ml0 +
									sin_phi * delta_lon * al / 2 * (1 +
										als / 12 * (5 - t + 9 * c + 4 * cs +
											als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +
												als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +
									this.y0;
							}

							p.x = x;
							p.y = y;

							return p;
						}

						/**
							Transverse Mercator Inverse  -  x/y to long/lat
						  */
						function inverse$2(p) {
							var con, phi;
							var lat, lon;
							var x = (p.x - this.x0) * (1 / this.a);
							var y = (p.y - this.y0) * (1 / this.a);

							if (!this.es) {
								var f = Math.exp(x / this.k0);
								var g = 0.5 * (f - 1 / f);
								var temp = this.lat0 + y / this.k0;
								var h = Math.cos(temp);
								con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
								lat = Math.asin(con);

								if (y < 0) {
									lat = -lat;
								}

								if ((g === 0) && (h === 0)) {
									lon = 0;
								}
								else {
									lon = adjust_lon(Math.atan2(g, h) + this.long0);
								}
							}
							else { // ellipsoidal form
								con = this.ml0 + y / this.k0;
								phi = pj_inv_mlfn(con, this.es, this.en);

								if (Math.abs(phi) < HALF_PI) {
									var sin_phi = Math.sin(phi);
									var cos_phi = Math.cos(phi);
									var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
									var c = this.ep2 * Math.pow(cos_phi, 2);
									var cs = Math.pow(c, 2);
									var t = Math.pow(tan_phi, 2);
									var ts = Math.pow(t, 2);
									con = 1 - this.es * Math.pow(sin_phi, 2);
									var d = x * Math.sqrt(con) / this.k0;
									var ds = Math.pow(d, 2);
									con = con * tan_phi;

									lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -
										ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -
											ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -
												ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));

									lon = adjust_lon(this.long0 + (d * (1 -
										ds / 6 * (1 + 2 * t + c -
											ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -
												ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));
								}
								else {
									lat = HALF_PI * sign(y);
									lon = 0;
								}
							}

							p.x = lon;
							p.y = lat;

							return p;
						}

						var names$3 = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
						var tmerc = {
							init: init$2,
							forward: forward$2,
							inverse: inverse$2,
							names: names$3
						};

						var sinh = function (x) {
							var r = Math.exp(x);
							r = (r - 1 / r) / 2;
							return r;
						};

						var hypot = function (x, y) {
							x = Math.abs(x);
							y = Math.abs(y);
							var a = Math.max(x, y);
							var b = Math.min(x, y) / (a ? a : 1);

							return a * Math.sqrt(1 + Math.pow(b, 2));
						};

						var log1py = function (x) {
							var y = 1 + x;
							var z = y - 1;

							return z === 0 ? x : x * Math.log(y) / z;
						};

						var asinhy = function (x) {
							var y = Math.abs(x);
							y = log1py(y * (1 + y / (hypot(1, y) + 1)));

							return x < 0 ? -y : y;
						};

						var gatg = function (pp, B) {
							var cos_2B = 2 * Math.cos(2 * B);
							var i = pp.length - 1;
							var h1 = pp[i];
							var h2 = 0;
							var h;

							while (--i >= 0) {
								h = -h2 + cos_2B * h1 + pp[i];
								h2 = h1;
								h1 = h;
							}

							return (B + h * Math.sin(2 * B));
						};

						var clens = function (pp, arg_r) {
							var r = 2 * Math.cos(arg_r);
							var i = pp.length - 1;
							var hr1 = pp[i];
							var hr2 = 0;
							var hr;

							while (--i >= 0) {
								hr = -hr2 + r * hr1 + pp[i];
								hr2 = hr1;
								hr1 = hr;
							}

							return Math.sin(arg_r) * hr;
						};

						var cosh = function (x) {
							var r = Math.exp(x);
							r = (r + 1 / r) / 2;
							return r;
						};

						var clens_cmplx = function (pp, arg_r, arg_i) {
							var sin_arg_r = Math.sin(arg_r);
							var cos_arg_r = Math.cos(arg_r);
							var sinh_arg_i = sinh(arg_i);
							var cosh_arg_i = cosh(arg_i);
							var r = 2 * cos_arg_r * cosh_arg_i;
							var i = -2 * sin_arg_r * sinh_arg_i;
							var j = pp.length - 1;
							var hr = pp[j];
							var hi1 = 0;
							var hr1 = 0;
							var hi = 0;
							var hr2;
							var hi2;

							while (--j >= 0) {
								hr2 = hr1;
								hi2 = hi1;
								hr1 = hr;
								hi1 = hi;
								hr = -hr2 + r * hr1 - i * hi1 + pp[j];
								hi = -hi2 + i * hr1 + r * hi1;
							}

							r = sin_arg_r * cosh_arg_i;
							i = cos_arg_r * sinh_arg_i;

							return [r * hr - i * hi, r * hi + i * hr];
						};

						// Heavily based on this etmerc projection implementation
						// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/etmerc.js

						function init$3() {
							if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
								throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
							}
							if (this.approx) {
								// When '+approx' is set, use tmerc instead
								tmerc.init.apply(this);
								this.forward = tmerc.forward;
								this.inverse = tmerc.inverse;
							}

							this.x0 = this.x0 !== undefined ? this.x0 : 0;
							this.y0 = this.y0 !== undefined ? this.y0 : 0;
							this.long0 = this.long0 !== undefined ? this.long0 : 0;
							this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

							this.cgb = [];
							this.cbg = [];
							this.utg = [];
							this.gtu = [];

							var f = this.es / (1 + Math.sqrt(1 - this.es));
							var n = f / (2 - f);
							var np = n;

							this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675))))));
							this.cbg[0] = n * (-2 + n * (2 / 3 + n * (4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));

							np = np * n;
							this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
							this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * (-13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));

							np = np * n;
							this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
							this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));

							np = np * n;
							this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
							this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * (-24832 / 14175)));

							np = np * n;
							this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
							this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));

							np = np * n;
							this.cgb[5] = np * (601676 / 22275);
							this.cbg[5] = np * (444337 / 155925);

							np = Math.pow(n, 2);
							this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));

							this.utg[0] = n * (-0.5 + n * (2 / 3 + n * (-37 / 96 + n * (1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
							this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));

							this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
							this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));

							np = np * n;
							this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720))));
							this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));

							np = np * n;
							this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
							this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));

							np = np * n;
							this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
							this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));

							np = np * n;
							this.utg[5] = np * (-20648693 / 638668800);
							this.gtu[5] = np * (212378941 / 319334400);

							var Z = gatg(this.cbg, this.lat0);
							this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));
						}

						function forward$3(p) {
							var Ce = adjust_lon(p.x - this.long0);
							var Cn = p.y;

							Cn = gatg(this.cbg, Cn);
							var sin_Cn = Math.sin(Cn);
							var cos_Cn = Math.cos(Cn);
							var sin_Ce = Math.sin(Ce);
							var cos_Ce = Math.cos(Ce);

							Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
							Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
							Ce = asinhy(Math.tan(Ce));

							var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);

							Cn = Cn + tmp[0];
							Ce = Ce + tmp[1];

							var x;
							var y;

							if (Math.abs(Ce) <= 2.623395162778) {
								x = this.a * (this.Qn * Ce) + this.x0;
								y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
							}
							else {
								x = Infinity;
								y = Infinity;
							}

							p.x = x;
							p.y = y;

							return p;
						}

						function inverse$3(p) {
							var Ce = (p.x - this.x0) * (1 / this.a);
							var Cn = (p.y - this.y0) * (1 / this.a);

							Cn = (Cn - this.Zb) / this.Qn;
							Ce = Ce / this.Qn;

							var lon;
							var lat;

							if (Math.abs(Ce) <= 2.623395162778) {
								var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);

								Cn = Cn + tmp[0];
								Ce = Ce + tmp[1];
								Ce = Math.atan(sinh(Ce));

								var sin_Cn = Math.sin(Cn);
								var cos_Cn = Math.cos(Cn);
								var sin_Ce = Math.sin(Ce);
								var cos_Ce = Math.cos(Ce);

								Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
								Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);

								lon = adjust_lon(Ce + this.long0);
								lat = gatg(this.cgb, Cn);
							}
							else {
								lon = Infinity;
								lat = Infinity;
							}

							p.x = lon;
							p.y = lat;

							return p;
						}

						var names$4 = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
						var etmerc = {
							init: init$3,
							forward: forward$3,
							inverse: inverse$3,
							names: names$4
						};

						var adjust_zone = function (zone, lon) {
							if (zone === undefined) {
								zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;

								if (zone < 0) {
									return 0;
								} else if (zone > 60) {
									return 60;
								}
							}
							return zone;
						};

						var dependsOn = 'etmerc';
						function init$4() {
							var zone = adjust_zone(this.zone, this.long0);
							if (zone === undefined) {
								throw new Error('unknown utm zone');
							}
							this.lat0 = 0;
							this.long0 = ((6 * Math.abs(zone)) - 183) * D2R;
							this.x0 = 500000;
							this.y0 = this.utmSouth ? 10000000 : 0;
							this.k0 = 0.9996;

							etmerc.init.apply(this);
							this.forward = etmerc.forward;
							this.inverse = etmerc.inverse;
						}

						var names$5 = ["Universal Transverse Mercator System", "utm"];
						var utm = {
							init: init$4,
							names: names$5,
							dependsOn: dependsOn
						};

						var srat = function (esinp, exp) {
							return (Math.pow((1 - esinp) / (1 + esinp), exp));
						};

						var MAX_ITER$1 = 20;
						function init$6() {
							var sphi = Math.sin(this.lat0);
							var cphi = Math.cos(this.lat0);
							cphi *= cphi;
							this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
							this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
							this.phic0 = Math.asin(sphi / this.C);
							this.ratexp = 0.5 * this.C * this.e;
							this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
						}

						function forward$5(p) {
							var lon = p.x;
							var lat = p.y;

							p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
							p.x = this.C * lon;
							return p;
						}

						function inverse$5(p) {
							var DEL_TOL = 1e-14;
							var lon = p.x / this.C;
							var lat = p.y;
							var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
							for (var i = MAX_ITER$1; i > 0; --i) {
								lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;
								if (Math.abs(lat - p.y) < DEL_TOL) {
									break;
								}
								p.y = lat;
							}
							/* convergence failed */
							if (!i) {
								return null;
							}
							p.x = lon;
							p.y = lat;
							return p;
						}

						var names$7 = ["gauss"];
						var gauss = {
							init: init$6,
							forward: forward$5,
							inverse: inverse$5,
							names: names$7
						};

						function init$5() {
							gauss.init.apply(this);
							if (!this.rc) {
								return;
							}
							this.sinc0 = Math.sin(this.phic0);
							this.cosc0 = Math.cos(this.phic0);
							this.R2 = 2 * this.rc;
							if (!this.title) {
								this.title = "Oblique Stereographic Alternative";
							}
						}

						function forward$4(p) {
							var sinc, cosc, cosl, k;
							p.x = adjust_lon(p.x - this.long0);
							gauss.forward.apply(this, [p]);
							sinc = Math.sin(p.y);
							cosc = Math.cos(p.y);
							cosl = Math.cos(p.x);
							k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
							p.x = k * cosc * Math.sin(p.x);
							p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
							p.x = this.a * p.x + this.x0;
							p.y = this.a * p.y + this.y0;
							return p;
						}

						function inverse$4(p) {
							var sinc, cosc, lon, lat, rho;
							p.x = (p.x - this.x0) / this.a;
							p.y = (p.y - this.y0) / this.a;

							p.x /= this.k0;
							p.y /= this.k0;
							if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {
								var c = 2 * Math.atan2(rho, this.R2);
								sinc = Math.sin(c);
								cosc = Math.cos(c);
								lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
								lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
							}
							else {
								lat = this.phic0;
								lon = 0;
							}

							p.x = lon;
							p.y = lat;
							gauss.inverse.apply(this, [p]);
							p.x = adjust_lon(p.x + this.long0);
							return p;
						}

						var names$6 = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
						var sterea = {
							init: init$5,
							forward: forward$4,
							inverse: inverse$4,
							names: names$6
						};

						function ssfn_(phit, sinphi, eccen) {
							sinphi *= eccen;
							return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));
						}

						function init$7() {
							this.coslat0 = Math.cos(this.lat0);
							this.sinlat0 = Math.sin(this.lat0);
							if (this.sphere) {
								if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
									this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
								}
							}
							else {
								if (Math.abs(this.coslat0) <= EPSLN) {
									if (this.lat0 > 0) {
										//North pole
										//trace('stere:north pole');
										this.con = 1;
									}
									else {
										//South pole
										//trace('stere:south pole');
										this.con = -1;
									}
								}
								this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
								if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
									this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
								}
								this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
								this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
								this.cosX0 = Math.cos(this.X0);
								this.sinX0 = Math.sin(this.X0);
							}
						}

						// Stereographic forward equations--mapping lat,long to x,y
						function forward$6(p) {
							var lon = p.x;
							var lat = p.y;
							var sinlat = Math.sin(lat);
							var coslat = Math.cos(lat);
							var A, X, sinX, cosX, ts, rh;
							var dlon = adjust_lon(lon - this.long0);

							if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
								//case of the origine point
								//trace('stere:this is the origin point');
								p.x = NaN;
								p.y = NaN;
								return p;
							}
							if (this.sphere) {
								//trace('stere:sphere case');
								A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
								p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
								p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
								return p;
							}
							else {
								X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
								cosX = Math.cos(X);
								sinX = Math.sin(X);
								if (Math.abs(this.coslat0) <= EPSLN) {
									ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
									rh = 2 * this.a * this.k0 * ts / this.cons;
									p.x = this.x0 + rh * Math.sin(lon - this.long0);
									p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
									//trace(p.toString());
									return p;
								}
								else if (Math.abs(this.sinlat0) < EPSLN) {
									//Eq
									//trace('stere:equateur');
									A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
									p.y = A * sinX;
								}
								else {
									//other case
									//trace('stere:normal case');
									A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
									p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
								}
								p.x = A * cosX * Math.sin(dlon) + this.x0;
							}
							//trace(p.toString());
							return p;
						}

						//* Stereographic inverse equations--mapping x,y to lat/long
						function inverse$6(p) {
							p.x -= this.x0;
							p.y -= this.y0;
							var lon, lat, ts, ce, Chi;
							var rh = Math.sqrt(p.x * p.x + p.y * p.y);
							if (this.sphere) {
								var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
								lon = this.long0;
								lat = this.lat0;
								if (rh <= EPSLN) {
									p.x = lon;
									p.y = lat;
									return p;
								}
								lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
								if (Math.abs(this.coslat0) < EPSLN) {
									if (this.lat0 > 0) {
										lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
									}
									else {
										lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
									}
								}
								else {
									lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
								}
								p.x = lon;
								p.y = lat;
								return p;
							}
							else {
								if (Math.abs(this.coslat0) <= EPSLN) {
									if (rh <= EPSLN) {
										lat = this.lat0;
										lon = this.long0;
										p.x = lon;
										p.y = lat;
										//trace(p.toString());
										return p;
									}
									p.x *= this.con;
									p.y *= this.con;
									ts = rh * this.cons / (2 * this.a * this.k0);
									lat = this.con * phi2z(this.e, ts);
									lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));
								}
								else {
									ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
									lon = this.long0;
									if (rh <= EPSLN) {
										Chi = this.X0;
									}
									else {
										Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
										lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
									}
									lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
								}
							}
							p.x = lon;
							p.y = lat;

							//trace(p.toString());
							return p;

						}

						var names$8 = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
						var stere = {
							init: init$7,
							forward: forward$6,
							inverse: inverse$6,
							names: names$8,
							ssfn_: ssfn_
						};

						/*
						  references:
							Formules et constantes pour le Calcul pour la
							projection cylindrique conforme à axe oblique et pour la transformation entre
							des systèmes de référence.
							http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
						  */

						function init$8() {
							var phy0 = this.lat0;
							this.lambda0 = this.long0;
							var sinPhy0 = Math.sin(phy0);
							var semiMajorAxis = this.a;
							var invF = this.rf;
							var flattening = 1 / invF;
							var e2 = 2 * flattening - Math.pow(flattening, 2);
							var e = this.e = Math.sqrt(e2);
							this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
							this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
							this.b0 = Math.asin(sinPhy0 / this.alpha);
							var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
							var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
							var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
							this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
						}

						function forward$7(p) {
							var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
							var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
							var S = -this.alpha * (Sa1 + Sa2) + this.K;

							// spheric latitude
							var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);

							// spheric longitude
							var I = this.alpha * (p.x - this.lambda0);

							// psoeudo equatorial rotation
							var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));

							var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));

							p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
							p.x = this.R * rotI + this.x0;
							return p;
						}

						function inverse$7(p) {
							var Y = p.x - this.x0;
							var X = p.y - this.y0;

							var rotI = Y / this.R;
							var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);

							var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
							var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));

							var lambda = this.lambda0 + I / this.alpha;

							var S = 0;
							var phy = b;
							var prevPhy = -1000;
							var iteration = 0;
							while (Math.abs(phy - prevPhy) > 0.0000001) {
								if (++iteration > 20) {
									//...reportError("omercFwdInfinity");
									return;
								}
								//S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
								S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
								prevPhy = phy;
								phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
							}

							p.x = lambda;
							p.y = phy;
							return p;
						}

						var names$9 = ["somerc"];
						var somerc = {
							init: init$8,
							forward: forward$7,
							inverse: inverse$7,
							names: names$9
						};

						var TOL = 1e-7;

						function isTypeA(P) {
							var typeAProjections = ['Hotine_Oblique_Mercator', 'Hotine_Oblique_Mercator_Azimuth_Natural_Origin'];
							var projectionName = typeof P.PROJECTION === "object" ? Object.keys(P.PROJECTION)[0] : P.PROJECTION;

							return 'no_uoff' in P || 'no_off' in P || typeAProjections.indexOf(projectionName) !== -1;
						}


						/* Initialize the Oblique Mercator  projection
							------------------------------------------*/
						function init$9() {
							var con, com, cosph0, D, F, H, L, sinph0, p, J, gamma = 0,
								gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0;

							// only Type A uses the no_off or no_uoff property
							// https://github.com/OSGeo/proj.4/issues/104
							this.no_off = isTypeA(this);
							this.no_rot = 'no_rot' in this;

							var alp = false;
							if ("alpha" in this) {
								alp = true;
							}

							var gam = false;
							if ("rectified_grid_angle" in this) {
								gam = true;
							}

							if (alp) {
								alpha_c = this.alpha;
							}

							if (gam) {
								gamma = (this.rectified_grid_angle * D2R);
							}

							if (alp || gam) {
								lamc = this.longc;
							} else {
								lam1 = this.long1;
								phi1 = this.lat1;
								lam2 = this.long2;
								phi2 = this.lat2;

								if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL ||
									Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL ||
									Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
									throw new Error();
								}
							}

							var one_es = 1.0 - this.es;
							com = Math.sqrt(one_es);

							if (Math.abs(this.lat0) > EPSLN) {
								sinph0 = Math.sin(this.lat0);
								cosph0 = Math.cos(this.lat0);
								con = 1 - this.es * sinph0 * sinph0;
								this.B = cosph0 * cosph0;
								this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
								this.A = this.B * this.k0 * com / con;
								D = this.B * com / (cosph0 * Math.sqrt(con));
								F = D * D - 1;

								if (F <= 0) {
									F = 0;
								} else {
									F = Math.sqrt(F);
									if (this.lat0 < 0) {
										F = -F;
									}
								}

								this.E = F += D;
								this.E *= Math.pow(tsfnz(this.e, this.lat0, sinph0), this.B);
							} else {
								this.B = 1 / com;
								this.A = this.k0;
								this.E = D = F = 1;
							}

							if (alp || gam) {
								if (alp) {
									gamma0 = Math.asin(Math.sin(alpha_c) / D);
									if (!gam) {
										gamma = alpha_c;
									}
								} else {
									gamma0 = gamma;
									alpha_c = Math.asin(D * Math.sin(gamma0));
								}
								this.lam0 = lamc - Math.asin(0.5 * (F - 1 / F) * Math.tan(gamma0)) / this.B;
							} else {
								H = Math.pow(tsfnz(this.e, phi1, Math.sin(phi1)), this.B);
								L = Math.pow(tsfnz(this.e, phi2, Math.sin(phi2)), this.B);
								F = this.E / H;
								p = (L - H) / (L + H);
								J = this.E * this.E;
								J = (J - L * H) / (J + L * H);
								con = lam1 - lam2;

								if (con < -Math.pi) {
									lam2 -= TWO_PI;
								} else if (con > Math.pi) {
									lam2 += TWO_PI;
								}

								this.lam0 = adjust_lon(0.5 * (lam1 + lam2) - Math.atan(J * Math.tan(0.5 * this.B * (lam1 - lam2)) / p) / this.B);
								gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon(lam1 - this.lam0)) / (F - 1 / F));
								gamma = alpha_c = Math.asin(D * Math.sin(gamma0));
							}

							this.singam = Math.sin(gamma0);
							this.cosgam = Math.cos(gamma0);
							this.sinrot = Math.sin(gamma);
							this.cosrot = Math.cos(gamma);

							this.rB = 1 / this.B;
							this.ArB = this.A * this.rB;
							this.BrA = 1 / this.ArB;
							if (this.no_off) {
								this.u_0 = 0;
							} else {
								this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D * D - 1) / Math.cos(alpha_c)));

								if (this.lat0 < 0) {
									this.u_0 = - this.u_0;
								}
							}

							F = 0.5 * gamma0;
							this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F));
							this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F));
						}


						/* Oblique Mercator forward equations--mapping lat,long to x,y
							----------------------------------------------------------*/
						function forward$8(p) {
							var coords = {};
							var S, T, U, V, W, temp, u, v;
							p.x = p.x - this.lam0;

							if (Math.abs(Math.abs(p.y) - HALF_PI) > EPSLN) {
								W = this.E / Math.pow(tsfnz(this.e, p.y, Math.sin(p.y)), this.B);

								temp = 1 / W;
								S = 0.5 * (W - temp);
								T = 0.5 * (W + temp);
								V = Math.sin(this.B * p.x);
								U = (S * this.singam - V * this.cosgam) / T;

								if (Math.abs(Math.abs(U) - 1.0) < EPSLN) {
									throw new Error();
								}

								v = 0.5 * this.ArB * Math.log((1 - U) / (1 + U));
								temp = Math.cos(this.B * p.x);

								if (Math.abs(temp) < TOL) {
									u = this.A * p.x;
								} else {
									u = this.ArB * Math.atan2((S * this.cosgam + V * this.singam), temp);
								}
							} else {
								v = p.y > 0 ? this.v_pole_n : this.v_pole_s;
								u = this.ArB * p.y;
							}

							if (this.no_rot) {
								coords.x = u;
								coords.y = v;
							} else {
								u -= this.u_0;
								coords.x = v * this.cosrot + u * this.sinrot;
								coords.y = u * this.cosrot - v * this.sinrot;
							}

							coords.x = (this.a * coords.x + this.x0);
							coords.y = (this.a * coords.y + this.y0);

							return coords;
						}

						function inverse$8(p) {
							var u, v, Qp, Sp, Tp, Vp, Up;
							var coords = {};

							p.x = (p.x - this.x0) * (1.0 / this.a);
							p.y = (p.y - this.y0) * (1.0 / this.a);

							if (this.no_rot) {
								v = p.y;
								u = p.x;
							} else {
								v = p.x * this.cosrot - p.y * this.sinrot;
								u = p.y * this.cosrot + p.x * this.sinrot + this.u_0;
							}

							Qp = Math.exp(-this.BrA * v);
							Sp = 0.5 * (Qp - 1 / Qp);
							Tp = 0.5 * (Qp + 1 / Qp);
							Vp = Math.sin(this.BrA * u);
							Up = (Vp * this.cosgam + Sp * this.singam) / Tp;

							if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
								coords.x = 0;
								coords.y = Up < 0 ? -HALF_PI : HALF_PI;
							} else {
								coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
								coords.y = phi2z(this.e, Math.pow(coords.y, 1 / this.B));

								if (coords.y === Infinity) {
									throw new Error();
								}

								coords.x = -this.rB * Math.atan2((Sp * this.cosgam - Vp * this.singam), Math.cos(this.BrA * u));
							}

							coords.x += this.lam0;

							return coords;
						}

						var names$10 = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
						var omerc = {
							init: init$9,
							forward: forward$8,
							inverse: inverse$8,
							names: names$10
						};

						function init$10() {

							//double lat0;                    /* the reference latitude               */
							//double long0;                   /* the reference longitude              */
							//double lat1;                    /* first standard parallel              */
							//double lat2;                    /* second standard parallel             */
							//double r_maj;                   /* major axis                           */
							//double r_min;                   /* minor axis                           */
							//double false_east;              /* x offset in meters                   */
							//double false_north;             /* y offset in meters                   */

							//the above value can be set with proj4.defs
							//example: proj4.defs("EPSG:2154","+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

							if (!this.lat2) {
								this.lat2 = this.lat1;
							} //if lat2 is not defined
							if (!this.k0) {
								this.k0 = 1;
							}
							this.x0 = this.x0 || 0;
							this.y0 = this.y0 || 0;
							// Standard Parallels cannot be equal and on opposite sides of the equator
							if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
								return;
							}

							var temp = this.b / this.a;
							this.e = Math.sqrt(1 - temp * temp);

							var sin1 = Math.sin(this.lat1);
							var cos1 = Math.cos(this.lat1);
							var ms1 = msfnz(this.e, sin1, cos1);
							var ts1 = tsfnz(this.e, this.lat1, sin1);

							var sin2 = Math.sin(this.lat2);
							var cos2 = Math.cos(this.lat2);
							var ms2 = msfnz(this.e, sin2, cos2);
							var ts2 = tsfnz(this.e, this.lat2, sin2);

							var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));

							if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
								this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
							}
							else {
								this.ns = sin1;
							}
							if (isNaN(this.ns)) {
								this.ns = sin1;
							}
							this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
							this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
							if (!this.title) {
								this.title = "Lambert Conformal Conic";
							}
						}

						// Lambert Conformal conic forward equations--mapping lat,long to x,y
						// -----------------------------------------------------------------
						function forward$9(p) {

							var lon = p.x;
							var lat = p.y;

							// singular cases :
							if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
								lat = sign(lat) * (HALF_PI - 2 * EPSLN);
							}

							var con = Math.abs(Math.abs(lat) - HALF_PI);
							var ts, rh1;
							if (con > EPSLN) {
								ts = tsfnz(this.e, lat, Math.sin(lat));
								rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
							}
							else {
								con = lat * this.ns;
								if (con <= 0) {
									return null;
								}
								rh1 = 0;
							}
							var theta = this.ns * adjust_lon(lon - this.long0);
							p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
							p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;

							return p;
						}

						// Lambert Conformal Conic inverse equations--mapping x,y to lat/long
						// -----------------------------------------------------------------
						function inverse$9(p) {

							var rh1, con, ts;
							var lat, lon;
							var x = (p.x - this.x0) / this.k0;
							var y = (this.rh - (p.y - this.y0) / this.k0);
							if (this.ns > 0) {
								rh1 = Math.sqrt(x * x + y * y);
								con = 1;
							}
							else {
								rh1 = -Math.sqrt(x * x + y * y);
								con = -1;
							}
							var theta = 0;
							if (rh1 !== 0) {
								theta = Math.atan2((con * x), (con * y));
							}
							if ((rh1 !== 0) || (this.ns > 0)) {
								con = 1 / this.ns;
								ts = Math.pow((rh1 / (this.a * this.f0)), con);
								lat = phi2z(this.e, ts);
								if (lat === -9999) {
									return null;
								}
							}
							else {
								lat = -HALF_PI;
							}
							lon = adjust_lon(theta / this.ns + this.long0);

							p.x = lon;
							p.y = lat;
							return p;
						}

						var names$11 = [
							"Lambert Tangential Conformal Conic Projection",
							"Lambert_Conformal_Conic",
							"Lambert_Conformal_Conic_1SP",
							"Lambert_Conformal_Conic_2SP",
							"lcc"
						];

						var lcc = {
							init: init$10,
							forward: forward$9,
							inverse: inverse$9,
							names: names$11
						};

						function init$11() {
							this.a = 6377397.155;
							this.es = 0.006674372230614;
							this.e = Math.sqrt(this.es);
							if (!this.lat0) {
								this.lat0 = 0.863937979737193;
							}
							if (!this.long0) {
								this.long0 = 0.7417649320975901 - 0.308341501185665;
							}
							/* if scale not set default to 0.9999 */
							if (!this.k0) {
								this.k0 = 0.9999;
							}
							this.s45 = 0.785398163397448; /* 45 */
							this.s90 = 2 * this.s45;
							this.fi0 = this.lat0;
							this.e2 = this.es;
							this.e = Math.sqrt(this.e2);
							this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));
							this.uq = 1.04216856380474;
							this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
							this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
							this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
							this.k1 = this.k0;
							this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
							this.s0 = 1.37008346281555;
							this.n = Math.sin(this.s0);
							this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
							this.ad = this.s90 - this.uq;
						}

						/* ellipsoid */
						/* calculate xy from lat/lon */
						/* Constants, identical to inverse transform function */
						function forward$10(p) {
							var gfi, u, deltav, s, d, eps, ro;
							var lon = p.x;
							var lat = p.y;
							var delta_lon = adjust_lon(lon - this.long0);
							/* Transformation */
							gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));
							u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
							deltav = -delta_lon * this.alfa;
							s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
							d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
							eps = this.n * d;
							ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
							p.y = ro * Math.cos(eps) / 1;
							p.x = ro * Math.sin(eps) / 1;

							if (!this.czech) {
								p.y *= -1;
								p.x *= -1;
							}
							return (p);
						}

						/* calculate lat/lon from xy */
						function inverse$10(p) {
							var u, deltav, s, d, eps, ro, fi1;
							var ok;

							/* Transformation */
							/* revert y, x*/
							var tmp = p.x;
							p.x = p.y;
							p.y = tmp;
							if (!this.czech) {
								p.y *= -1;
								p.x *= -1;
							}
							ro = Math.sqrt(p.x * p.x + p.y * p.y);
							eps = Math.atan2(p.y, p.x);
							d = eps / Math.sin(this.s0);
							s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
							u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
							deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
							p.x = this.long0 - deltav / this.alfa;
							fi1 = u;
							ok = 0;
							var iter = 0;
							do {
								p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
								if (Math.abs(fi1 - p.y) < 0.0000000001) {
									ok = 1;
								}
								fi1 = p.y;
								iter += 1;
							} while (ok === 0 && iter < 15);
							if (iter >= 15) {
								return null;
							}

							return (p);
						}

						var names$12 = ["Krovak", "krovak"];
						var krovak = {
							init: init$11,
							forward: forward$10,
							inverse: inverse$10,
							names: names$12
						};

						var mlfn = function (e0, e1, e2, e3, phi) {
							return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));
						};

						var e0fn = function (x) {
							return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));
						};

						var e1fn = function (x) {
							return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));
						};

						var e2fn = function (x) {
							return (0.05859375 * x * x * (1 + 0.75 * x));
						};

						var e3fn = function (x) {
							return (x * x * x * (35 / 3072));
						};

						var gN = function (a, e, sinphi) {
							var temp = e * sinphi;
							return a / Math.sqrt(1 - temp * temp);
						};

						var adjust_lat = function (x) {
							return (Math.abs(x) < HALF_PI) ? x : (x - (sign(x) * Math.PI));
						};

						var imlfn = function (ml, e0, e1, e2, e3) {
							var phi;
							var dphi;

							phi = ml / e0;
							for (var i = 0; i < 15; i++) {
								dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
								phi += dphi;
								if (Math.abs(dphi) <= 0.0000000001) {
									return phi;
								}
							}

							//..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
							return NaN;
						};

						function init$12() {
							if (!this.sphere) {
								this.e0 = e0fn(this.es);
								this.e1 = e1fn(this.es);
								this.e2 = e2fn(this.es);
								this.e3 = e3fn(this.es);
								this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
							}
						}

						/* Cassini forward equations--mapping lat,long to x,y
						  -----------------------------------------------------------------------*/
						function forward$11(p) {

							/* Forward equations
								-----------------*/
							var x, y;
							var lam = p.x;
							var phi = p.y;
							lam = adjust_lon(lam - this.long0);

							if (this.sphere) {
								x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
								y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
							}
							else {
								//ellipsoid
								var sinphi = Math.sin(phi);
								var cosphi = Math.cos(phi);
								var nl = gN(this.a, this.e, sinphi);
								var tl = Math.tan(phi) * Math.tan(phi);
								var al = lam * Math.cos(phi);
								var asq = al * al;
								var cl = this.es * cosphi * cosphi / (1 - this.es);
								var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);

								x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
								y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);


							}

							p.x = x + this.x0;
							p.y = y + this.y0;
							return p;
						}

						/* Inverse equations
						  -----------------*/
						function inverse$11(p) {
							p.x -= this.x0;
							p.y -= this.y0;
							var x = p.x / this.a;
							var y = p.y / this.a;
							var phi, lam;

							if (this.sphere) {
								var dd = y + this.lat0;
								phi = Math.asin(Math.sin(dd) * Math.cos(x));
								lam = Math.atan2(Math.tan(x), Math.cos(dd));
							}
							else {
								/* ellipsoid */
								var ml1 = this.ml0 / this.a + y;
								var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
								if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
									p.x = this.long0;
									p.y = HALF_PI;
									if (y < 0) {
										p.y *= -1;
									}
									return p;
								}
								var nl1 = gN(this.a, this.e, Math.sin(phi1));

								var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
								var tl1 = Math.pow(Math.tan(phi1), 2);
								var dl = x * this.a / nl1;
								var dsq = dl * dl;
								phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
								lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);

							}

							p.x = adjust_lon(lam + this.long0);
							p.y = adjust_lat(phi);
							return p;

						}

						var names$13 = ["Cassini", "Cassini_Soldner", "cass"];
						var cass = {
							init: init$12,
							forward: forward$11,
							inverse: inverse$11,
							names: names$13
						};

						var qsfnz = function (eccent, sinphi) {
							var con;
							if (eccent > 1.0e-7) {
								con = eccent * sinphi;
								return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));
							}
							else {
								return (2 * sinphi);
							}
						};

						/*
						  reference
							"New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
							The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
						  */

						var S_POLE = 1;

						var N_POLE = 2;
						var EQUIT = 3;
						var OBLIQ = 4;

						/* Initialize the Lambert Azimuthal Equal Area projection
						  ------------------------------------------------------*/
						function init$13() {
							var t = Math.abs(this.lat0);
							if (Math.abs(t - HALF_PI) < EPSLN) {
								this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
							}
							else if (Math.abs(t) < EPSLN) {
								this.mode = this.EQUIT;
							}
							else {
								this.mode = this.OBLIQ;
							}
							if (this.es > 0) {
								var sinphi;

								this.qp = qsfnz(this.e, 1);
								this.mmf = 0.5 / (1 - this.es);
								this.apa = authset(this.es);
								switch (this.mode) {
									case this.N_POLE:
										this.dd = 1;
										break;
									case this.S_POLE:
										this.dd = 1;
										break;
									case this.EQUIT:
										this.rq = Math.sqrt(0.5 * this.qp);
										this.dd = 1 / this.rq;
										this.xmf = 1;
										this.ymf = 0.5 * this.qp;
										break;
									case this.OBLIQ:
										this.rq = Math.sqrt(0.5 * this.qp);
										sinphi = Math.sin(this.lat0);
										this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
										this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
										this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
										this.ymf = (this.xmf = this.rq) / this.dd;
										this.xmf *= this.dd;
										break;
								}
							}
							else {
								if (this.mode === this.OBLIQ) {
									this.sinph0 = Math.sin(this.lat0);
									this.cosph0 = Math.cos(this.lat0);
								}
							}
						}

						/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
						  -----------------------------------------------------------------------*/
						function forward$12(p) {

							/* Forward equations
								-----------------*/
							var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
							var lam = p.x;
							var phi = p.y;

							lam = adjust_lon(lam - this.long0);
							if (this.sphere) {
								sinphi = Math.sin(phi);
								cosphi = Math.cos(phi);
								coslam = Math.cos(lam);
								if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
									y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
									if (y <= EPSLN) {
										return null;
									}
									y = Math.sqrt(2 / y);
									x = y * cosphi * Math.sin(lam);
									y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
								}
								else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
									if (this.mode === this.N_POLE) {
										coslam = -coslam;
									}
									if (Math.abs(phi + this.lat0) < EPSLN) {
										return null;
									}
									y = FORTPI - phi * 0.5;
									y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));
									x = y * Math.sin(lam);
									y *= coslam;
								}
							}
							else {
								sinb = 0;
								cosb = 0;
								b = 0;
								coslam = Math.cos(lam);
								sinlam = Math.sin(lam);
								sinphi = Math.sin(phi);
								q = qsfnz(this.e, sinphi);
								if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
									sinb = q / this.qp;
									cosb = Math.sqrt(1 - sinb * sinb);
								}
								switch (this.mode) {
									case this.OBLIQ:
										b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
										break;
									case this.EQUIT:
										b = 1 + cosb * coslam;
										break;
									case this.N_POLE:
										b = HALF_PI + phi;
										q = this.qp - q;
										break;
									case this.S_POLE:
										b = phi - HALF_PI;
										q = this.qp + q;
										break;
								}
								if (Math.abs(b) < EPSLN) {
									return null;
								}
								switch (this.mode) {
									case this.OBLIQ:
									case this.EQUIT:
										b = Math.sqrt(2 / b);
										if (this.mode === this.OBLIQ) {
											y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
										}
										else {
											y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
										}
										x = this.xmf * b * cosb * sinlam;
										break;
									case this.N_POLE:
									case this.S_POLE:
										if (q >= 0) {
											x = (b = Math.sqrt(q)) * sinlam;
											y = coslam * ((this.mode === this.S_POLE) ? b : -b);
										}
										else {
											x = y = 0;
										}
										break;
								}
							}

							p.x = this.a * x + this.x0;
							p.y = this.a * y + this.y0;
							return p;
						}

						/* Inverse equations
						  -----------------*/
						function inverse$12(p) {
							p.x -= this.x0;
							p.y -= this.y0;
							var x = p.x / this.a;
							var y = p.y / this.a;
							var lam, phi, cCe, sCe, q, rho, ab;
							if (this.sphere) {
								var cosz = 0,
									rh, sinz = 0;

								rh = Math.sqrt(x * x + y * y);
								phi = rh * 0.5;
								if (phi > 1) {
									return null;
								}
								phi = 2 * Math.asin(phi);
								if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
									sinz = Math.sin(phi);
									cosz = Math.cos(phi);
								}
								switch (this.mode) {
									case this.EQUIT:
										phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);
										x *= sinz;
										y = cosz * rh;
										break;
									case this.OBLIQ:
										phi = (Math.abs(rh) <= EPSLN) ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
										x *= sinz * this.cosph0;
										y = (cosz - Math.sin(phi) * this.sinph0) * rh;
										break;
									case this.N_POLE:
										y = -y;
										phi = HALF_PI - phi;
										break;
									case this.S_POLE:
										phi -= HALF_PI;
										break;
								}
								lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);
							}
							else {
								ab = 0;
								if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
									x /= this.dd;
									y *= this.dd;
									rho = Math.sqrt(x * x + y * y);
									if (rho < EPSLN) {
										p.x = this.long0;
										p.y = this.lat0;
										return p;
									}
									sCe = 2 * Math.asin(0.5 * rho / this.rq);
									cCe = Math.cos(sCe);
									x *= (sCe = Math.sin(sCe));
									if (this.mode === this.OBLIQ) {
										ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
										q = this.qp * ab;
										y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
									}
									else {
										ab = y * sCe / rho;
										q = this.qp * ab;
										y = rho * cCe;
									}
								}
								else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
									if (this.mode === this.N_POLE) {
										y = -y;
									}
									q = (x * x + y * y);
									if (!q) {
										p.x = this.long0;
										p.y = this.lat0;
										return p;
									}
									ab = 1 - q / this.qp;
									if (this.mode === this.S_POLE) {
										ab = -ab;
									}
								}
								lam = Math.atan2(x, y);
								phi = authlat(Math.asin(ab), this.apa);
							}

							p.x = adjust_lon(this.long0 + lam);
							p.y = phi;
							return p;
						}

						/* determine latitude from authalic latitude */
						var P00 = 0.33333333333333333333;

						var P01 = 0.17222222222222222222;
						var P02 = 0.10257936507936507936;
						var P10 = 0.06388888888888888888;
						var P11 = 0.06640211640211640211;
						var P20 = 0.01641501294219154443;

						function authset(es) {
							var t;
							var APA = [];
							APA[0] = es * P00;
							t = es * es;
							APA[0] += t * P01;
							APA[1] = t * P10;
							t *= es;
							APA[0] += t * P02;
							APA[1] += t * P11;
							APA[2] = t * P20;
							return APA;
						}

						function authlat(beta, APA) {
							var t = beta + beta;
							return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));
						}

						var names$14 = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
						var laea = {
							init: init$13,
							forward: forward$12,
							inverse: inverse$12,
							names: names$14,
							S_POLE: S_POLE,
							N_POLE: N_POLE,
							EQUIT: EQUIT,
							OBLIQ: OBLIQ
						};

						var asinz = function (x) {
							if (Math.abs(x) > 1) {
								x = (x > 1) ? 1 : -1;
							}
							return Math.asin(x);
						};

						function init$14() {

							if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
								return;
							}
							this.temp = this.b / this.a;
							this.es = 1 - Math.pow(this.temp, 2);
							this.e3 = Math.sqrt(this.es);

							this.sin_po = Math.sin(this.lat1);
							this.cos_po = Math.cos(this.lat1);
							this.t1 = this.sin_po;
							this.con = this.sin_po;
							this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
							this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);

							this.sin_po = Math.sin(this.lat2);
							this.cos_po = Math.cos(this.lat2);
							this.t2 = this.sin_po;
							this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
							this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);

							this.sin_po = Math.sin(this.lat0);
							this.cos_po = Math.cos(this.lat0);
							this.t3 = this.sin_po;
							this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);

							if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
								this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
							}
							else {
								this.ns0 = this.con;
							}
							this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
							this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
						}

						/* Albers Conical Equal Area forward equations--mapping lat,long to x,y
						  -------------------------------------------------------------------*/
						function forward$13(p) {

							var lon = p.x;
							var lat = p.y;

							this.sin_phi = Math.sin(lat);
							this.cos_phi = Math.cos(lat);

							var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
							var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
							var theta = this.ns0 * adjust_lon(lon - this.long0);
							var x = rh1 * Math.sin(theta) + this.x0;
							var y = this.rh - rh1 * Math.cos(theta) + this.y0;

							p.x = x;
							p.y = y;
							return p;
						}

						function inverse$13(p) {
							var rh1, qs, con, theta, lon, lat;

							p.x -= this.x0;
							p.y = this.rh - p.y + this.y0;
							if (this.ns0 >= 0) {
								rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
								con = 1;
							}
							else {
								rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
								con = -1;
							}
							theta = 0;
							if (rh1 !== 0) {
								theta = Math.atan2(con * p.x, con * p.y);
							}
							con = rh1 * this.ns0 / this.a;
							if (this.sphere) {
								lat = Math.asin((this.c - con * con) / (2 * this.ns0));
							}
							else {
								qs = (this.c - con * con) / this.ns0;
								lat = this.phi1z(this.e3, qs);
							}

							lon = adjust_lon(theta / this.ns0 + this.long0);
							p.x = lon;
							p.y = lat;
							return p;
						}

						/* Function to compute phi1, the latitude for the inverse of the
						   Albers Conical Equal-Area projection.
						-------------------------------------------*/
						function phi1z(eccent, qs) {
							var sinphi, cosphi, con, com, dphi;
							var phi = asinz(0.5 * qs);
							if (eccent < EPSLN) {
								return phi;
							}

							var eccnts = eccent * eccent;
							for (var i = 1; i <= 25; i++) {
								sinphi = Math.sin(phi);
								cosphi = Math.cos(phi);
								con = eccent * sinphi;
								com = 1 - con * con;
								dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
								phi = phi + dphi;
								if (Math.abs(dphi) <= 1e-7) {
									return phi;
								}
							}
							return null;
						}

						var names$15 = ["Albers_Conic_Equal_Area", "Albers", "aea"];
						var aea = {
							init: init$14,
							forward: forward$13,
							inverse: inverse$13,
							names: names$15,
							phi1z: phi1z
						};

						/*
						  reference:
							Wolfram Mathworld "Gnomonic Projection"
							http://mathworld.wolfram.com/GnomonicProjection.html
							Accessed: 12th November 2009
						  */
						function init$15() {

							/* Place parameters in static storage for common use
								-------------------------------------------------*/
							this.sin_p14 = Math.sin(this.lat0);
							this.cos_p14 = Math.cos(this.lat0);
							// Approximation for projecting points to the horizon (infinity)
							this.infinity_dist = 1000 * this.a;
							this.rc = 1;
						}

						/* Gnomonic forward equations--mapping lat,long to x,y
							---------------------------------------------------*/
						function forward$14(p) {
							var sinphi, cosphi; /* sin and cos value        */
							var dlon; /* delta longitude value      */
							var coslon; /* cos of longitude        */
							var ksp; /* scale factor          */
							var g;
							var x, y;
							var lon = p.x;
							var lat = p.y;
							/* Forward equations
								-----------------*/
							dlon = adjust_lon(lon - this.long0);

							sinphi = Math.sin(lat);
							cosphi = Math.cos(lat);

							coslon = Math.cos(dlon);
							g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
							ksp = 1;
							if ((g > 0) || (Math.abs(g) <= EPSLN)) {
								x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
								y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
							}
							else {

								// Point is in the opposing hemisphere and is unprojectable
								// We still need to return a reasonable point, so we project
								// to infinity, on a bearing
								// equivalent to the northern hemisphere equivalent
								// This is a reasonable approximation for short shapes and lines that
								// straddle the horizon.

								x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
								y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);

							}
							p.x = x;
							p.y = y;
							return p;
						}

						function inverse$14(p) {
							var rh; /* Rho */
							var sinc, cosc;
							var c;
							var lon, lat;

							/* Inverse equations
								-----------------*/
							p.x = (p.x - this.x0) / this.a;
							p.y = (p.y - this.y0) / this.a;

							p.x /= this.k0;
							p.y /= this.k0;

							if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {
								c = Math.atan2(rh, this.rc);
								sinc = Math.sin(c);
								cosc = Math.cos(c);

								lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);
								lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
								lon = adjust_lon(this.long0 + lon);
							}
							else {
								lat = this.phic0;
								lon = 0;
							}

							p.x = lon;
							p.y = lat;
							return p;
						}

						var names$16 = ["gnom"];
						var gnom = {
							init: init$15,
							forward: forward$14,
							inverse: inverse$14,
							names: names$16
						};

						var iqsfnz = function (eccent, q) {
							var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
							if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
								if (q < 0) {
									return (-1 * HALF_PI);
								}
								else {
									return HALF_PI;
								}
							}
							//var phi = 0.5* q/(1-eccent*eccent);
							var phi = Math.asin(0.5 * q);
							var dphi;
							var sin_phi;
							var cos_phi;
							var con;
							for (var i = 0; i < 30; i++) {
								sin_phi = Math.sin(phi);
								cos_phi = Math.cos(phi);
								con = eccent * sin_phi;
								dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
								phi += dphi;
								if (Math.abs(dphi) <= 0.0000000001) {
									return phi;
								}
							}

							//console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
							return NaN;
						};

						/*
						  reference:
							"Cartographic Projection Procedures for the UNIX Environment-
							A User's Manual" by Gerald I. Evenden,
							USGS Open File Report 90-284and Release 4 Interim Reports (2003)
						*/
						function init$16() {
							//no-op
							if (!this.sphere) {
								this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
							}
						}

						/* Cylindrical Equal Area forward equations--mapping lat,long to x,y
							------------------------------------------------------------*/
						function forward$15(p) {
							var lon = p.x;
							var lat = p.y;
							var x, y;
							/* Forward equations
								-----------------*/
							var dlon = adjust_lon(lon - this.long0);
							if (this.sphere) {
								x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
								y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
							}
							else {
								var qs = qsfnz(this.e, Math.sin(lat));
								x = this.x0 + this.a * this.k0 * dlon;
								y = this.y0 + this.a * qs * 0.5 / this.k0;
							}

							p.x = x;
							p.y = y;
							return p;
						}

						/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
							------------------------------------------------------------*/
						function inverse$15(p) {
							p.x -= this.x0;
							p.y -= this.y0;
							var lon, lat;

							if (this.sphere) {
								lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));
								lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));
							}
							else {
								lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
								lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
							}

							p.x = lon;
							p.y = lat;
							return p;
						}

						var names$17 = ["cea"];
						var cea = {
							init: init$16,
							forward: forward$15,
							inverse: inverse$15,
							names: names$17
						};

						function init$17() {

							this.x0 = this.x0 || 0;
							this.y0 = this.y0 || 0;
							this.lat0 = this.lat0 || 0;
							this.long0 = this.long0 || 0;
							this.lat_ts = this.lat_ts || 0;
							this.title = this.title || "Equidistant Cylindrical (Plate Carre)";

							this.rc = Math.cos(this.lat_ts);
						}

						// forward equations--mapping lat,long to x,y
						// -----------------------------------------------------------------
						function forward$16(p) {

							var lon = p.x;
							var lat = p.y;

							var dlon = adjust_lon(lon - this.long0);
							var dlat = adjust_lat(lat - this.lat0);
							p.x = this.x0 + (this.a * dlon * this.rc);
							p.y = this.y0 + (this.a * dlat);
							return p;
						}

						// inverse equations--mapping x,y to lat/long
						// -----------------------------------------------------------------
						function inverse$16(p) {

							var x = p.x;
							var y = p.y;

							p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));
							p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));
							return p;
						}

						var names$18 = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
						var eqc = {
							init: init$17,
							forward: forward$16,
							inverse: inverse$16,
							names: names$18
						};

						var MAX_ITER$2 = 20;

						function init$18() {
							/* Place parameters in static storage for common use
								-------------------------------------------------*/
							this.temp = this.b / this.a;
							this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
							this.e = Math.sqrt(this.es);
							this.e0 = e0fn(this.es);
							this.e1 = e1fn(this.es);
							this.e2 = e2fn(this.es);
							this.e3 = e3fn(this.es);
							this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
						}

						/* Polyconic forward equations--mapping lat,long to x,y
							---------------------------------------------------*/
						function forward$17(p) {
							var lon = p.x;
							var lat = p.y;
							var x, y, el;
							var dlon = adjust_lon(lon - this.long0);
							el = dlon * Math.sin(lat);
							if (this.sphere) {
								if (Math.abs(lat) <= EPSLN) {
									x = this.a * dlon;
									y = -1 * this.a * this.lat0;
								}
								else {
									x = this.a * Math.sin(el) / Math.tan(lat);
									y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
								}
							}
							else {
								if (Math.abs(lat) <= EPSLN) {
									x = this.a * dlon;
									y = -1 * this.ml0;
								}
								else {
									var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
									x = nl * Math.sin(el);
									y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
								}

							}
							p.x = x + this.x0;
							p.y = y + this.y0;
							return p;
						}

						/* Inverse equations
						  -----------------*/
						function inverse$17(p) {
							var lon, lat, x, y, i;
							var al, bl;
							var phi, dphi;
							x = p.x - this.x0;
							y = p.y - this.y0;

							if (this.sphere) {
								if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
									lon = adjust_lon(x / this.a + this.long0);
									lat = 0;
								}
								else {
									al = this.lat0 + y / this.a;
									bl = x * x / this.a / this.a + al * al;
									phi = al;
									var tanphi;
									for (i = MAX_ITER$2; i; --i) {
										tanphi = Math.tan(phi);
										dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
										phi += dphi;
										if (Math.abs(dphi) <= EPSLN) {
											lat = phi;
											break;
										}
									}
									lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));
								}
							}
							else {
								if (Math.abs(y + this.ml0) <= EPSLN) {
									lat = 0;
									lon = adjust_lon(this.long0 + x / this.a);
								}
								else {

									al = (this.ml0 + y) / this.a;
									bl = x * x / this.a / this.a + al * al;
									phi = al;
									var cl, mln, mlnp, ma;
									var con;
									for (i = MAX_ITER$2; i; --i) {
										con = this.e * Math.sin(phi);
										cl = Math.sqrt(1 - con * con) * Math.tan(phi);
										mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
										mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
										ma = mln / this.a;
										dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
										phi -= dphi;
										if (Math.abs(dphi) <= EPSLN) {
											lat = phi;
											break;
										}
									}

									//lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
									cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
									lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
								}
							}

							p.x = lon;
							p.y = lat;
							return p;
						}

						var names$19 = ["Polyconic", "poly"];
						var poly = {
							init: init$18,
							forward: forward$17,
							inverse: inverse$17,
							names: names$19
						};

						/*
						  reference
							Department of Land and Survey Technical Circular 1973/32
							  http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf
							OSG Technical Report 4.1
							  http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf
						  */

						/**
						 * iterations: Number of iterations to refine inverse transform.
						 *     0 -> km accuracy
						 *     1 -> m accuracy -- suitable for most mapping applications
						 *     2 -> mm accuracy
						 */


						function init$19() {
							this.A = [];
							this.A[1] = 0.6399175073;
							this.A[2] = -0.1358797613;
							this.A[3] = 0.063294409;
							this.A[4] = -0.02526853;
							this.A[5] = 0.0117879;
							this.A[6] = -0.0055161;
							this.A[7] = 0.0026906;
							this.A[8] = -0.001333;
							this.A[9] = 0.00067;
							this.A[10] = -0.00034;

							this.B_re = [];
							this.B_im = [];
							this.B_re[1] = 0.7557853228;
							this.B_im[1] = 0;
							this.B_re[2] = 0.249204646;
							this.B_im[2] = 0.003371507;
							this.B_re[3] = -0.001541739;
							this.B_im[3] = 0.041058560;
							this.B_re[4] = -0.10162907;
							this.B_im[4] = 0.01727609;
							this.B_re[5] = -0.26623489;
							this.B_im[5] = -0.36249218;
							this.B_re[6] = -0.6870983;
							this.B_im[6] = -1.1651967;

							this.C_re = [];
							this.C_im = [];
							this.C_re[1] = 1.3231270439;
							this.C_im[1] = 0;
							this.C_re[2] = -0.577245789;
							this.C_im[2] = -0.007809598;
							this.C_re[3] = 0.508307513;
							this.C_im[3] = -0.112208952;
							this.C_re[4] = -0.15094762;
							this.C_im[4] = 0.18200602;
							this.C_re[5] = 1.01418179;
							this.C_im[5] = 1.64497696;
							this.C_re[6] = 1.9660549;
							this.C_im[6] = 2.5127645;

							this.D = [];
							this.D[1] = 1.5627014243;
							this.D[2] = 0.5185406398;
							this.D[3] = -0.03333098;
							this.D[4] = -0.1052906;
							this.D[5] = -0.0368594;
							this.D[6] = 0.007317;
							this.D[7] = 0.01220;
							this.D[8] = 0.00394;
							this.D[9] = -0.0013;
						}

						/**
							New Zealand Map Grid Forward  - long/lat to x/y
							long/lat in radians
						  */
						function forward$18(p) {
							var n;
							var lon = p.x;
							var lat = p.y;

							var delta_lat = lat - this.lat0;
							var delta_lon = lon - this.long0;

							// 1. Calculate d_phi and d_psi    ...                          // and d_lambda
							// For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
							var d_phi = delta_lat / SEC_TO_RAD * 1E-5;
							var d_lambda = delta_lon;
							var d_phi_n = 1; // d_phi^0

							var d_psi = 0;
							for (n = 1; n <= 10; n++) {
								d_phi_n = d_phi_n * d_phi;
								d_psi = d_psi + this.A[n] * d_phi_n;
							}

							// 2. Calculate theta
							var th_re = d_psi;
							var th_im = d_lambda;

							// 3. Calculate z
							var th_n_re = 1;
							var th_n_im = 0; // theta^0
							var th_n_re1;
							var th_n_im1;

							var z_re = 0;
							var z_im = 0;
							for (n = 1; n <= 6; n++) {
								th_n_re1 = th_n_re * th_re - th_n_im * th_im;
								th_n_im1 = th_n_im * th_re + th_n_re * th_im;
								th_n_re = th_n_re1;
								th_n_im = th_n_im1;
								z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
								z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
							}

							// 4. Calculate easting and northing
							p.x = (z_im * this.a) + this.x0;
							p.y = (z_re * this.a) + this.y0;

							return p;
						}

						/**
							New Zealand Map Grid Inverse  -  x/y to long/lat
						  */
						function inverse$18(p) {
							var n;
							var x = p.x;
							var y = p.y;

							var delta_x = x - this.x0;
							var delta_y = y - this.y0;

							// 1. Calculate z
							var z_re = delta_y / this.a;
							var z_im = delta_x / this.a;

							// 2a. Calculate theta - first approximation gives km accuracy
							var z_n_re = 1;
							var z_n_im = 0; // z^0
							var z_n_re1;
							var z_n_im1;

							var th_re = 0;
							var th_im = 0;
							for (n = 1; n <= 6; n++) {
								z_n_re1 = z_n_re * z_re - z_n_im * z_im;
								z_n_im1 = z_n_im * z_re + z_n_re * z_im;
								z_n_re = z_n_re1;
								z_n_im = z_n_im1;
								th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
								th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
							}

							// 2b. Iterate to refine the accuracy of the calculation
							//        0 iterations gives km accuracy
							//        1 iteration gives m accuracy -- good enough for most mapping applications
							//        2 iterations bives mm accuracy
							for (var i = 0; i < this.iterations; i++) {
								var th_n_re = th_re;
								var th_n_im = th_im;
								var th_n_re1;
								var th_n_im1;

								var num_re = z_re;
								var num_im = z_im;
								for (n = 2; n <= 6; n++) {
									th_n_re1 = th_n_re * th_re - th_n_im * th_im;
									th_n_im1 = th_n_im * th_re + th_n_re * th_im;
									th_n_re = th_n_re1;
									th_n_im = th_n_im1;
									num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
									num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
								}

								th_n_re = 1;
								th_n_im = 0;
								var den_re = this.B_re[1];
								var den_im = this.B_im[1];
								for (n = 2; n <= 6; n++) {
									th_n_re1 = th_n_re * th_re - th_n_im * th_im;
									th_n_im1 = th_n_im * th_re + th_n_re * th_im;
									th_n_re = th_n_re1;
									th_n_im = th_n_im1;
									den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
									den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
								}

								// Complex division
								var den2 = den_re * den_re + den_im * den_im;
								th_re = (num_re * den_re + num_im * den_im) / den2;
								th_im = (num_im * den_re - num_re * den_im) / den2;
							}

							// 3. Calculate d_phi              ...                                    // and d_lambda
							var d_psi = th_re;
							var d_lambda = th_im;
							var d_psi_n = 1; // d_psi^0

							var d_phi = 0;
							for (n = 1; n <= 9; n++) {
								d_psi_n = d_psi_n * d_psi;
								d_phi = d_phi + this.D[n] * d_psi_n;
							}

							// 4. Calculate latitude and longitude
							// d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
							var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);
							var lon = this.long0 + d_lambda;

							p.x = lon;
							p.y = lat;

							return p;
						}

						var names$20 = ["New_Zealand_Map_Grid", "nzmg"];
						var nzmg = {
							init: init$19,
							forward: forward$18,
							inverse: inverse$18,
							names: names$20
						};

						/*
						  reference
							"New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
							The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
						  */


						/* Initialize the Miller Cylindrical projection
						  -------------------------------------------*/
						function init$20() {
							//no-op
						}

						/* Miller Cylindrical forward equations--mapping lat,long to x,y
							------------------------------------------------------------*/
						function forward$19(p) {
							var lon = p.x;
							var lat = p.y;
							/* Forward equations
								-----------------*/
							var dlon = adjust_lon(lon - this.long0);
							var x = this.x0 + this.a * dlon;
							var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;

							p.x = x;
							p.y = y;
							return p;
						}

						/* Miller Cylindrical inverse equations--mapping x,y to lat/long
							------------------------------------------------------------*/
						function inverse$19(p) {
							p.x -= this.x0;
							p.y -= this.y0;

							var lon = adjust_lon(this.long0 + p.x / this.a);
							var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);

							p.x = lon;
							p.y = lat;
							return p;
						}

						var names$21 = ["Miller_Cylindrical", "mill"];
						var mill = {
							init: init$20,
							forward: forward$19,
							inverse: inverse$19,
							names: names$21
						};

						var MAX_ITER$3 = 20;
						function init$21() {
							/* Place parameters in static storage for common use
							  -------------------------------------------------*/


							if (!this.sphere) {
								this.en = pj_enfn(this.es);
							}
							else {
								this.n = 1;
								this.m = 0;
								this.es = 0;
								this.C_y = Math.sqrt((this.m + 1) / this.n);
								this.C_x = this.C_y / (this.m + 1);
							}

						}

						/* Sinusoidal forward equations--mapping lat,long to x,y
						  -----------------------------------------------------*/
						function forward$20(p) {
							var x, y;
							var lon = p.x;
							var lat = p.y;
							/* Forward equations
							  -----------------*/
							lon = adjust_lon(lon - this.long0);

							if (this.sphere) {
								if (!this.m) {
									lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
								}
								else {
									var k = this.n * Math.sin(lat);
									for (var i = MAX_ITER$3; i; --i) {
										var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
										lat -= V;
										if (Math.abs(V) < EPSLN) {
											break;
										}
									}
								}
								x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
								y = this.a * this.C_y * lat;

							}
							else {

								var s = Math.sin(lat);
								var c = Math.cos(lat);
								y = this.a * pj_mlfn(lat, s, c, this.en);
								x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
							}

							p.x = x;
							p.y = y;
							return p;
						}

						function inverse$20(p) {
							var lat, temp, lon, s;

							p.x -= this.x0;
							lon = p.x / this.a;
							p.y -= this.y0;
							lat = p.y / this.a;

							if (this.sphere) {
								lat /= this.C_y;
								lon = lon / (this.C_x * (this.m + Math.cos(lat)));
								if (this.m) {
									lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
								}
								else if (this.n !== 1) {
									lat = asinz(Math.sin(lat) / this.n);
								}
								lon = adjust_lon(lon + this.long0);
								lat = adjust_lat(lat);
							}
							else {
								lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
								s = Math.abs(lat);
								if (s < HALF_PI) {
									s = Math.sin(lat);
									temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
									//temp = this.long0 + p.x / (this.a * Math.cos(lat));
									lon = adjust_lon(temp);
								}
								else if ((s - EPSLN) < HALF_PI) {
									lon = this.long0;
								}
							}
							p.x = lon;
							p.y = lat;
							return p;
						}

						var names$22 = ["Sinusoidal", "sinu"];
						var sinu = {
							init: init$21,
							forward: forward$20,
							inverse: inverse$20,
							names: names$22
						};

						function init$22() { }
						/* Mollweide forward equations--mapping lat,long to x,y
							----------------------------------------------------*/
						function forward$21(p) {

							/* Forward equations
								-----------------*/
							var lon = p.x;
							var lat = p.y;

							var delta_lon = adjust_lon(lon - this.long0);
							var theta = lat;
							var con = Math.PI * Math.sin(lat);

							/* Iterate using the Newton-Raphson method to find theta
								-----------------------------------------------------*/
							while (true) {
								var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
								theta += delta_theta;
								if (Math.abs(delta_theta) < EPSLN) {
									break;
								}
							}
							theta /= 2;

							/* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
								 this is done here because of precision problems with "cos(theta)"
								 --------------------------------------------------------------------------*/
							if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
								delta_lon = 0;
							}
							var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
							var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;

							p.x = x;
							p.y = y;
							return p;
						}

						function inverse$21(p) {
							var theta;
							var arg;

							/* Inverse equations
								-----------------*/
							p.x -= this.x0;
							p.y -= this.y0;
							arg = p.y / (1.4142135623731 * this.a);

							/* Because of division by zero problems, 'arg' can not be 1.  Therefore
								 a number very close to one is used instead.
								 -------------------------------------------------------------------*/
							if (Math.abs(arg) > 0.999999999999) {
								arg = 0.999999999999;
							}
							theta = Math.asin(arg);
							var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));
							if (lon < (-Math.PI)) {
								lon = -Math.PI;
							}
							if (lon > Math.PI) {
								lon = Math.PI;
							}
							arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
							if (Math.abs(arg) > 1) {
								arg = 1;
							}
							var lat = Math.asin(arg);

							p.x = lon;
							p.y = lat;
							return p;
						}

						var names$23 = ["Mollweide", "moll"];
						var moll = {
							init: init$22,
							forward: forward$21,
							inverse: inverse$21,
							names: names$23
						};

						function init$23() {

							/* Place parameters in static storage for common use
								-------------------------------------------------*/
							// Standard Parallels cannot be equal and on opposite sides of the equator
							if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
								return;
							}
							this.lat2 = this.lat2 || this.lat1;
							this.temp = this.b / this.a;
							this.es = 1 - Math.pow(this.temp, 2);
							this.e = Math.sqrt(this.es);
							this.e0 = e0fn(this.es);
							this.e1 = e1fn(this.es);
							this.e2 = e2fn(this.es);
							this.e3 = e3fn(this.es);

							this.sinphi = Math.sin(this.lat1);
							this.cosphi = Math.cos(this.lat1);

							this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
							this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);

							if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
								this.ns = this.sinphi;
							}
							else {
								this.sinphi = Math.sin(this.lat2);
								this.cosphi = Math.cos(this.lat2);
								this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
								this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
								this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
							}
							this.g = this.ml1 + this.ms1 / this.ns;
							this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
							this.rh = this.a * (this.g - this.ml0);
						}

						/* Equidistant Conic forward equations--mapping lat,long to x,y
						  -----------------------------------------------------------*/
						function forward$22(p) {
							var lon = p.x;
							var lat = p.y;
							var rh1;

							/* Forward equations
								-----------------*/
							if (this.sphere) {
								rh1 = this.a * (this.g - lat);
							}
							else {
								var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
								rh1 = this.a * (this.g - ml);
							}
							var theta = this.ns * adjust_lon(lon - this.long0);
							var x = this.x0 + rh1 * Math.sin(theta);
							var y = this.y0 + this.rh - rh1 * Math.cos(theta);
							p.x = x;
							p.y = y;
							return p;
						}

						/* Inverse equations
						  -----------------*/
						function inverse$22(p) {
							p.x -= this.x0;
							p.y = this.rh - p.y + this.y0;
							var con, rh1, lat, lon;
							if (this.ns >= 0) {
								rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
								con = 1;
							}
							else {
								rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
								con = -1;
							}
							var theta = 0;
							if (rh1 !== 0) {
								theta = Math.atan2(con * p.x, con * p.y);
							}

							if (this.sphere) {
								lon = adjust_lon(this.long0 + theta / this.ns);
								lat = adjust_lat(this.g - rh1 / this.a);
								p.x = lon;
								p.y = lat;
								return p;
							}
							else {
								var ml = this.g - rh1 / this.a;
								lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
								lon = adjust_lon(this.long0 + theta / this.ns);
								p.x = lon;
								p.y = lat;
								return p;
							}

						}

						var names$24 = ["Equidistant_Conic", "eqdc"];
						var eqdc = {
							init: init$23,
							forward: forward$22,
							inverse: inverse$22,
							names: names$24
						};

						/* Initialize the Van Der Grinten projection
						  ----------------------------------------*/
						function init$24() {
							//this.R = 6370997; //Radius of earth
							this.R = this.a;
						}

						function forward$23(p) {

							var lon = p.x;
							var lat = p.y;

							/* Forward equations
							  -----------------*/
							var dlon = adjust_lon(lon - this.long0);
							var x, y;

							if (Math.abs(lat) <= EPSLN) {
								x = this.x0 + this.R * dlon;
								y = this.y0;
							}
							var theta = asinz(2 * Math.abs(lat / Math.PI));
							if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {
								x = this.x0;
								if (lat >= 0) {
									y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
								}
								else {
									y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
								}
								//  return(OK);
							}
							var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));
							var asq = al * al;
							var sinth = Math.sin(theta);
							var costh = Math.cos(theta);

							var g = costh / (sinth + costh - 1);
							var gsq = g * g;
							var m = g * (2 / sinth - 1);
							var msq = m * m;
							var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
							if (dlon < 0) {
								con = -con;
							}
							x = this.x0 + con;
							//con = Math.abs(con / (Math.PI * this.R));
							var q = asq + g;
							con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
							if (lat >= 0) {
								//y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
								y = this.y0 + con;
							}
							else {
								//y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
								y = this.y0 - con;
							}
							p.x = x;
							p.y = y;
							return p;
						}

						/* Van Der Grinten inverse equations--mapping x,y to lat/long
						  ---------------------------------------------------------*/
						function inverse$23(p) {
							var lon, lat;
							var xx, yy, xys, c1, c2, c3;
							var a1;
							var m1;
							var con;
							var th1;
							var d;

							/* inverse equations
							  -----------------*/
							p.x -= this.x0;
							p.y -= this.y0;
							con = Math.PI * this.R;
							xx = p.x / con;
							yy = p.y / con;
							xys = xx * xx + yy * yy;
							c1 = -Math.abs(yy) * (1 + xys);
							c2 = c1 - 2 * yy * yy + xx * xx;
							c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
							d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
							a1 = (c1 - c2 * c2 / 3 / c3) / c3;
							m1 = 2 * Math.sqrt(-a1 / 3);
							con = ((3 * d) / a1) / m1;
							if (Math.abs(con) > 1) {
								if (con >= 0) {
									con = 1;
								}
								else {
									con = -1;
								}
							}
							th1 = Math.acos(con) / 3;
							if (p.y >= 0) {
								lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
							}
							else {
								lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
							}

							if (Math.abs(xx) < EPSLN) {
								lon = this.long0;
							}
							else {
								lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
							}

							p.x = lon;
							p.y = lat;
							return p;
						}

						var names$25 = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
						var vandg = {
							init: init$24,
							forward: forward$23,
							inverse: inverse$23,
							names: names$25
						};

						function init$25() {
							this.sin_p12 = Math.sin(this.lat0);
							this.cos_p12 = Math.cos(this.lat0);
						}

						function forward$24(p) {
							var lon = p.x;
							var lat = p.y;
							var sinphi = Math.sin(p.y);
							var cosphi = Math.cos(p.y);
							var dlon = adjust_lon(lon - this.long0);
							var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
							if (this.sphere) {
								if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
									//North Pole case
									p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
									p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
									return p;
								}
								else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
									//South Pole case
									p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
									p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
									return p;
								}
								else {
									//default case
									cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
									c = Math.acos(cos_c);
									kp = c ? c / Math.sin(c) : 1;
									p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
									p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
									return p;
								}
							}
							else {
								e0 = e0fn(this.es);
								e1 = e1fn(this.es);
								e2 = e2fn(this.es);
								e3 = e3fn(this.es);
								if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
									//North Pole case
									Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
									Ml = this.a * mlfn(e0, e1, e2, e3, lat);
									p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
									p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
									return p;
								}
								else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
									//South Pole case
									Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
									Ml = this.a * mlfn(e0, e1, e2, e3, lat);
									p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
									p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
									return p;
								}
								else {
									//Default case
									tanphi = sinphi / cosphi;
									Nl1 = gN(this.a, this.e, this.sin_p12);
									Nl = gN(this.a, this.e, sinphi);
									psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
									Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
									if (Az === 0) {
										s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
									}
									else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
										s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
									}
									else {
										s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
									}
									G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
									H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
									GH = G * H;
									Hs = H * H;
									s2 = s * s;
									s3 = s2 * s;
									s4 = s3 * s;
									s5 = s4 * s;
									c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
									p.x = this.x0 + c * Math.sin(Az);
									p.y = this.y0 + c * Math.cos(Az);
									return p;
								}
							}


						}

						function inverse$24(p) {
							p.x -= this.x0;
							p.y -= this.y0;
							var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F, sinpsi;
							if (this.sphere) {
								rh = Math.sqrt(p.x * p.x + p.y * p.y);
								if (rh > (2 * HALF_PI * this.a)) {
									return;
								}
								z = rh / this.a;

								sinz = Math.sin(z);
								cosz = Math.cos(z);

								lon = this.long0;
								if (Math.abs(rh) <= EPSLN) {
									lat = this.lat0;
								}
								else {
									lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);
									con = Math.abs(this.lat0) - HALF_PI;
									if (Math.abs(con) <= EPSLN) {
										if (this.lat0 >= 0) {
											lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
										}
										else {
											lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
										}
									}
									else {
										/*con = cosz - this.sin_p12 * Math.sin(lat);
										if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
										  //no-op, just keep the lon value as is
										} else {
										  var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
										  lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
										}*/
										lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
									}
								}

								p.x = lon;
								p.y = lat;
								return p;
							}
							else {
								e0 = e0fn(this.es);
								e1 = e1fn(this.es);
								e2 = e2fn(this.es);
								e3 = e3fn(this.es);
								if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
									//North pole case
									Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
									rh = Math.sqrt(p.x * p.x + p.y * p.y);
									M = Mlp - rh;
									lat = imlfn(M / this.a, e0, e1, e2, e3);
									lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
									p.x = lon;
									p.y = lat;
									return p;
								}
								else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
									//South pole case
									Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
									rh = Math.sqrt(p.x * p.x + p.y * p.y);
									M = rh - Mlp;

									lat = imlfn(M / this.a, e0, e1, e2, e3);
									lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
									p.x = lon;
									p.y = lat;
									return p;
								}
								else {
									//default case
									rh = Math.sqrt(p.x * p.x + p.y * p.y);
									Az = Math.atan2(p.x, p.y);
									N1 = gN(this.a, this.e, this.sin_p12);
									cosAz = Math.cos(Az);
									tmp = this.e * this.cos_p12 * cosAz;
									A = -tmp * tmp / (1 - this.es);
									B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
									D = rh / N1;
									Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
									F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
									psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
									lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
									sinpsi = Math.sin(psi);
									lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
									p.x = lon;
									p.y = lat;
									return p;
								}
							}

						}

						var names$26 = ["Azimuthal_Equidistant", "aeqd"];
						var aeqd = {
							init: init$25,
							forward: forward$24,
							inverse: inverse$24,
							names: names$26
						};

						function init$26() {
							//double temp;      /* temporary variable    */

							/* Place parameters in static storage for common use
								-------------------------------------------------*/
							this.sin_p14 = Math.sin(this.lat0);
							this.cos_p14 = Math.cos(this.lat0);
						}

						/* Orthographic forward equations--mapping lat,long to x,y
							---------------------------------------------------*/
						function forward$25(p) {
							var sinphi, cosphi; /* sin and cos value        */
							var dlon; /* delta longitude value      */
							var coslon; /* cos of longitude        */
							var ksp; /* scale factor          */
							var g, x, y;
							var lon = p.x;
							var lat = p.y;
							/* Forward equations
								-----------------*/
							dlon = adjust_lon(lon - this.long0);

							sinphi = Math.sin(lat);
							cosphi = Math.cos(lat);

							coslon = Math.cos(dlon);
							g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
							ksp = 1;
							if ((g > 0) || (Math.abs(g) <= EPSLN)) {
								x = this.a * ksp * cosphi * Math.sin(dlon);
								y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
							}
							p.x = x;
							p.y = y;
							return p;
						}

						function inverse$25(p) {
							var rh; /* height above ellipsoid      */
							var z; /* angle          */
							var sinz, cosz; /* sin of z and cos of z      */
							var con;
							var lon, lat;
							/* Inverse equations
								-----------------*/
							p.x -= this.x0;
							p.y -= this.y0;
							rh = Math.sqrt(p.x * p.x + p.y * p.y);
							z = asinz(rh / this.a);

							sinz = Math.sin(z);
							cosz = Math.cos(z);

							lon = this.long0;
							if (Math.abs(rh) <= EPSLN) {
								lat = this.lat0;
								p.x = lon;
								p.y = lat;
								return p;
							}
							lat = asinz(cosz * this.sin_p14 + (p.y * sinz * this.cos_p14) / rh);
							con = Math.abs(this.lat0) - HALF_PI;
							if (Math.abs(con) <= EPSLN) {
								if (this.lat0 >= 0) {
									lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
								}
								else {
									lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
								}
								p.x = lon;
								p.y = lat;
								return p;
							}
							lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz), rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
							p.x = lon;
							p.y = lat;
							return p;
						}

						var names$27 = ["ortho"];
						var ortho = {
							init: init$26,
							forward: forward$25,
							inverse: inverse$25,
							names: names$27
						};

						// QSC projection rewritten from the original PROJ4
						// https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c

						/* constants */
						var FACE_ENUM = {
							FRONT: 1,
							RIGHT: 2,
							BACK: 3,
							LEFT: 4,
							TOP: 5,
							BOTTOM: 6
						};

						var AREA_ENUM = {
							AREA_0: 1,
							AREA_1: 2,
							AREA_2: 3,
							AREA_3: 4
						};

						function init$27() {

							this.x0 = this.x0 || 0;
							this.y0 = this.y0 || 0;
							this.lat0 = this.lat0 || 0;
							this.long0 = this.long0 || 0;
							this.lat_ts = this.lat_ts || 0;
							this.title = this.title || "Quadrilateralized Spherical Cube";

							/* Determine the cube face from the center of projection. */
							if (this.lat0 >= HALF_PI - FORTPI / 2.0) {
								this.face = FACE_ENUM.TOP;
							} else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {
								this.face = FACE_ENUM.BOTTOM;
							} else if (Math.abs(this.long0) <= FORTPI) {
								this.face = FACE_ENUM.FRONT;
							} else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
								this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
							} else {
								this.face = FACE_ENUM.BACK;
							}

							/* Fill in useful values for the ellipsoid <-> sphere shift
							 * described in [LK12]. */
							if (this.es !== 0) {
								this.one_minus_f = 1 - (this.a - this.b) / this.a;
								this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
							}
						}

						// QSC forward equations--mapping lat,long to x,y
						// -----------------------------------------------------------------
						function forward$26(p) {
							var xy = { x: 0, y: 0 };
							var lat, lon;
							var theta, phi;
							var t, mu;
							/* nu; */
							var area = { value: 0 };

							// move lon according to projection's lon
							p.x -= this.long0;

							/* Convert the geodetic latitude to a geocentric latitude.
							 * This corresponds to the shift from the ellipsoid to the sphere
							 * described in [LK12]. */
							if (this.es !== 0) {//if (P->es != 0) {
								lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
							} else {
								lat = p.y;
							}

							/* Convert the input lat, lon into theta, phi as used by QSC.
							 * This depends on the cube face and the area on it.
							 * For the top and bottom face, we can compute theta and phi
							 * directly from phi, lam. For the other faces, we must use
							 * unit sphere cartesian coordinates as an intermediate step. */
							lon = p.x; //lon = lp.lam;
							if (this.face === FACE_ENUM.TOP) {
								phi = HALF_PI - lat;
								if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
									area.value = AREA_ENUM.AREA_0;
									theta = lon - HALF_PI;
								} else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
									area.value = AREA_ENUM.AREA_1;
									theta = (lon > 0.0 ? lon - SPI : lon + SPI);
								} else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
									area.value = AREA_ENUM.AREA_2;
									theta = lon + HALF_PI;
								} else {
									area.value = AREA_ENUM.AREA_3;
									theta = lon;
								}
							} else if (this.face === FACE_ENUM.BOTTOM) {
								phi = HALF_PI + lat;
								if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
									area.value = AREA_ENUM.AREA_0;
									theta = -lon + HALF_PI;
								} else if (lon < FORTPI && lon >= -FORTPI) {
									area.value = AREA_ENUM.AREA_1;
									theta = -lon;
								} else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
									area.value = AREA_ENUM.AREA_2;
									theta = -lon - HALF_PI;
								} else {
									area.value = AREA_ENUM.AREA_3;
									theta = (lon > 0.0 ? -lon + SPI : -lon - SPI);
								}
							} else {
								var q, r, s;
								var sinlat, coslat;
								var sinlon, coslon;

								if (this.face === FACE_ENUM.RIGHT) {
									lon = qsc_shift_lon_origin(lon, +HALF_PI);
								} else if (this.face === FACE_ENUM.BACK) {
									lon = qsc_shift_lon_origin(lon, +SPI);
								} else if (this.face === FACE_ENUM.LEFT) {
									lon = qsc_shift_lon_origin(lon, -HALF_PI);
								}
								sinlat = Math.sin(lat);
								coslat = Math.cos(lat);
								sinlon = Math.sin(lon);
								coslon = Math.cos(lon);
								q = coslat * coslon;
								r = coslat * sinlon;
								s = sinlat;

								if (this.face === FACE_ENUM.FRONT) {
									phi = Math.acos(q);
									theta = qsc_fwd_equat_face_theta(phi, s, r, area);
								} else if (this.face === FACE_ENUM.RIGHT) {
									phi = Math.acos(r);
									theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
								} else if (this.face === FACE_ENUM.BACK) {
									phi = Math.acos(-q);
									theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
								} else if (this.face === FACE_ENUM.LEFT) {
									phi = Math.acos(-r);
									theta = qsc_fwd_equat_face_theta(phi, s, q, area);
								} else {
									/* Impossible */
									phi = theta = 0;
									area.value = AREA_ENUM.AREA_0;
								}
							}

							/* Compute mu and nu for the area of definition.
							 * For mu, see Eq. (3-21) in [OL76], but note the typos:
							 * compare with Eq. (3-14). For nu, see Eq. (3-38). */
							mu = Math.atan((12 / SPI) * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
							t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));

							/* Apply the result to the real area. */
							if (area.value === AREA_ENUM.AREA_1) {
								mu += HALF_PI;
							} else if (area.value === AREA_ENUM.AREA_2) {
								mu += SPI;
							} else if (area.value === AREA_ENUM.AREA_3) {
								mu += 1.5 * SPI;
							}

							/* Now compute x, y from mu and nu */
							xy.x = t * Math.cos(mu);
							xy.y = t * Math.sin(mu);
							xy.x = xy.x * this.a + this.x0;
							xy.y = xy.y * this.a + this.y0;

							p.x = xy.x;
							p.y = xy.y;
							return p;
						}

						// QSC inverse equations--mapping x,y to lat/long
						// -----------------------------------------------------------------
						function inverse$26(p) {
							var lp = { lam: 0, phi: 0 };
							var mu, nu, cosmu, tannu;
							var tantheta, theta, cosphi, phi;
							var t;
							var area = { value: 0 };

							/* de-offset */
							p.x = (p.x - this.x0) / this.a;
							p.y = (p.y - this.y0) / this.a;

							/* Convert the input x, y to the mu and nu angles as used by QSC.
							 * This depends on the area of the cube face. */
							nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
							mu = Math.atan2(p.y, p.x);
							if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {
								area.value = AREA_ENUM.AREA_0;
							} else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {
								area.value = AREA_ENUM.AREA_1;
								mu -= HALF_PI;
							} else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {
								area.value = AREA_ENUM.AREA_2;
								mu = (mu < 0.0 ? mu + SPI : mu - SPI);
							} else {
								area.value = AREA_ENUM.AREA_3;
								mu += HALF_PI;
							}

							/* Compute phi and theta for the area of definition.
							 * The inverse projection is not described in the original paper, but some
							 * good hints can be found here (as of 2011-12-14):
							 * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302
							 * (search for "Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>") */
							t = (SPI / 12) * Math.tan(mu);
							tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));
							theta = Math.atan(tantheta);
							cosmu = Math.cos(mu);
							tannu = Math.tan(nu);
							cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
							if (cosphi < -1) {
								cosphi = -1;
							} else if (cosphi > +1) {
								cosphi = +1;
							}

							/* Apply the result to the real area on the cube face.
							 * For the top and bottom face, we can compute phi and lam directly.
							 * For the other faces, we must use unit sphere cartesian coordinates
							 * as an intermediate step. */
							if (this.face === FACE_ENUM.TOP) {
								phi = Math.acos(cosphi);
								lp.phi = HALF_PI - phi;
								if (area.value === AREA_ENUM.AREA_0) {
									lp.lam = theta + HALF_PI;
								} else if (area.value === AREA_ENUM.AREA_1) {
									lp.lam = (theta < 0.0 ? theta + SPI : theta - SPI);
								} else if (area.value === AREA_ENUM.AREA_2) {
									lp.lam = theta - HALF_PI;
								} else /* area.value == AREA_ENUM.AREA_3 */ {
									lp.lam = theta;
								}
							} else if (this.face === FACE_ENUM.BOTTOM) {
								phi = Math.acos(cosphi);
								lp.phi = phi - HALF_PI;
								if (area.value === AREA_ENUM.AREA_0) {
									lp.lam = -theta + HALF_PI;
								} else if (area.value === AREA_ENUM.AREA_1) {
									lp.lam = -theta;
								} else if (area.value === AREA_ENUM.AREA_2) {
									lp.lam = -theta - HALF_PI;
								} else /* area.value == AREA_ENUM.AREA_3 */ {
									lp.lam = (theta < 0.0 ? -theta - SPI : -theta + SPI);
								}
							} else {
								/* Compute phi and lam via cartesian unit sphere coordinates. */
								var q, r, s;
								q = cosphi;
								t = q * q;
								if (t >= 1) {
									s = 0;
								} else {
									s = Math.sqrt(1 - t) * Math.sin(theta);
								}
								t += s * s;
								if (t >= 1) {
									r = 0;
								} else {
									r = Math.sqrt(1 - t);
								}
								/* Rotate q,r,s into the correct area. */
								if (area.value === AREA_ENUM.AREA_1) {
									t = r;
									r = -s;
									s = t;
								} else if (area.value === AREA_ENUM.AREA_2) {
									r = -r;
									s = -s;
								} else if (area.value === AREA_ENUM.AREA_3) {
									t = r;
									r = s;
									s = -t;
								}
								/* Rotate q,r,s into the correct cube face. */
								if (this.face === FACE_ENUM.RIGHT) {
									t = q;
									q = -r;
									r = t;
								} else if (this.face === FACE_ENUM.BACK) {
									q = -q;
									r = -r;
								} else if (this.face === FACE_ENUM.LEFT) {
									t = q;
									q = r;
									r = -t;
								}
								/* Now compute phi and lam from the unit sphere coordinates. */
								lp.phi = Math.acos(-s) - HALF_PI;
								lp.lam = Math.atan2(r, q);
								if (this.face === FACE_ENUM.RIGHT) {
									lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
								} else if (this.face === FACE_ENUM.BACK) {
									lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
								} else if (this.face === FACE_ENUM.LEFT) {
									lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
								}
							}

							/* Apply the shift from the sphere to the ellipsoid as described
							 * in [LK12]. */
							if (this.es !== 0) {
								var invert_sign;
								var tanphi, xa;
								invert_sign = (lp.phi < 0 ? 1 : 0);
								tanphi = Math.tan(lp.phi);
								xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
								lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
								if (invert_sign) {
									lp.phi = -lp.phi;
								}
							}

							lp.lam += this.long0;
							p.x = lp.lam;
							p.y = lp.phi;
							return p;
						}

						/* Helper function for forward projection: compute the theta angle
						 * and determine the area number. */
						function qsc_fwd_equat_face_theta(phi, y, x, area) {
							var theta;
							if (phi < EPSLN) {
								area.value = AREA_ENUM.AREA_0;
								theta = 0.0;
							} else {
								theta = Math.atan2(y, x);
								if (Math.abs(theta) <= FORTPI) {
									area.value = AREA_ENUM.AREA_0;
								} else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
									area.value = AREA_ENUM.AREA_1;
									theta -= HALF_PI;
								} else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
									area.value = AREA_ENUM.AREA_2;
									theta = (theta >= 0.0 ? theta - SPI : theta + SPI);
								} else {
									area.value = AREA_ENUM.AREA_3;
									theta += HALF_PI;
								}
							}
							return theta;
						}

						/* Helper function: shift the longitude. */
						function qsc_shift_lon_origin(lon, offset) {
							var slon = lon + offset;
							if (slon < -SPI) {
								slon += TWO_PI;
							} else if (slon > +SPI) {
								slon -= TWO_PI;
							}
							return slon;
						}

						var names$28 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
						var qsc = {
							init: init$27,
							forward: forward$26,
							inverse: inverse$26,
							names: names$28
						};

						// Robinson projection
						// Based on https://github.com/OSGeo/proj.4/blob/master/src/PJ_robin.c
						// Polynomial coeficients from http://article.gmane.org/gmane.comp.gis.proj-4.devel/6039

						var COEFS_X = [
							[1.0000, 2.2199e-17, -7.15515e-05, 3.1103e-06],
							[0.9986, -0.000482243, -2.4897e-05, -1.3309e-06],
							[0.9954, -0.00083103, -4.48605e-05, -9.86701e-07],
							[0.9900, -0.00135364, -5.9661e-05, 3.6777e-06],
							[0.9822, -0.00167442, -4.49547e-06, -5.72411e-06],
							[0.9730, -0.00214868, -9.03571e-05, 1.8736e-08],
							[0.9600, -0.00305085, -9.00761e-05, 1.64917e-06],
							[0.9427, -0.00382792, -6.53386e-05, -2.6154e-06],
							[0.9216, -0.00467746, -0.00010457, 4.81243e-06],
							[0.8962, -0.00536223, -3.23831e-05, -5.43432e-06],
							[0.8679, -0.00609363, -0.000113898, 3.32484e-06],
							[0.8350, -0.00698325, -6.40253e-05, 9.34959e-07],
							[0.7986, -0.00755338, -5.00009e-05, 9.35324e-07],
							[0.7597, -0.00798324, -3.5971e-05, -2.27626e-06],
							[0.7186, -0.00851367, -7.01149e-05, -8.6303e-06],
							[0.6732, -0.00986209, -0.000199569, 1.91974e-05],
							[0.6213, -0.010418, 8.83923e-05, 6.24051e-06],
							[0.5722, -0.00906601, 0.000182, 6.24051e-06],
							[0.5322, -0.00677797, 0.000275608, 6.24051e-06]
						];

						var COEFS_Y = [
							[-5.20417e-18, 0.0124, 1.21431e-18, -8.45284e-11],
							[0.0620, 0.0124, -1.26793e-09, 4.22642e-10],
							[0.1240, 0.0124, 5.07171e-09, -1.60604e-09],
							[0.1860, 0.0123999, -1.90189e-08, 6.00152e-09],
							[0.2480, 0.0124002, 7.10039e-08, -2.24e-08],
							[0.3100, 0.0123992, -2.64997e-07, 8.35986e-08],
							[0.3720, 0.0124029, 9.88983e-07, -3.11994e-07],
							[0.4340, 0.0123893, -3.69093e-06, -4.35621e-07],
							[0.4958, 0.0123198, -1.02252e-05, -3.45523e-07],
							[0.5571, 0.0121916, -1.54081e-05, -5.82288e-07],
							[0.6176, 0.0119938, -2.41424e-05, -5.25327e-07],
							[0.6769, 0.011713, -3.20223e-05, -5.16405e-07],
							[0.7346, 0.0113541, -3.97684e-05, -6.09052e-07],
							[0.7903, 0.0109107, -4.89042e-05, -1.04739e-06],
							[0.8435, 0.0103431, -6.4615e-05, -1.40374e-09],
							[0.8936, 0.00969686, -6.4636e-05, -8.547e-06],
							[0.9394, 0.00840947, -0.000192841, -4.2106e-06],
							[0.9761, 0.00616527, -0.000256, -4.2106e-06],
							[1.0000, 0.00328947, -0.000319159, -4.2106e-06]
						];

						var FXC = 0.8487;
						var FYC = 1.3523;
						var C1 = R2D / 5; // rad to 5-degree interval
						var RC1 = 1 / C1;
						var NODES = 18;

						var poly3_val = function (coefs, x) {
							return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
						};

						var poly3_der = function (coefs, x) {
							return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
						};

						function newton_rapshon(f_df, start, max_err, iters) {
							var x = start;
							for (; iters; --iters) {
								var upd = f_df(x);
								x -= upd;
								if (Math.abs(upd) < max_err) {
									break;
								}
							}
							return x;
						}

						function init$28() {
							this.x0 = this.x0 || 0;
							this.y0 = this.y0 || 0;
							this.long0 = this.long0 || 0;
							this.es = 0;
							this.title = this.title || "Robinson";
						}

						function forward$27(ll) {
							var lon = adjust_lon(ll.x - this.long0);

							var dphi = Math.abs(ll.y);
							var i = Math.floor(dphi * C1);
							if (i < 0) {
								i = 0;
							} else if (i >= NODES) {
								i = NODES - 1;
							}
							dphi = R2D * (dphi - RC1 * i);
							var xy = {
								x: poly3_val(COEFS_X[i], dphi) * lon,
								y: poly3_val(COEFS_Y[i], dphi)
							};
							if (ll.y < 0) {
								xy.y = -xy.y;
							}

							xy.x = xy.x * this.a * FXC + this.x0;
							xy.y = xy.y * this.a * FYC + this.y0;
							return xy;
						}

						function inverse$27(xy) {
							var ll = {
								x: (xy.x - this.x0) / (this.a * FXC),
								y: Math.abs(xy.y - this.y0) / (this.a * FYC)
							};

							if (ll.y >= 1) { // pathologic case
								ll.x /= COEFS_X[NODES][0];
								ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
							} else {
								// find table interval
								var i = Math.floor(ll.y * NODES);
								if (i < 0) {
									i = 0;
								} else if (i >= NODES) {
									i = NODES - 1;
								}
								for (; ;) {
									if (COEFS_Y[i][0] > ll.y) {
										--i;
									} else if (COEFS_Y[i + 1][0] <= ll.y) {
										++i;
									} else {
										break;
									}
								}
								// linear interpolation in 5 degree interval
								var coefs = COEFS_Y[i];
								var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i + 1][0] - coefs[0]);
								// find t so that poly3_val(coefs, t) = ll.y
								t = newton_rapshon(function (x) {
									return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
								}, t, EPSLN, 100);

								ll.x /= poly3_val(COEFS_X[i], t);
								ll.y = (5 * i + t) * D2R;
								if (xy.y < 0) {
									ll.y = -ll.y;
								}
							}

							ll.x = adjust_lon(ll.x + this.long0);
							return ll;
						}

						var names$29 = ["Robinson", "robin"];
						var robin = {
							init: init$28,
							forward: forward$27,
							inverse: inverse$27,
							names: names$29
						};

						function init$29() {
							this.name = 'geocent';

						}

						function forward$28(p) {
							var point = geodeticToGeocentric(p, this.es, this.a);
							return point;
						}

						function inverse$28(p) {
							var point = geocentricToGeodetic(p, this.es, this.a, this.b);
							return point;
						}

						var names$30 = ["Geocentric", 'geocentric', "geocent", "Geocent"];
						var geocent = {
							init: init$29,
							forward: forward$28,
							inverse: inverse$28,
							names: names$30
						};

						var mode = {
							N_POLE: 0,
							S_POLE: 1,
							EQUIT: 2,
							OBLIQ: 3
						};

						var params = {
							h: { def: 100000, num: true },           // default is Karman line, no default in PROJ.7
							azi: { def: 0, num: true, degrees: true }, // default is North
							tilt: { def: 0, num: true, degrees: true }, // default is Nadir
							long0: { def: 0, num: true },                // default is Greenwich, conversion to rad is automatic
							lat0: { def: 0, num: true }                 // default is Equator, conversion to rad is automatic
						};

						function init$30() {
							Object.keys(params).forEach(function (p) {
								if (typeof this[p] === "undefined") {
									this[p] = params[p].def;
								} else if (params[p].num && isNaN(this[p])) {
									throw new Error("Invalid parameter value, must be numeric " + p + " = " + this[p]);
								} else if (params[p].num) {
									this[p] = parseFloat(this[p]);
								}
								if (params[p].degrees) {
									this[p] = this[p] * D2R;
								}
							}.bind(this));

							if (Math.abs((Math.abs(this.lat0) - HALF_PI)) < EPSLN) {
								this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
							} else if (Math.abs(this.lat0) < EPSLN) {
								this.mode = mode.EQUIT;
							} else {
								this.mode = mode.OBLIQ;
								this.sinph0 = Math.sin(this.lat0);
								this.cosph0 = Math.cos(this.lat0);
							}

							this.pn1 = this.h / this.a;  // Normalize relative to the Earth's radius

							if (this.pn1 <= 0 || this.pn1 > 1e10) {
								throw new Error("Invalid height");
							}

							this.p = 1 + this.pn1;
							this.rp = 1 / this.p;
							this.h1 = 1 / this.pn1;
							this.pfact = (this.p + 1) * this.h1;
							this.es = 0;

							var omega = this.tilt;
							var gamma = this.azi;
							this.cg = Math.cos(gamma);
							this.sg = Math.sin(gamma);
							this.cw = Math.cos(omega);
							this.sw = Math.sin(omega);
						}

						function forward$29(p) {
							p.x -= this.long0;
							var sinphi = Math.sin(p.y);
							var cosphi = Math.cos(p.y);
							var coslam = Math.cos(p.x);
							var x, y;
							switch (this.mode) {
								case mode.OBLIQ:
									y = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
									break;
								case mode.EQUIT:
									y = cosphi * coslam;
									break;
								case mode.S_POLE:
									y = -sinphi;
									break;
								case mode.N_POLE:
									y = sinphi;
									break;
							}
							y = this.pn1 / (this.p - y);
							x = y * cosphi * Math.sin(p.x);

							switch (this.mode) {
								case mode.OBLIQ:
									y *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
									break;
								case mode.EQUIT:
									y *= sinphi;
									break;
								case mode.N_POLE:
									y *= -(cosphi * coslam);
									break;
								case mode.S_POLE:
									y *= cosphi * coslam;
									break;
							}

							// Tilt 
							var yt, ba;
							yt = y * this.cg + x * this.sg;
							ba = 1 / (yt * this.sw * this.h1 + this.cw);
							x = (x * this.cg - y * this.sg) * this.cw * ba;
							y = yt * ba;

							p.x = x * this.a;
							p.y = y * this.a;
							return p;
						}

						function inverse$29(p) {
							p.x /= this.a;
							p.y /= this.a;
							var r = { x: p.x, y: p.y };

							// Un-Tilt
							var bm, bq, yt;
							yt = 1 / (this.pn1 - p.y * this.sw);
							bm = this.pn1 * p.x * yt;
							bq = this.pn1 * p.y * this.cw * yt;
							p.x = bm * this.cg + bq * this.sg;
							p.y = bq * this.cg - bm * this.sg;

							var rh = hypot(p.x, p.y);
							if (Math.abs(rh) < EPSLN) {
								r.x = 0;
								r.y = p.y;
							} else {
								var cosz, sinz;
								sinz = 1 - rh * rh * this.pfact;
								sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
								cosz = Math.sqrt(1 - sinz * sinz);
								switch (this.mode) {
									case mode.OBLIQ:
										r.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh);
										p.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh;
										p.x *= sinz * this.cosph0;
										break;
									case mode.EQUIT:
										r.y = Math.asin(p.y * sinz / rh);
										p.y = cosz * rh;
										p.x *= sinz;
										break;
									case mode.N_POLE:
										r.y = Math.asin(cosz);
										p.y = -p.y;
										break;
									case mode.S_POLE:
										r.y = -Math.asin(cosz);
										break;
								}
								r.x = Math.atan2(p.x, p.y);
							}

							p.x = r.x + this.long0;
							p.y = r.y;
							return p;
						}

						var names$31 = ["Tilted_Perspective", "tpers"];
						var tpers = {
							init: init$30,
							forward: forward$29,
							inverse: inverse$29,
							names: names$31
						};

						var includedProjections = function (proj4) {
							proj4.Proj.projections.add(tmerc);
							proj4.Proj.projections.add(etmerc);
							proj4.Proj.projections.add(utm);
							proj4.Proj.projections.add(sterea);
							proj4.Proj.projections.add(stere);
							proj4.Proj.projections.add(somerc);
							proj4.Proj.projections.add(omerc);
							proj4.Proj.projections.add(lcc);
							proj4.Proj.projections.add(krovak);
							proj4.Proj.projections.add(cass);
							proj4.Proj.projections.add(laea);
							proj4.Proj.projections.add(aea);
							proj4.Proj.projections.add(gnom);
							proj4.Proj.projections.add(cea);
							proj4.Proj.projections.add(eqc);
							proj4.Proj.projections.add(poly);
							proj4.Proj.projections.add(nzmg);
							proj4.Proj.projections.add(mill);
							proj4.Proj.projections.add(sinu);
							proj4.Proj.projections.add(moll);
							proj4.Proj.projections.add(eqdc);
							proj4.Proj.projections.add(vandg);
							proj4.Proj.projections.add(aeqd);
							proj4.Proj.projections.add(ortho);
							proj4.Proj.projections.add(qsc);
							proj4.Proj.projections.add(robin);
							proj4.Proj.projections.add(geocent);
							proj4.Proj.projections.add(tpers);
						};

						proj4$1.defaultDatum = 'WGS84'; //default datum
						proj4$1.Proj = Projection;
						proj4$1.WGS84 = new proj4$1.Proj('WGS84');
						proj4$1.Point = Point;
						proj4$1.toPoint = toPoint;
						proj4$1.defs = defs;
						proj4$1.nadgrid = nadgrid;
						proj4$1.transform = transform;
						proj4$1.mgrs = mgrs;
						proj4$1.version = '2.7.4';
						includedProjections(proj4$1);

						return proj4$1;

					})));

				}, {}], 18: [function (require, module, exports) {
					/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
					/* eslint-disable node/no-deprecated-api */
					var buffer = require('buffer');
					var Buffer = buffer.Buffer;

					// alternative to using Object.keys for old browsers
					function copyProps(src, dst) {
						for (var key in src) {
							dst[key] = src[key];
						}
					}
					if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
						module.exports = buffer;
					} else {
						// Copy properties from require('buffer')
						copyProps(buffer, exports);
						exports.Buffer = SafeBuffer;
					}

					function SafeBuffer(arg, encodingOrOffset, length) {
						return Buffer(arg, encodingOrOffset, length)
					}

					SafeBuffer.prototype = Object.create(Buffer.prototype);

					// Copy static methods from Buffer
					copyProps(Buffer, SafeBuffer);

					SafeBuffer.from = function (arg, encodingOrOffset, length) {
						if (typeof arg === 'number') {
							throw new TypeError('Argument must not be a number')
						}
						return Buffer(arg, encodingOrOffset, length)
					};

					SafeBuffer.alloc = function (size, fill, encoding) {
						if (typeof size !== 'number') {
							throw new TypeError('Argument must be a number')
						}
						var buf = Buffer(size);
						if (fill !== undefined) {
							if (typeof encoding === 'string') {
								buf.fill(fill, encoding);
							} else {
								buf.fill(fill);
							}
						} else {
							buf.fill(0);
						}
						return buf
					};

					SafeBuffer.allocUnsafe = function (size) {
						if (typeof size !== 'number') {
							throw new TypeError('Argument must be a number')
						}
						return Buffer(size)
					};

					SafeBuffer.allocUnsafeSlow = function (size) {
						if (typeof size !== 'number') {
							throw new TypeError('Argument must be a number')
						}
						return buffer.SlowBuffer(size)
					};

				}, { "buffer": 8 }], 19: [function (require, module, exports) {

					/*<replacement>*/

					var Buffer = require('safe-buffer').Buffer;
					/*</replacement>*/

					var isEncoding = Buffer.isEncoding || function (encoding) {
						encoding = '' + encoding;
						switch (encoding && encoding.toLowerCase()) {
							case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw':
								return true;
							default:
								return false;
						}
					};

					function _normalizeEncoding(enc) {
						if (!enc) return 'utf8';
						var retried;
						while (true) {
							switch (enc) {
								case 'utf8':
								case 'utf-8':
									return 'utf8';
								case 'ucs2':
								case 'ucs-2':
								case 'utf16le':
								case 'utf-16le':
									return 'utf16le';
								case 'latin1':
								case 'binary':
									return 'latin1';
								case 'base64':
								case 'ascii':
								case 'hex':
									return enc;
								default:
									if (retried) return; // undefined
									enc = ('' + enc).toLowerCase();
									retried = true;
							}
						}
					}
					// Do not cache `Buffer.isEncoding` when checking encoding names as some
					// modules monkey-patch it to support additional encodings
					function normalizeEncoding(enc) {
						var nenc = _normalizeEncoding(enc);
						if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
						return nenc || enc;
					}

					// StringDecoder provides an interface for efficiently splitting a series of
					// buffers into a series of JS strings without breaking apart multi-byte
					// characters.
					exports.StringDecoder = StringDecoder;
					function StringDecoder(encoding) {
						this.encoding = normalizeEncoding(encoding);
						var nb;
						switch (this.encoding) {
							case 'utf16le':
								this.text = utf16Text;
								this.end = utf16End;
								nb = 4;
								break;
							case 'utf8':
								this.fillLast = utf8FillLast;
								nb = 4;
								break;
							case 'base64':
								this.text = base64Text;
								this.end = base64End;
								nb = 3;
								break;
							default:
								this.write = simpleWrite;
								this.end = simpleEnd;
								return;
						}
						this.lastNeed = 0;
						this.lastTotal = 0;
						this.lastChar = Buffer.allocUnsafe(nb);
					}

					StringDecoder.prototype.write = function (buf) {
						if (buf.length === 0) return '';
						var r;
						var i;
						if (this.lastNeed) {
							r = this.fillLast(buf);
							if (r === undefined) return '';
							i = this.lastNeed;
							this.lastNeed = 0;
						} else {
							i = 0;
						}
						if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
						return r || '';
					};

					StringDecoder.prototype.end = utf8End;

					// Returns only complete characters in a Buffer
					StringDecoder.prototype.text = utf8Text;

					// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
					StringDecoder.prototype.fillLast = function (buf) {
						if (this.lastNeed <= buf.length) {
							buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
							return this.lastChar.toString(this.encoding, 0, this.lastTotal);
						}
						buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
						this.lastNeed -= buf.length;
					};

					// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
					// continuation byte. If an invalid byte is detected, -2 is returned.
					function utf8CheckByte(byte) {
						if (byte <= 0x7F) return 0; else if (byte >> 5 === 0x06) return 2; else if (byte >> 4 === 0x0E) return 3; else if (byte >> 3 === 0x1E) return 4;
						return byte >> 6 === 0x02 ? -1 : -2;
					}

					// Checks at most 3 bytes at the end of a Buffer in order to detect an
					// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
					// needed to complete the UTF-8 character (if applicable) are returned.
					function utf8CheckIncomplete(self, buf, i) {
						var j = buf.length - 1;
						if (j < i) return 0;
						var nb = utf8CheckByte(buf[j]);
						if (nb >= 0) {
							if (nb > 0) self.lastNeed = nb - 1;
							return nb;
						}
						if (--j < i || nb === -2) return 0;
						nb = utf8CheckByte(buf[j]);
						if (nb >= 0) {
							if (nb > 0) self.lastNeed = nb - 2;
							return nb;
						}
						if (--j < i || nb === -2) return 0;
						nb = utf8CheckByte(buf[j]);
						if (nb >= 0) {
							if (nb > 0) {
								if (nb === 2) nb = 0; else self.lastNeed = nb - 3;
							}
							return nb;
						}
						return 0;
					}

					// Validates as many continuation bytes for a multi-byte UTF-8 character as
					// needed or are available. If we see a non-continuation byte where we expect
					// one, we "replace" the validated continuation bytes we've seen so far with
					// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
					// behavior. The continuation byte check is included three times in the case
					// where all of the continuation bytes for a character exist in the same buffer.
					// It is also done this way as a slight performance increase instead of using a
					// loop.
					function utf8CheckExtraBytes(self, buf, p) {
						if ((buf[0] & 0xC0) !== 0x80) {
							self.lastNeed = 0;
							return '\ufffd';
						}
						if (self.lastNeed > 1 && buf.length > 1) {
							if ((buf[1] & 0xC0) !== 0x80) {
								self.lastNeed = 1;
								return '\ufffd';
							}
							if (self.lastNeed > 2 && buf.length > 2) {
								if ((buf[2] & 0xC0) !== 0x80) {
									self.lastNeed = 2;
									return '\ufffd';
								}
							}
						}
					}

					// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
					function utf8FillLast(buf) {
						var p = this.lastTotal - this.lastNeed;
						var r = utf8CheckExtraBytes(this, buf);
						if (r !== undefined) return r;
						if (this.lastNeed <= buf.length) {
							buf.copy(this.lastChar, p, 0, this.lastNeed);
							return this.lastChar.toString(this.encoding, 0, this.lastTotal);
						}
						buf.copy(this.lastChar, p, 0, buf.length);
						this.lastNeed -= buf.length;
					}

					// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
					// partial character, the character's bytes are buffered until the required
					// number of bytes are available.
					function utf8Text(buf, i) {
						var total = utf8CheckIncomplete(this, buf, i);
						if (!this.lastNeed) return buf.toString('utf8', i);
						this.lastTotal = total;
						var end = buf.length - (total - this.lastNeed);
						buf.copy(this.lastChar, 0, end);
						return buf.toString('utf8', i, end);
					}

					// For UTF-8, a replacement character is added when ending on a partial
					// character.
					function utf8End(buf) {
						var r = buf && buf.length ? this.write(buf) : '';
						if (this.lastNeed) return r + '\ufffd';
						return r;
					}

					// UTF-16LE typically needs two bytes per character, but even if we have an even
					// number of bytes available, we need to check if we end on a leading/high
					// surrogate. In that case, we need to wait for the next two bytes in order to
					// decode the last character properly.
					function utf16Text(buf, i) {
						if ((buf.length - i) % 2 === 0) {
							var r = buf.toString('utf16le', i);
							if (r) {
								var c = r.charCodeAt(r.length - 1);
								if (c >= 0xD800 && c <= 0xDBFF) {
									this.lastNeed = 2;
									this.lastTotal = 4;
									this.lastChar[0] = buf[buf.length - 2];
									this.lastChar[1] = buf[buf.length - 1];
									return r.slice(0, -1);
								}
							}
							return r;
						}
						this.lastNeed = 1;
						this.lastTotal = 2;
						this.lastChar[0] = buf[buf.length - 1];
						return buf.toString('utf16le', i, buf.length - 1);
					}

					// For UTF-16LE we do not explicitly append special replacement characters if we
					// end on a partial character, we simply let v8 handle that.
					function utf16End(buf) {
						var r = buf && buf.length ? this.write(buf) : '';
						if (this.lastNeed) {
							var end = this.lastTotal - this.lastNeed;
							return r + this.lastChar.toString('utf16le', 0, end);
						}
						return r;
					}

					function base64Text(buf, i) {
						var n = (buf.length - i) % 3;
						if (n === 0) return buf.toString('base64', i);
						this.lastNeed = 3 - n;
						this.lastTotal = 3;
						if (n === 1) {
							this.lastChar[0] = buf[buf.length - 1];
						} else {
							this.lastChar[0] = buf[buf.length - 2];
							this.lastChar[1] = buf[buf.length - 1];
						}
						return buf.toString('base64', i, buf.length - n);
					}

					function base64End(buf) {
						var r = buf && buf.length ? this.write(buf) : '';
						if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
						return r;
					}

					// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
					function simpleWrite(buf) {
						return buf.toString(this.encoding);
					}

					function simpleEnd(buf) {
						return buf && buf.length ? this.write(buf) : '';
					}
				}, { "safe-buffer": 18 }], 20: [function (require, module, exports) {
					// This is free and unencumbered software released into the public domain.
					// See LICENSE.md for more information.

					module.exports = require("./lib/encoding.js");

				}, { "./lib/encoding.js": 21 }], 21: [function (require, module, exports) {
					// This is free and unencumbered software released into the public domain.
					// See LICENSE.md for more information.

					/**
					 * @fileoverview Global |this| required for resolving indexes in node.
					 * @suppress {globalThis}
					 */
					(function (global) {

						// If we're in node require encoding-indexes and attach it to the global.
						if (typeof module !== "undefined" && module.exports &&
							!global["encoding-indexes"]) {
							require("./encoding-indexes.js");
						}

						//
						// Utilities
						//

						/**
						 * @param {number} a The number to test.
						 * @param {number} min The minimum value in the range, inclusive.
						 * @param {number} max The maximum value in the range, inclusive.
						 * @return {boolean} True if a >= min and a <= max.
						 */
						function inRange(a, min, max) {
							return min <= a && a <= max;
						}

						/**
						 * @param {!Array.<*>} array The array to check.
						 * @param {*} item The item to look for in the array.
						 * @return {boolean} True if the item appears in the array.
						 */
						function includes(array, item) {
							return array.indexOf(item) !== -1;
						}

						var floor = Math.floor;

						/**
						 * @param {*} o
						 * @return {Object}
						 */
						function ToDictionary(o) {
							if (o === undefined) return {};
							if (o === Object(o)) return o;
							throw TypeError('Could not convert argument to dictionary');
						}

						/**
						 * @param {string} string Input string of UTF-16 code units.
						 * @return {!Array.<number>} Code points.
						 */
						function stringToCodePoints(string) {
							// https://heycam.github.io/webidl/#dfn-obtain-unicode

							// 1. Let S be the DOMString value.
							var s = String(string);

							// 2. Let n be the length of S.
							var n = s.length;

							// 3. Initialize i to 0.
							var i = 0;

							// 4. Initialize U to be an empty sequence of Unicode characters.
							var u = [];

							// 5. While i < n:
							while (i < n) {

								// 1. Let c be the code unit in S at index i.
								var c = s.charCodeAt(i);

								// 2. Depending on the value of c:

								// c < 0xD800 or c > 0xDFFF
								if (c < 0xD800 || c > 0xDFFF) {
									// Append to U the Unicode character with code point c.
									u.push(c);
								}

								// 0xDC00 ≤ c ≤ 0xDFFF
								else if (0xDC00 <= c && c <= 0xDFFF) {
									// Append to U a U+FFFD REPLACEMENT CHARACTER.
									u.push(0xFFFD);
								}

								// 0xD800 ≤ c ≤ 0xDBFF
								else if (0xD800 <= c && c <= 0xDBFF) {
									// 1. If i = n−1, then append to U a U+FFFD REPLACEMENT
									// CHARACTER.
									if (i === n - 1) {
										u.push(0xFFFD);
									}
									// 2. Otherwise, i < n−1:
									else {
										// 1. Let d be the code unit in S at index i+1.
										var d = s.charCodeAt(i + 1);

										// 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:
										if (0xDC00 <= d && d <= 0xDFFF) {
											// 1. Let a be c & 0x3FF.
											var a = c & 0x3FF;

											// 2. Let b be d & 0x3FF.
											var b = d & 0x3FF;

											// 3. Append to U the Unicode character with code point
											// 2^16+2^10*a+b.
											u.push(0x10000 + (a << 10) + b);

											// 4. Set i to i+1.
											i += 1;
										}

										// 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a
										// U+FFFD REPLACEMENT CHARACTER.
										else {
											u.push(0xFFFD);
										}
									}
								}

								// 3. Set i to i+1.
								i += 1;
							}

							// 6. Return U.
							return u;
						}

						/**
						 * @param {!Array.<number>} code_points Array of code points.
						 * @return {string} string String of UTF-16 code units.
						 */
						function codePointsToString(code_points) {
							var s = '';
							for (var i = 0; i < code_points.length; ++i) {
								var cp = code_points[i];
								if (cp <= 0xFFFF) {
									s += String.fromCharCode(cp);
								} else {
									cp -= 0x10000;
									s += String.fromCharCode((cp >> 10) + 0xD800,
										(cp & 0x3FF) + 0xDC00);
								}
							}
							return s;
						}


						//
						// Implementation of Encoding specification
						// https://encoding.spec.whatwg.org/
						//

						//
						// 4. Terminology
						//

						/**
						 * An ASCII byte is a byte in the range 0x00 to 0x7F, inclusive.
						 * @param {number} a The number to test.
						 * @return {boolean} True if a is in the range 0x00 to 0x7F, inclusive.
						 */
						function isASCIIByte(a) {
							return 0x00 <= a && a <= 0x7F;
						}

						/**
						 * An ASCII code point is a code point in the range U+0000 to
						 * U+007F, inclusive.
						 */
						var isASCIICodePoint = isASCIIByte;


    	  /**
    	   * End-of-stream is a special token that signifies no more tokens
    	   * are in the stream.
    	   * @const
    	   */ var end_of_stream = -1;

						/**
						 * A stream represents an ordered sequence of tokens.
						 *
						 * @constructor
						 * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide
						 * the stream.
						 */
						function Stream(tokens) {
							/** @type {!Array.<number>} */
							this.tokens = [].slice.call(tokens);
							// Reversed as push/pop is more efficient than shift/unshift.
							this.tokens.reverse();
						}

						Stream.prototype = {
							/**
							 * @return {boolean} True if end-of-stream has been hit.
							 */
							endOfStream: function () {
								return !this.tokens.length;
							},

							/**
							 * When a token is read from a stream, the first token in the
							 * stream must be returned and subsequently removed, and
							 * end-of-stream must be returned otherwise.
							 *
							 * @return {number} Get the next token from the stream, or
							 * end_of_stream.
							 */
							read: function () {
								if (!this.tokens.length)
									return end_of_stream;
								return this.tokens.pop();
							},

							/**
							 * When one or more tokens are prepended to a stream, those tokens
							 * must be inserted, in given order, before the first token in the
							 * stream.
							 *
							 * @param {(number|!Array.<number>)} token The token(s) to prepend to the
							 * stream.
							 */
							prepend: function (token) {
								if (Array.isArray(token)) {
									var tokens = /**@type {!Array.<number>}*/(token);
									while (tokens.length)
										this.tokens.push(tokens.pop());
								} else {
									this.tokens.push(token);
								}
							},

							/**
							 * When one or more tokens are pushed to a stream, those tokens
							 * must be inserted, in given order, after the last token in the
							 * stream.
							 *
							 * @param {(number|!Array.<number>)} token The tokens(s) to push to the
							 * stream.
							 */
							push: function (token) {
								if (Array.isArray(token)) {
									var tokens = /**@type {!Array.<number>}*/(token);
									while (tokens.length)
										this.tokens.unshift(tokens.shift());
								} else {
									this.tokens.unshift(token);
								}
							}
						};

						//
						// 5. Encodings
						//

						// 5.1 Encoders and decoders

						/** @const */
						var finished = -1;

						/**
						 * @param {boolean} fatal If true, decoding errors raise an exception.
						 * @param {number=} opt_code_point Override the standard fallback code point.
						 * @return {number} The code point to insert on a decoding error.
						 */
						function decoderError(fatal, opt_code_point) {
							if (fatal)
								throw TypeError('Decoder error');
							return opt_code_point || 0xFFFD;
						}

						/**
						 * @param {number} code_point The code point that could not be encoded.
						 * @return {number} Always throws, no value is actually returned.
						 */
						function encoderError(code_point) {
							throw TypeError('The code point ' + code_point + ' could not be encoded.');
						}

						// 5.2 Names and labels

						// TODO: Define @typedef for Encoding: {name:string,labels:Array.<string>}
						// https://github.com/google/closure-compiler/issues/247

						/**
						 * @param {string} label The encoding label.
						 * @return {?{name:string,labels:Array.<string>}}
						 */
						function getEncoding(label) {
							// 1. Remove any leading and trailing ASCII whitespace from label.
							label = String(label).trim().toLowerCase();

							// 2. If label is an ASCII case-insensitive match for any of the
							// labels listed in the table below, return the corresponding
							// encoding, and failure otherwise.
							if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {
								return label_to_encoding[label];
							}
							return null;
						}

						/**
						 * Encodings table: https://encoding.spec.whatwg.org/encodings.json
						 * @const
						 * @type {!Array.<{
						 *          heading: string,
						 *          encodings: Array.<{name:string,labels:Array.<string>}>
						 *        }>}
						 */
						var encodings = [
							{
								"encodings": [
									{
										"labels": [
											"unicode-1-1-utf-8",
											"utf-8",
											"utf8"
										],
										"name": "UTF-8"
									}
								],
								"heading": "The Encoding"
							},
							{
								"encodings": [
									{
										"labels": [
											"866",
											"cp866",
											"csibm866",
											"ibm866"
										],
										"name": "IBM866"
									},
									{
										"labels": [
											"csisolatin2",
											"iso-8859-2",
											"iso-ir-101",
											"iso8859-2",
											"iso88592",
											"iso_8859-2",
											"iso_8859-2:1987",
											"l2",
											"latin2"
										],
										"name": "ISO-8859-2"
									},
									{
										"labels": [
											"csisolatin3",
											"iso-8859-3",
											"iso-ir-109",
											"iso8859-3",
											"iso88593",
											"iso_8859-3",
											"iso_8859-3:1988",
											"l3",
											"latin3"
										],
										"name": "ISO-8859-3"
									},
									{
										"labels": [
											"csisolatin4",
											"iso-8859-4",
											"iso-ir-110",
											"iso8859-4",
											"iso88594",
											"iso_8859-4",
											"iso_8859-4:1988",
											"l4",
											"latin4"
										],
										"name": "ISO-8859-4"
									},
									{
										"labels": [
											"csisolatincyrillic",
											"cyrillic",
											"iso-8859-5",
											"iso-ir-144",
											"iso8859-5",
											"iso88595",
											"iso_8859-5",
											"iso_8859-5:1988"
										],
										"name": "ISO-8859-5"
									},
									{
										"labels": [
											"arabic",
											"asmo-708",
											"csiso88596e",
											"csiso88596i",
											"csisolatinarabic",
											"ecma-114",
											"iso-8859-6",
											"iso-8859-6-e",
											"iso-8859-6-i",
											"iso-ir-127",
											"iso8859-6",
											"iso88596",
											"iso_8859-6",
											"iso_8859-6:1987"
										],
										"name": "ISO-8859-6"
									},
									{
										"labels": [
											"csisolatingreek",
											"ecma-118",
											"elot_928",
											"greek",
											"greek8",
											"iso-8859-7",
											"iso-ir-126",
											"iso8859-7",
											"iso88597",
											"iso_8859-7",
											"iso_8859-7:1987",
											"sun_eu_greek"
										],
										"name": "ISO-8859-7"
									},
									{
										"labels": [
											"csiso88598e",
											"csisolatinhebrew",
											"hebrew",
											"iso-8859-8",
											"iso-8859-8-e",
											"iso-ir-138",
											"iso8859-8",
											"iso88598",
											"iso_8859-8",
											"iso_8859-8:1988",
											"visual"
										],
										"name": "ISO-8859-8"
									},
									{
										"labels": [
											"csiso88598i",
											"iso-8859-8-i",
											"logical"
										],
										"name": "ISO-8859-8-I"
									},
									{
										"labels": [
											"csisolatin6",
											"iso-8859-10",
											"iso-ir-157",
											"iso8859-10",
											"iso885910",
											"l6",
											"latin6"
										],
										"name": "ISO-8859-10"
									},
									{
										"labels": [
											"iso-8859-13",
											"iso8859-13",
											"iso885913"
										],
										"name": "ISO-8859-13"
									},
									{
										"labels": [
											"iso-8859-14",
											"iso8859-14",
											"iso885914"
										],
										"name": "ISO-8859-14"
									},
									{
										"labels": [
											"csisolatin9",
											"iso-8859-15",
											"iso8859-15",
											"iso885915",
											"iso_8859-15",
											"l9"
										],
										"name": "ISO-8859-15"
									},
									{
										"labels": [
											"iso-8859-16"
										],
										"name": "ISO-8859-16"
									},
									{
										"labels": [
											"cskoi8r",
											"koi",
											"koi8",
											"koi8-r",
											"koi8_r"
										],
										"name": "KOI8-R"
									},
									{
										"labels": [
											"koi8-ru",
											"koi8-u"
										],
										"name": "KOI8-U"
									},
									{
										"labels": [
											"csmacintosh",
											"mac",
											"macintosh",
											"x-mac-roman"
										],
										"name": "macintosh"
									},
									{
										"labels": [
											"dos-874",
											"iso-8859-11",
											"iso8859-11",
											"iso885911",
											"tis-620",
											"windows-874"
										],
										"name": "windows-874"
									},
									{
										"labels": [
											"cp1250",
											"windows-1250",
											"x-cp1250"
										],
										"name": "windows-1250"
									},
									{
										"labels": [
											"cp1251",
											"windows-1251",
											"x-cp1251"
										],
										"name": "windows-1251"
									},
									{
										"labels": [
											"ansi_x3.4-1968",
											"ascii",
											"cp1252",
											"cp819",
											"csisolatin1",
											"ibm819",
											"iso-8859-1",
											"iso-ir-100",
											"iso8859-1",
											"iso88591",
											"iso_8859-1",
											"iso_8859-1:1987",
											"l1",
											"latin1",
											"us-ascii",
											"windows-1252",
											"x-cp1252"
										],
										"name": "windows-1252"
									},
									{
										"labels": [
											"cp1253",
											"windows-1253",
											"x-cp1253"
										],
										"name": "windows-1253"
									},
									{
										"labels": [
											"cp1254",
											"csisolatin5",
											"iso-8859-9",
											"iso-ir-148",
											"iso8859-9",
											"iso88599",
											"iso_8859-9",
											"iso_8859-9:1989",
											"l5",
											"latin5",
											"windows-1254",
											"x-cp1254"
										],
										"name": "windows-1254"
									},
									{
										"labels": [
											"cp1255",
											"windows-1255",
											"x-cp1255"
										],
										"name": "windows-1255"
									},
									{
										"labels": [
											"cp1256",
											"windows-1256",
											"x-cp1256"
										],
										"name": "windows-1256"
									},
									{
										"labels": [
											"cp1257",
											"windows-1257",
											"x-cp1257"
										],
										"name": "windows-1257"
									},
									{
										"labels": [
											"cp1258",
											"windows-1258",
											"x-cp1258"
										],
										"name": "windows-1258"
									},
									{
										"labels": [
											"x-mac-cyrillic",
											"x-mac-ukrainian"
										],
										"name": "x-mac-cyrillic"
									}
								],
								"heading": "Legacy single-byte encodings"
							},
							{
								"encodings": [
									{
										"labels": [
											"chinese",
											"csgb2312",
											"csiso58gb231280",
											"gb2312",
											"gb_2312",
											"gb_2312-80",
											"gbk",
											"iso-ir-58",
											"x-gbk"
										],
										"name": "GBK"
									},
									{
										"labels": [
											"gb18030"
										],
										"name": "gb18030"
									}
								],
								"heading": "Legacy multi-byte Chinese (simplified) encodings"
							},
							{
								"encodings": [
									{
										"labels": [
											"big5",
											"big5-hkscs",
											"cn-big5",
											"csbig5",
											"x-x-big5"
										],
										"name": "Big5"
									}
								],
								"heading": "Legacy multi-byte Chinese (traditional) encodings"
							},
							{
								"encodings": [
									{
										"labels": [
											"cseucpkdfmtjapanese",
											"euc-jp",
											"x-euc-jp"
										],
										"name": "EUC-JP"
									},
									{
										"labels": [
											"csiso2022jp",
											"iso-2022-jp"
										],
										"name": "ISO-2022-JP"
									},
									{
										"labels": [
											"csshiftjis",
											"ms932",
											"ms_kanji",
											"shift-jis",
											"shift_jis",
											"sjis",
											"windows-31j",
											"x-sjis"
										],
										"name": "Shift_JIS"
									}
								],
								"heading": "Legacy multi-byte Japanese encodings"
							},
							{
								"encodings": [
									{
										"labels": [
											"cseuckr",
											"csksc56011987",
											"euc-kr",
											"iso-ir-149",
											"korean",
											"ks_c_5601-1987",
											"ks_c_5601-1989",
											"ksc5601",
											"ksc_5601",
											"windows-949"
										],
										"name": "EUC-KR"
									}
								],
								"heading": "Legacy multi-byte Korean encodings"
							},
							{
								"encodings": [
									{
										"labels": [
											"csiso2022kr",
											"hz-gb-2312",
											"iso-2022-cn",
											"iso-2022-cn-ext",
											"iso-2022-kr"
										],
										"name": "replacement"
									},
									{
										"labels": [
											"utf-16be"
										],
										"name": "UTF-16BE"
									},
									{
										"labels": [
											"utf-16",
											"utf-16le"
										],
										"name": "UTF-16LE"
									},
									{
										"labels": [
											"x-user-defined"
										],
										"name": "x-user-defined"
									}
								],
								"heading": "Legacy miscellaneous encodings"
							}
						];

						// Label to encoding registry.
						/** @type {Object.<string,{name:string,labels:Array.<string>}>} */
						var label_to_encoding = {};
						encodings.forEach(function (category) {
							category.encodings.forEach(function (encoding) {
								encoding.labels.forEach(function (label) {
									label_to_encoding[label] = encoding;
								});
							});
						});

						// Registry of of encoder/decoder factories, by encoding name.
						/** @type {Object.<string, function({fatal:boolean}): Encoder>} */
						var encoders = {};
						/** @type {Object.<string, function({fatal:boolean}): Decoder>} */
						var decoders = {};

						//
						// 6. Indexes
						//

						/**
						 * @param {number} pointer The |pointer| to search for.
						 * @param {(!Array.<?number>|undefined)} index The |index| to search within.
						 * @return {?number} The code point corresponding to |pointer| in |index|,
						 *     or null if |code point| is not in |index|.
						 */
						function indexCodePointFor(pointer, index) {
							if (!index) return null;
							return index[pointer] || null;
						}

						/**
						 * @param {number} code_point The |code point| to search for.
						 * @param {!Array.<?number>} index The |index| to search within.
						 * @return {?number} The first pointer corresponding to |code point| in
						 *     |index|, or null if |code point| is not in |index|.
						 */
						function indexPointerFor(code_point, index) {
							var pointer = index.indexOf(code_point);
							return pointer === -1 ? null : pointer;
						}

						/**
						 * @param {string} name Name of the index.
						 * @return {(!Array.<number>|!Array.<Array.<number>>)}
						 *  */
						function index(name) {
							if (!('encoding-indexes' in global)) {
								throw Error("Indexes missing." +
									" Did you forget to include encoding-indexes.js first?");
							}
							return global['encoding-indexes'][name];
						}

						/**
						 * @param {number} pointer The |pointer| to search for in the gb18030 index.
						 * @return {?number} The code point corresponding to |pointer| in |index|,
						 *     or null if |code point| is not in the gb18030 index.
						 */
						function indexGB18030RangesCodePointFor(pointer) {
							// 1. If pointer is greater than 39419 and less than 189000, or
							// pointer is greater than 1237575, return null.
							if ((pointer > 39419 && pointer < 189000) || (pointer > 1237575))
								return null;

							// 2. If pointer is 7457, return code point U+E7C7.
							if (pointer === 7457) return 0xE7C7;

							// 3. Let offset be the last pointer in index gb18030 ranges that
							// is equal to or less than pointer and let code point offset be
							// its corresponding code point.
							var offset = 0;
							var code_point_offset = 0;
							var idx = index('gb18030-ranges');
							var i;
							for (i = 0; i < idx.length; ++i) {
								/** @type {!Array.<number>} */
								var entry = idx[i];
								if (entry[0] <= pointer) {
									offset = entry[0];
									code_point_offset = entry[1];
								} else {
									break;
								}
							}

							// 4. Return a code point whose value is code point offset +
							// pointer − offset.
							return code_point_offset + pointer - offset;
						}

						/**
						 * @param {number} code_point The |code point| to locate in the gb18030 index.
						 * @return {number} The first pointer corresponding to |code point| in the
						 *     gb18030 index.
						 */
						function indexGB18030RangesPointerFor(code_point) {
							// 1. If code point is U+E7C7, return pointer 7457.
							if (code_point === 0xE7C7) return 7457;

							// 2. Let offset be the last code point in index gb18030 ranges
							// that is equal to or less than code point and let pointer offset
							// be its corresponding pointer.
							var offset = 0;
							var pointer_offset = 0;
							var idx = index('gb18030-ranges');
							var i;
							for (i = 0; i < idx.length; ++i) {
								/** @type {!Array.<number>} */
								var entry = idx[i];
								if (entry[1] <= code_point) {
									offset = entry[1];
									pointer_offset = entry[0];
								} else {
									break;
								}
							}

							// 3. Return a pointer whose value is pointer offset + code point
							// − offset.
							return pointer_offset + code_point - offset;
						}

						/**
						 * @param {number} code_point The |code_point| to search for in the Shift_JIS
						 *     index.
						 * @return {?number} The code point corresponding to |pointer| in |index|,
						 *     or null if |code point| is not in the Shift_JIS index.
						 */
						function indexShiftJISPointerFor(code_point) {
							// 1. Let index be index jis0208 excluding all entries whose
							// pointer is in the range 8272 to 8835, inclusive.
							shift_jis_index = shift_jis_index ||
								index('jis0208').map(function (code_point, pointer) {
									return inRange(pointer, 8272, 8835) ? null : code_point;
								});
							var index_ = shift_jis_index;

							// 2. Return the index pointer for code point in index.
							return index_.indexOf(code_point);
						}
						var shift_jis_index;

						/**
						 * @param {number} code_point The |code_point| to search for in the big5
						 *     index.
						 * @return {?number} The code point corresponding to |pointer| in |index|,
						 *     or null if |code point| is not in the big5 index.
						 */
						function indexBig5PointerFor(code_point) {
							// 1. Let index be index Big5 excluding all entries whose pointer
							big5_index_no_hkscs = big5_index_no_hkscs ||
								index('big5').map(function (code_point, pointer) {
									return (pointer < (0xA1 - 0x81) * 157) ? null : code_point;
								});
							var index_ = big5_index_no_hkscs;

							// 2. If code point is U+2550, U+255E, U+2561, U+256A, U+5341, or
							// U+5345, return the last pointer corresponding to code point in
							// index.
							if (code_point === 0x2550 || code_point === 0x255E ||
								code_point === 0x2561 || code_point === 0x256A ||
								code_point === 0x5341 || code_point === 0x5345) {
								return index_.lastIndexOf(code_point);
							}

							// 3. Return the index pointer for code point in index.
							return indexPointerFor(code_point, index_);
						}
						var big5_index_no_hkscs;

    	  //
    	  // 8. API
    	  //

    	  /** @const */ var DEFAULT_ENCODING = 'utf-8';

						// 8.1 Interface TextDecoder

						/**
						 * @constructor
						 * @param {string=} label The label of the encoding;
						 *     defaults to 'utf-8'.
						 * @param {Object=} options
						 */
						function TextDecoder(label, options) {
							// Web IDL conventions
							if (!(this instanceof TextDecoder))
								throw TypeError('Called as a function. Did you forget \'new\'?');
							label = label !== undefined ? String(label) : DEFAULT_ENCODING;
							options = ToDictionary(options);

							// A TextDecoder object has an associated encoding, decoder,
							// stream, ignore BOM flag (initially unset), BOM seen flag
							// (initially unset), error mode (initially replacement), and do
							// not flush flag (initially unset).

							/** @private */
							this._encoding = null;
							/** @private @type {?Decoder} */
							this._decoder = null;
							/** @private @type {boolean} */
							this._ignoreBOM = false;
							/** @private @type {boolean} */
							this._BOMseen = false;
							/** @private @type {string} */
							this._error_mode = 'replacement';
							/** @private @type {boolean} */
							this._do_not_flush = false;


							// 1. Let encoding be the result of getting an encoding from
							// label.
							var encoding = getEncoding(label);

							// 2. If encoding is failure or replacement, throw a RangeError.
							if (encoding === null || encoding.name === 'replacement')
								throw RangeError('Unknown encoding: ' + label);
							if (!decoders[encoding.name]) {
								throw Error('Decoder not present.' +
									' Did you forget to include encoding-indexes.js first?');
							}

							// 3. Let dec be a new TextDecoder object.
							var dec = this;

							// 4. Set dec's encoding to encoding.
							dec._encoding = encoding;

							// 5. If options's fatal member is true, set dec's error mode to
							// fatal.
							if (Boolean(options['fatal']))
								dec._error_mode = 'fatal';

							// 6. If options's ignoreBOM member is true, set dec's ignore BOM
							// flag.
							if (Boolean(options['ignoreBOM']))
								dec._ignoreBOM = true;

							// For pre-ES5 runtimes:
							if (!Object.defineProperty) {
								this.encoding = dec._encoding.name.toLowerCase();
								this.fatal = dec._error_mode === 'fatal';
								this.ignoreBOM = dec._ignoreBOM;
							}

							// 7. Return dec.
							return dec;
						}

						if (Object.defineProperty) {
							// The encoding attribute's getter must return encoding's name.
							Object.defineProperty(TextDecoder.prototype, 'encoding', {
								/** @this {TextDecoder} */
								get: function () { return this._encoding.name.toLowerCase(); }
							});

							// The fatal attribute's getter must return true if error mode
							// is fatal, and false otherwise.
							Object.defineProperty(TextDecoder.prototype, 'fatal', {
								/** @this {TextDecoder} */
								get: function () { return this._error_mode === 'fatal'; }
							});

							// The ignoreBOM attribute's getter must return true if ignore
							// BOM flag is set, and false otherwise.
							Object.defineProperty(TextDecoder.prototype, 'ignoreBOM', {
								/** @this {TextDecoder} */
								get: function () { return this._ignoreBOM; }
							});
						}

						/**
						 * @param {BufferSource=} input The buffer of bytes to decode.
						 * @param {Object=} options
						 * @return {string} The decoded string.
						 */
						TextDecoder.prototype.decode = function decode(input, options) {
							var bytes;
							if (typeof input === 'object' && input instanceof ArrayBuffer) {
								bytes = new Uint8Array(input);
							} else if (typeof input === 'object' && 'buffer' in input &&
								input.buffer instanceof ArrayBuffer) {
								bytes = new Uint8Array(input.buffer,
									input.byteOffset,
									input.byteLength);
							} else {
								bytes = new Uint8Array(0);
							}

							options = ToDictionary(options);

							// 1. If the do not flush flag is unset, set decoder to a new
							// encoding's decoder, set stream to a new stream, and unset the
							// BOM seen flag.
							if (!this._do_not_flush) {
								this._decoder = decoders[this._encoding.name]({
									fatal: this._error_mode === 'fatal'
								});
								this._BOMseen = false;
							}

							// 2. If options's stream is true, set the do not flush flag, and
							// unset the do not flush flag otherwise.
							this._do_not_flush = Boolean(options['stream']);

							// 3. If input is given, push a copy of input to stream.
							// TODO: Align with spec algorithm - maintain stream on instance.
							var input_stream = new Stream(bytes);

							// 4. Let output be a new stream.
							var output = [];

							/** @type {?(number|!Array.<number>)} */
							var result;

							// 5. While true:
							while (true) {
								// 1. Let token be the result of reading from stream.
								var token = input_stream.read();

								// 2. If token is end-of-stream and the do not flush flag is
								// set, return output, serialized.
								// TODO: Align with spec algorithm.
								if (token === end_of_stream)
									break;

								// 3. Otherwise, run these subsubsteps:

								// 1. Let result be the result of processing token for decoder,
								// stream, output, and error mode.
								result = this._decoder.handler(input_stream, token);

								// 2. If result is finished, return output, serialized.
								if (result === finished)
									break;

								if (result !== null) {
									if (Array.isArray(result))
										output.push.apply(output, /**@type {!Array.<number>}*/(result));
									else
										output.push(result);
								}

								// 3. Otherwise, if result is error, throw a TypeError.
								// (Thrown in handler)

								// 4. Otherwise, do nothing.
							}
							// TODO: Align with spec algorithm.
							if (!this._do_not_flush) {
								do {
									result = this._decoder.handler(input_stream, input_stream.read());
									if (result === finished)
										break;
									if (result === null)
										continue;
									if (Array.isArray(result))
										output.push.apply(output, /**@type {!Array.<number>}*/(result));
									else
										output.push(result);
								} while (!input_stream.endOfStream());
								this._decoder = null;
							}

							// A TextDecoder object also has an associated serialize stream
							// algorithm...
							/**
							 * @param {!Array.<number>} stream
							 * @return {string}
							 * @this {TextDecoder}
							 */
							function serializeStream(stream) {
								// 1. Let token be the result of reading from stream.
								// (Done in-place on array, rather than as a stream)

								// 2. If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore
								// BOM flag and BOM seen flag are unset, run these subsubsteps:
								if (includes(['UTF-8', 'UTF-16LE', 'UTF-16BE'], this._encoding.name) &&
									!this._ignoreBOM && !this._BOMseen) {
									if (stream.length > 0 && stream[0] === 0xFEFF) {
										// 1. If token is U+FEFF, set BOM seen flag.
										this._BOMseen = true;
										stream.shift();
									} else if (stream.length > 0) {
										// 2. Otherwise, if token is not end-of-stream, set BOM seen
										// flag and append token to stream.
										this._BOMseen = true;
									} else;
								}
								// 4. Otherwise, return output.
								return codePointsToString(stream);
							}

							return serializeStream.call(this, output);
						};

						// 8.2 Interface TextEncoder

						/**
						 * @constructor
						 * @param {string=} label The label of the encoding. NONSTANDARD.
						 * @param {Object=} options NONSTANDARD.
						 */
						function TextEncoder(label, options) {
							// Web IDL conventions
							if (!(this instanceof TextEncoder))
								throw TypeError('Called as a function. Did you forget \'new\'?');
							options = ToDictionary(options);

							// A TextEncoder object has an associated encoding and encoder.

							/** @private */
							this._encoding = null;
							/** @private @type {?Encoder} */
							this._encoder = null;

							// Non-standard
							/** @private @type {boolean} */
							this._do_not_flush = false;
							/** @private @type {string} */
							this._fatal = Boolean(options['fatal']) ? 'fatal' : 'replacement';

							// 1. Let enc be a new TextEncoder object.
							var enc = this;

							// 2. Set enc's encoding to UTF-8's encoder.
							if (Boolean(options['NONSTANDARD_allowLegacyEncoding'])) {
								// NONSTANDARD behavior.
								label = label !== undefined ? String(label) : DEFAULT_ENCODING;
								var encoding = getEncoding(label);
								if (encoding === null || encoding.name === 'replacement')
									throw RangeError('Unknown encoding: ' + label);
								if (!encoders[encoding.name]) {
									throw Error('Encoder not present.' +
										' Did you forget to include encoding-indexes.js first?');
								}
								enc._encoding = encoding;
							} else {
								// Standard behavior.
								enc._encoding = getEncoding('utf-8');

								if (label !== undefined && 'console' in global) {
									console.warn('TextEncoder constructor called with encoding label, '
										+ 'which is ignored.');
								}
							}

							// For pre-ES5 runtimes:
							if (!Object.defineProperty)
								this.encoding = enc._encoding.name.toLowerCase();

							// 3. Return enc.
							return enc;
						}

						if (Object.defineProperty) {
							// The encoding attribute's getter must return encoding's name.
							Object.defineProperty(TextEncoder.prototype, 'encoding', {
								/** @this {TextEncoder} */
								get: function () { return this._encoding.name.toLowerCase(); }
							});
						}

						/**
						 * @param {string=} opt_string The string to encode.
						 * @param {Object=} options
						 * @return {!Uint8Array} Encoded bytes, as a Uint8Array.
						 */
						TextEncoder.prototype.encode = function encode(opt_string, options) {
							opt_string = opt_string === undefined ? '' : String(opt_string);
							options = ToDictionary(options);

							// NOTE: This option is nonstandard. None of the encodings
							// permitted for encoding (i.e. UTF-8, UTF-16) are stateful when
							// the input is a USVString so streaming is not necessary.
							if (!this._do_not_flush)
								this._encoder = encoders[this._encoding.name]({
									fatal: this._fatal === 'fatal'
								});
							this._do_not_flush = Boolean(options['stream']);

							// 1. Convert input to a stream.
							var input = new Stream(stringToCodePoints(opt_string));

							// 2. Let output be a new stream
							var output = [];

							/** @type {?(number|!Array.<number>)} */
							var result;
							// 3. While true, run these substeps:
							while (true) {
								// 1. Let token be the result of reading from input.
								var token = input.read();
								if (token === end_of_stream)
									break;
								// 2. Let result be the result of processing token for encoder,
								// input, output.
								result = this._encoder.handler(input, token);
								if (result === finished)
									break;
								if (Array.isArray(result))
									output.push.apply(output, /**@type {!Array.<number>}*/(result));
								else
									output.push(result);
							}
							// TODO: Align with spec algorithm.
							if (!this._do_not_flush) {
								while (true) {
									result = this._encoder.handler(input, input.read());
									if (result === finished)
										break;
									if (Array.isArray(result))
										output.push.apply(output, /**@type {!Array.<number>}*/(result));
									else
										output.push(result);
								}
								this._encoder = null;
							}
							// 3. If result is finished, convert output into a byte sequence,
							// and then return a Uint8Array object wrapping an ArrayBuffer
							// containing output.
							return new Uint8Array(output);
						};


						//
						// 9. The encoding
						//

						// 9.1 utf-8

						// 9.1.1 utf-8 decoder
						/**
						 * @constructor
						 * @implements {Decoder}
						 * @param {{fatal: boolean}} options
						 */
						function UTF8Decoder(options) {
							var fatal = options.fatal;

							// utf-8's decoder's has an associated utf-8 code point, utf-8
							// bytes seen, and utf-8 bytes needed (all initially 0), a utf-8
							// lower boundary (initially 0x80), and a utf-8 upper boundary
							// (initially 0xBF).
							var /** @type {number} */ utf8_code_point = 0,
    	        /** @type {number} */ utf8_bytes_seen = 0,
    	        /** @type {number} */ utf8_bytes_needed = 0,
    	        /** @type {number} */ utf8_lower_boundary = 0x80,
    	        /** @type {number} */ utf8_upper_boundary = 0xBF;

							/**
							 * @param {Stream} stream The stream of bytes being decoded.
							 * @param {number} bite The next byte read from the stream.
							 * @return {?(number|!Array.<number>)} The next code point(s)
							 *     decoded, or null if not enough data exists in the input
							 *     stream to decode a complete code point.
							 */
							this.handler = function (stream, bite) {
								// 1. If byte is end-of-stream and utf-8 bytes needed is not 0,
								// set utf-8 bytes needed to 0 and return error.
								if (bite === end_of_stream && utf8_bytes_needed !== 0) {
									utf8_bytes_needed = 0;
									return decoderError(fatal);
								}

								// 2. If byte is end-of-stream, return finished.
								if (bite === end_of_stream)
									return finished;

								// 3. If utf-8 bytes needed is 0, based on byte:
								if (utf8_bytes_needed === 0) {

									// 0x00 to 0x7F
									if (inRange(bite, 0x00, 0x7F)) {
										// Return a code point whose value is byte.
										return bite;
									}

									// 0xC2 to 0xDF
									else if (inRange(bite, 0xC2, 0xDF)) {
										// 1. Set utf-8 bytes needed to 1.
										utf8_bytes_needed = 1;

										// 2. Set UTF-8 code point to byte & 0x1F.
										utf8_code_point = bite & 0x1F;
									}

									// 0xE0 to 0xEF
									else if (inRange(bite, 0xE0, 0xEF)) {
										// 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.
										if (bite === 0xE0)
											utf8_lower_boundary = 0xA0;
										// 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.
										if (bite === 0xED)
											utf8_upper_boundary = 0x9F;
										// 3. Set utf-8 bytes needed to 2.
										utf8_bytes_needed = 2;
										// 4. Set UTF-8 code point to byte & 0xF.
										utf8_code_point = bite & 0xF;
									}

									// 0xF0 to 0xF4
									else if (inRange(bite, 0xF0, 0xF4)) {
										// 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.
										if (bite === 0xF0)
											utf8_lower_boundary = 0x90;
										// 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.
										if (bite === 0xF4)
											utf8_upper_boundary = 0x8F;
										// 3. Set utf-8 bytes needed to 3.
										utf8_bytes_needed = 3;
										// 4. Set UTF-8 code point to byte & 0x7.
										utf8_code_point = bite & 0x7;
									}

									// Otherwise
									else {
										// Return error.
										return decoderError(fatal);
									}

									// Return continue.
									return null;
								}

								// 4. If byte is not in the range utf-8 lower boundary to utf-8
								// upper boundary, inclusive, run these substeps:
								if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {

									// 1. Set utf-8 code point, utf-8 bytes needed, and utf-8
									// bytes seen to 0, set utf-8 lower boundary to 0x80, and set
									// utf-8 upper boundary to 0xBF.
									utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
									utf8_lower_boundary = 0x80;
									utf8_upper_boundary = 0xBF;

									// 2. Prepend byte to stream.
									stream.prepend(bite);

									// 3. Return error.
									return decoderError(fatal);
								}

								// 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary
								// to 0xBF.
								utf8_lower_boundary = 0x80;
								utf8_upper_boundary = 0xBF;

								// 6. Set UTF-8 code point to (UTF-8 code point << 6) | (byte &
								// 0x3F)
								utf8_code_point = (utf8_code_point << 6) | (bite & 0x3F);

								// 7. Increase utf-8 bytes seen by one.
								utf8_bytes_seen += 1;

								// 8. If utf-8 bytes seen is not equal to utf-8 bytes needed,
								// continue.
								if (utf8_bytes_seen !== utf8_bytes_needed)
									return null;

								// 9. Let code point be utf-8 code point.
								var code_point = utf8_code_point;

								// 10. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes
								// seen to 0.
								utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;

								// 11. Return a code point whose value is code point.
								return code_point;
							};
						}

						// 9.1.2 utf-8 encoder
						/**
						 * @constructor
						 * @implements {Encoder}
						 * @param {{fatal: boolean}} options
						 */
						function UTF8Encoder(options) {
							options.fatal;
							/**
							 * @param {Stream} stream Input stream.
							 * @param {number} code_point Next code point read from the stream.
							 * @return {(number|!Array.<number>)} Byte(s) to emit.
							 */
							this.handler = function (stream, code_point) {
								// 1. If code point is end-of-stream, return finished.
								if (code_point === end_of_stream)
									return finished;

								// 2. If code point is an ASCII code point, return a byte whose
								// value is code point.
								if (isASCIICodePoint(code_point))
									return code_point;

								// 3. Set count and offset based on the range code point is in:
								var count, offset;
								// U+0080 to U+07FF, inclusive:
								if (inRange(code_point, 0x0080, 0x07FF)) {
									// 1 and 0xC0
									count = 1;
									offset = 0xC0;
								}
								// U+0800 to U+FFFF, inclusive:
								else if (inRange(code_point, 0x0800, 0xFFFF)) {
									// 2 and 0xE0
									count = 2;
									offset = 0xE0;
								}
								// U+10000 to U+10FFFF, inclusive:
								else if (inRange(code_point, 0x10000, 0x10FFFF)) {
									// 3 and 0xF0
									count = 3;
									offset = 0xF0;
								}

								// 4. Let bytes be a byte sequence whose first byte is (code
								// point >> (6 × count)) + offset.
								var bytes = [(code_point >> (6 * count)) + offset];

								// 5. Run these substeps while count is greater than 0:
								while (count > 0) {

									// 1. Set temp to code point >> (6 × (count − 1)).
									var temp = code_point >> (6 * (count - 1));

									// 2. Append to bytes 0x80 | (temp & 0x3F).
									bytes.push(0x80 | (temp & 0x3F));

									// 3. Decrease count by one.
									count -= 1;
								}

								// 6. Return bytes bytes, in order.
								return bytes;
							};
						}

						/** @param {{fatal: boolean}} options */
						encoders['UTF-8'] = function (options) {
							return new UTF8Encoder(options);
						};
						/** @param {{fatal: boolean}} options */
						decoders['UTF-8'] = function (options) {
							return new UTF8Decoder(options);
						};

						//
						// 10. Legacy single-byte encodings
						//

						// 10.1 single-byte decoder
						/**
						 * @constructor
						 * @implements {Decoder}
						 * @param {!Array.<number>} index The encoding index.
						 * @param {{fatal: boolean}} options
						 */
						function SingleByteDecoder(index, options) {
							var fatal = options.fatal;
							/**
							 * @param {Stream} stream The stream of bytes being decoded.
							 * @param {number} bite The next byte read from the stream.
							 * @return {?(number|!Array.<number>)} The next code point(s)
							 *     decoded, or null if not enough data exists in the input
							 *     stream to decode a complete code point.
							 */
							this.handler = function (stream, bite) {
								// 1. If byte is end-of-stream, return finished.
								if (bite === end_of_stream)
									return finished;

								// 2. If byte is an ASCII byte, return a code point whose value
								// is byte.
								if (isASCIIByte(bite))
									return bite;

								// 3. Let code point be the index code point for byte − 0x80 in
								// index single-byte.
								var code_point = index[bite - 0x80];

								// 4. If code point is null, return error.
								if (code_point === null)
									return decoderError(fatal);

								// 5. Return a code point whose value is code point.
								return code_point;
							};
						}

						// 10.2 single-byte encoder
						/**
						 * @constructor
						 * @implements {Encoder}
						 * @param {!Array.<?number>} index The encoding index.
						 * @param {{fatal: boolean}} options
						 */
						function SingleByteEncoder(index, options) {
							options.fatal;
							/**
							 * @param {Stream} stream Input stream.
							 * @param {number} code_point Next code point read from the stream.
							 * @return {(number|!Array.<number>)} Byte(s) to emit.
							 */
							this.handler = function (stream, code_point) {
								// 1. If code point is end-of-stream, return finished.
								if (code_point === end_of_stream)
									return finished;

								// 2. If code point is an ASCII code point, return a byte whose
								// value is code point.
								if (isASCIICodePoint(code_point))
									return code_point;

								// 3. Let pointer be the index pointer for code point in index
								// single-byte.
								var pointer = indexPointerFor(code_point, index);

								// 4. If pointer is null, return error with code point.
								if (pointer === null)
									encoderError(code_point);

								// 5. Return a byte whose value is pointer + 0x80.
								return pointer + 0x80;
							};
						}

						(function () {
							if (!('encoding-indexes' in global))
								return;
							encodings.forEach(function (category) {
								if (category.heading !== 'Legacy single-byte encodings')
									return;
								category.encodings.forEach(function (encoding) {
									var name = encoding.name;
									var idx = index(name.toLowerCase());
									/** @param {{fatal: boolean}} options */
									decoders[name] = function (options) {
										return new SingleByteDecoder(idx, options);
									};
									/** @param {{fatal: boolean}} options */
									encoders[name] = function (options) {
										return new SingleByteEncoder(idx, options);
									};
								});
							});
						}());

						//
						// 11. Legacy multi-byte Chinese (simplified) encodings
						//

						// 11.1 gbk

						// 11.1.1 gbk decoder
						// gbk's decoder is gb18030's decoder.
						/** @param {{fatal: boolean}} options */
						decoders['GBK'] = function (options) {
							return new GB18030Decoder(options);
						};

						// 11.1.2 gbk encoder
						// gbk's encoder is gb18030's encoder with its gbk flag set.
						/** @param {{fatal: boolean}} options */
						encoders['GBK'] = function (options) {
							return new GB18030Encoder(options, true);
						};

						// 11.2 gb18030

						// 11.2.1 gb18030 decoder
						/**
						 * @constructor
						 * @implements {Decoder}
						 * @param {{fatal: boolean}} options
						 */
						function GB18030Decoder(options) {
							var fatal = options.fatal;
							// gb18030's decoder has an associated gb18030 first, gb18030
							// second, and gb18030 third (all initially 0x00).
							var /** @type {number} */ gb18030_first = 0x00,
    	        /** @type {number} */ gb18030_second = 0x00,
    	        /** @type {number} */ gb18030_third = 0x00;
							/**
							 * @param {Stream} stream The stream of bytes being decoded.
							 * @param {number} bite The next byte read from the stream.
							 * @return {?(number|!Array.<number>)} The next code point(s)
							 *     decoded, or null if not enough data exists in the input
							 *     stream to decode a complete code point.
							 */
							this.handler = function (stream, bite) {
								// 1. If byte is end-of-stream and gb18030 first, gb18030
								// second, and gb18030 third are 0x00, return finished.
								if (bite === end_of_stream && gb18030_first === 0x00 &&
									gb18030_second === 0x00 && gb18030_third === 0x00) {
									return finished;
								}
								// 2. If byte is end-of-stream, and gb18030 first, gb18030
								// second, or gb18030 third is not 0x00, set gb18030 first,
								// gb18030 second, and gb18030 third to 0x00, and return error.
								if (bite === end_of_stream &&
									(gb18030_first !== 0x00 || gb18030_second !== 0x00 ||
										gb18030_third !== 0x00)) {
									gb18030_first = 0x00;
									gb18030_second = 0x00;
									gb18030_third = 0x00;
									decoderError(fatal);
								}
								var code_point;
								// 3. If gb18030 third is not 0x00, run these substeps:
								if (gb18030_third !== 0x00) {
									// 1. Let code point be null.
									code_point = null;
									// 2. If byte is in the range 0x30 to 0x39, inclusive, set
									// code point to the index gb18030 ranges code point for
									// (((gb18030 first − 0x81) × 10 + gb18030 second − 0x30) ×
									// 126 + gb18030 third − 0x81) × 10 + byte − 0x30.
									if (inRange(bite, 0x30, 0x39)) {
										code_point = indexGB18030RangesCodePointFor(
											(((gb18030_first - 0x81) * 10 + gb18030_second - 0x30) * 126 +
												gb18030_third - 0x81) * 10 + bite - 0x30);
									}

									// 3. Let buffer be a byte sequence consisting of gb18030
									// second, gb18030 third, and byte, in order.
									var buffer = [gb18030_second, gb18030_third, bite];

									// 4. Set gb18030 first, gb18030 second, and gb18030 third to
									// 0x00.
									gb18030_first = 0x00;
									gb18030_second = 0x00;
									gb18030_third = 0x00;

									// 5. If code point is null, prepend buffer to stream and
									// return error.
									if (code_point === null) {
										stream.prepend(buffer);
										return decoderError(fatal);
									}

									// 6. Return a code point whose value is code point.
									return code_point;
								}

								// 4. If gb18030 second is not 0x00, run these substeps:
								if (gb18030_second !== 0x00) {

									// 1. If byte is in the range 0x81 to 0xFE, inclusive, set
									// gb18030 third to byte and return continue.
									if (inRange(bite, 0x81, 0xFE)) {
										gb18030_third = bite;
										return null;
									}

									// 2. Prepend gb18030 second followed by byte to stream, set
									// gb18030 first and gb18030 second to 0x00, and return error.
									stream.prepend([gb18030_second, bite]);
									gb18030_first = 0x00;
									gb18030_second = 0x00;
									return decoderError(fatal);
								}

								// 5. If gb18030 first is not 0x00, run these substeps:
								if (gb18030_first !== 0x00) {

									// 1. If byte is in the range 0x30 to 0x39, inclusive, set
									// gb18030 second to byte and return continue.
									if (inRange(bite, 0x30, 0x39)) {
										gb18030_second = bite;
										return null;
									}

									// 2. Let lead be gb18030 first, let pointer be null, and set
									// gb18030 first to 0x00.
									var lead = gb18030_first;
									var pointer = null;
									gb18030_first = 0x00;

									// 3. Let offset be 0x40 if byte is less than 0x7F and 0x41
									// otherwise.
									var offset = bite < 0x7F ? 0x40 : 0x41;

									// 4. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80
									// to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 +
									// (byte − offset).
									if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFE))
										pointer = (lead - 0x81) * 190 + (bite - offset);

									// 5. Let code point be null if pointer is null and the index
									// code point for pointer in index gb18030 otherwise.
									code_point = pointer === null ? null :
										indexCodePointFor(pointer, index('gb18030'));

									// 6. If code point is null and byte is an ASCII byte, prepend
									// byte to stream.
									if (code_point === null && isASCIIByte(bite))
										stream.prepend(bite);

									// 7. If code point is null, return error.
									if (code_point === null)
										return decoderError(fatal);

									// 8. Return a code point whose value is code point.
									return code_point;
								}

								// 6. If byte is an ASCII byte, return a code point whose value
								// is byte.
								if (isASCIIByte(bite))
									return bite;

								// 7. If byte is 0x80, return code point U+20AC.
								if (bite === 0x80)
									return 0x20AC;

								// 8. If byte is in the range 0x81 to 0xFE, inclusive, set
								// gb18030 first to byte and return continue.
								if (inRange(bite, 0x81, 0xFE)) {
									gb18030_first = bite;
									return null;
								}

								// 9. Return error.
								return decoderError(fatal);
							};
						}

						// 11.2.2 gb18030 encoder
						/**
						 * @constructor
						 * @implements {Encoder}
						 * @param {{fatal: boolean}} options
						 * @param {boolean=} gbk_flag
						 */
						function GB18030Encoder(options, gbk_flag) {
							options.fatal;
							// gb18030's decoder has an associated gbk flag (initially unset).
							/**
							 * @param {Stream} stream Input stream.
							 * @param {number} code_point Next code point read from the stream.
							 * @return {(number|!Array.<number>)} Byte(s) to emit.
							 */
							this.handler = function (stream, code_point) {
								// 1. If code point is end-of-stream, return finished.
								if (code_point === end_of_stream)
									return finished;

								// 2. If code point is an ASCII code point, return a byte whose
								// value is code point.
								if (isASCIICodePoint(code_point))
									return code_point;

								// 3. If code point is U+E5E5, return error with code point.
								if (code_point === 0xE5E5)
									return encoderError(code_point);

								// 4. If the gbk flag is set and code point is U+20AC, return
								// byte 0x80.
								if (gbk_flag && code_point === 0x20AC)
									return 0x80;

								// 5. Let pointer be the index pointer for code point in index
								// gb18030.
								var pointer = indexPointerFor(code_point, index('gb18030'));

								// 6. If pointer is not null, run these substeps:
								if (pointer !== null) {

									// 1. Let lead be floor(pointer / 190) + 0x81.
									var lead = floor(pointer / 190) + 0x81;

									// 2. Let trail be pointer % 190.
									var trail = pointer % 190;

									// 3. Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.
									var offset = trail < 0x3F ? 0x40 : 0x41;

									// 4. Return two bytes whose values are lead and trail + offset.
									return [lead, trail + offset];
								}

								// 7. If gbk flag is set, return error with code point.
								if (gbk_flag)
									return encoderError(code_point);

								// 8. Set pointer to the index gb18030 ranges pointer for code
								// point.
								pointer = indexGB18030RangesPointerFor(code_point);

								// 9. Let byte1 be floor(pointer / 10 / 126 / 10).
								var byte1 = floor(pointer / 10 / 126 / 10);

								// 10. Set pointer to pointer − byte1 × 10 × 126 × 10.
								pointer = pointer - byte1 * 10 * 126 * 10;

								// 11. Let byte2 be floor(pointer / 10 / 126).
								var byte2 = floor(pointer / 10 / 126);

								// 12. Set pointer to pointer − byte2 × 10 × 126.
								pointer = pointer - byte2 * 10 * 126;

								// 13. Let byte3 be floor(pointer / 10).
								var byte3 = floor(pointer / 10);

								// 14. Let byte4 be pointer − byte3 × 10.
								var byte4 = pointer - byte3 * 10;

								// 15. Return four bytes whose values are byte1 + 0x81, byte2 +
								// 0x30, byte3 + 0x81, byte4 + 0x30.
								return [byte1 + 0x81,
								byte2 + 0x30,
								byte3 + 0x81,
								byte4 + 0x30];
							};
						}

						/** @param {{fatal: boolean}} options */
						encoders['gb18030'] = function (options) {
							return new GB18030Encoder(options);
						};
						/** @param {{fatal: boolean}} options */
						decoders['gb18030'] = function (options) {
							return new GB18030Decoder(options);
						};


						//
						// 12. Legacy multi-byte Chinese (traditional) encodings
						//

						// 12.1 Big5

						// 12.1.1 Big5 decoder
						/**
						 * @constructor
						 * @implements {Decoder}
						 * @param {{fatal: boolean}} options
						 */
						function Big5Decoder(options) {
							var fatal = options.fatal;
							// Big5's decoder has an associated Big5 lead (initially 0x00).
							var /** @type {number} */ Big5_lead = 0x00;

							/**
							 * @param {Stream} stream The stream of bytes being decoded.
							 * @param {number} bite The next byte read from the stream.
							 * @return {?(number|!Array.<number>)} The next code point(s)
							 *     decoded, or null if not enough data exists in the input
							 *     stream to decode a complete code point.
							 */
							this.handler = function (stream, bite) {
								// 1. If byte is end-of-stream and Big5 lead is not 0x00, set
								// Big5 lead to 0x00 and return error.
								if (bite === end_of_stream && Big5_lead !== 0x00) {
									Big5_lead = 0x00;
									return decoderError(fatal);
								}

								// 2. If byte is end-of-stream and Big5 lead is 0x00, return
								// finished.
								if (bite === end_of_stream && Big5_lead === 0x00)
									return finished;

								// 3. If Big5 lead is not 0x00, let lead be Big5 lead, let
								// pointer be null, set Big5 lead to 0x00, and then run these
								// substeps:
								if (Big5_lead !== 0x00) {
									var lead = Big5_lead;
									var pointer = null;
									Big5_lead = 0x00;

									// 1. Let offset be 0x40 if byte is less than 0x7F and 0x62
									// otherwise.
									var offset = bite < 0x7F ? 0x40 : 0x62;

									// 2. If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1
									// to 0xFE, inclusive, set pointer to (lead − 0x81) × 157 +
									// (byte − offset).
									if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0xA1, 0xFE))
										pointer = (lead - 0x81) * 157 + (bite - offset);

									// 3. If there is a row in the table below whose first column
									// is pointer, return the two code points listed in its second
									// column
									// Pointer | Code points
									// --------+--------------
									// 1133    | U+00CA U+0304
									// 1135    | U+00CA U+030C
									// 1164    | U+00EA U+0304
									// 1166    | U+00EA U+030C
									switch (pointer) {
										case 1133: return [0x00CA, 0x0304];
										case 1135: return [0x00CA, 0x030C];
										case 1164: return [0x00EA, 0x0304];
										case 1166: return [0x00EA, 0x030C];
									}

									// 4. Let code point be null if pointer is null and the index
									// code point for pointer in index Big5 otherwise.
									var code_point = (pointer === null) ? null :
										indexCodePointFor(pointer, index('big5'));

									// 5. If code point is null and byte is an ASCII byte, prepend
									// byte to stream.
									if (code_point === null && isASCIIByte(bite))
										stream.prepend(bite);

									// 6. If code point is null, return error.
									if (code_point === null)
										return decoderError(fatal);

									// 7. Return a code point whose value is code point.
									return code_point;
								}

								// 4. If byte is an ASCII byte, return a code point whose value
								// is byte.
								if (isASCIIByte(bite))
									return bite;

								// 5. If byte is in the range 0x81 to 0xFE, inclusive, set Big5
								// lead to byte and return continue.
								if (inRange(bite, 0x81, 0xFE)) {
									Big5_lead = bite;
									return null;
								}

								// 6. Return error.
								return decoderError(fatal);
							};
						}

						// 12.1.2 Big5 encoder
						/**
						 * @constructor
						 * @implements {Encoder}
						 * @param {{fatal: boolean}} options
						 */
						function Big5Encoder(options) {
							options.fatal;
							/**
							 * @param {Stream} stream Input stream.
							 * @param {number} code_point Next code point read from the stream.
							 * @return {(number|!Array.<number>)} Byte(s) to emit.
							 */
							this.handler = function (stream, code_point) {
								// 1. If code point is end-of-stream, return finished.
								if (code_point === end_of_stream)
									return finished;

								// 2. If code point is an ASCII code point, return a byte whose
								// value is code point.
								if (isASCIICodePoint(code_point))
									return code_point;

								// 3. Let pointer be the index Big5 pointer for code point.
								var pointer = indexBig5PointerFor(code_point);

								// 4. If pointer is null, return error with code point.
								if (pointer === null)
									return encoderError(code_point);

								// 5. Let lead be floor(pointer / 157) + 0x81.
								var lead = floor(pointer / 157) + 0x81;

								// 6. If lead is less than 0xA1, return error with code point.
								if (lead < 0xA1)
									return encoderError(code_point);

								// 7. Let trail be pointer % 157.
								var trail = pointer % 157;

								// 8. Let offset be 0x40 if trail is less than 0x3F and 0x62
								// otherwise.
								var offset = trail < 0x3F ? 0x40 : 0x62;

								// Return two bytes whose values are lead and trail + offset.
								return [lead, trail + offset];
							};
						}

						/** @param {{fatal: boolean}} options */
						encoders['Big5'] = function (options) {
							return new Big5Encoder(options);
						};
						/** @param {{fatal: boolean}} options */
						decoders['Big5'] = function (options) {
							return new Big5Decoder(options);
						};


						//
						// 13. Legacy multi-byte Japanese encodings
						//

						// 13.1 euc-jp

						// 13.1.1 euc-jp decoder
						/**
						 * @constructor
						 * @implements {Decoder}
						 * @param {{fatal: boolean}} options
						 */
						function EUCJPDecoder(options) {
							var fatal = options.fatal;

							// euc-jp's decoder has an associated euc-jp jis0212 flag
							// (initially unset) and euc-jp lead (initially 0x00).
							var /** @type {boolean} */ eucjp_jis0212_flag = false,
    	        /** @type {number} */ eucjp_lead = 0x00;

							/**
							 * @param {Stream} stream The stream of bytes being decoded.
							 * @param {number} bite The next byte read from the stream.
							 * @return {?(number|!Array.<number>)} The next code point(s)
							 *     decoded, or null if not enough data exists in the input
							 *     stream to decode a complete code point.
							 */
							this.handler = function (stream, bite) {
								// 1. If byte is end-of-stream and euc-jp lead is not 0x00, set
								// euc-jp lead to 0x00, and return error.
								if (bite === end_of_stream && eucjp_lead !== 0x00) {
									eucjp_lead = 0x00;
									return decoderError(fatal);
								}

								// 2. If byte is end-of-stream and euc-jp lead is 0x00, return
								// finished.
								if (bite === end_of_stream && eucjp_lead === 0x00)
									return finished;

								// 3. If euc-jp lead is 0x8E and byte is in the range 0xA1 to
								// 0xDF, inclusive, set euc-jp lead to 0x00 and return a code
								// point whose value is 0xFF61 − 0xA1 + byte.
								if (eucjp_lead === 0x8E && inRange(bite, 0xA1, 0xDF)) {
									eucjp_lead = 0x00;
									return 0xFF61 - 0xA1 + bite;
								}

								// 4. If euc-jp lead is 0x8F and byte is in the range 0xA1 to
								// 0xFE, inclusive, set the euc-jp jis0212 flag, set euc-jp lead
								// to byte, and return continue.
								if (eucjp_lead === 0x8F && inRange(bite, 0xA1, 0xFE)) {
									eucjp_jis0212_flag = true;
									eucjp_lead = bite;
									return null;
								}

								// 5. If euc-jp lead is not 0x00, let lead be euc-jp lead, set
								// euc-jp lead to 0x00, and run these substeps:
								if (eucjp_lead !== 0x00) {
									var lead = eucjp_lead;
									eucjp_lead = 0x00;

									// 1. Let code point be null.
									var code_point = null;

									// 2. If lead and byte are both in the range 0xA1 to 0xFE,
									// inclusive, set code point to the index code point for (lead
									// − 0xA1) × 94 + byte − 0xA1 in index jis0208 if the euc-jp
									// jis0212 flag is unset and in index jis0212 otherwise.
									if (inRange(lead, 0xA1, 0xFE) && inRange(bite, 0xA1, 0xFE)) {
										code_point = indexCodePointFor(
											(lead - 0xA1) * 94 + (bite - 0xA1),
											index(!eucjp_jis0212_flag ? 'jis0208' : 'jis0212'));
									}

									// 3. Unset the euc-jp jis0212 flag.
									eucjp_jis0212_flag = false;

									// 4. If byte is not in the range 0xA1 to 0xFE, inclusive,
									// prepend byte to stream.
									if (!inRange(bite, 0xA1, 0xFE))
										stream.prepend(bite);

									// 5. If code point is null, return error.
									if (code_point === null)
										return decoderError(fatal);

									// 6. Return a code point whose value is code point.
									return code_point;
								}

								// 6. If byte is an ASCII byte, return a code point whose value
								// is byte.
								if (isASCIIByte(bite))
									return bite;

								// 7. If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE,
								// inclusive, set euc-jp lead to byte and return continue.
								if (bite === 0x8E || bite === 0x8F || inRange(bite, 0xA1, 0xFE)) {
									eucjp_lead = bite;
									return null;
								}

								// 8. Return error.
								return decoderError(fatal);
							};
						}

						// 13.1.2 euc-jp encoder
						/**
						 * @constructor
						 * @implements {Encoder}
						 * @param {{fatal: boolean}} options
						 */
						function EUCJPEncoder(options) {
							options.fatal;
							/**
							 * @param {Stream} stream Input stream.
							 * @param {number} code_point Next code point read from the stream.
							 * @return {(number|!Array.<number>)} Byte(s) to emit.
							 */
							this.handler = function (stream, code_point) {
								// 1. If code point is end-of-stream, return finished.
								if (code_point === end_of_stream)
									return finished;

								// 2. If code point is an ASCII code point, return a byte whose
								// value is code point.
								if (isASCIICodePoint(code_point))
									return code_point;

								// 3. If code point is U+00A5, return byte 0x5C.
								if (code_point === 0x00A5)
									return 0x5C;

								// 4. If code point is U+203E, return byte 0x7E.
								if (code_point === 0x203E)
									return 0x7E;

								// 5. If code point is in the range U+FF61 to U+FF9F, inclusive,
								// return two bytes whose values are 0x8E and code point −
								// 0xFF61 + 0xA1.
								if (inRange(code_point, 0xFF61, 0xFF9F))
									return [0x8E, code_point - 0xFF61 + 0xA1];

								// 6. If code point is U+2212, set it to U+FF0D.
								if (code_point === 0x2212)
									code_point = 0xFF0D;

								// 7. Let pointer be the index pointer for code point in index
								// jis0208.
								var pointer = indexPointerFor(code_point, index('jis0208'));

								// 8. If pointer is null, return error with code point.
								if (pointer === null)
									return encoderError(code_point);

								// 9. Let lead be floor(pointer / 94) + 0xA1.
								var lead = floor(pointer / 94) + 0xA1;

								// 10. Let trail be pointer % 94 + 0xA1.
								var trail = pointer % 94 + 0xA1;

								// 11. Return two bytes whose values are lead and trail.
								return [lead, trail];
							};
						}

						/** @param {{fatal: boolean}} options */
						encoders['EUC-JP'] = function (options) {
							return new EUCJPEncoder(options);
						};
						/** @param {{fatal: boolean}} options */
						decoders['EUC-JP'] = function (options) {
							return new EUCJPDecoder(options);
						};

						// 13.2 iso-2022-jp

						// 13.2.1 iso-2022-jp decoder
						/**
						 * @constructor
						 * @implements {Decoder}
						 * @param {{fatal: boolean}} options
						 */
						function ISO2022JPDecoder(options) {
							var fatal = options.fatal;
							/** @enum */
							var states = {
								ASCII: 0,
								Roman: 1,
								Katakana: 2,
								LeadByte: 3,
								TrailByte: 4,
								EscapeStart: 5,
								Escape: 6
							};
							// iso-2022-jp's decoder has an associated iso-2022-jp decoder
							// state (initially ASCII), iso-2022-jp decoder output state
							// (initially ASCII), iso-2022-jp lead (initially 0x00), and
							// iso-2022-jp output flag (initially unset).
							var /** @type {number} */ iso2022jp_decoder_state = states.ASCII,
    	        /** @type {number} */ iso2022jp_decoder_output_state = states.ASCII,
    	        /** @type {number} */ iso2022jp_lead = 0x00,
    	        /** @type {boolean} */ iso2022jp_output_flag = false;
							/**
							 * @param {Stream} stream The stream of bytes being decoded.
							 * @param {number} bite The next byte read from the stream.
							 * @return {?(number|!Array.<number>)} The next code point(s)
							 *     decoded, or null if not enough data exists in the input
							 *     stream to decode a complete code point.
							 */
							this.handler = function (stream, bite) {
								// switching on iso-2022-jp decoder state:
								switch (iso2022jp_decoder_state) {
									default:
									case states.ASCII:
										// ASCII
										// Based on byte:

										// 0x1B
										if (bite === 0x1B) {
											// Set iso-2022-jp decoder state to escape start and return
											// continue.
											iso2022jp_decoder_state = states.EscapeStart;
											return null;
										}

										// 0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B
										if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E
											&& bite !== 0x0F && bite !== 0x1B) {
											// Unset the iso-2022-jp output flag and return a code point
											// whose value is byte.
											iso2022jp_output_flag = false;
											return bite;
										}

										// end-of-stream
										if (bite === end_of_stream) {
											// Return finished.
											return finished;
										}

										// Otherwise
										// Unset the iso-2022-jp output flag and return error.
										iso2022jp_output_flag = false;
										return decoderError(fatal);

									case states.Roman:
										// Roman
										// Based on byte:

										// 0x1B
										if (bite === 0x1B) {
											// Set iso-2022-jp decoder state to escape start and return
											// continue.
											iso2022jp_decoder_state = states.EscapeStart;
											return null;
										}

										// 0x5C
										if (bite === 0x5C) {
											// Unset the iso-2022-jp output flag and return code point
											// U+00A5.
											iso2022jp_output_flag = false;
											return 0x00A5;
										}

										// 0x7E
										if (bite === 0x7E) {
											// Unset the iso-2022-jp output flag and return code point
											// U+203E.
											iso2022jp_output_flag = false;
											return 0x203E;
										}

										// 0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E
										if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E && bite !== 0x0F
											&& bite !== 0x1B && bite !== 0x5C && bite !== 0x7E) {
											// Unset the iso-2022-jp output flag and return a code point
											// whose value is byte.
											iso2022jp_output_flag = false;
											return bite;
										}

										// end-of-stream
										if (bite === end_of_stream) {
											// Return finished.
											return finished;
										}

										// Otherwise
										// Unset the iso-2022-jp output flag and return error.
										iso2022jp_output_flag = false;
										return decoderError(fatal);

									case states.Katakana:
										// Katakana
										// Based on byte:

										// 0x1B
										if (bite === 0x1B) {
											// Set iso-2022-jp decoder state to escape start and return
											// continue.
											iso2022jp_decoder_state = states.EscapeStart;
											return null;
										}

										// 0x21 to 0x5F
										if (inRange(bite, 0x21, 0x5F)) {
											// Unset the iso-2022-jp output flag and return a code point
											// whose value is 0xFF61 − 0x21 + byte.
											iso2022jp_output_flag = false;
											return 0xFF61 - 0x21 + bite;
										}

										// end-of-stream
										if (bite === end_of_stream) {
											// Return finished.
											return finished;
										}

										// Otherwise
										// Unset the iso-2022-jp output flag and return error.
										iso2022jp_output_flag = false;
										return decoderError(fatal);

									case states.LeadByte:
										// Lead byte
										// Based on byte:

										// 0x1B
										if (bite === 0x1B) {
											// Set iso-2022-jp decoder state to escape start and return
											// continue.
											iso2022jp_decoder_state = states.EscapeStart;
											return null;
										}

										// 0x21 to 0x7E
										if (inRange(bite, 0x21, 0x7E)) {
											// Unset the iso-2022-jp output flag, set iso-2022-jp lead
											// to byte, iso-2022-jp decoder state to trail byte, and
											// return continue.
											iso2022jp_output_flag = false;
											iso2022jp_lead = bite;
											iso2022jp_decoder_state = states.TrailByte;
											return null;
										}

										// end-of-stream
										if (bite === end_of_stream) {
											// Return finished.
											return finished;
										}

										// Otherwise
										// Unset the iso-2022-jp output flag and return error.
										iso2022jp_output_flag = false;
										return decoderError(fatal);

									case states.TrailByte:
										// Trail byte
										// Based on byte:

										// 0x1B
										if (bite === 0x1B) {
											// Set iso-2022-jp decoder state to escape start and return
											// continue.
											iso2022jp_decoder_state = states.EscapeStart;
											return decoderError(fatal);
										}

										// 0x21 to 0x7E
										if (inRange(bite, 0x21, 0x7E)) {
											// 1. Set the iso-2022-jp decoder state to lead byte.
											iso2022jp_decoder_state = states.LeadByte;

											// 2. Let pointer be (iso-2022-jp lead − 0x21) × 94 + byte − 0x21.
											var pointer = (iso2022jp_lead - 0x21) * 94 + bite - 0x21;

											// 3. Let code point be the index code point for pointer in
											// index jis0208.
											var code_point = indexCodePointFor(pointer, index('jis0208'));

											// 4. If code point is null, return error.
											if (code_point === null)
												return decoderError(fatal);

											// 5. Return a code point whose value is code point.
											return code_point;
										}

										// end-of-stream
										if (bite === end_of_stream) {
											// Set the iso-2022-jp decoder state to lead byte, prepend
											// byte to stream, and return error.
											iso2022jp_decoder_state = states.LeadByte;
											stream.prepend(bite);
											return decoderError(fatal);
										}

										// Otherwise
										// Set iso-2022-jp decoder state to lead byte and return
										// error.
										iso2022jp_decoder_state = states.LeadByte;
										return decoderError(fatal);

									case states.EscapeStart:
										// Escape start

										// 1. If byte is either 0x24 or 0x28, set iso-2022-jp lead to
										// byte, iso-2022-jp decoder state to escape, and return
										// continue.
										if (bite === 0x24 || bite === 0x28) {
											iso2022jp_lead = bite;
											iso2022jp_decoder_state = states.Escape;
											return null;
										}

										// 2. Prepend byte to stream.
										stream.prepend(bite);

										// 3. Unset the iso-2022-jp output flag, set iso-2022-jp
										// decoder state to iso-2022-jp decoder output state, and
										// return error.
										iso2022jp_output_flag = false;
										iso2022jp_decoder_state = iso2022jp_decoder_output_state;
										return decoderError(fatal);

									case states.Escape:
										// Escape

										// 1. Let lead be iso-2022-jp lead and set iso-2022-jp lead to
										// 0x00.
										var lead = iso2022jp_lead;
										iso2022jp_lead = 0x00;

										// 2. Let state be null.
										var state = null;

										// 3. If lead is 0x28 and byte is 0x42, set state to ASCII.
										if (lead === 0x28 && bite === 0x42)
											state = states.ASCII;

										// 4. If lead is 0x28 and byte is 0x4A, set state to Roman.
										if (lead === 0x28 && bite === 0x4A)
											state = states.Roman;

										// 5. If lead is 0x28 and byte is 0x49, set state to Katakana.
										if (lead === 0x28 && bite === 0x49)
											state = states.Katakana;

										// 6. If lead is 0x24 and byte is either 0x40 or 0x42, set
										// state to lead byte.
										if (lead === 0x24 && (bite === 0x40 || bite === 0x42))
											state = states.LeadByte;

										// 7. If state is non-null, run these substeps:
										if (state !== null) {
											// 1. Set iso-2022-jp decoder state and iso-2022-jp decoder
											// output state to states.
											iso2022jp_decoder_state = iso2022jp_decoder_state = state;

											// 2. Let output flag be the iso-2022-jp output flag.
											var output_flag = iso2022jp_output_flag;

											// 3. Set the iso-2022-jp output flag.
											iso2022jp_output_flag = true;

											// 4. Return continue, if output flag is unset, and error
											// otherwise.
											return !output_flag ? null : decoderError(fatal);
										}

										// 8. Prepend lead and byte to stream.
										stream.prepend([lead, bite]);

										// 9. Unset the iso-2022-jp output flag, set iso-2022-jp
										// decoder state to iso-2022-jp decoder output state and
										// return error.
										iso2022jp_output_flag = false;
										iso2022jp_decoder_state = iso2022jp_decoder_output_state;
										return decoderError(fatal);
								}
							};
						}

						// 13.2.2 iso-2022-jp encoder
						/**
						 * @constructor
						 * @implements {Encoder}
						 * @param {{fatal: boolean}} options
						 */
						function ISO2022JPEncoder(options) {
							options.fatal;
							// iso-2022-jp's encoder has an associated iso-2022-jp encoder
							// state which is one of ASCII, Roman, and jis0208 (initially
							// ASCII).
							/** @enum */
							var states = {
								ASCII: 0,
								Roman: 1,
								jis0208: 2
							};
							var /** @type {number} */ iso2022jp_state = states.ASCII;
							/**
							 * @param {Stream} stream Input stream.
							 * @param {number} code_point Next code point read from the stream.
							 * @return {(number|!Array.<number>)} Byte(s) to emit.
							 */
							this.handler = function (stream, code_point) {
								// 1. If code point is end-of-stream and iso-2022-jp encoder
								// state is not ASCII, prepend code point to stream, set
								// iso-2022-jp encoder state to ASCII, and return three bytes
								// 0x1B 0x28 0x42.
								if (code_point === end_of_stream &&
									iso2022jp_state !== states.ASCII) {
									stream.prepend(code_point);
									iso2022jp_state = states.ASCII;
									return [0x1B, 0x28, 0x42];
								}

								// 2. If code point is end-of-stream and iso-2022-jp encoder
								// state is ASCII, return finished.
								if (code_point === end_of_stream && iso2022jp_state === states.ASCII)
									return finished;

								// 3. If ISO-2022-JP encoder state is ASCII or Roman, and code
								// point is U+000E, U+000F, or U+001B, return error with U+FFFD.
								if ((iso2022jp_state === states.ASCII ||
									iso2022jp_state === states.Roman) &&
									(code_point === 0x000E || code_point === 0x000F ||
										code_point === 0x001B)) {
									return encoderError(0xFFFD);
								}

								// 4. If iso-2022-jp encoder state is ASCII and code point is an
								// ASCII code point, return a byte whose value is code point.
								if (iso2022jp_state === states.ASCII &&
									isASCIICodePoint(code_point))
									return code_point;

								// 5. If iso-2022-jp encoder state is Roman and code point is an
								// ASCII code point, excluding U+005C and U+007E, or is U+00A5
								// or U+203E, run these substeps:
								if (iso2022jp_state === states.Roman &&
									((isASCIICodePoint(code_point) &&
										code_point !== 0x005C && code_point !== 0x007E) ||
										(code_point == 0x00A5 || code_point == 0x203E))) {

									// 1. If code point is an ASCII code point, return a byte
									// whose value is code point.
									if (isASCIICodePoint(code_point))
										return code_point;

									// 2. If code point is U+00A5, return byte 0x5C.
									if (code_point === 0x00A5)
										return 0x5C;

									// 3. If code point is U+203E, return byte 0x7E.
									if (code_point === 0x203E)
										return 0x7E;
								}

								// 6. If code point is an ASCII code point, and iso-2022-jp
								// encoder state is not ASCII, prepend code point to stream, set
								// iso-2022-jp encoder state to ASCII, and return three bytes
								// 0x1B 0x28 0x42.
								if (isASCIICodePoint(code_point) &&
									iso2022jp_state !== states.ASCII) {
									stream.prepend(code_point);
									iso2022jp_state = states.ASCII;
									return [0x1B, 0x28, 0x42];
								}

								// 7. If code point is either U+00A5 or U+203E, and iso-2022-jp
								// encoder state is not Roman, prepend code point to stream, set
								// iso-2022-jp encoder state to Roman, and return three bytes
								// 0x1B 0x28 0x4A.
								if ((code_point === 0x00A5 || code_point === 0x203E) &&
									iso2022jp_state !== states.Roman) {
									stream.prepend(code_point);
									iso2022jp_state = states.Roman;
									return [0x1B, 0x28, 0x4A];
								}

								// 8. If code point is U+2212, set it to U+FF0D.
								if (code_point === 0x2212)
									code_point = 0xFF0D;

								// 9. Let pointer be the index pointer for code point in index
								// jis0208.
								var pointer = indexPointerFor(code_point, index('jis0208'));

								// 10. If pointer is null, return error with code point.
								if (pointer === null)
									return encoderError(code_point);

								// 11. If iso-2022-jp encoder state is not jis0208, prepend code
								// point to stream, set iso-2022-jp encoder state to jis0208,
								// and return three bytes 0x1B 0x24 0x42.
								if (iso2022jp_state !== states.jis0208) {
									stream.prepend(code_point);
									iso2022jp_state = states.jis0208;
									return [0x1B, 0x24, 0x42];
								}

								// 12. Let lead be floor(pointer / 94) + 0x21.
								var lead = floor(pointer / 94) + 0x21;

								// 13. Let trail be pointer % 94 + 0x21.
								var trail = pointer % 94 + 0x21;

								// 14. Return two bytes whose values are lead and trail.
								return [lead, trail];
							};
						}

						/** @param {{fatal: boolean}} options */
						encoders['ISO-2022-JP'] = function (options) {
							return new ISO2022JPEncoder(options);
						};
						/** @param {{fatal: boolean}} options */
						decoders['ISO-2022-JP'] = function (options) {
							return new ISO2022JPDecoder(options);
						};

						// 13.3 Shift_JIS

						// 13.3.1 Shift_JIS decoder
						/**
						 * @constructor
						 * @implements {Decoder}
						 * @param {{fatal: boolean}} options
						 */
						function ShiftJISDecoder(options) {
							var fatal = options.fatal;
							// Shift_JIS's decoder has an associated Shift_JIS lead (initially
							// 0x00).
							var /** @type {number} */ Shift_JIS_lead = 0x00;
							/**
							 * @param {Stream} stream The stream of bytes being decoded.
							 * @param {number} bite The next byte read from the stream.
							 * @return {?(number|!Array.<number>)} The next code point(s)
							 *     decoded, or null if not enough data exists in the input
							 *     stream to decode a complete code point.
							 */
							this.handler = function (stream, bite) {
								// 1. If byte is end-of-stream and Shift_JIS lead is not 0x00,
								// set Shift_JIS lead to 0x00 and return error.
								if (bite === end_of_stream && Shift_JIS_lead !== 0x00) {
									Shift_JIS_lead = 0x00;
									return decoderError(fatal);
								}

								// 2. If byte is end-of-stream and Shift_JIS lead is 0x00,
								// return finished.
								if (bite === end_of_stream && Shift_JIS_lead === 0x00)
									return finished;

								// 3. If Shift_JIS lead is not 0x00, let lead be Shift_JIS lead,
								// let pointer be null, set Shift_JIS lead to 0x00, and then run
								// these substeps:
								if (Shift_JIS_lead !== 0x00) {
									var lead = Shift_JIS_lead;
									var pointer = null;
									Shift_JIS_lead = 0x00;

									// 1. Let offset be 0x40, if byte is less than 0x7F, and 0x41
									// otherwise.
									var offset = (bite < 0x7F) ? 0x40 : 0x41;

									// 2. Let lead offset be 0x81, if lead is less than 0xA0, and
									// 0xC1 otherwise.
									var lead_offset = (lead < 0xA0) ? 0x81 : 0xC1;

									// 3. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80
									// to 0xFC, inclusive, set pointer to (lead − lead offset) ×
									// 188 + byte − offset.
									if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFC))
										pointer = (lead - lead_offset) * 188 + bite - offset;

									// 4. If pointer is in the range 8836 to 10715, inclusive,
									// return a code point whose value is 0xE000 − 8836 + pointer.
									if (inRange(pointer, 8836, 10715))
										return 0xE000 - 8836 + pointer;

									// 5. Let code point be null, if pointer is null, and the
									// index code point for pointer in index jis0208 otherwise.
									var code_point = (pointer === null) ? null :
										indexCodePointFor(pointer, index('jis0208'));

									// 6. If code point is null and byte is an ASCII byte, prepend
									// byte to stream.
									if (code_point === null && isASCIIByte(bite))
										stream.prepend(bite);

									// 7. If code point is null, return error.
									if (code_point === null)
										return decoderError(fatal);

									// 8. Return a code point whose value is code point.
									return code_point;
								}

								// 4. If byte is an ASCII byte or 0x80, return a code point
								// whose value is byte.
								if (isASCIIByte(bite) || bite === 0x80)
									return bite;

								// 5. If byte is in the range 0xA1 to 0xDF, inclusive, return a
								// code point whose value is 0xFF61 − 0xA1 + byte.
								if (inRange(bite, 0xA1, 0xDF))
									return 0xFF61 - 0xA1 + bite;

								// 6. If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0
								// to 0xFC, inclusive, set Shift_JIS lead to byte and return
								// continue.
								if (inRange(bite, 0x81, 0x9F) || inRange(bite, 0xE0, 0xFC)) {
									Shift_JIS_lead = bite;
									return null;
								}

								// 7. Return error.
								return decoderError(fatal);
							};
						}

						// 13.3.2 Shift_JIS encoder
						/**
						 * @constructor
						 * @implements {Encoder}
						 * @param {{fatal: boolean}} options
						 */
						function ShiftJISEncoder(options) {
							options.fatal;
							/**
							 * @param {Stream} stream Input stream.
							 * @param {number} code_point Next code point read from the stream.
							 * @return {(number|!Array.<number>)} Byte(s) to emit.
							 */
							this.handler = function (stream, code_point) {
								// 1. If code point is end-of-stream, return finished.
								if (code_point === end_of_stream)
									return finished;

								// 2. If code point is an ASCII code point or U+0080, return a
								// byte whose value is code point.
								if (isASCIICodePoint(code_point) || code_point === 0x0080)
									return code_point;

								// 3. If code point is U+00A5, return byte 0x5C.
								if (code_point === 0x00A5)
									return 0x5C;

								// 4. If code point is U+203E, return byte 0x7E.
								if (code_point === 0x203E)
									return 0x7E;

								// 5. If code point is in the range U+FF61 to U+FF9F, inclusive,
								// return a byte whose value is code point − 0xFF61 + 0xA1.
								if (inRange(code_point, 0xFF61, 0xFF9F))
									return code_point - 0xFF61 + 0xA1;

								// 6. If code point is U+2212, set it to U+FF0D.
								if (code_point === 0x2212)
									code_point = 0xFF0D;

								// 7. Let pointer be the index Shift_JIS pointer for code point.
								var pointer = indexShiftJISPointerFor(code_point);

								// 8. If pointer is null, return error with code point.
								if (pointer === null)
									return encoderError(code_point);

								// 9. Let lead be floor(pointer / 188).
								var lead = floor(pointer / 188);

								// 10. Let lead offset be 0x81, if lead is less than 0x1F, and
								// 0xC1 otherwise.
								var lead_offset = (lead < 0x1F) ? 0x81 : 0xC1;

								// 11. Let trail be pointer % 188.
								var trail = pointer % 188;

								// 12. Let offset be 0x40, if trail is less than 0x3F, and 0x41
								// otherwise.
								var offset = (trail < 0x3F) ? 0x40 : 0x41;

								// 13. Return two bytes whose values are lead + lead offset and
								// trail + offset.
								return [lead + lead_offset, trail + offset];
							};
						}

						/** @param {{fatal: boolean}} options */
						encoders['Shift_JIS'] = function (options) {
							return new ShiftJISEncoder(options);
						};
						/** @param {{fatal: boolean}} options */
						decoders['Shift_JIS'] = function (options) {
							return new ShiftJISDecoder(options);
						};

						//
						// 14. Legacy multi-byte Korean encodings
						//

						// 14.1 euc-kr

						// 14.1.1 euc-kr decoder
						/**
						 * @constructor
						 * @implements {Decoder}
						 * @param {{fatal: boolean}} options
						 */
						function EUCKRDecoder(options) {
							var fatal = options.fatal;

							// euc-kr's decoder has an associated euc-kr lead (initially 0x00).
							var /** @type {number} */ euckr_lead = 0x00;
							/**
							 * @param {Stream} stream The stream of bytes being decoded.
							 * @param {number} bite The next byte read from the stream.
							 * @return {?(number|!Array.<number>)} The next code point(s)
							 *     decoded, or null if not enough data exists in the input
							 *     stream to decode a complete code point.
							 */
							this.handler = function (stream, bite) {
								// 1. If byte is end-of-stream and euc-kr lead is not 0x00, set
								// euc-kr lead to 0x00 and return error.
								if (bite === end_of_stream && euckr_lead !== 0) {
									euckr_lead = 0x00;
									return decoderError(fatal);
								}

								// 2. If byte is end-of-stream and euc-kr lead is 0x00, return
								// finished.
								if (bite === end_of_stream && euckr_lead === 0)
									return finished;

								// 3. If euc-kr lead is not 0x00, let lead be euc-kr lead, let
								// pointer be null, set euc-kr lead to 0x00, and then run these
								// substeps:
								if (euckr_lead !== 0x00) {
									var lead = euckr_lead;
									var pointer = null;
									euckr_lead = 0x00;

									// 1. If byte is in the range 0x41 to 0xFE, inclusive, set
									// pointer to (lead − 0x81) × 190 + (byte − 0x41).
									if (inRange(bite, 0x41, 0xFE))
										pointer = (lead - 0x81) * 190 + (bite - 0x41);

									// 2. Let code point be null, if pointer is null, and the
									// index code point for pointer in index euc-kr otherwise.
									var code_point = (pointer === null)
										? null : indexCodePointFor(pointer, index('euc-kr'));

									// 3. If code point is null and byte is an ASCII byte, prepend
									// byte to stream.
									if (pointer === null && isASCIIByte(bite))
										stream.prepend(bite);

									// 4. If code point is null, return error.
									if (code_point === null)
										return decoderError(fatal);

									// 5. Return a code point whose value is code point.
									return code_point;
								}

								// 4. If byte is an ASCII byte, return a code point whose value
								// is byte.
								if (isASCIIByte(bite))
									return bite;

								// 5. If byte is in the range 0x81 to 0xFE, inclusive, set
								// euc-kr lead to byte and return continue.
								if (inRange(bite, 0x81, 0xFE)) {
									euckr_lead = bite;
									return null;
								}

								// 6. Return error.
								return decoderError(fatal);
							};
						}

						// 14.1.2 euc-kr encoder
						/**
						 * @constructor
						 * @implements {Encoder}
						 * @param {{fatal: boolean}} options
						 */
						function EUCKREncoder(options) {
							options.fatal;
							/**
							 * @param {Stream} stream Input stream.
							 * @param {number} code_point Next code point read from the stream.
							 * @return {(number|!Array.<number>)} Byte(s) to emit.
							 */
							this.handler = function (stream, code_point) {
								// 1. If code point is end-of-stream, return finished.
								if (code_point === end_of_stream)
									return finished;

								// 2. If code point is an ASCII code point, return a byte whose
								// value is code point.
								if (isASCIICodePoint(code_point))
									return code_point;

								// 3. Let pointer be the index pointer for code point in index
								// euc-kr.
								var pointer = indexPointerFor(code_point, index('euc-kr'));

								// 4. If pointer is null, return error with code point.
								if (pointer === null)
									return encoderError(code_point);

								// 5. Let lead be floor(pointer / 190) + 0x81.
								var lead = floor(pointer / 190) + 0x81;

								// 6. Let trail be pointer % 190 + 0x41.
								var trail = (pointer % 190) + 0x41;

								// 7. Return two bytes whose values are lead and trail.
								return [lead, trail];
							};
						}

						/** @param {{fatal: boolean}} options */
						encoders['EUC-KR'] = function (options) {
							return new EUCKREncoder(options);
						};
						/** @param {{fatal: boolean}} options */
						decoders['EUC-KR'] = function (options) {
							return new EUCKRDecoder(options);
						};


						//
						// 15. Legacy miscellaneous encodings
						//

						// 15.1 replacement

						// Not needed - API throws RangeError

						// 15.2 Common infrastructure for utf-16be and utf-16le

						/**
						 * @param {number} code_unit
						 * @param {boolean} utf16be
						 * @return {!Array.<number>} bytes
						 */
						function convertCodeUnitToBytes(code_unit, utf16be) {
							// 1. Let byte1 be code unit >> 8.
							var byte1 = code_unit >> 8;

							// 2. Let byte2 be code unit & 0x00FF.
							var byte2 = code_unit & 0x00FF;

							// 3. Then return the bytes in order:
							// utf-16be flag is set: byte1, then byte2.
							if (utf16be)
								return [byte1, byte2];
							// utf-16be flag is unset: byte2, then byte1.
							return [byte2, byte1];
						}

						// 15.2.1 shared utf-16 decoder
						/**
						 * @constructor
						 * @implements {Decoder}
						 * @param {boolean} utf16_be True if big-endian, false if little-endian.
						 * @param {{fatal: boolean}} options
						 */
						function UTF16Decoder(utf16_be, options) {
							var fatal = options.fatal;
							var /** @type {?number} */ utf16_lead_byte = null,
    	        /** @type {?number} */ utf16_lead_surrogate = null;
							/**
							 * @param {Stream} stream The stream of bytes being decoded.
							 * @param {number} bite The next byte read from the stream.
							 * @return {?(number|!Array.<number>)} The next code point(s)
							 *     decoded, or null if not enough data exists in the input
							 *     stream to decode a complete code point.
							 */
							this.handler = function (stream, bite) {
								// 1. If byte is end-of-stream and either utf-16 lead byte or
								// utf-16 lead surrogate is not null, set utf-16 lead byte and
								// utf-16 lead surrogate to null, and return error.
								if (bite === end_of_stream && (utf16_lead_byte !== null ||
									utf16_lead_surrogate !== null)) {
									return decoderError(fatal);
								}

								// 2. If byte is end-of-stream and utf-16 lead byte and utf-16
								// lead surrogate are null, return finished.
								if (bite === end_of_stream && utf16_lead_byte === null &&
									utf16_lead_surrogate === null) {
									return finished;
								}

								// 3. If utf-16 lead byte is null, set utf-16 lead byte to byte
								// and return continue.
								if (utf16_lead_byte === null) {
									utf16_lead_byte = bite;
									return null;
								}

								// 4. Let code unit be the result of:
								var code_unit;
								if (utf16_be) {
									// utf-16be decoder flag is set
									//   (utf-16 lead byte << 8) + byte.
									code_unit = (utf16_lead_byte << 8) + bite;
								} else {
									// utf-16be decoder flag is unset
									//   (byte << 8) + utf-16 lead byte.
									code_unit = (bite << 8) + utf16_lead_byte;
								}
								// Then set utf-16 lead byte to null.
								utf16_lead_byte = null;

								// 5. If utf-16 lead surrogate is not null, let lead surrogate
								// be utf-16 lead surrogate, set utf-16 lead surrogate to null,
								// and then run these substeps:
								if (utf16_lead_surrogate !== null) {
									var lead_surrogate = utf16_lead_surrogate;
									utf16_lead_surrogate = null;

									// 1. If code unit is in the range U+DC00 to U+DFFF,
									// inclusive, return a code point whose value is 0x10000 +
									// ((lead surrogate − 0xD800) << 10) + (code unit − 0xDC00).
									if (inRange(code_unit, 0xDC00, 0xDFFF)) {
										return 0x10000 + (lead_surrogate - 0xD800) * 0x400 +
											(code_unit - 0xDC00);
									}

									// 2. Prepend the sequence resulting of converting code unit
									// to bytes using utf-16be decoder flag to stream and return
									// error.
									stream.prepend(convertCodeUnitToBytes(code_unit, utf16_be));
									return decoderError(fatal);
								}

								// 6. If code unit is in the range U+D800 to U+DBFF, inclusive,
								// set utf-16 lead surrogate to code unit and return continue.
								if (inRange(code_unit, 0xD800, 0xDBFF)) {
									utf16_lead_surrogate = code_unit;
									return null;
								}

								// 7. If code unit is in the range U+DC00 to U+DFFF, inclusive,
								// return error.
								if (inRange(code_unit, 0xDC00, 0xDFFF))
									return decoderError(fatal);

								// 8. Return code point code unit.
								return code_unit;
							};
						}

						// 15.2.2 shared utf-16 encoder
						/**
						 * @constructor
						 * @implements {Encoder}
						 * @param {boolean} utf16_be True if big-endian, false if little-endian.
						 * @param {{fatal: boolean}} options
						 */
						function UTF16Encoder(utf16_be, options) {
							options.fatal;
							/**
							 * @param {Stream} stream Input stream.
							 * @param {number} code_point Next code point read from the stream.
							 * @return {(number|!Array.<number>)} Byte(s) to emit.
							 */
							this.handler = function (stream, code_point) {
								// 1. If code point is end-of-stream, return finished.
								if (code_point === end_of_stream)
									return finished;

								// 2. If code point is in the range U+0000 to U+FFFF, inclusive,
								// return the sequence resulting of converting code point to
								// bytes using utf-16be encoder flag.
								if (inRange(code_point, 0x0000, 0xFFFF))
									return convertCodeUnitToBytes(code_point, utf16_be);

								// 3. Let lead be ((code point − 0x10000) >> 10) + 0xD800,
								// converted to bytes using utf-16be encoder flag.
								var lead = convertCodeUnitToBytes(
									((code_point - 0x10000) >> 10) + 0xD800, utf16_be);

								// 4. Let trail be ((code point − 0x10000) & 0x3FF) + 0xDC00,
								// converted to bytes using utf-16be encoder flag.
								var trail = convertCodeUnitToBytes(
									((code_point - 0x10000) & 0x3FF) + 0xDC00, utf16_be);

								// 5. Return a byte sequence of lead followed by trail.
								return lead.concat(trail);
							};
						}

						// 15.3 utf-16be
						// 15.3.1 utf-16be decoder
						/** @param {{fatal: boolean}} options */
						encoders['UTF-16BE'] = function (options) {
							return new UTF16Encoder(true, options);
						};
						// 15.3.2 utf-16be encoder
						/** @param {{fatal: boolean}} options */
						decoders['UTF-16BE'] = function (options) {
							return new UTF16Decoder(true, options);
						};

						// 15.4 utf-16le
						// 15.4.1 utf-16le decoder
						/** @param {{fatal: boolean}} options */
						encoders['UTF-16LE'] = function (options) {
							return new UTF16Encoder(false, options);
						};
						// 15.4.2 utf-16le encoder
						/** @param {{fatal: boolean}} options */
						decoders['UTF-16LE'] = function (options) {
							return new UTF16Decoder(false, options);
						};

						// 15.5 x-user-defined

						// 15.5.1 x-user-defined decoder
						/**
						 * @constructor
						 * @implements {Decoder}
						 * @param {{fatal: boolean}} options
						 */
						function XUserDefinedDecoder(options) {
							options.fatal;
							/**
							 * @param {Stream} stream The stream of bytes being decoded.
							 * @param {number} bite The next byte read from the stream.
							 * @return {?(number|!Array.<number>)} The next code point(s)
							 *     decoded, or null if not enough data exists in the input
							 *     stream to decode a complete code point.
							 */
							this.handler = function (stream, bite) {
								// 1. If byte is end-of-stream, return finished.
								if (bite === end_of_stream)
									return finished;

								// 2. If byte is an ASCII byte, return a code point whose value
								// is byte.
								if (isASCIIByte(bite))
									return bite;

								// 3. Return a code point whose value is 0xF780 + byte − 0x80.
								return 0xF780 + bite - 0x80;
							};
						}

						// 15.5.2 x-user-defined encoder
						/**
						 * @constructor
						 * @implements {Encoder}
						 * @param {{fatal: boolean}} options
						 */
						function XUserDefinedEncoder(options) {
							options.fatal;
							/**
							 * @param {Stream} stream Input stream.
							 * @param {number} code_point Next code point read from the stream.
							 * @return {(number|!Array.<number>)} Byte(s) to emit.
							 */
							this.handler = function (stream, code_point) {
								// 1.If code point is end-of-stream, return finished.
								if (code_point === end_of_stream)
									return finished;

								// 2. If code point is an ASCII code point, return a byte whose
								// value is code point.
								if (isASCIICodePoint(code_point))
									return code_point;

								// 3. If code point is in the range U+F780 to U+F7FF, inclusive,
								// return a byte whose value is code point − 0xF780 + 0x80.
								if (inRange(code_point, 0xF780, 0xF7FF))
									return code_point - 0xF780 + 0x80;

								// 4. Return error with code point.
								return encoderError(code_point);
							};
						}

						/** @param {{fatal: boolean}} options */
						encoders['x-user-defined'] = function (options) {
							return new XUserDefinedEncoder(options);
						};
						/** @param {{fatal: boolean}} options */
						decoders['x-user-defined'] = function (options) {
							return new XUserDefinedDecoder(options);
						};

						if (!global['TextEncoder'])
							global['TextEncoder'] = TextEncoder;
						if (!global['TextDecoder'])
							global['TextDecoder'] = TextDecoder;

						if (typeof module !== "undefined" && module.exports) {
							module.exports = {
								TextEncoder: global['TextEncoder'],
								TextDecoder: global['TextDecoder'],
								EncodingIndexes: global["encoding-indexes"]
							};
						}

						// For strict environments where `this` inside the global scope
						// is `undefined`, take a pure object instead
					}(this || {}));

				}, { "./encoding-indexes.js": 7 }], 22: [function (require, module, exports) {
					(function (setImmediate, clearImmediate) {
						(function () {
							var nextTick = require('process/browser.js').nextTick;
							var apply = Function.prototype.apply;
							var slice = Array.prototype.slice;
							var immediateIds = {};
							var nextImmediateId = 0;

							// DOM APIs, for completeness

							exports.setTimeout = function () {
								return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
							};
							exports.setInterval = function () {
								return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
							};
							exports.clearTimeout =
								exports.clearInterval = function (timeout) { timeout.close(); };

							function Timeout(id, clearFn) {
								this._id = id;
								this._clearFn = clearFn;
							}
							Timeout.prototype.unref = Timeout.prototype.ref = function () { };
							Timeout.prototype.close = function () {
								this._clearFn.call(window, this._id);
							};

							// Does not start the time, just sets up the members needed.
							exports.enroll = function (item, msecs) {
								clearTimeout(item._idleTimeoutId);
								item._idleTimeout = msecs;
							};

							exports.unenroll = function (item) {
								clearTimeout(item._idleTimeoutId);
								item._idleTimeout = -1;
							};

							exports._unrefActive = exports.active = function (item) {
								clearTimeout(item._idleTimeoutId);

								var msecs = item._idleTimeout;
								if (msecs >= 0) {
									item._idleTimeoutId = setTimeout(function onTimeout() {
										if (item._onTimeout)
											item._onTimeout();
									}, msecs);
								}
							};

							// That's not how node.js implements it but the exposed api is the same.
							exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function (fn) {
								var id = nextImmediateId++;
								var args = arguments.length < 2 ? false : slice.call(arguments, 1);

								immediateIds[id] = true;

								nextTick(function onNextTick() {
									if (immediateIds[id]) {
										// fn.call() is faster so we optimize for the common use-case
										// @see http://jsperf.com/call-apply-segu
										if (args) {
											fn.apply(null, args);
										} else {
											fn.call(null);
										}
										// Prevent ids from leaking
										exports.clearImmediate(id);
									}
								});

								return id;
							};

							exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function (id) {
								delete immediateIds[id];
							};
						}).call(this);
					}).call(this, require("timers").setImmediate, require("timers").clearImmediate);
				}, { "process/browser.js": 16, "timers": 22 }], 23: [function (require, module, exports) {
					(function (global) {
						(function () {
							let proj4 = require('proj4');
							if (proj4.default) {
								proj4 = proj4.default;
							}
							const unzip = require('./unzip');
							const binaryAjax = require('./binaryajax');
							const parseShp = require('./parseShp');
							const parseDbf = require('parsedbf');
							const Promise = require('lie');
							const Cache = require('lru-cache');
							const Buffer = require('buffer').Buffer;
							const URL = global.URL;

							const cache = new Cache({
								max: 20
							});

							function toBuffer(b) {
								if (!b) {
									throw new Error('forgot to pass buffer');
								}
								if (Buffer.isBuffer(b)) {
									return b;
								}
								if (isArrayBuffer(b)) {
									return Buffer.from(b);
								}
								if (isArrayBuffer(b.buffer)) {
									if (b.BYTES_PER_ELEMENT === 1) {
										return Buffer.from(b);
									}
									return Buffer.from(b.buffer);
								}
							}

							function isArrayBuffer(subject) {
								return subject instanceof global.ArrayBuffer || Object.prototype.toString.call(subject) === '[object ArrayBuffer]';
							}

							function shp(base, whiteList) {
								if (typeof base === 'string' && cache.has(base)) {
									return Promise.resolve(cache.get(base));
								}
								return shp.getShapefile(base, whiteList).then(function (resp) {
									if (typeof base === 'string') {
										cache.set(base, resp);
									}
									return resp;
								});
							}
							shp.combine = function ([shp, dbf]) {
								const out = {};
								out.type = 'FeatureCollection';
								out.features = [];
								let i = 0;
								const len = shp.length;
								if (!dbf) {
									dbf = [];
								}
								while (i < len) {
									out.features.push({
										type: 'Feature',
										geometry: shp[i],
										properties: dbf[i] || {}
									});
									i++;
								}
								return out;
							};
							shp.parseZip = async function (buffer, whiteList) {
								let key;
								buffer = toBuffer(buffer);
								const zip = await unzip(buffer);
								const names = [];
								whiteList = whiteList || [];
								for (key in zip) {
									if (key.indexOf('__MACOSX') !== -1) {
										continue;
									}
									if (key.slice(-3).toLowerCase() === 'shp') {
										names.push(key.slice(0, -4));
										zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = zip[key];
									} else if (key.slice(-3).toLowerCase() === 'prj') {
										zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = proj4(zip[key]);
									} else if (key.slice(-4).toLowerCase() === 'json' || whiteList.indexOf(key.split('.').pop()) > -1) {
										names.push(key.slice(0, -3) + key.slice(-3).toLowerCase());
									} else if (key.slice(-3).toLowerCase() === 'dbf' || key.slice(-3).toLowerCase() === 'cpg') {
										zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = zip[key];
									}
								}
								if (!names.length) {
									throw new Error('no layers founds');
								}
								const geojson = names.map(function (name) {
									let parsed, dbf;
									const lastDotIdx = name.lastIndexOf('.');
									if (lastDotIdx > -1 && name.slice(lastDotIdx).indexOf('json') > -1) {
										parsed = JSON.parse(zip[name]);
										parsed.fileName = name.slice(0, lastDotIdx);
									} else if (whiteList.indexOf(name.slice(lastDotIdx + 1)) > -1) {
										parsed = zip[name];
										parsed.fileName = name;
									} else {
										if (zip[name + '.dbf']) {
											dbf = parseDbf(zip[name + '.dbf'], zip[name + '.cpg']);
										}
										parsed = shp.combine([parseShp(zip[name + '.shp'], zip[name + '.prj']), dbf]);
										parsed.fileName = name;
									}
									return parsed;
								});
								if (geojson.length === 1) {
									return geojson[0];
								} else {
									return geojson;
								}
							};

							async function getZip(base, whiteList) {
								const a = await binaryAjax(base);
								return shp.parseZip(a, whiteList);
							}
							const handleShp = async (base) => {
								const args = await Promise.all([
									binaryAjax(base, 'shp'),
									binaryAjax(base, 'prj')
								]);
								let prj = false;
								try {
									if (args[1]) {
										prj = proj4(args[1]);
									}
								} catch (e) {
									prj = false;
								}
								return parseShp(args[0], prj);
							};
							const handleDbf = async (base) => {
								const [dbf, cpg] = await Promise.all([
									binaryAjax(base, 'dbf'),
									binaryAjax(base, 'cpg')
								]);
								if (!dbf) {
									return;
								}
								return parseDbf(dbf, cpg);
							};
							const checkSuffix = (base, suffix) => {
								const url = new URL(base);
								return url.pathname.slice(-4).toLowerCase() === suffix;
							};
							shp.getShapefile = async function (base, whiteList) {
								if (typeof base !== 'string') {
									return shp.parseZip(base);
								}
								if (checkSuffix(base, '.zip')) {
									return getZip(base, whiteList);
								}
								const results = await Promise.all([
									handleShp(base),
									handleDbf(base)
								]);
								return shp.combine(results);
							};
							shp.parseShp = function (shp, prj) {
								shp = toBuffer(shp);
								if (Buffer.isBuffer(prj)) {
									prj = prj.toString();
								}
								if (typeof prj === 'string') {
									try {
										prj = proj4(prj);
									} catch (e) {
										prj = false;
									}
								}
								return parseShp(shp, prj);
							};
							shp.parseDbf = function (dbf, cpg) {
								dbf = toBuffer(dbf);
								return parseDbf(dbf, cpg);
							};
							module.exports = shp;

						}).call(this);
					}).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
				}, { "./binaryajax": 2, "./parseShp": 4, "./unzip": 5, "buffer": 8, "lie": 12, "lru-cache": 13, "parsedbf": 15, "proj4": 17 }]
			}, {}, [23])(23)
		});
	}(shp$1));

	var shp = shpExports;

	/* global SceneGIS */
	var terrainN = [];//存放平面坐标系的地形位置

	function TerrainClipPlan(viewer, options) {
		this.viewer = viewer;
		this.options = options || {};
		this._positions = options.positions;
		this._height = this.options.height || 0;
		this.bottomImg = options.bottomImg;
		this.wallImg = options.wallImg;
		this.splitNum = SceneGIS.defaultValue(options.splitNum, 50);
		this._positions && this._positions.length > 0 && this.updateData(this._positions);
	}

	Object.defineProperties(TerrainClipPlan.prototype, {
		show: {
			get: function () {
				return this._show
			},
			set: function (e) {
				this._show = e, this.viewer.scene.globe.clippingPlanes && (this.viewer.scene.globe.clippingPlanes.enabled = e), this._switchExcavate(e);
			}
		},
		height: {
			get: function () {
				return this._height
			},
			set: function (e) {
				this._height = e, this._updateExcavateDepth(e);
			}
		}
	});

	TerrainClipPlan.prototype.updateData = function (e, screenPoints, isUpdate) {
		this.clear();
		var t = [],
			i = e.length;
		new SceneGIS.Cartesian3;
		if (i == 0) {
			return;
		}
		///var  n = SceneGIS.Cartesian3.subtract(e[0], e[1], a);
		//  n = n.x > 0, 
		this.excavateMinHeight = 9999;
		//求ab bc向量的点积计算顺时针、逆时针
		var n = (e[0].x * e[1].y + e[1].x * e[2].y + e[2].x * e[0].y - e[0].y * e[1].x - e[1].y * e[2].x - e[2].y * e[0].x) < 0;//为正时，p1-p2-p3  路径的走向为逆时针，

		const planeView = this.viewer.scene.planeView;
		for (var r = 0; r < i; ++r) {
			var s = (r + 1) % i,
				l = SceneGIS.Cartesian3.midpoint(e[r], e[s], new SceneGIS.Cartesian3),//r和r+1取中点
				u = SceneGIS.Cartographic.fromCartesian(e[r]),
				c = planeView === true ? e[r].z : (this.viewer.scene.globe.getHeight(u) || u.height);//拾取r高程c
			c < this.excavateMinHeight && (this.excavateMinHeight = c);
			var d, h = planeView === true ? new SceneGIS.Cartesian3(0, 0, 1) : SceneGIS.Cartesian3.normalize(l, new SceneGIS.Cartesian3);//求中点的单位向量
			//d是否与n相等，若相等则d=起点与中点的方向向量，若不相等则为终点与中点的方向向量
			//确定顺时针逆时针
			d = n ? SceneGIS.Cartesian3.subtract(e[r], l, new SceneGIS.Cartesian3) : SceneGIS.Cartesian3.subtract(e[s], l, new SceneGIS.Cartesian3),
				d = SceneGIS.Cartesian3.normalize(d, d);//将方向向量标准化
			var f = SceneGIS.Cartesian3.cross(d, h, new SceneGIS.Cartesian3);//计算两个坐标点的交叉乘积
			f = SceneGIS.Cartesian3.normalize(f, f);
			const negate = SceneGIS.Cartesian3.negate(f, new SceneGIS.Cartesian3());
			var p = new SceneGIS.Plane(f, 0),
				m = planeView === true ? SceneGIS.Cartesian3.dot(negate, l) : SceneGIS.Plane.getPointDistance(p, l);



			t.push(new SceneGIS.ClippingPlane(f, m));
		}

		this.viewer.scene.globe.clippingPlanes = new SceneGIS.ClippingPlaneCollection({
			planes: t,
			edgeWidth: 0,
			edgeColor: SceneGIS.Color.WHITE,
			enabled: !0
		});
		this._prepareWell(e, screenPoints);
		this._createWell(this.wellData, isUpdate);
	};

	TerrainClipPlan.prototype.clear = function () {
		if (this.viewer.scene.globe.clippingPlanes) {
			this.viewer.scene.globe.clippingPlanes && (
				this.viewer.scene.globe.clippingPlanes.enabled = !1,
				this.viewer.scene.globe.clippingPlanes.removeAll(),
				this.viewer.scene.globe.clippingPlanes.isDestroyed()
			),
				this.viewer.scene.globe.clippingPlanes = void 0,
				this.bottomSurface && this.viewer.scene.primitives.remove(this.bottomSurface),
				this.wellWall && this.viewer.scene.primitives.remove(this.wellWall),
				delete this.bottomSurface,
				delete this.wellWall,
				this.viewer.scene.render();
		}
	};

	TerrainClipPlan.prototype._prepareWell = function (e, screenPoints) {
		const planeView = this.viewer.scene.planeView;
		var ss = [];
		var t = this.splitNum,
			i = e.length;
		if (0 != i) {
			for (var a = this.excavateMinHeight - this.height, n = [], r = [], s = [], l = 0; l < i; l++) {
				var u = l == i - 1 ? 0 : l + 1,
					c = planeView === true ? new SceneGIS.Cartographic(e[l].x, e[l].y, e[l].z) : SceneGIS.Cartographic.fromCartesian(e[l]),
					d = planeView === true ? new SceneGIS.Cartographic(e[u].x, e[u].y, e[u].z) : SceneGIS.Cartographic.fromCartesian(e[u]),
					h = [c.longitude, c.latitude],
					f = [d.longitude, d.latitude],
					s1 = [screenPoints[l][0], screenPoints[l][1]],
					s2 = [screenPoints[u][0], screenPoints[u][1]];

				0 == l && (
					s.push(new SceneGIS.Cartographic(h[0], h[1])),
					ss.push({ x: s1[0], y: s1[1] }),
					r.push(planeView === true ? new SceneGIS.Cartesian3(h[0], h[1], a) : SceneGIS.Cartesian3.fromRadians(h[0], h[1], a)),
					n.push(planeView === true ? new SceneGIS.Cartesian3(h[0], h[1], 0) : SceneGIS.Cartesian3.fromRadians(h[0], h[1], 0)));

				for (var p = 1; p <= t; p++) {
					var m = SceneGIS.Math.lerp(h[0], f[0], p / t),
						g = SceneGIS.Math.lerp(h[1], f[1], p / t),
						slerp0 = SceneGIS.Math.lerp(s1[0], s2[0], p / t),
						slerp1 = SceneGIS.Math.lerp(s1[1], s2[1], p / t);
					l == i - 1 && p == t || (
						s.push(new SceneGIS.Cartographic(m, g)),
						ss.push({ x: slerp0, y: slerp1 }),
						r.push(planeView === true ? new SceneGIS.Cartesian3(m, g, a) : SceneGIS.Cartesian3.fromRadians(m, g, a)),
						n.push(planeView === true ? new SceneGIS.Cartesian3(m, g, 0) : SceneGIS.Cartesian3.fromRadians(m, g, 0)));
				}
			}
			this.wellData = {
				lerp_pos: s,
				screenlerp: ss,
				bottom_pos: r,
				no_height_top: n
			};
		}
	};

	TerrainClipPlan.prototype._createWell = function (e) {
		var t = this.splitNum,
			i = e.length;
		if (0 != i) {
			for (var a = this.excavateMinHeight - this.height, n = [], r = [], s = [], l = 0; l < i; l++) {
				var u = l == i - 1 ? 0 : l + 1,
					c = SceneGIS.Cartographic.fromCartesian(e[l]),
					d = SceneGIS.Cartographic.fromCartesian(e[u]),
					h = [c.longitude, c.latitude],
					f = [d.longitude, d.latitude];

				0 == l && (
					s.push(new SceneGIS.Cartographic(h[0], h[1])),
					r.push(SceneGIS.Cartesian3.fromRadians(h[0], h[1], a)),
					n.push(SceneGIS.Cartesian3.fromRadians(h[0], h[1], 0)));

				for (var p = 1; p <= t; p++) {
					var m = SceneGIS.Math.lerp(h[0], f[0], p / t),
						g = SceneGIS.Math.lerp(h[1], f[1], p / t);
					l == i - 1 && p == t || (
						s.push(new SceneGIS.Cartographic(m, g)),
						r.push(SceneGIS.Cartesian3.fromRadians(m, g, a)),
						n.push(SceneGIS.Cartesian3.fromRadians(m, g, 0)));
				}
			}
			this.wellData = {
				lerp_pos: s,
				bottom_pos: r,
				no_height_top: n
			};
		}
	};

	TerrainClipPlan.prototype._createWell = function (e, isUpdate) {
		const planeView = this.viewer.scene.planeView;
		if (Boolean(this.viewer.terrainProvider._layers)) {
			var t = this;
			this._createBottomSurface(e.bottom_pos);
			if (planeView === true) {
				if (!isUpdate) {
					terrainN = [];
					for (let i in e.screenlerp) {
						var ray = this.viewer.camera.getPickRay(e.screenlerp[i]);
						var cartesian = this.viewer.scene.globe.pick(ray, this.viewer.scene);
						let temp = new SceneGIS.Cartesian3();
						temp.x = e.lerp_pos[i].longitude;
						temp.y = e.lerp_pos[i].latitude;
						temp.z = cartesian.z;
						terrainN.push(temp);
					}
				}
				t._createWellWall(e.bottom_pos, terrainN);
			}
			else {
				const promise = SceneGIS.sampleTerrainMostDetailed(this.viewer.terrainProvider, e.lerp_pos);
				if (promise) {
					Promise.resolve(promise).then(function (updatedPositions) {
						for (var a = updatedPositions.length, n = [], r = 0; r < a; r++) {
							var s = planeView === true ? new SceneGIS.Cartesian3(updatedPositions[r].longitude, updatedPositions[r].latitude, updatedPositions[r].height) :
								SceneGIS.Cartesian3.fromRadians(updatedPositions[r].longitude, updatedPositions[r].latitude, updatedPositions[r].height);
							n.push(s);
						}
						t._createWellWall(e.bottom_pos, n);
					});
				}
			}
		} else {
			this._createBottomSurface(e.bottom_pos);
			this._createWellWall(e.bottom_pos, e.no_height_top);
		}
	};

	TerrainClipPlan.prototype._getMinHeight = function (e) {
		let minHeight = 5000000;
		let minPoint = null;
		for (let i = 0; i < e.length; i++) {
			let height = e[i]['z'];
			if (height < minHeight) {
				minHeight = height;
				minPoint = this._ellipsoidToLonLat(e[i]);
			}
		}
		return minPoint.altitude;
	};

	TerrainClipPlan.prototype._ellipsoidToLonLat = function (c) {
		let ellipsoid = this.viewer.scene.globe.ellipsoid;
		let cartesian3 = new SceneGIS.Cartesian3(c.x, c.y, c.z);
		const planeView = this.viewer.scene.planeView;
		if (planeView === true) {
			return {
				longitude: cartesian3.x,
				latitude: cartesian3.y,
				altitude: cartesian3.z
			}
		}
		let cartographic = ellipsoid.cartesianToCartographic(cartesian3);
		let lat = SceneGIS.Math.toDegrees(cartographic.latitude);
		let lng = SceneGIS.Math.toDegrees(cartographic.longitude);
		let alt = cartographic.height;
		return {
			longitude: lng,
			latitude: lat,
			altitude: alt
		}
	};

	TerrainClipPlan.prototype._createWellWall = function (e, t) {
		const planeView = this.viewer.scene.planeView;
		e.push(e[0]);
		t.push(t[0]);
		//自动补齐闭合墙壁
		let minHeight = this._getMinHeight(e);
		let maxHeights = [];
		let minHeights = [];

		for (let i = 0; i < t.length; i++) {
			maxHeights.push(this._ellipsoidToLonLat(t[i]).altitude);
			minHeights.push(minHeight);
		}
		let wall = new SceneGIS.WallGeometry({
			positions: t,
			maximumHeights: maxHeights,
			minimumHeights: minHeights,
			planeView: planeView
		});
		let geometry = SceneGIS.WallGeometry.createGeometry(wall);
		var a = new SceneGIS.Material({
			fabric: {
				type: "Image",
				uniforms: {
					image: this.wallImg
				}
			}
		}),
			n = new SceneGIS.MaterialAppearance({
				translucent: !1,
				flat: !0,
				material: a
			});
		this.wellWall = new SceneGIS.Primitive({
			geometryInstances: new SceneGIS.GeometryInstance({
				geometry: geometry,
				attributes: {
					color: SceneGIS.ColorGeometryInstanceAttribute.fromColor(SceneGIS.Color.GREY)
				},
				id: "PitWall"
			}),
			appearance: n,
			asynchronous: !1
		}), this.viewer.scene.primitives.add(this.wellWall);
	};

	TerrainClipPlan.prototype._createBottomSurface = function (e) {
		const planeView = this.viewer.scene.planeView;
		if (e.length) {
			let minHeight = this._getMinHeight(e);
			let positions = [];
			for (let i = 0; i < e.length; i++) {
				let p = this._ellipsoidToLonLat(e[i]);
				positions.push(p.longitude);
				positions.push(p.latitude);
				positions.push(minHeight);
			}

			let polygon = new SceneGIS.PolygonGeometry({
				polygonHierarchy: new SceneGIS.PolygonHierarchy(
					planeView === true ? SceneGIS.Cartesian3.unpackArray(positions) : SceneGIS.Cartesian3.fromDegreesArrayHeights(positions)
				),
				perPositionHeight: true
			});
			let geometry = SceneGIS.PolygonGeometry.createGeometry(polygon);


			var i = new SceneGIS.Material({
				fabric: {
					type: "Image",
					uniforms: {
						image: this.bottomImg
					}
				}
			}),
				a = new SceneGIS.MaterialAppearance({
					translucent: !1,
					flat: !0,
					material: i
				});
			this.bottomSurface = new SceneGIS.Primitive({
				geometryInstances: new SceneGIS.GeometryInstance({
					geometry: geometry
				}),
				appearance: a,
				asynchronous: !1
			}), this.viewer.scene.primitives.add(this.bottomSurface);
		}
	};

	TerrainClipPlan.prototype._switchExcavate = function (e) {
		e ? (this.viewer.scene.globe.material = SceneGIS.Material.fromType("WaJue"), this.wellWall.show = !0, this.bottomSurface.show = !0) : (this.viewer.scene.globe.material = null, this.wellWall.show = !1, this.bottomSurface.show = !1);
	};

	TerrainClipPlan.prototype._updateExcavateDepth = function (e) {
		this.bottomSurface && this.viewer.scene.primitives.remove(this.bottomSurface), this.wellWall && this.viewer.scene.primitives.remove(this.wellWall);
		for (var t = this.wellData.lerp_pos, i = [], a = t.length, n = 0; n < a; n++) i.push(SceneGIS.Cartesian3.fromRadians(t[n].longitude, t[n].latitude, this.excavateMinHeight - e));
		this.wellData.bottom_pos = i, this._createWell(this.wellData), this.viewer.scene.primitives.add(this.bottomSurface), this.viewer.scene.primitives.add(this.wellWall);
	};

	/**
	 * 3dtile动态色带
	 * @class TilesetRibbonEX
	 * @param {object} options
	 * @param {number} [options.height=50] 间隔高度
	 * @param {SceneGIS.Color} [options.color=SceneGIS.Color.CYAN] 3dtile底色
	 * @param {SceneGIS.Color} [options.ribbonColor=SceneGIS.Color.GREEN] 色带颜色
	 * @param {number} [options.speed=0.5] 速度倍率
	 */
	function TilesetRibbonEX(options) {
		CheckEX.typeOf("options.height", options.height, "number");
		CheckEX.instanceOf("options.color", options.color, SceneGIS.Color);
		CheckEX.instanceOf("options.ribbonColor", options.ribbonColor, SceneGIS.Color);
		CheckEX.typeOf("options.speed", options.speed, "number");

		this._height = SceneGIS.defaultValue(options.height, 50);
		this._color = SceneGIS.defaultValue(options.color, SceneGIS.Color.CYAN);
		this._ribbonColor = SceneGIS.defaultValue(options.ribbonColor, SceneGIS.Color.GREEN);
		this._speed = SceneGIS.defaultValue(options.speed, 0.5);
	}

	TilesetRibbonEX.cmdName = "_TilesetRibbonEX";

	/**
	 * 添加动态色带的CustomShader
	 * @param {SceneGIS.SceneGIS3DTileset} tileset 
	 */
	TilesetRibbonEX.prototype.bindCustomShader = function (tileset) {
		let customShader = new SceneGIS.CustomShader({
			uniforms: {
				u_height: {
					type: SceneGIS.UniformType.FLOAT,
					value: this._height
				},
				u_color: {
					type: SceneGIS.UniformType.VEC3,
					value: this._color
				},
				u_ribbonColor: {
					type: SceneGIS.UniformType.VEC3,
					value: this._ribbonColor
				},
				u_speed: {
					type: SceneGIS.UniformType.FLOAT,
					value: this._speed
				}
			},
			varyings: {
				v_modelHeight: SceneGIS.VaryingType.FLOAT,
				v_modelNormal: SceneGIS.VaryingType.VEC3
			},
			vertexShaderText: `
            void vertexMain(VertexInput vsInput, inout czm_modelVertexOutput vsOutput, inout ProcessedAttributes attributes) {
                v_modelHeight=vsInput.attributes.positionMC.z;
                v_modelNormal=vsInput.attributes.normalMC;
            }
        `,
			fragmentShaderText: `
            void fragmentMain(FragmentInput fsInput, inout czm_modelMaterial material) {
                float weight=abs(v_modelHeight/u_height);
                weight=fract(weight);

                if(1.0-dot(v_modelNormal,vec3(.0,.0,1.0))<0.01){
                    material.diffuse=u_color;
                    return;
                }
            
                float line = fract(czm_frameNumber * u_speed / 360.0);
                line=abs(line-0.5)*2.0;
                if(abs(weight-line)<0.01){
                    material.diffuse=u_ribbonColor;
                }else{
                    material.diffuse=u_color;
                }
            }
        `
		});

		tileset.customShader = customShader;
	};

	/**
	 * 3dtile扫描线
	 * @alias TilesetScanningEX
	 * @constructor
	 * @param {object} options 
	 * @param {SceneGIS.Color} [options.color=SceneGIS.Color.CYAN] 扫描线颜色
	 * @param {number} [options.radius=500] 扫描半径，单位：米
	 */
	function TilesetScanningEX(options) {
		CheckEX.instanceOf("options.color", options.color, SceneGIS.Color);
		CheckEX.typeOf("options.radius", options.radius, "number");

		this._color = SceneGIS.defaultValue(options.color, SceneGIS.Color.CYAN);
		this._centers;
		this._radius = SceneGIS.defaultValue(options.radius, 500);
	}

	TilesetScanningEX.cmdName = "_TilesetScanningEX";

	/**
	 * 添加扫描线的CustomShader
	 * @param {SceneGIS3DTileset} tileset 
	 * @param {SceneGIS.Cartesian3[]} centers 扫描圆的中心点数组，默认为3dtile中心
	 */
	TilesetScanningEX.prototype.bindCustomShader = function (tileset, centers) {
		if (!centers) {
			let center = tileset.root.boundingSphere.center;
			this._centers = [center];
		} else {
			this._centers = centers;
		}

		let customShader = new SceneGIS.CustomShader({
			uniforms: {
				u_color: {
					type: SceneGIS.UniformType.VEC3,
					value: this._color
				},
				u_center: {
					type: SceneGIS.UniformType.VEC3,
					arrayNum: this._centers.length,
					value: this._centers
				},
				u_circleLength: {
					type: SceneGIS.UniformType.INT,
					value: this._centers.length,
				},
				u_radius: {
					type: SceneGIS.UniformType.FLOAT,
					value: this._radius,
				}
			},
			varyings: {
				v_modelPosition: SceneGIS.VaryingType.VEC3,
				v_modelNormal: SceneGIS.VaryingType.VEC3
			},
			vertexShaderText: `
            void vertexMain(VertexInput vsInput, inout czm_modelVertexOutput vsOutput, inout ProcessedAttributes attributes) {
                v_modelPosition=vsInput.attributes.positionMC;
                v_modelNormal=vsInput.attributes.normalMC;
            }
        `,
			fragmentShaderText: `
        float isPointOnLine(float position, float differentialLength) {
            float fractionPartOfPosition = position - floor(position + 0.5); // fract part around unit [-0.5; 0.5]
            fractionPartOfPosition /= differentialLength; // adapt to the screen space size it takes
            fractionPartOfPosition = clamp(fractionPartOfPosition, -1., 1.);
            
            float result = 0.5 + 0.5 * cos(fractionPartOfPosition * 3.14159); // Convert to 0-1 for antialiasing.
            return result;    
        }

        float getVisibility(float position) {
            // Major grid line every Frequency defined in material.
            float majorGridFrequency = 5.;
            if (floor(position + 0.5) == floor(position / majorGridFrequency + 0.5) * majorGridFrequency)
            {
                return 1.0;
            }  
        
            return 0.3;
        }

        float getAnisotropicAttenuation(float differentialLength) {
            const float maxNumberOfLines = 10.0;
            return clamp(1.0 / (differentialLength + 1.0) - 1.0 / maxNumberOfLines, 0.0, 1.0);
        }

        float normalImpactOnAxis(float x) {
            float normalImpact = clamp(1.0 - 3.0 * abs(x * x * x), 0.0, 1.0);
            return normalImpact;
        }

        float contributionOnAxis(float position) {
            float differentialLength = length(vec2(dFdx(position), dFdy(position)));
            differentialLength *= 1.41421356;  // Multiply by SQRT2 for diagonal length
            
            // Is the point on the line.
            float result = isPointOnLine(position, differentialLength);
        
            //控制一部分线的粗细的
            // Add dynamic visibility.
            // float visibility = getVisibility(position);
            // result *= visibility;
            
            // Anisotropic filtering.
            float anisotropicAttenuation = getAnisotropicAttenuation(differentialLength);
            result *= anisotropicAttenuation;
            
            return result;
        }

        void fragmentMain(FragmentInput fsInput, inout czm_modelMaterial material) {
            float gridRatio = 5.0;//密度
            vec3 gridPos = v_modelPosition / gridRatio;
            float x = contributionOnAxis(gridPos.x);
            float y = contributionOnAxis(gridPos.y);
            float z = contributionOnAxis(gridPos.z);
            vec3 normal2 = czm_inverseNormal * v_modelNormal;
            x *= normalImpactOnAxis(normal2.x);
            y *= normalImpactOnAxis(normal2.y);
            z *= normalImpactOnAxis(normal2.z);
            float grid = clamp(x + y + z, 0., 1.);
            vec3 lineColor =u_color; 
            vec3 gridColor = mix(material.diffuse, lineColor, grid);

            float cantrol = fract(czm_frameNumber / 360.0);

            for(int i=0;i<u_circleLength;i++){
                vec4 center=vec4(u_center[i],1.0);
                center=czm_view*center;
                if(distance(fsInput.attributes.positionEC,center.xyz)<u_radius*cantrol){
                    material.diffuse=gridColor;
                }
            }
        }
        `
		});

		tileset.customShader = customShader;
	};

	/**
	 * 3dtile垂直渐变
	 * @class TilesetVerticalGradientEX
	 * @param {objecg} options
	 * @param {number} [options.height=10] 垂直渐变的高度
	 * @param {SceneGIS.Color} [options.color=SceneGIS.Color.CYAN] 垂直渐变的颜色，不支持透明度
	 */
	function TilesetVerticalGradientEX(options) {
		CheckEX.typeOf("options.height", options.height, "number");
		CheckEX.instanceOf("options.color", options.color, SceneGIS.Color);

		this._height = SceneGIS.defaultValue(options.height, 10);
		this._color = SceneGIS.defaultValue(options.color, SceneGIS.Color.CYAN);
	}

	TilesetVerticalGradientEX.cmdName = "_TilesetVerticalGradientEX";

	/**
	 * 添加垂直渐变的CustomShader
	 * @param {SceneGIS.SceneGIS3DTileset} tileset 
	 */
	TilesetVerticalGradientEX.prototype.bindCustomShader = function (tileset) {
		let customShader = new SceneGIS.CustomShader({
			uniforms: {
				u_height: {
					type: SceneGIS.UniformType.FLOAT,
					value: this._height
				},
				u_color: {
					type: SceneGIS.UniformType.VEC3,
					value: this._color
				}
			},
			varyings: {
				v_modelHeight: SceneGIS.VaryingType.FLOAT
			},
			vertexShaderText: `
            void vertexMain(VertexInput vsInput, inout czm_modelVertexOutput vsOutput, inout ProcessedAttributes attributes) {
                v_modelHeight=vsInput.attributes.positionMC.z;
            }
        `,
			fragmentShaderText: `
            void fragmentMain(FragmentInput fsInput, inout czm_modelMaterial material) {
                material.diffuse = u_color*v_modelHeight/u_height;
            }
        `
		});

		tileset.customShader = customShader;
	};

	function PolylineTrail(option) {
		//添加到材质缓存中
		this.PolylineTrailLinkType = option.name; //'PolylineTrailLink';
		this.PolylineTrailLinkImage = option.img;

		var colorstr =
			" material.diffuse = color.rgb ;\n\
fragColor.rgb =colorImage.rgb+color.rgb;\n\
material.alpha =colorImage.a* color.a;\n";
		if (option.useimg) {
			colorstr =
				" material.diffuse =  colorImage.rgb;\n\
   fragColor.rgb = colorImage.rgb ;\n\
   material.alpha =colorImage.a;\n ";
		}

		var emissionstr = "";
		if (option.light) {
			emissionstr =
				" fragColor = czm_gammaCorrect(fragColor);\n\
   material.emission = fragColor.rgb;\n ";
		}

		this.PolylineTrailLinkSource =
			"czm_material czm_getMaterial(czm_materialInput materialInput)\n\
          {\n\
             float time = czm_frameNumber / 300.0;\n\
             czm_material material = czm_getDefaultMaterial(materialInput);\n\
              vec2 st = materialInput.st;\n\
              vec4 colorImage = texture2D(image, vec2(fract(repeat*st.t - time), fract(st.s)));\n\
              vec4 fragColor;\n " +
			colorstr +
			emissionstr +
			" return material;\n}";

		SceneGIS.Material._materialCache.addMaterial(this.PolylineTrailLinkType, {
			fabric: {
				type: this.PolylineTrailLinkType,
				uniforms: {
					color: option.color,
					image: this.PolylineTrailLinkImage,
					repeat: option.repeat,
					diffuseColor: option.diffuseColor,
				},
				source: this.PolylineTrailLinkSource,
			},
			translucent: function (material) {
				return true;
			},
		});
	}

	Object.defineProperties(PolylineTrail.prototype, {});

	function WallTrailLinkMaterialPropertyEX(color, PolylineTrail, duration) {

		this._definitionChanged = new SceneGIS.Event();
		this._color = undefined;
		this._colorSubscription = undefined;
		this.color = color;
		this.duration = duration || 3000;
		this._time = (new Date()).getTime();



		this._PolylineTrail = PolylineTrail;
		//this._name=PolylineTrail.PolylineTrailLinkType

		this.isTranslucent = function () {
			return true;
		};
	}

	Object.defineProperties(WallTrailLinkMaterialPropertyEX.prototype, {
		isConstant: {
			get: function () {
				return true;
			}
		},
		definitionChanged: {
			get: function () {
				return this._definitionChanged;
			}
		},
		color: SceneGIS.createPropertyDescriptor('color'),
		image: SceneGIS.createPropertyDescriptor('image'),
		time: SceneGIS.createPropertyDescriptor('time'),
		repeat: SceneGIS.createPropertyDescriptor('repeat')
	});

	WallTrailLinkMaterialPropertyEX.prototype.getType = function (time) {
		return this._PolylineTrail.PolylineTrailLinkType;
	};
	WallTrailLinkMaterialPropertyEX.prototype.getValue = function (time, result) {

		if (!SceneGIS.defined(result)) {
			result = {};
		}
		result.color = SceneGIS.Property.getValueOrClonedDefault(this._color, time, SceneGIS.Color.WHITE, result.color);
		result.image = this._PolylineTrail.PolylineTrailLinkImage;
		result.time = (((new Date()).getTime() - this._time) % this.duration) / this.duration;

		return result;
	};
	WallTrailLinkMaterialPropertyEX.prototype.equals = function (other) {
		return this === other ||
			(other instanceof WallTrailLinkMaterialPropertyEX &&
				SceneGIS.Property.equals(this._color, other._color))
	};

	/**
	 *  绘制面
	 *
	 * @alias AttributeEditorEX
	 * @constructor
	 *
	 * @param {Object} options 接下来的属性对象
	 * @param {Viewer} viewer viewer对象
	 * @return {*}
	 */
	function AttributeEditorEX(options, viewer, layer) {
		this.name = "AttributeEditorEX";
		this._viewer = viewer;
		this.prepolygon = undefined;
		this.editorPoints = [];
		this.editorPointsIndex = -1;
		this.currentPoint = undefined;

		this.handle = null;

		this.event = [];
		this.events = new CoreEx.GisEvent();
	}

	Object.defineProperties(AttributeEditorEX.prototype, {
		/**
		 * 获取viewer 对象
		 * @memberof AttributeEditorEX.prototype
		 *
		 * @type {Viewer}
		 * @readonly
		 */
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			},
		},
	});

	/**
	 *  重置
	 * @param {*}
	 * @return {*}
	 */
	AttributeEditorEX.prototype.reset = function (options) {
		try {
			this._data = options.data;
			this.clearclipingplane();
		} finally {
			//this.addEvent();//事件回加
		}
	};

	AttributeEditorEX.prototype.click = function () { };

	/**
	 * 销毁操作，销毁内部事件和临时对象，右键内部会调用
	 * @param {*}
	 * @return {*}
	 */

	AttributeEditorEX.prototype.destroy = function () {
		this.end();
	};

	AttributeEditorEX.prototype.RIGHT_CLICK = function (e) { };
	AttributeEditorEX.prototype.LEFT_CLICK = function (e) { };
	AttributeEditorEX.prototype.LEFT_DOWN = function (e) { };
	AttributeEditorEX.prototype.LEFT_UP = function (e) { };
	AttributeEditorEX.prototype.MOUSE_MOVE = function () { };

	/**
	 *  使用entity方式添加点
	 * @param {SceneGIS.PositionProperty} worldPosition 点坐标
	 * @return {SceneGIS.Entity} 添加的点实体
	 */
	AttributeEditorEX.prototype.createPoint = function (
		worldPosition,
		color,
		index
	) {
		var point = this._datasource.entities.add({
			name: "EditorPolygonPoint" + index,
			position: worldPosition,
			point: {
				pixelSize: 10,
				color: color ? color : SceneGIS.Color.RED,

				//   heightReference:SceneGIS.HeightReference.CLAMP_TO_GROUND,
				disableDepthTestDistance: 100000000000000000,
				outlineWidth: 1,
				outlineColor: SceneGIS.Color.WHITE,
			},
			// ,
			// label:{
			//   text:"@#!"+index.toString(),
			//   font: '18px sans-serif',
			//   fillColor: SceneGIS.Color.GOLD,
			//   style: SceneGIS.LabelStyle.FILL_AND_OUTLINE,
			//   outlineWidth: 2,
			//   verticalOrigin: SceneGIS.VerticalOrigin.CENTER,
			//   pixelOffset: new SceneGIS.Cartesian2(0, -20),
			//   eyeOffset: new SceneGIS.Cartesian3(0, 0, -10),
			//   showBackground:true
			// }
		});
		return point;
	};

	/**
	 *  功能开始
	 */
	AttributeEditorEX.prototype.start = function () {
		if (this.handle) {
			this.handle.destroy();
		}
		this.handle = new SceneGIS.ScreenSpaceEventHandler(this.viewer.canvas);
		this.viewer.scene.globe.depthTestAgainstTerrain = true; //开启地形深度检测
		var that = this;
		var viewer = this.viewer;

		this.handle.setInputAction(function (event) {
			if (that.prepolygon) {
				that.prepolygon.material = SceneGIS.Color.GREEN.withAlpha(0.3);
			}

			var pickfeature = viewer.scene.pick(event.position);
			if (pickfeature && pickfeature.id) {

				if (pickfeature.id.name.indexOf("Editor") > -1) {
					var polygon = pickfeature.id.polygon;
					polygon.material = SceneGIS.Color.BLUE.withAlpha(0.3);
					that.prepolygon = polygon;

					var entity = pickfeature.id;
					entity.properties;
					// var callprop={};
					// for(let p of props){
					//   callprop[p]=prop[p]._value;
					// }

					that.events.raiseEvent("LEFTCLICK", pickfeature.id.id);

				}
			}

		},
			SceneGIS.ScreenSpaceEventType.LEFT_CLICK);

		this.handle.setInputAction(function (event) { },
			SceneGIS.ScreenSpaceEventType.LEFT_DOWN);

		this.handle.setInputAction(function (event) { },
			SceneGIS.ScreenSpaceEventType.LEFT_UP);

		//鼠标移动
		this.handle.setInputAction(function (event) { },
			SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);

		this.handle.setInputAction(function (event) {
			viewer.scene.pick(event.position);
		}, SceneGIS.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
	};

	/**
	 *  功能结束
	 */
	AttributeEditorEX.prototype.end = function () {

		if (this.prepolygon) {
			this.prepolygon.material = SceneGIS.Color.GREEN.withAlpha(0.3);
		}
		if (this.handle) {
			this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.LEFT_CLICK);
			this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
			this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.RIGHT_CLICK);
			this.handle.removeInputAction(
				SceneGIS.ScreenSpaceEventType.LEFT_DOUBLE_CLICK
			);

			this.handle.destroy();
		}
	};

	AttributeEditorEX.prototype.addEvent = function (fun) {
		this.event.push(fun);
	};
	//删除事件
	AttributeEditorEX.prototype.removeEvent = function (fun) {
		for (var i = 0; i < this.event.length; i++) {
			if (this.event[i] == fun) {
				break;
			}
		}
		this.event = this.event.splice(i, 1); //删除掉
	};

	/**
	 * 单体化类型
	 *
	 * @enum {String}
	 */
	var EntityPropEX = {
		/**
		 * 加载固定模板得切边影像,如在线影像
		 *
		 * @type {String}
		 * @constant
		 */
		id: {
			name: "id",
			required: true,
			default: "id",
			disabled: false,
		},
		guid: {
			name: "guid",
			required: true,
			default: "110",
			disabled: false
		},
		// lx: {
		//   name: "类型",
		//   required:true,
		//   default: "建筑物",
		// },code: {
		//   name: "编码",
		//   required:true,
		//   default: "1011111",disabled:true
		// },
		bz: {
			name: "备注",
			required: false,
			default: "",
			disabled: false,
		},
		status: {
			name: "状态",
			default: false,
			disabled: false,
		},
		geoType: {
			name: "地理类型",
			disabled: false,
			default: "polygon",
		},

		/**
			 * 单张地图影像
			 
			 *
			 * @type {String}
			 * @constant
			 */
	};

	var SceneGisEntityProp = Object.freeze(EntityPropEX);

	/**
	 * 单体化类型
	 *
	 * @enum {String}
	 */
	var EntityTypeEX = {
		/**
		 * 加载固定模板得切边影像,如在线影像
		 *
		 * @type {String}
		 * @constant
		 */

		yard: {
			layerName: "院落面",
			entityCode: "1125010801"

		},
		river: {
			layerName: "水系面",
			entityCode: "1121020201"
		},
		sxfsssm: {
			layerName: "水系附属设施面",
			entityCode: "1125010801"
		},
		jmdm: {
			layerName: "居民地面",
			entityCode: "1125010801"
		},
		jmdwbm: {
			layerName: "居民地外包面",
			entityCode: "1125010801"
		},
		jmdssm: {
			layerName: "居民地设施面",
			entityCode: "1125010801"
		},
		dlm: {
			layerName: "道路面",
			entityCode: "1125010801"
		},
		dlfsssm: {
			layerName: "道路附属设施面",
			entityCode: "1125010801"
		},
		gxm: {
			layerName: "管线面",
			entityCode: "1125010801"
		},
		xzqhjm: {
			layerName: "行政区划界面",
			entityCode: "1125010801"
		},
		dmm: {
			layerName: "地貌面",
			entityCode: "1125010801"
		},
		zbm: {
			layerName: "植被面",
			entityCode: "1125010801"
		},


		/**
		   * 单张地图影像
		   
		   *
		   * @type {String}
		   * @constant
		   */

	};

	var EntityTypeEX$1 = Object.freeze(EntityTypeEX);

	/**
	* 
	* 此类是编辑器提示使用，一般不主动创建
	* @class ToolTipEX
	* @constructor
	*/
	function ToolTipEX(option) {

		this._span = undefined;
		this.dialog = createElement$3(option, this);

		this._id = option.id ? option.id : CoreEX.MathEX.createUID();

	}

	ToolTipEX.prototype.destroy = function () {

		if (this._parentDiv) {
			var parentDom = document.getElementById(option.parentDiv);
			parentDom.removeChild(this.dialog);
		}
		else {
			document.body.removeChild(this.dialog);
		}
	};

	function createElement$3(option, self) {

		var dialog = document.createElement("div");

		dialog.className = 'sg-m-box';
		//document.body.appendChild(dialog);
		if (option.parentDiv) {

			var parentDom = document.getElementById(option.parentDiv);
			parentDom.appendChild(dialog);
		}
		else {
			document.body.appendChild(dialog);
		}
		var span = document.createElement("span");
		self._span = span;
		span.insertAdjacentHTML('beforeEnd', option.text ? option.text : "测试");

		dialog.appendChild(span);

		var div1 = document.createElement("div");

		div1.className = 'sg-m-cross';

		dialog.appendChild(div1);

		var div2 = document.createElement("div");
		div2.className = 'sg-m-cross-up';

		// var pText = document.createTextNode(option.text?option.text:"");
		// div2.appendChild(pText);
		dialog.appendChild(div2);


		// <div class="sg-tubiao"  style="left:0px;top:0px;width:200px;height:50px">
		// <div @mouseover="mouseover()" @click='click()' class="sg-rightclass" style="float:right;width:calc(70% - 2px);color:#fff;border:1px solid 1px;height:70%;line-height:35px" :style="{background: 'url(' + option.img1 + ')' , backgroundSize:'100% 100%', backgroundRepeat: 'no-repeat'}"> 厂前液位:<label style="color:#000">1.5</label>米</div>
		// <div @mouseover="mouseover()" @click='click()' style="float:left;width:calc(30% - 2px);height:calc(100% - 11px);margin-top:10px;cursor: pointer" :style="{background: 'url(' + option.img + ')' , backgroundSize:'100% 100%', backgroundRepeat: 'no-repeat'}"></div>
		// </div>

		return dialog;
	}

	ToolTipEX.prototype.getObj = function () {
		return [];
	};
	//设置位置
	ToolTipEX.prototype.setPosition = function (left, top, leftoffset = 0, topoffset = 0) {
		this.dialog.style.left = left + leftoffset + "px";
		this.dialog.style.top = top + topoffset + "px";

	};

	//设置内容
	ToolTipEX.prototype.setContent = function (text) {
		this._span.innerHTML = text;

	};

	Object.defineProperties(ToolTipEX.prototype, {
		show: {
			get: function () {
				if (this.dialog.style.display == "none") {
					return false;
				}
				else {
					return true;
				}
			},
			set: function (value) {
				if (value) {
					this.dialog.style.display = "inline";
				}
				else {
					this.dialog.style.display = "none";
				}
			}
		},
		id: {
			get: function () {
				return this._id;
			}
		}

	});

	/**
	 * 绘制面
	 *
	 * @alias PolygonDrawEX
	 * @constructor
	 *
	 * @param {Object} options 接下来的属性对象
	 * @param {Viewer} viewer viewer对象
	 * @return {*}
	 */
	function PolygonDrawEX(options, viewer, layer) {
		this.name = "PolygonDrawEX";
		this._viewer = viewer;
		this._layer = layer;
		this.polygonOption = options.name ? options :
			{
				name: "EditorPolygon",
				heightReference: SceneGIS.HeightReference.RELATIVE_TO_GROUND,
				perPositionHeight: false,
				material: SceneGIS.Color.GREEN.withAlpha(0.3),
			};

		this._primitivecollection = new SceneGIS.PrimitiveCollection();
		this.viewer.scene.primitives.add(this._primitivecollection);

		this.prepolygon = undefined;

		//   this.currentEditorPolygon=
		this._datasource = undefined;
		var self = this;
		if (layer) {
			layer._featureReadyPromise.then((ds) => {
				self._datasource = ds;
			});
		}
		else {
			this._datasource = new SceneGIS.CustomDataSource();
			this._viewer.dataSources.add(this._datasource);
		}



		this.handle = null;
		this.floatingPoint = null;
		this.activeShape = null;
		this.activeShapePoints = [];
		this.lonlatpoints = [];
		this._tip = new ToolTipEX({ text: "左击添加点,右击回退点,双击结束绘画" });
		this.event = [];
		this.events = new CoreEX.GisEvent();


	}

	Object.defineProperties(PolygonDrawEX.prototype, {
		/**
		 * 获取viewer 对象
		 * @memberof PolygonDrawEX.prototype
		 *
		 * @type {Viewer}
		 * @readonly
		 */
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			},
		},
	});

	/**
	 *  重置
	 * @param {*}
	 * @return {*}
	 */
	PolygonDrawEX.prototype.reset = function (options) {
		try {
			this._data = options.data;
			this.clearclipingplane();
		} finally {
			//this.addEvent();//事件回加
		}
	};

	PolygonDrawEX.prototype.click = function () { };

	/**
	 * 销毁操作，销毁内部事件和临时对象，右键内部会调用
	 * @param {*}
	 * @return {*}
	 */

	PolygonDrawEX.prototype.destroy = function () {
		this.end();
	};

	PolygonDrawEX.prototype.RIGHT_CLICK = function (e) { };
	PolygonDrawEX.prototype.LEFT_CLICK = function (e) { };
	PolygonDrawEX.prototype.LEFT_DOWN = function (e) { };
	PolygonDrawEX.prototype.LEFT_UP = function (e) { };
	PolygonDrawEX.prototype.MOUSE_MOVE = function () { };

	/**
	 * 使用entity方式添加点
	 * @param {SceneGIS.PositionProperty} worldPosition 点坐标
	 * @return {SceneGIS.Entity} 添加的点实体
	 */
	PolygonDrawEX.prototype.createPoint = function (worldPosition) {
		var point = this.viewer.entities.add({
			position: worldPosition,
			point: {
				pixelSize: 10,
				color: SceneGIS.Color.RED
				,
				//   heightReference:SceneGIS.HeightReference.CLAMP_TO_GROUND,
				disableDepthTestDistance: 100000000000000000
			},
		});
		return point;
	};

	/**
	 * 功能开始
	 */
	PolygonDrawEX.prototype.start = function () {
		if (this.handle) {
			this.handle.destroy();
		}
		this.handle = new SceneGIS.ScreenSpaceEventHandler(this.viewer.canvas);
		this.viewer.scene.globe.depthTestAgainstTerrain = true; //开启地形深度检测
		var that = this;
		this.viewer;

		this.handle.setInputAction(function (event) {
			// let nowtime=Date.now();
			//   if(preclicktime){
			//    var dis= nowtime-preclicktime;
			//    if(dis<100)
			//   }
			//   preclicktime=nowtime;
			var earthPosition = that.viewer.scene.pickPosition(event.position);
			if (SceneGIS.defined(earthPosition)) {
				if (that.activeShapePoints.length === 0) {
					that.floatingPoint = earthPosition;// //that.createPoint(earthPosition);
					that.activeShapePoints.push(earthPosition);

					var dynamicPositions = new SceneGIS.CallbackProperty(function () {
						return new SceneGIS.PolygonHierarchy(that.activeShapePoints);
					}, false);

					that.activeShape = that.drawShape(dynamicPositions); //绘制动态图
				}
				that.activeShapePoints.push(earthPosition);

			}

		}, SceneGIS.ScreenSpaceEventType.LEFT_CLICK);

		//鼠标移动
		this.handle.setInputAction(function (event) {
			if (SceneGIS.defined(that.floatingPoint)) {
				var newPosition = that.viewer.scene.pickPosition(event.endPosition);
				if (SceneGIS.defined(newPosition)) {
					// that.floatingPoint.position.setValue(newPosition);
					that.activeShapePoints.pop();
					that.activeShapePoints.push(newPosition);
				}
			}
			that._tip.setPosition(event.endPosition.x, event.endPosition.y, 45, 85);
		}, SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);

		this.handle.setInputAction(function (event) {

			that.activeShapePoints.pop(); //去除最后一个动态点
			that.activeShapePoints.pop(); //去除倒数第二个点击点


			if (that.activeShapePoints.length) {
				for (var point of that.activeShapePoints) {
					var cartographic = SceneGIS.Cartographic.fromCartesian(point);
					var longitudeString = SceneGIS.Math.toDegrees(cartographic.longitude);
					var latitudeString = SceneGIS.Math.toDegrees(cartographic.latitude);
					var heightString = cartographic.height;
					that.lonlatpoints.push({
						lon: longitudeString,
						lat: latitudeString,
						hei: heightString,
					});
				}
				//   that.events.raiseEvent("RIGHTCLICK", that.activeShapePoints);
				var s = that.drawShapeEnd(that.activeShapePoints); //绘制最终图
				//drawPrimitive
				//that.drawPrimitive(that.activeShapePoints);
				that.events.raiseEvent("LEFTDOUBLECLICK", s);

				//that.drawShapeOutline(that.activeShapePoints);//最终图绘制polygon边框
			}

			for (let f of that.event) {
				f(that.activeShapePoints);
			}

			that.viewer.entities.remove(that.floatingPoint); //去除动态点图形（当前鼠标点）
			that._datasource.entities.remove(that.activeShape); //去除动态图形
			that.floatingPoint = undefined;
			that.activeShape = undefined;
			that.activeShapePoints = [];
			that.lonlatpoints = [];


		}, SceneGIS.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);

		this.handle.setInputAction(function (event) {
			that.activeShapePoints.pop();//去除最后一个动态点
		}, SceneGIS.ScreenSpaceEventType.RIGHT_CLICK);
	};

	/**
	 * 绘制面
	 * @param {Array.< Cartesian3 >} positionData 一个属性，用于指定定义面的 Cartesian3 位置的数组
	 * @return {SceneGIS.Entity} 添加的面实体
	 */
	PolygonDrawEX.prototype.drawShape = function (positionData) {

		if (!this._datasource) {
			return;
		}
		var shape;
		var id = CoreEX.MathEX.createUID();
		this.polygonOption.hierarchy = positionData;
		var bag_ = {};
		for (let prop in SceneGisEntityProp) {
			switch (prop) {
				case "id": {
					bag_[prop] = id;
					break;
				}
				default: {
					bag_[prop] = SceneGisEntityProp[prop].default;
					break;
				}

			}

		}
		shape = this._datasource.entities.add({
			name: "EditorPolygon",
			polygon: this.polygonOption,
			properties: new SceneGIS.PropertyBag(bag_)

		});
		return shape;
	};

	/**
	 * 绘制面
	 * @param {Array.< Cartesian3 >} positionData 一个属性，用于指定定义面的 Cartesian3 位置的数组
	 * @return {SceneGIS.Entity} 添加的面实体
	 */
	PolygonDrawEX.prototype.drawShapeEnd = function (positionData) {

		if (!this._datasource) {
			return;
		}
		var id = CoreEX.MathEX.createUID();
		this.polygonOption.hierarchy = positionData;
		var bag_ = {};
		for (let prop in SceneGisEntityProp) {
			switch (prop) {
				case "id": {
					bag_[prop] = id;
					break;
				}
				default: {
					bag_[prop] = SceneGisEntityProp[prop].default;
					break;
				}

			}

		}
		var option = {
			id: bag_.id,
			name: "EditorPolygon",
			polygon: this.polygonOption,
			properties: new SceneGIS.PropertyBag(bag_)

		};
		var poArray = [];
		positionData.forEach((item) => {
			poArray.push(item.x);
			poArray.push(item.y);
			poArray.push(item.z);
		});
		bag_.positions = poArray;
		bag_.geo_polygon = poArray;

		if (this._layer) {
			this._layer.addFeature(option, bag_);
		}
		else {
			bag_.name = option.name;
			this._datasource.entities.add(option);
		}

		//shape = this._datasource.entities.add();
		return bag_;
	};


	PolygonDrawEX.prototype.drawPrimitive = function (positionData, color) {
		//this.addColorLine(positionData);

		var polygon = new SceneGIS.PolygonGeometry({
			polygonHierarchy: new SceneGIS.PolygonHierarchy(
				positionData
			)
		});
		new SceneGIS.GeometryInstance({
			geometry: polygon,
			id: "EditorPolygonPoint-1",
			onlyUseSemiMajorAxis: false,
		});

		var polyline = new SceneGIS.PolylineGeometry({
			positions: positionData,
			arcType: SceneGIS.ArcType.NONE,
			width: 10.0,
			vertexFormat: SceneGIS.PolylineColorAppearance.VERTEX_FORMAT
		});
		// var polyline = new SceneGIS.SimplePolylineGeometry({
		//   positions : positionData,
		//   rcType:SceneGIS.ArcType.NONE,
		//   // SceneGIS.Cartesian3.fromDegreesArray([
		//   //   118.0, 32.0,
		//   //   118.0, 31.0,
		//   //   119.0, 30.0
		//   // ]),
		//   width : 10.0
		// });

		const instance1 = new SceneGIS.GeometryInstance({
			geometry: polyline,
			id: "EditorPolygonPoint-2",
			// onlyUseSemiMajorAxis: false,
		});

		// this._primitivecollection.add(
		//   new SceneGIS.GroundPrimitive({
		//     releaseGeometryInstances: false,
		//     geometryInstances: instance,
		//     appearance: new SceneGIS.MaterialAppearance({
		//       material: new SceneGIS.Material({
		//         //用于生成材质的fabric JSON。
		//         fabric: {
		//           type: "Color",
		//           uniforms: {
		//             color: color ? color : new SceneGIS.Color(0.0, 1.0, 0.0, 0.3),
		//           },
		//         },
		//       }),
		//       faceForward: true,
		//     }),
		//     //被遮挡时，点显示其他颜色
		//     depthFailAppearance: new SceneGIS.MaterialAppearance({
		//       material:
		//         //SceneGIS.Material.fromType("Grid"),
		//         new SceneGIS.Material({
		//           fabric: {
		//             type : 'Grid',
		//             uniforms : {
		//               color: new SceneGIS.Color(0.0, 0.0, 0.0, 1.0),
		//               cellAlpha: 0,
		//               lineCount:new SceneGIS.Cartesian2(5,5),
		//               lineThickness: new SceneGIS.Cartesian2(1,1),
		//               lineOffset:new SceneGIS.Cartesian2(0,0)
		//             }
		//             // type: "Color",
		//             // uniforms: {
		//             //   color: new SceneGIS.Color(0.0, 0.0, 1.0, 0.5),//蓝色
		//             // },
		//           },
		//         }),
		//       faceForward: true,
		//     }),

		//   })
		// )

		this._primitivecollection.add(
			new SceneGIS.Primitive({
				releaseGeometryInstances: false,
				geometryInstances: instance1,
				// appearance: new SceneGIS.MaterialAppearance({
				//   material: new SceneGIS.Material({
				//     //用于生成材质的fabric JSON。
				//     fabric: {
				//       type: "Color",
				//       uniforms: {
				//         color: color ? color : new SceneGIS.Color(0.0, 1.0, 0.0, 1.0),
				//       },
				//     },
				//   }),
				//   faceForward: true,
				// }),
				// //被遮挡时，点显示其他颜色
				// depthFailAppearance: new SceneGIS.MaterialAppearance({
				//   material:
				//     //SceneGIS.Material.fromType("Grid"),
				//     new SceneGIS.Material({
				//       fabric: {
				//         // type : 'Grid',
				//         // uniforms : {
				//         //   color: new SceneGIS.Color(0.0, 0.0, 0.0, 1.0),
				//         //   cellAlpha: 0,
				//         //   lineCount:new SceneGIS.Cartesian2(5,5),
				//         //   lineThickness: new SceneGIS.Cartesian2(1,1),
				//         //   lineOffset:new SceneGIS.Cartesian2(0,0)
				//         // }
				//         type: "Color",
				//         uniforms: {
				//           color: new SceneGIS.Color(0.0, 0.0, 1.0, 0.5),//蓝色
				//         },
				//       },
				//     }),
				//   faceForward: true,
				// }),

			})
		);
	};

	PolygonDrawEX.prototype.addColorLine = function (positions) {//多颜色线段
		var m = this;
		//创建多段线和每段颜色  随机的
		const positions11 = [];
		const colors1 = [];
		for (let j = 0; j <= 50; j += 5) {
			positions11.push(
				SceneGIS.Cartesian3.fromDegrees(108.94388 + j, 34.319, 5000.0 * (j % 10))
			);
			colors1.push(SceneGIS.Color.fromRandom({ alpha: 1.0 }));
		}

		//设置线段的位置和颜色，一一对应，arcType为ArcType.NONE
		const perSegmentPolyline = new SceneGIS.GeometryInstance({
			geometry: new SceneGIS.SimplePolylineGeometry({
				positions: positions11,
				colors: colors1,
				arcType: SceneGIS.ArcType.NONE,
			}),
		});
		//使用逐顶点着色绘制多段线
		//对于逐顶点着色，将colorsPerVertex选项设置为true，并为colors选项提供长度等于位置数的颜色数组
		//  const perVertexPolyline = new SceneGIS.GeometryInstance({
		//      geometry: new SceneGIS.SimplePolylineGeometry({
		//          positions: positions11,
		//          colors: colors1,
		//          colorsPerVertex: true,
		//      }),
		//  });
		//添加多段线instances到primitives
		m.viewer.scene.primitives.add(
			new SceneGIS.Primitive({
				geometryInstances: perSegmentPolyline,//[perSegmentPolyline, perVertexPolyline],
				appearance: new SceneGIS.PerInstanceColorAppearance({
					flat: true,
					renderState: {
						lineWidth: Math.min(5.0, m.viewer.scene.maximumAliasedLineWidth),
					},
				}),
			})
		);
		//flyToBS(this.viewer, Cartesian3.fromDegrees(108.94,34.3),0.5,-45,-45, 1500)
	};



	/**
	 * 绘制面边框
	 * @param {Array.< Cartesian3 >} positionData 一个属性，用于指定定义polyline的 Cartesian3 位置的数组
	 * @return {SceneGIS.Entity} 添加线
	 */
	PolygonDrawEX.prototype.drawShapeOutline = function (positionData) {
		var ds = this._viewer.dataSources.getByName("polygonEditords");//存放编辑要素的数据集合
		if (ds.length > 0) {
			this._datasource = ds[0];
		}

		if (!this._datasource) {
			this._datasource = new SceneGIS.CustomDataSource("polygonEditords");
			this._viewer.dataSources.add(this._datasource);
		}

		var shapeOutline;
		var outlinePositionData = positionData.concat(positionData[0]);
		shapeOutline = this._datasource.entities.add({
			polyline: {
				positions: outlinePositionData,
				width: 2,
				material: SceneGIS.Color.WHITE.withAlpha(0.5),
				clampToGround: true,
			}
		});
		console.log(outlinePositionData);
		return shapeOutline;

	};
	/**
	 * 功能结束
	 */
	PolygonDrawEX.prototype.end = function () {
		if (this.handle) {
			this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.LEFT_CLICK);
			this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
			this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.RIGHT_CLICK);
			this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);

			this.handle.destroy();
			this.handle = undefined;
		}
		if (this._tip) {
			this._tip.destroy();
			this._tip = undefined;
		}
		this.events.removeAllEvent();

	};

	/**
	 * 设置面的初始化选项
	 * @param {SceneGIS.PolygonGraphics.ConstructorOptions} option 初始化选项
	 */
	PolygonDrawEX.prototype.setPolygonOption = function (option) {
		this.polygonOption = option;
	};

	PolygonDrawEX.prototype.addEvent = function (fun) {
		this.event.push(fun);
	};
	//删除事件
	PolygonDrawEX.prototype.removeEvent = function (fun) {
		for (var i = 0; i < this.event.length; i++) {
			if (this.event[i] == fun) {
				break;
			}
		}
		this.event = this.event.splice(i, 1); //删除掉
	};

	/**
	 * 绘制面
	 *
	 * @alias PolygonEditorEX
	 * @constructor
	 *
	 * @param {Object} options 接下来的属性对象
	 * @param {Viewer} viewer viewer对象
	 */
	function PolygonEditorEX(options, viewer) {
		this.name = "PolygonEditorEX";
		this._viewer = viewer;

		this._datasource = new SceneGIS.CustomDataSource("polygonEditorPoints");
		this._primitivecollection = new SceneGIS.PrimitiveCollection();
		this.viewer.scene.primitives.add(this._primitivecollection);
		this._viewer.dataSources.add(this._datasource);
		this._tip = new ToolTipEX({ text: "双击拾取编辑面" });
		this.prepolygon = undefined;
		this.editorPoints = [];
		this.editorPointsIndex = -1;
		this.currentPoint = undefined;

		this.handle = null;

		this.event = [];
		this.events = new CoreEX.GisEvent();
	}

	Object.defineProperties(PolygonEditorEX.prototype, {
		/**
		 * 获取viewer 对象
		 * @memberof PolygonEditorEX.prototype
		 *
		 * @type {Viewer}
		 * @readonly
		 */
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			},
		},
	});

	/**
	 *  重置
	 * @param {Object} options
	 */
	PolygonEditorEX.prototype.reset = function (options) {
		try {
			this._data = options.data;
			this.clearclipingplane();
		} finally {
			//this.addEvent();//事件回加
		}
	};

	PolygonEditorEX.prototype.click = function () { };

	/**
	 * 销毁操作，销毁内部事件和临时对象，右键内部会调用
	 * @param {*}
	 * @return {*}
	 */

	PolygonEditorEX.prototype.destroy = function () {
		this.end();
	};

	PolygonEditorEX.prototype.RIGHT_CLICK = function (e) { };
	PolygonEditorEX.prototype.LEFT_CLICK = function (e) { };
	PolygonEditorEX.prototype.LEFT_DOWN = function (e) { };
	PolygonEditorEX.prototype.LEFT_UP = function (e) { };
	PolygonEditorEX.prototype.MOUSE_MOVE = function () { };

	/**
	 * 使用entity方式添加点
	 * @param {SceneGIS.PositionProperty} worldPosition 点坐标
	 * @return {SceneGIS.Entity} 添加的点实体
	 */
	PolygonEditorEX.prototype.createPoint = function (worldPosition, color, index) {
		var point = this._datasource.entities.add({
			name: "EditorPolygonPoint" + index,
			position: worldPosition,
			point: {
				pixelSize: 10,
				color: color ? color : SceneGIS.Color.RED,

				//   heightReference:SceneGIS.HeightReference.CLAMP_TO_GROUND,
				disableDepthTestDistance: 100000000000000000,
				outlineWidth: 1,
				outlineColor: SceneGIS.Color.WHITE,
			},
		});
		return point;
	};

	PolygonEditorEX.prototype.createCircle = function (
		worldPosition,
		color,
		index,
		h
	) {
		const circle = new SceneGIS.CircleGeometry({
			center: worldPosition,
			radius: 0.3,
			onlyUseSemiMajorAxis: false,
			height: h,
		});
		//

		const instance = new SceneGIS.GeometryInstance({
			geometry: circle,
			id: "EditorPolygonPoint" + index,
			onlyUseSemiMajorAxis: false,
		});
		//
		const ring = new SceneGIS.CircleOutlineGeometry({
			center: worldPosition,
			radius: 1.005,
			height: h + 0.5,
		});

		new SceneGIS.GeometryInstance({
			geometry: ring,
			attributes: {
				color: SceneGIS.ColorGeometryInstanceAttribute.fromColor(
					SceneGIS.Color.GOLD
				),
			},
		});

		SceneGIS.Transforms.eastNorthUpToFixedFrame(worldPosition);

		// this._viewer.entities.add({
		//   polyline: {
		//     positions: computeCircle(0.3),
		//     width: 1,
		//     faceForward: true,
		//     material: new SceneGIS.PolylineDashMaterialProperty({
		//       color: SceneGIS.Color.RED.withAlpha(0),
		//       dashLength: 20 //短划线长度
		//     }),
		//     depthFailMaterial:new SceneGIS.PolylineDashMaterialProperty({
		//       color: SceneGIS.Color.RED.withAlpha(1),
		//       dashLength: 3 //短划线长度
		//     })
		//   }
		// });

		//添加圆
		this._primitivecollection.add(
			new SceneGIS.Primitive({
				releaseGeometryInstances: false,
				geometryInstances: instance,
				appearance: new SceneGIS.MaterialAppearance({
					material: new SceneGIS.Material({
						//用于生成材质的fabric JSON。
						fabric: {
							type: "Color",
							uniforms: {
								color: color ? color : new SceneGIS.Color(0.0, 0.0, 0.0, 1.0),
							},
						},
					}),
					faceForward: true,
				}),
				// //被遮挡时，点显示其他颜色
				depthFailAppearance: new SceneGIS.MaterialAppearance({
					material:
						//SceneGIS.Material.fromType("Grid"),
						new SceneGIS.Material({
							fabric: {
								type: "Grid",
								uniforms: {
									color: color ? color : new SceneGIS.Color(0.0, 0.0, 0.0, 1.0),
									cellAlpha: 0,
									lineCount: new SceneGIS.Cartesian2(5, 5),
									lineThickness: new SceneGIS.Cartesian2(1, 1),
									lineOffset: new SceneGIS.Cartesian2(0, 0),
								},
								// type: "Color",
								// uniforms: {
								//   color: new SceneGIS.Color(0.0, 0.0, 1.0, 0.5),//蓝色
								// },
							},
						}),
					faceForward: true,
				}),
			})
		);
		return this._primitivecollection;
	};

	/**
	 * 功能开始
	 */
	PolygonEditorEX.prototype.start = function () {
		if (this.handle) {
			this.handle.destroy();
		}
		this.handle = new SceneGIS.ScreenSpaceEventHandler(this.viewer.canvas);
		this.viewer.scene.globe.depthTestAgainstTerrain = true; //开启地形深度检测
		var that = this;
		var viewer = this.viewer;

		this.handle.setInputAction(function (event) { },
			SceneGIS.ScreenSpaceEventType.LEFT_CLICK);

		this.handle.setInputAction(function (event) {
			var pickfeature = viewer.scene.pick(event.position);

			if (
				pickfeature &&
				pickfeature.primitive &&
				pickfeature.id &&
				pickfeature.id.indexOf
			) {
				if (pickfeature.id.indexOf("EditorPolygonPoint") > -1) {
					var name = pickfeature.id;
					name = name.replace("EditorPolygonPoint", "");
					that.editorPointsIndex = parseInt(name);

					that.currentPoint = pickfeature.primitive;
					that.viewer.scene.screenSpaceCameraController.enableRotate = false;
					// 如果为true，则允许用户平移地图。如果为假，相机将保持锁定在当前位置。此标志仅适用于2D和Columbus视图模式。
					that.viewer.scene.screenSpaceCameraController.enableTranslate = false;
					// 如果为真，允许用户放大和缩小。如果为假，相机将锁定到距离椭圆体的当前距离
					that.viewer.scene.screenSpaceCameraController.enableZoom = false;
				}
			} else if (pickfeature && pickfeature.id) {
				if (pickfeature.id.name.indexOf("EditorPolygonPoint") > -1) {
					var name = pickfeature.id.name;
					name = name.replace("EditorPolygonPoint", "");
					that.editorPointsIndex = parseInt(name);
					that.currentPoint = pickfeature.id;
					that.viewer.scene.screenSpaceCameraController.enableRotate = false;
					// 如果为true，则允许用户平移地图。如果为假，相机将保持锁定在当前位置。此标志仅适用于2D和Columbus视图模式。
					that.viewer.scene.screenSpaceCameraController.enableTranslate = false;
					// 如果为真，允许用户放大和缩小。如果为假，相机将锁定到距离椭圆体的当前距离
					that.viewer.scene.screenSpaceCameraController.enableZoom = false;
				}
			} else;
		}, SceneGIS.ScreenSpaceEventType.LEFT_DOWN);

		this.handle.setInputAction(function (event) {
			if (that.editorPointsIndex % 2 != 0) {
				//如果是奇数，继续增加点
				var nowpoint = that.editorPoints[that.editorPointsIndex];
				var lasepoint = that.editorPoints[that.editorPointsIndex - 1];
				var prepoint;
				if (that.editorPointsIndex == that.editorPoints.length - 1) {
					prepoint = that.editorPoints[0];
				} else {
					prepoint = that.editorPoints[that.editorPointsIndex + 1];
				}
				var mid = new SceneGIS.Cartesian3();
				mid = SceneGIS.Cartesian3.midpoint(lasepoint, nowpoint, mid);

				var mid1 = new SceneGIS.Cartesian3();
				mid1 = SceneGIS.Cartesian3.midpoint(nowpoint, prepoint, mid1);
				that.editorPoints.splice(that.editorPointsIndex, 0, mid);
				that.editorPoints.splice(that.editorPointsIndex + 2, 0, mid1);
				that.createPoints(that.editorPoints);
			}

			that.editorPointsIndex = -1;
			that.viewer.scene.screenSpaceCameraController.enableRotate = true;
			// 如果为true，则允许用户平移地图。如果为假，相机将保持锁定在当前位置。此标志仅适用于2D和Columbus视图模式。
			that.viewer.scene.screenSpaceCameraController.enableTranslate = true;
			// 如果为真，允许用户放大和缩小。如果为假，相机将锁定到距离椭圆体的当前距离
			that.viewer.scene.screenSpaceCameraController.enableZoom = true;
			that.currentPoint = undefined;
		}, SceneGIS.ScreenSpaceEventType.LEFT_UP);

		//鼠标移动
		this.handle.setInputAction(function (event) {
			that._tip.setPosition(event.endPosition.x, event.endPosition.y, 45, 85);
			var newPosition = that.viewer.scene.pickPosition(event.endPosition);
			var pickfeature = viewer.scene.pick(event.endPosition);
			if (that.editorPointsIndex > -1 && SceneGIS.defined(newPosition)) {
				that.editorPoints[that.editorPointsIndex] = newPosition;
				if (that.currentPoint.position) {
					that.currentPoint.position.setValue(newPosition);
				} else {
					// var p_=that.currentPoint.geometryInstances.geometry._ellipseGeometry ._center;

					//var h_=that.currentPoint.geometryInstances.geometry._ellipseGeometry ._height;
					// var color=that.currentPoint.appearance.material.uniforms.color;
					// var index=that.currentPoint.geometryInstances.id.replace("EditorPolygonPoint","");
					// that._primitivecollection.remove(that.currentPoint);
					// that.currentPoint=that.createCircle(newPosition,color,index,h_);
					var cartographic = SceneGIS.Cartographic.fromCartesian(newPosition);
					var h_ = that.viewer.scene.sampleHeight(cartographic);
					var lon = SceneGIS.Math.toDegrees(cartographic.longitude);
					var lat = SceneGIS.Math.toDegrees(cartographic.latitude);
					var newPosition1 = SceneGIS.Cartesian3.fromDegrees(lon, lat, h_);
					var modelToWorld =
						SceneGIS.Transforms.eastNorthUpToFixedFrame(newPosition1);
					var center =
						that.currentPoint.geometryInstances.geometry._ellipseGeometry._center;
					var modelToWorld1 = SceneGIS.Transforms.eastNorthUpToFixedFrame(center);
					var MNI = SceneGIS.Matrix4.inverse(
						modelToWorld1,
						new SceneGIS.Matrix4()
					);
					modelToWorld = SceneGIS.Matrix4.multiply(
						modelToWorld,
						MNI,
						modelToWorld
					);
					that.currentPoint.modelMatrix = modelToWorld;

					if (that.editorPointsIndex % 2 == 0) {
						//如果是红点，则旁边绿点需要跟着动

						//更新前一个绿点坐标
						var preindex; //绿点位置
						if (that.editorPointsIndex == 0) {
							preindex = that.editorPoints.length - 1;
						} else {
							preindex = that.editorPointsIndex - 1;
						}
						var preRedPoint = preindex - 1; //前红点位置
						var preRedPointT = that.editorPoints[preRedPoint]; //红点坐标
						//更新前一个绿点坐标
						var mid = new SceneGIS.Cartesian3();

						cartographic = SceneGIS.Cartographic.fromCartesian(preRedPointT);
						h_ = that.viewer.scene.sampleHeight(cartographic);
						lon = SceneGIS.Math.toDegrees(cartographic.longitude);
						lat = SceneGIS.Math.toDegrees(cartographic.latitude);
						preRedPointT = SceneGIS.Cartesian3.fromDegrees(lon, lat, h_);

						mid = SceneGIS.Cartesian3.midpoint(preRedPointT, newPosition1, mid);

						var modelToWorld = SceneGIS.Transforms.eastNorthUpToFixedFrame(mid);
						var preprimitive = that._primitivecollection.get(preindex);
						var center =
							preprimitive.geometryInstances.geometry._ellipseGeometry._center;
						var modelToWorld1 =
							SceneGIS.Transforms.eastNorthUpToFixedFrame(center);
						var MNI = SceneGIS.Matrix4.inverse(
							modelToWorld1,
							new SceneGIS.Matrix4()
						);
						modelToWorld = SceneGIS.Matrix4.multiply(
							modelToWorld,
							MNI,
							modelToWorld
						);
						preprimitive.modelMatrix = modelToWorld;

						that.editorPoints[preindex] = mid;

						//更新后一个绿点的坐标
						var nextindex = that.editorPointsIndex + 1;
						var nextRedPoint; //后红点位置
						if (nextindex == that.editorPointsIndex - 1) {
							nextRedPoint = 0;
						} else {
							nextRedPoint = nextindex + 1;
						}
						var nextRedPointT = that.editorPoints[nextRedPoint]; //红点坐标

						cartographic = SceneGIS.Cartographic.fromCartesian(nextRedPointT);
						h_ = that.viewer.scene.sampleHeight(cartographic);
						lon = SceneGIS.Math.toDegrees(cartographic.longitude);
						lat = SceneGIS.Math.toDegrees(cartographic.latitude);
						nextRedPointT = SceneGIS.Cartesian3.fromDegrees(lon, lat, h_);

						var mid = new SceneGIS.Cartesian3();
						mid = SceneGIS.Cartesian3.midpoint(nextRedPointT, newPosition1, mid);

						var modelToWorld = SceneGIS.Transforms.eastNorthUpToFixedFrame(mid);
						var preprimitive1 = that._primitivecollection.get(nextindex);
						var center =
							preprimitive1.geometryInstances.geometry._ellipseGeometry._center;
						var modelToWorld1 =
							SceneGIS.Transforms.eastNorthUpToFixedFrame(center);
						var MNI = SceneGIS.Matrix4.inverse(
							modelToWorld1,
							new SceneGIS.Matrix4()
						);
						modelToWorld = SceneGIS.Matrix4.multiply(
							modelToWorld,
							MNI,
							modelToWorld
						);
						preprimitive1.modelMatrix = modelToWorld;

						that.editorPoints[nextindex] = mid;
					}

					//viewer.scene.requestRender();
				}
			}
			if (
				pickfeature &&
				pickfeature.primitive &&
				pickfeature.id &&
				pickfeature.id.indexOf
			) {
				if (pickfeature.id.indexOf("EditorPolygonPoint") > -1) {
					that.viewer._container.style.cursor = "move";
				} else {
					that.viewer._container.style.cursor = "default";
				}
			} else if (pickfeature && pickfeature.id) {
				if (pickfeature.id.name.indexOf("EditorPolygonPoint") > -1) {
					that.viewer._container.style.cursor = "move";
				} else {
					that.viewer._container.style.cursor = "default";
				}
			} else {
				that.viewer._container.style.cursor = "default";
			}
		}, SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);

		this.handle.setInputAction(function (event) {
			viewer.trackedEntity = undefined;
			var pickfeature = viewer.scene.pick(event.position);
			if (that.prepolygon) {
				that.prepolygon.material = SceneGIS.Color.GREEN.withAlpha(0.3);
				var points = removeCaculatePoints(that.editorPoints);
				that.prepolygon.hierarchy = points;
				that.prepolygon = undefined;
			}

			if (pickfeature && pickfeature.id) {
				if (pickfeature.id.name == "EditorPolygon") {
					that._datasource.entities.removeAll();
					that._primitivecollection.removeAll();

					var polygon = pickfeature.id.polygon;
					var points = polygon.hierarchy._value
						? polygon.hierarchy._value.positions
						: polygon._positions._value;

					polygon.material = SceneGIS.Color.GREEN.withAlpha(0.3);
					that.prepolygon = polygon;
					if (points) {
						var newpoints = caculatePoints(points);
						that.editorPoints = newpoints;
						that.createPoints(newpoints);
						//修改面属性
						polygon.hierarchy = new SceneGIS.CallbackProperty(function () {
							return new SceneGIS.PolygonHierarchy(that.editorPoints);
						}, false);
					}
					that._tip.setContent(
						"拖动点移动，红色只移动，绿色可以添加新点，虚线表示遮挡"
					);
				}
			}
		}, SceneGIS.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
	};

	/**
	 * 功能结束
	 */
	PolygonEditorEX.prototype.end = function () {
		this._datasource.entities.removeAll();
		this._primitivecollection.removeAll();
		if (this.prepolygon) {
			//结束时要做特殊处理
			this.prepolygon.material = SceneGIS.Color.GREEN.withAlpha(0.3);
			var points = removeCaculatePoints(this.editorPoints);
			this.prepolygon.hierarchy = points;
			this.prepolygon = undefined;
		}
		this._viewer.dataSources.remove(this._datasource);
		if (this.handle) {
			this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.LEFT_CLICK);
			this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
			this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.RIGHT_CLICK);
			this.handle.removeInputAction(
				SceneGIS.ScreenSpaceEventType.LEFT_DOUBLE_CLICK
			);

			this.handle.destroy();
			this.handle = undefined;
		}
		if (this._tip) {
			this._tip.destroy();
			this._tip = undefined;
		}
	};

	PolygonEditorEX.prototype.addEvent = function (fun) {
		this.event.push(fun);
	};
	//删除事件
	PolygonEditorEX.prototype.removeEvent = function (fun) {
		for (var i = 0; i < this.event.length; i++) {
			if (this.event[i] == fun) {
				break;
			}
		}
		this.event = this.event.splice(i, 1); //删除掉
	};

	PolygonEditorEX.saveEntity = function (viewer, url) {
		var ds = viewer.dataSources.getByName("polygonEditords"); //存放编辑要素的数据集合
		var entity = [];
		if (ds.length > 0) {
			var _datasource = ds[0];
			var entities = _datasource.entities;
			entities.values.forEach((element) => {
				var _e = {};
				var poArray = [];
				element.polygon.hierarchy._value.positions.forEach((item) => {
					poArray.push(item.x);
					poArray.push(item.y);
					poArray.push(item.z);
				});
				_e.positions = poArray;
				for (let prop in SceneGisEntityProp) {
					if (element.properties[prop] && element.properties[prop]._value) {
						_e[prop] = element.properties[prop]._value;
					}
				}
				// _e.id = element.properties.id._value;
				// _e.type = element.properties.type._value;
				// _e.name = element.properties.name._value;
				entity.push(_e);
			});
		}

		var e_s = JSON.stringify(entity);

		var com = {
			visual: {
				id: "1571748316027068417",
			},
			config: {
				id: "1571748316089982978",
				visualId: "1571748316027068417",
				detail:
					'{"width":1920,"height":1080,"query":{},"header":"","mark":{"show":false,"text":"","fontSize":20,"color":"rgba(100,100,100,0.2)","degree":-20},"scale":69.375,"backgroundImage":"/img/bg/bg.png","url":"","gradeShow":false,"gradeLen":30,"name":"实体化数据"}',
				component: e_s,
			},
		};

		if (window.$axios) {
			window
				.$axios({
					url: url,
					method: "post",
					data: com,
				})
				.then((response) => { });
		} else {
			fetch(url ? url : "http://localhost:8050/blade-visual/visual/update", {
				method: "post",
				body: JSON.stringify(com),
				headers: {
					"Content-Type": "application/json",
				},
			})
				.then((res) => res.json())
				.then((response) => { });
		}
	};

	PolygonEditorEX.lodEntity = function (viewer, url, callback) {
		var ds = viewer.dataSources.getByName("polygonEditords"); //存放编辑要素的数据集合
		var _datasource;
		if (ds.length > 0) {
			_datasource = ds[0];
		} else {
			_datasource = new SceneGIS.CustomDataSource("polygonEditords");
			viewer.dataSources.add(_datasource);
		}
		if (_datasource) {
			if (window.$axios) {
				window
					.$axios({
						url: url,
						method: "get",
					})
					.then((response) => {
						var config = response.data.data.config;
						const contain = {
							config: JSON.parse(config.detail) || {},
							component: JSON.parse(config.component) || [],
						};
						if (callback) {
							callback(contain.component);
						}
						for (var en of contain.component) {
							en.positions = SceneGIS.Cartesian3.unpackArray(en.positions);
							drawShape(_datasource, en);
						}
					});
			} else {
				fetch(
					url
						? url
						: "http://localhost:8050/blade-visual/visual/detail?id=1571748316027068417",
					{
						method: "get",
						headers: {
							"Content-Type": "application/json",
						},
					}
				)
					.then((res) => res.json())
					.then((response) => {
						var config = response.data.config;
						const contain = {
							config: JSON.parse(config.detail) || {},
							component: JSON.parse(config.component) || [],
						};
						for (var en of contain.component) {
							en.positions = SceneGIS.Cartesian3.unpackArray(en.positions);

							drawShape(_datasource, en);
						}
					});
			}
		}
	};

	PolygonEditorEX.zoomEntity = function (viewer, id) {
		var ds = viewer.dataSources.getByName("polygonEditords"); //存放编辑要素的数据集合
		if (ds.length > 0) {
			var _datasource = ds[0];
			var entity = _datasource.entities.getById(id);
			viewer.flyTo(entity, {
				offset: new SceneGIS.HeadingPitchRange(0, -1.57, 50),
			});
		}
	};

	PolygonEditorEX.removeEntity = function (viewer, id) {
		var ds = viewer.dataSources.getByName("polygonEditords"); //存放编辑要素的数据集合
		if (ds.length > 0) {
			var _datasource = ds[0];
			_datasource.entities.removeById(id);
		}
	};

	PolygonEditorEX.updateEntity = function (viewer, param) {
		var ds = viewer.dataSources.getByName("polygonEditords"); //存放编辑要素的数据集合
		if (ds.length > 0) {
			var _datasource = ds[0];
			var entity = _datasource.entities.getById(param.id);

			for (let prop in param) {
				if (entity.properties[prop] && entity.properties[prop].setValue) {
					entity.properties[prop].setValue(param[prop]);
				}
			}
		}
	};

	PolygonEditorEX.removeAllEntity = function (viewer) {
		var ds = viewer.dataSources.getByName("polygonEditords"); //存放编辑要素的数据集合
		if (ds.length > 0) {
			var _datasource = ds[0];
			_datasource.entities.removeAll();
		}
	};

	function drawShape(ds, param) {
		var polygonOption = {
			name: "EditorPolygon",
			perPositionHeight: false,
			material: SceneGIS.Color.GREEN.withAlpha(0.3),
			outline: true,
			outlineWidth: 2,
			outlineColor: SceneGIS.Color.RED,
			hierarchy: param.positions,
		};
		var bag_ = {};
		for (let prop in SceneGisEntityProp) {
			bag_[prop] = param[prop];
		}

		ds.entities.add({
			id: param.id,
			name: "EditorPolygon",
			polygon: polygonOption,
			properties: new SceneGIS.PropertyBag(bag_),
		});
	}

	function caculatePoints(points) {
		var newpoints = [];
		for (var i = 0; i < points.length; i++) {
			var p = points[i];
			p = new SceneGIS.Cartesian3(p.x, p.y, p.z);
			var p1;
			if (i < points.length - 1) {
				p1 = points[i + 1];
			} else {
				p1 = points[0];
			}

			var mid = new SceneGIS.Cartesian3();
			mid = SceneGIS.Cartesian3.midpoint(p, p1, mid);
			newpoints.push(p.clone());
			newpoints.push(mid);
		}

		return newpoints;
	}

	function removeCaculatePoints(points) {
		var newpoints = [];
		for (var i = 0; i < points.length; i = i + 2) {
			newpoints.push(points[i].clone());
		}

		return newpoints;
	}

	PolygonEditorEX.prototype.createPoints = function (newpoints) {
		this._datasource.entities.removeAll();
		this._primitivecollection.removeAll();
		var index = 0;
		var color = SceneGIS.Color.RED;
		var color1 = SceneGIS.Color.GREEN;
		newpoints.forEach((item) => {
			var p = item.clone();

			//var carto=new SceneGIS.Cartographic.fromDegrees(lon,lat)　　//输入经纬度
			var cartographic = SceneGIS.Cartographic.fromCartesian(p);
			var lon = SceneGIS.Math.toDegrees(cartographic.longitude);
			var lat = SceneGIS.Math.toDegrees(cartographic.latitude);
			var h2 = this.viewer.scene.sampleHeight(cartographic);
			var pnew = SceneGIS.Cartesian3.fromDegrees(lon, lat, h2);
			if (SceneGIS.defined(pnew)) {
				if (index % 2 == 0) {
					this.createCircle(pnew, color, index, h2);
					//this.createPoint(pnew, color, index);
				} else {
					//this.createPoint(pnew, color1, index);
					this.createCircle(pnew, color1, index, h2);
				}
			}
			index++;
		});
	};

	/**
	 * 编辑轴类
	 * @class TransformEX
	 * @param {SceneGIS.Viewer} viewer 
	 */
	function TransformEX(viewer) {
		this.name = "TransformEX";
		this._viewer = viewer;
		this.pickModel = undefined;
		this.axis = undefined;
		this.ifdata = false;
		this.position = {
			lat: 0,
			lon: 0,
			alt: 0,
			heading: 0,
			pitch: 0,
			roll: 0,
			scalex: 0,
			scaley: 0,
			scalez: 0,
		};
		this.originMatrix = undefined;
		this.control = new SceneGIS.TransformControls(viewer);
		this.control.setMode(1);
		viewer.scene.primitives.add(this.control);
		this.planeView = viewer.scene.planeView;
		this.addEvent();
	}
	TransformEX.cmdName = "_TransformEX";
	Object.freeze({});

	Object.defineProperties(TransformEX.prototype, {
		/**
		* 获取 三维 viewer
		*
		* @memberof TransformEX.prototype
		*
		* @type {Viewer}
		* @readonly
		*
		* @default undefined
		*/
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		}
	});

	//添加双击事件
	/** @private */
	TransformEX.prototype.addEvent = function () {
		if (this.handle) return;
		this.handle = new SceneGIS.ScreenSpaceEventHandler(this.viewer.canvas);
		this.viewer.scene.globe.depthTestAgainstTerrain = true;//开启地形深度检测
		var that = this;
		//添加事件
		this.handle.setInputAction(function (event) {
			that.LEFT_DOUBLE_CLICK(event);
		}, SceneGIS.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);

		this.handle.setInputAction(function (event) {
			that.LEFT_DOWN(event);
		}, SceneGIS.ScreenSpaceEventType.LEFT_DOWN);

		this.handle.setInputAction(function () {
			that.ifdata = false;
		}, SceneGIS.ScreenSpaceEventType.LEFT_UP);

		this.handle.setInputAction(getData.bind(this), SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
	};

	//获取当前点击三维坐标
	/** @private */
	TransformEX.prototype.LEFT_DOUBLE_CLICK = function (clickEvent) {
		//当前点击的点的位置
		var position = {
			x: clickEvent.position.x,
			y: clickEvent.position.y
		};
		var pick = this.viewer.scene.pickPosition(position);
		//获得点击的模型
		this.pickModel = this.viewer.scene.pick(position);
		if (this.pickModel && pick) {
			console.log("pickModel", this.pickModel);
			this.control.attach(this.pickModel.primitive);
			this.position = this.save();
			if (this.pickModel.primitive instanceof SceneGIS.SceneGIS3DTileset) {
				this.originMatrix = SceneGIS.Matrix4.clone(
					this.pickModel.primitive._root.transform,
					new SceneGIS.Matrix4()
				);
			} else {
				this.originMatrix = SceneGIS.Matrix4.clone(
					this.pickModel.primitive.modelMatrix,
					new SceneGIS.Matrix4()
				);
			}
		}
	};
	/**
	 * 恢复到原来位置和方向
	 */
	TransformEX.prototype.recover = function () {
		if (this.pickModel.primitive instanceof SceneGIS.SceneGIS3DTileset) {
			this.pickModel.primitive._root.transform = SceneGIS.clone(this.originMatrix);
		} else {
			this.pickModel.primitive.modelMatrix = SceneGIS.clone(this.originMatrix);
		}
		this.position = this.save();
	};
	/** @private */
	TransformEX.prototype.LEFT_DOWN = function (clickEvent) {
		//当前点击的点的位置
		var position = {
			x: clickEvent.position.x,
			y: clickEvent.position.y
		};
		var pick = this.viewer.scene.pickPosition(position);
		//获得点击的模型
		this.axis = this.viewer.scene.pick(position);
		if (pick && this.axis && this.axis.type) {
			if (this.axis.type.indexOf("Gizmo") != -1) {  //说明按到编辑轴
				this.ifdata = true;
			}
		}
	};
	/**
	 * 切换到平移功能
	 */
	TransformEX.prototype.transform = function () {
		this.control.setMode(1);
	};
	/**
	 * 切换到旋转功能
	 */
	TransformEX.prototype.rotate = function () {
		console.log("rotate");
		this.control.setMode(0);
	};
	/**
	 * 切换到缩放功能
	 */
	TransformEX.prototype.scale = function () {
		this.control.setMode(2);
	};
	/**
	 * 手动输入数值进行模型位置和方向、缩放的调整
	 * @param {Object} options 
	 * @param {Object} [options.longitude] 经度, 在type='position'时使用
	 * @param {Object} [options.latitude] 纬度, 在type='position'时使用
	 * @param {Object} [options.height] 高度, 在type='position'时使用
	 * @param {Object} [options.rotatex] 绕 X 轴旋转的角度, 在type='rotatex'时使用
	 * @param {Object} [options.rotatey] 绕 Y 轴旋转的角度, 在type='rotatey'时使用
	 * @param {Object} [options.rotatez] 绕 Z 轴旋转的角度, 在type='rotatez'时使用
	 * @param {Object} [options.scaleX] X轴的缩放比例, 在type='scale'时使用
	 * @param {Object} [options.scaleY] Y轴的缩放比例, 在type='scale'时使用
	 * @param {Object} [options.scaleZ] Z轴的缩放比例, 在type='scale'时使用
	 * @param {String} type 调整模式，包括'position','rotatex','rotatey','rotatez','scale'
	 */
	TransformEX.prototype.update = function (options, type) {
		console.log("options:", options, " type:", type);
		var rootTransform = undefined;
		if (this.pickModel.primitive instanceof SceneGIS.SceneGIS3DTileset) {
			rootTransform = this.pickModel.primitive._root.transform;
		} else {
			rootTransform = this.pickModel.primitive.modelMatrix;
		}

		if (type === "position") {
			var WSposition = undefined;
			if (this.planeView === true) {
				WSposition = new SceneGIS.Cartesian3(Number(options.longitude), Number(options.latitude), Number(options.height));
			} else {
				var position = {
					longitude: Number(options.longitude),
					latitude: Number(options.latitude),
					height: Number(options.height),
				};
				WSposition = transformWGS84ToCartesian(this.viewer, position);
			}

			rootTransform = SceneGIS.Matrix4.setTranslation(rootTransform, WSposition, rootTransform);
		} else if (type === "rotatex") {
			var m1 = SceneGIS.Matrix3.fromRotationX(SceneGIS.Math.toRadians(options.rotatex));
			SceneGIS.Matrix4.multiplyByMatrix3(rootTransform, m1, rootTransform);
		} else if (type === "rotatey") {
			var m1 = SceneGIS.Matrix3.fromRotationY(SceneGIS.Math.toRadians(options.rotatey));
			SceneGIS.Matrix4.multiplyByMatrix3(rootTransform, m1, rootTransform);
		} else if (type === "rotatez") {
			var m1 = SceneGIS.Matrix3.fromRotationZ(SceneGIS.Math.toRadians(options.rotatez));
			SceneGIS.Matrix4.multiplyByMatrix3(rootTransform, m1, rootTransform);
		} else if (type === "scale") {
			var scale = new SceneGIS.Cartesian3(Number(options.scaleX), Number(options.scaleY), Number(options.scaleZ));
			rootTransform = SceneGIS.Matrix4.setScale(rootTransform, scale, rootTransform);
		}
		this.position = this.save();
	};

	/*
	 * 坐标转换 84转笛卡尔
	 * 
	 * @param {Object} {lng,lat,alt} 地理坐标
	 * 
	 * @return {Object} Cartesian3 三维位置坐标
	 */
	function transformWGS84ToCartesian(viewer, position) {
		if (viewer) {
			return position
				? SceneGIS.Cartesian3.fromDegrees(
					position.longitude,
					position.latitude,
					position.height,
					SceneGIS.Ellipsoid.WGS84
				)
				: SceneGIS.Cartesian3.ZERO
		}
	}


	function getData() {
		if (this.axis && this.ifdata) {
			this.position = this.save();
		}
	}
	/**
	 * 保存调整的参数
	 * @returns position
	 * @returns position.isSave=true
	 * @returns position.url:模型的资源路径
	 * @returns position.lat:纬度
	 * @returns position.lon:经度
	 * @returns position.alt:高度
	 * @returns position.heading:偏航角，角度值
	 * @returns position.pitch:俯仰角，角度值
	 * @returns position.roll:翻滚角，角度值
	 * @returns position.scalex:x轴缩放比例
	 * @returns position.scaley:y轴缩放比例
	 * @returns position.scalez:z轴缩放比例
	 * @returns position.modelMatrix:模型位姿矩阵
	 */
	TransformEX.prototype.save = function () {
		var modelMatrix = undefined;
		if (this.pickModel.primitive instanceof SceneGIS.SceneGIS3DTileset) {
			modelMatrix = SceneGIS.Matrix4.clone(
				this.pickModel.primitive._root.transform,
				new SceneGIS.Matrix4()
			);
		} else {
			modelMatrix = SceneGIS.Matrix4.clone(
				this.pickModel.primitive.modelMatrix,
				new SceneGIS.Matrix4()
			);
		}
		if (modelMatrix) {
			//拿到位置的世界坐标
			var pos = SceneGIS.Matrix4.getTranslation(modelMatrix, new SceneGIS.Cartesian3());
			var ellipsoid = this.viewer.scene.globe.ellipsoid;
			var cart = ellipsoid.cartesianToCartographic(pos);
			var lat, lng, alt;
			if (this.planeView === true) {
				lng = pos.x;
				lat = pos.y;
				alt = pos.z;
			} else {
				lat = SceneGIS.Math.toDegrees(cart.latitude);
				lng = SceneGIS.Math.toDegrees(cart.longitude);
				alt = cart.height;
			}

			//拿到缩放矩阵
			var scale = SceneGIS.Matrix4.getScale(modelMatrix, new SceneGIS.Cartesian3());

			//拿到旋转矩阵
			var rotate = SceneGIS.Matrix4.getRotation(modelMatrix, new SceneGIS.Matrix3());
			rotate = SceneGIS.Quaternion.fromRotationMatrix(rotate, new SceneGIS.Quaternion());
			var headingpitchroll = SceneGIS.HeadingPitchRoll.fromQuaternion(rotate, new SceneGIS.HeadingPitchRoll());
			var heading = SceneGIS.Math.toDegrees(headingpitchroll.heading);
			var pitch = SceneGIS.Math.toDegrees(headingpitchroll.pitch);
			var roll = SceneGIS.Math.toDegrees(headingpitchroll.roll);

			//拿到url
			var url = this.pickModel.primitive._resource.url;

			var position = {
				isSave: true,
				url: url,
				lat: lat,
				lon: lng,
				alt: alt,
				heading: heading,
				pitch: pitch,
				roll: roll,
				scalex: scale.x.toFixed(2),
				scaley: scale.y.toFixed(2),
				scalez: scale.z.toFixed(2),
				modelMatrix: modelMatrix,
			};
			return position;
		}
	};
	/**
	 * 资源销毁
	 */
	TransformEX.prototype.destroy = function () {
		if (this.handle) {
			this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
			this.handle.destroy();
			this.handle = undefined;
		}
		if (this.control) {
			this.viewer.scene.primitives.remove(this.control);
		}

	};

	/**动态箭头，有一个起点,暂时不支持平面坐标系
	 * @alias CurveArrowEX
	 * @constructor
	 * @param {Viewer} viewer viewer对象
	 * @param {Object} option  对象参数
	 * @param {Array} option.positions  起点坐标
	 * @param {Number} option.height  高度
	 * @param {String} option.color  颜色
	 * @param {Array} option.center  中心点坐标
	 * @param {String} [option.img='img/effects/white_line.png']  图片路径
	 * @param {Number} option.lineWidth  线宽
	 * @param {String} option.name  名称
	 * @param {String} [option.icon='imgs/effects/1.png']  图标
	 * @param {Number} option.repeat  重复次数
	 * @param {Number} option.lineHeight  线高
	 * @param {Number} option.fillrate  填充率
	 * @param {Number} option.time  时间
	 * 
	 * @example
	 *var option=
	 *{
	 *	"positions":[119.77657562996326,33.043810364806035, 25],
	 *	"height":500,
	 *	"color": "rgba(130, 204, 255, 1.0)",
	 *	"center":[118.77657562996326,32.043810364806035, 25],
	 *	"img":"./img/effects/white_line.png",
	 *	"lineWidth":10,
	 *	"name": "PolylineTrailLink_2",
	 *	"icon": "./imgs/effects/1.png",
	 *	"repeat": 2,
	 *	"lineHeight": 500,
	 *	"fillrate": 1.0,
	 *	"time":1000,
	 *	"radius": 100
	 *	}
	 * var curveArrow=new CurveArrowEX(viewer,option);
	 */
	function CurveArrowEX(viewer, option) {
		if (viewer.scene.planeView) return;
		var _option = option;
		var opt = option;
		opt.img = opt.img ? opt.img : CoreEX.getAssetUrl("img/effects/white_line.png");
		opt.icon = opt.icon ? opt.icon : CoreEX.getAssetUrl("imgs/effects/1.png");
		this._objs = [];
		this._id = option.id ? option.id : CoreEX.MathEX.createUID();

		this._owner = option.owner ? option.owner : undefined;

		this.viewer = viewer;

		const startPoint = SceneGIS.Cartesian3.fromDegrees(_option.positions[0], _option.positions[1], _option.positions[2]);
		const endPoint = SceneGIS.Cartesian3.fromDegrees(_option.center[0], _option.center[1], _option.center[2]);
		var _color = opt.color;
		if (opt.color instanceof SceneGIS.Color);
		else {
			_color = SceneGIS.Color.fromCssColorString(opt.color);
		}

		opt.diffuseColor = new SceneGIS.Color(0.0, 0.0, 0.0, 1.0);
		var PolylineTrail = new PolylineTrailEX(opt);
		var p = new PolylineTrailLinkMaterialPropertyEX(_color, PolylineTrail, opt.time ? opt.time : 1000);
		var _ps = generateCurve(startPoint, endPoint, true);

		this._dataSource = new SceneGIS.CustomDataSource(); //换成自定义DataSource，避免被全局清除掉
		viewer.dataSources.add(this._dataSource);

		var e = this._dataSource.entities.add({
			name: opt.name,
			polyline: {
				positions: _ps,
				width: opt.lineWidth ? opt.lineWidth : (opt.linewidth ? opt.linewidth : 2),
				material: p
				// ,
				// clampToGround: true,
			}
		});
		this._objs.push(e);

	}


	/*
	 * 生成流动曲线
	 * @param startPoint 起点
	 * @param endPoint终点
	 * @returns {Array}
	 */
	function generateCurve(startPoint, endPoint, bUseHeight) {

		let addPointCartesian = new SceneGIS.Cartesian3();

		SceneGIS.Cartesian3.add(startPoint, endPoint, addPointCartesian);

		let midPointCartesian = new SceneGIS.Cartesian3();

		SceneGIS.Cartesian3.divideByScalar(addPointCartesian, 2, midPointCartesian);

		let midPointCartographic = SceneGIS.Cartographic.fromCartesian(midPointCartesian);
		if (bUseHeight) {
			midPointCartographic.height = SceneGIS.Cartesian3.distance(startPoint, endPoint) / 5;
		}


		let midPoint = new SceneGIS.Cartesian3();

		SceneGIS.Ellipsoid.WGS84.cartographicToCartesian(midPointCartographic, midPoint);

		let spline = new SceneGIS.CatmullRomSpline({ times: [0.0, 0.5, 1.0], points: [startPoint, midPoint, endPoint] });

		let curvePoints = [];

		for (let i = 0, len = 200; i < len; i++) {

			curvePoints.push(spline.evaluate(i / len));

		}

		return curvePoints;

	}

	/**
	 * 改变颜色
	 * @param {Object} option 颜色参数
	 * @param {SceneGIS.Color} option.color 颜色
	 */
	CurveArrowEX.prototype.changeColor = function (option) {
		//this.obj.color = option.color;
	};

	/**
	 * 删除相关对象
	*/
	CurveArrowEX.prototype.destroy = function () {
		this._dataSource.entities.removeAll();
		this.viewer.dataSources.remove(this._dataSource);
		//this._dataSource.destroy();
	};


	Object.defineProperties(CurveArrowEX.prototype, {
		/**
	 * 显隐控制
	 *
	 * @memberof  CurveArrowEX.prototype
	 * @type {Boolean}
	 */
		show: {
			get: function () {
				if (this._objs[0]) {
					return this._objs[0].show;
				}
				return false;
			},
			set: function (value) {
				for (var obj of this._objs) {
					obj.show = value;
				}
			}
		},
		/**
	   * 要素id
	   * @memberof  CurveArrowEX.prototype
	   * @readonly
	   * @type {Boolean}
	   */
		id: {
			get: function () {
				return this._id;
			},
		},
		/**
		 * 要素的data
		 * @memberof   CurveArrowEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		data: {
			get: function () {
				return this._objs;
			},
		},
		/**
		 * 要素的所属
		 * @memberof  CurveArrowEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		owner: {
			get: function () {
				return this._owner;
			},
			set: function (value) {
				this._owner = value;
				for (var obj of this._objs) {
					obj.owner = value;
				}
			},
		},
	});

	CurveArrowEX.prototype.getObj = function () {
		return this._objs;
	};

	/**
	 * Div 拉线Tip类，此类可单独使用
	 * @alias TipEX
	 * @constructor
	 * @param {viewer} viewer  Viewer对象
	 * @param {Object} option  参数
	 * @param {Array} option.positions  位置
	 * @param {Number} [option.width=200]  宽度，默认200
	 * @param {Number} [option.height=200]  高度，默认200
	 * @param {Dom} [option.parentDiv]  父div，默认document.body
	 * @param {String} [option.color="#fff"]  颜色，默认#fff
	 * @param {String} [option.mainImg]  背景图片
	 * @param {Number} [option.fontSize]  字体大小
	 * @param {String} [option.text]  文字描述
	 * @param {String} [option.lineImg]  拉线的图片
	 * @param {Number} [option.offsetx]  x偏移量
	 * @example
	 * var tip=new SceneGIS.TipEX(viewer,{
	*   "positions":[116.46,39.92,100],
	*   "text": "泵前液位:<label style='color:rgba(209,78,26,1)'>4.5</label>米",
		"show":true,
		"width": 200,
		"height":50,
		"offsetx":0
		});
	 */
	function TipEX(viewer, option) {
		if (!SceneGIS.defined(option.positions)) {
			throw new SceneGIS.DeveloperError('positions is required');
		}
		this.viewer = viewer;
		this._owner = undefined;
		let scene = this.viewer.scene;
		this.dialog = createElement$2(option, this);
		this._id = option.id ? option.id : CoreEX.MathEX.createUID();
		var position;
		if (scene.planView) {
			position = new SceneGIS.Cartesian3(option.positions[0], option.positions[1], option.positions[2]); //data.boxHeightMax为undef也没事
		}
		else {
			position = SceneGIS.Cartesian3.fromDegrees(option.positions[0], option.positions[1], option.positions[2]); //data.boxHeightMax为undef也没事
		}

		var scratch = new SceneGIS.Cartesian2(); //cesium二维笛卡尔 笛卡尔二维坐标系就是我们熟知的而二维坐标系；三维也如此
		var self = this;
		this._parentDiv = option.parentDiv;
		if (option.offsetx) {
			option.offsetx = 0;
		}
		this.vueupdate = function () {
			try {
				var canvasPosition = scene.cartesianToCanvasCoordinates(position, scratch); //cartesianToCanvasCoordinates 笛卡尔坐标（3维度）到画布坐标
				if (SceneGIS.defined(canvasPosition)) {
					self.dialog.style.left = (canvasPosition.x + option.offsetx) + "px";
					self.dialog.style.top = (canvasPosition.y - option.height) + "px";
				}
				else {

				}
			}
			catch (e) {
				console.log(e);
			}
		};
		this.viewer.scene.preRender.addEventListener(this.vueupdate);
	}

	/**
	 * 销毁对象
	 * @return {boolean} 销毁成功返回true,否则返回false
	 */
	TipEX.prototype.destroy = function () {
		this.viewer.scene.preRender.removeEventListener(this.vueupdate);
		if (this._parentDiv) {
			//var parentDom=document.getElementById(option.parentDiv);
			parentDom.removeChild(this.dialog);
		}
		else {
			this.viewer.container.appendChild(this.dialog);
		}
	};

	function createElement$2(option, self) {
		var dialog = document.createElement("div");

		dialog.className = 'sg-tubiao';
		dialog.style.width = (option.width ? option.width : 200) + "px";
		dialog.style.height = (option.height ? option.height : 50) + "px";
		//document.body.appendChild(dialog);

		var div1 = document.createElement("div");

		div1.className = 'sg-rightclass';
		div1.style.float = "right";
		div1.style.width = "calc(70% - 0px)";
		div1.style.border = "1px solid 1px";
		div1.style.height = "70%";
		div1.style.lineHeight = parseFloat(option.height) * 0.7 + "px";
		div1.style.color = option.color ? option.color : "#fff";
		div1.style.background = option.mainImg ? 'url(' + option.mainImg + ')' : CoreEX.getAssetUrl("img/kuang2.png");
		div1.style.backgroundSize = '100% 100%';
		div1.style.backgroundRepeat = 'no-repeat';
		div1.style.fontSize = (option.fontSize ? option.fontSize : 10) + "px";

		div1.insertAdjacentHTML('beforeEnd', option.text ? option.text : "");
		dialog.appendChild(div1);
		var div2 = document.createElement("div");
		div2.className = 'sg-rightclass';
		div2.style.float = "left";
		div2.style.width = "calc(30% - 0px)";
		div2.style.height = "calc(100% - 11px)";
		div2.style.marginTop = parseFloat(option.height) * 0.35 + "px";
		div2.style.cursor = "pointer";
		div2.style.background = option.lineImg ? 'url(' + option.lineImg + ')' : CoreEX.getAssetUrl("img/tubiaoleft.png");
		div2.style.backgroundSize = '100% 100%';
		div2.style.backgroundRepeat = 'no-repeat';
		dialog.appendChild(div2);
		if (option.parentDiv) {

			var parentDom = document.getElementById(option.parentDiv);
			parentDom.appendChild(dialog);
		}
		else {
			self.viewer.container.appendChild(dialog);
		}
		return dialog;
	}

	TipEX.prototype.getObj = function () {
		return [this.dialog];
	};

	/**
	* 改变颜色
	* @param {Object} option 颜色参数
	* @param {SceneGIS.Color} option.color 颜色
	 */
	TipEX.prototype.changeColor = function (option) {
		this.dialog.style.backgroundColor = option.color.toCssColorString();
	};

	Object.defineProperties(TipEX.prototype, {
		/**
		* 显隐控制
		* @memberof TipEX.prototype
		* @type {Boolean}
	   */
		show: {
			get: function () {
				if (this.dialog.style.display == "none") {
					return false;
				}
				else {
					return true;
				}
			},
			set: function (value) {
				if (value) {
					this.dialog.style.display = "inline-block";
				}
				else {
					this.dialog.style.display = "none";
				}
			}
		},
		/**
		* 要素id
		* @memberof TipEX.prototype
		* @readonly
		* @type {String}
	   */
		id: {
			get: function () {
				return this._id;
			}
		},
		/**
		 * 要素的data
		 * @memberof TipEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		*/
		data: {
			get: function () {
				return [this.dialog];
			}
		},
		/**
	   * 要素的所属
	   * @memberof TipEX.prototype
	   * @readonly
	   * @type {Array<Entity>|Array<Primitive>}
	  */
		owner: {
			get: function () {
				return this._owner;
			},
			set: function (value) {
				this._owner = value;
			}
		}

	});

	var DomFactory = {
		"list": function (option) {
			return createList$1(option);
		}

	};

	function createList$1(option) {
		var content = document.createElement("div");

		var table = document.createElement("table");
		table.className = "sg-list-tables";
		for (var field in option) {
			var tr = document.createElement("tr");
			tr.style.width = "100%";
			var td1 = document.createElement("td");
			td1.className = 'td1';
			var pText = document.createTextNode(field);
			td1.appendChild(pText);
			tr.appendChild(td1);

			var td2 = document.createElement("td");
			td2.className = 'td2';
			// var pText = document.createTextNode(option[field]);
			td2.insertAdjacentHTML('beforeEnd', option[field]);
			//appendChild(pText);
			tr.appendChild(td2);

			table.appendChild(tr);
		}
		content.appendChild(table);
		return content;
	}

	/**
	 * DialogLocation类型
	 *
	 * @enum {String}
	 */
	var DialogLocationType = {
		/**
		 * 顶部
		 * @type {String}
		 */
		"top": "top",
		/**
		 * 底部
		 * @type {String}
		 */
		"bottom": "bottom",
		/**
		 * 左侧
		 * @type {String}
		 */
		"left": "left",
		/**
		 * 右侧
		 * @type {String}
		 */
		"right": "right",
		/**
		 * 左上
		 * @type {String}
		 */
		"lefttop": "lefttop",
		/**
		 * 左下
		 * @type {String}
		 */
		"leftbottom": "leftbottom",

		/**
		 * 右上
		 * @type {String}
		 */
		"righttop": "righttop",
		/**
		 * 右下
		 * @type {String}
		 */
		"rightbottom": "rightbottom",

	};
	var DialogLocationType$1 = Object.freeze(DialogLocationType);

	/**
	 * 无边框对话框,可以整体偏移
	 * @alias DialogWithOutLineEX
	 * @constructor
	 * @param {Object} viewer
	 * @param {Object} option
	 * @param {Array} option.positions 位置
	 * @param {String} option.title 标题
	 * @param {String} option.subName 副标题
	 * @param {String} option.mainImg 主图片
	 * @param {Number} option.titleFontSize 标题字体大小
	 * @param {Number} option.subtitleFontSize 副标题字体大小
	 * @param {Number} option.contentFontSize 内容字体大小
	 * @param {Number} option.width 宽度
	 * @param {Number} option.height 高度
	 * @param {Boolean} option.show 显示隐藏
	 * @param {DialogLocationType} option.location 相对位置
	 * @param {String} option.margin margin值，形如"0px 20px 20px 0px"
	 * @param {Boolean} option.closeButton 是否显示关闭按钮
	 * @param {Number} option.offsetTop 顶部偏移量
	 * @param {Number} option.offsetLeft 左侧偏移量
	 * @param {Object} option.dom 内容
	 * @param {String} option.dom.type 内容类型，目前支持list和table
	 * @param {Object} option.dom.option 内容参数，不固定
	 * @example
	 * var dialog=new DialogWithOutLineEX(viewer,{
	 *     
		"positions":[116.46,39.92,100],
		"title": "昨日进水量/ <label style='color:rgba(209,78,26,1)'>出水量</label>",
		"subName":"",
		"mainImg": "./img/框3.png",
		"titleFontSize": 10,
		"show":true,
		"location":"lefttop",
		"margin":"0px 20px 20px 0px",
		"subtitleFontSize":14,
		"contentFontSize":14,
		"width": 250,
		"height":100,
		"closeButton":false,
		"offsetTop":-50,
		"dom":{
			"type":"list",
			"option":{
				"水量":"(133/<label style='color:rgba(209,78,26,1)'>149</label>)km³"

			}
		}
												
	 * });
	 */
	function DialogWithOutLineEX(viewer, option) {
		if (!SceneGIS.defined(option.positions)) {
			throw new SceneGIS.DeveloperError('positions is required');
		}
		this._owner = undefined;
		this.viewer = viewer;
		this.dialog = createElement$1(option, this);
		this._id = option.id;
		this._id = option.id ? option.id : CoreEX.MathEX.createUID();
		let scene = this.viewer.scene;
		var position;
		if (scene.planeView) {
			position = new SceneGIS.Cartesian3(option.positions[0], option.positions[1], option.positions[2]);
		} else {
			position = SceneGIS.Cartesian3.fromDegrees(option.positions[0], option.positions[1], option.positions[2]); //data.boxHeightMax为undef也没事
		}

		var scratch = new SceneGIS.Cartesian2(); //cesium二维笛卡尔 笛卡尔二维坐标系就是我们熟知的而二维坐标系；三维也如此

		var self = this;

		self._tile = option.title;

		option.location = option.location ? option.location : DialogLocationType$1.top;
		this.vueupdate = function () {
			try {
				var canvasPosition = scene.cartesianToCanvasCoordinates(position, scratch); //cartesianToCanvasCoordinates 笛卡尔坐标（3维度）到画布坐标
				if (SceneGIS.defined(canvasPosition)) {
					switch (option.location) {
						case "top":
							self.dialog.style.left = (canvasPosition.x - parseFloat(option.width) / 2 + (option.offsetLeft ? option.offsetLeft : 0)) + "px";
							self.dialog.style.top = (canvasPosition.y - option.height + (option.offsetTop ? option.offsetTop : 0)) + "px";
							break;
						case "bottom":
							self.dialog.style.left = (canvasPosition.x - parseFloat(option.width) / 2 + (option.offsetLeft ? option.offsetLeft : 0)) + "px";
							self.dialog.style.top = (canvasPosition.y + (option.offsetTop ? option.offsetTop : 0)) + "px";
							break;
						case "left":
							self.dialog.style.left = (canvasPosition.x - option.width + (option.offsetLeft ? option.offsetLeft : 0)) + "px";
							self.dialog.style.top = (canvasPosition.y - parseFloat(option.height) / 2 + (option.offsetTop ? option.offsetTop : 0)) + "px";
							break;
						case "right":
							self.dialog.style.left = (canvasPosition.x + (option.offsetLeft ? option.offsetLeft : 0)) + "px";
							self.dialog.style.top = (canvasPosition.y - parseFloat(option.height) / 2 + (option.offsetTop ? option.offsetTop : 0)) + "px";
							break;
						case "lefttop":
							self.dialog.style.left = (canvasPosition.x - option.width + (option.offsetLeft ? option.offsetLeft : 0)) + "px";
							self.dialog.style.top = (canvasPosition.y - option.height + (option.offsetTop ? option.offsetTop : 0)) + "px";
							break;
						case "leftbottom":
							self.dialog.style.left = (canvasPosition.x - option.width + (option.offsetLeft ? option.offsetLeft : 0)) + "px";
							self.dialog.style.top = (canvasPosition.y + (option.offsetTop ? option.offsetTop : 0)) + "px";
							break;
						case "righttop":
							self.dialog.style.left = (canvasPosition.x + (option.offsetLeft ? option.offsetLeft : 0)) + "px";
							self.dialog.style.top = (canvasPosition.y - option.height + (option.offsetTop ? option.offsetTop : 0)) + "px";
							break;
						case "rightbottom":
							self.dialog.style.left = (canvasPosition.x + (option.offsetLeft ? option.offsetLeft : 0)) + "px";
							self.dialog.style.top = (canvasPosition.y + (option.offsetTop ? option.offsetTop : 0)) + "px";
							break;
					}

				}
				else {

				}
			}
			catch (e) {
				console.log(e);
			}
		};
		this.viewer.scene.preRender.addEventListener(this.vueupdate);
	}
	/**
	 * 销毁对象
	 * @return {boolean} 销毁成功返回true,否则返回false
	 */
	DialogWithOutLineEX.prototype.destroy = function () {
		this.viewer.scene.preRender.removeEventListener(this.vueupdate);
		this.viewer.container.removeChild(this.dialog);
	};

	function createElement$1(option, self) {
		var dialog = document.createElement("div");

		dialog.className = 'sg-billbord-detailinfodiv';
		dialog.style.width = (option.width ? option.width : 200) + "px";
		dialog.style.height = (option.height ? option.height : 200) + "px";
		self.viewer.container.appendChild(dialog);

		var main = document.createElement("div");
		main.className = 'main-withoutline ';
		main.style.background = option.mainImg ? 'url(' + option.mainImg + ')' : CoreEX.getAssetUrl("img/框3.png");
		main.style.backgroundSize = '100% 100%';
		main.style.backgroundRepeat = 'no-repeat';
		main.style.margin = option.margin ? option.margin : "5px 5px 5px 5px";
		dialog.appendChild(main);

		if (option.hasOwnProperty("closeButton") && option.closeButton) {
			var closediv = document.createElement("div");
			closediv.className = 'sg-billbord-floatclose';
			closediv.addEventListener('click', function () {
				dialog.style.display = "none";
			}, false);
			var pText = document.createTextNode("X");
			closediv.appendChild(pText);
			main.appendChild(closediv);
		}


		var adiv1 = document.createElement("a");
		adiv1.className = 'sg-billbord-title1';
		adiv1.style.color = option.titleColor ? option.titleColor : "#fff";

		adiv1.style.float = 'left';
		adiv1.style.width = "75%";
		adiv1.style.textAlign = "left";
		adiv1.style.fontSize = option.titlefontsize + 'pt';
		adiv1.insertAdjacentHTML('beforeEnd', option.title ? option.title : "");

		main.appendChild(adiv1);


		var contentdiv = document.createElement("div");
		contentdiv.className = 'sg-billbord-propcontent';
		contentdiv.style.fontSize = option.contentFontSize + 'px';
		self._contentdiv = contentdiv;
		self.dom = option.dom;
		main.appendChild(contentdiv);
		return dialog;
	}

	DialogWithOutLineEX.prototype.getObj = function () {
		return [this.dialog];
	};


	/**
	* 改变颜色
	* @param {Object} option 颜色参数
	* @param {SceneGIS.Color} option.color 颜色
	 */
	DialogWithOutLineEX.prototype.changeColor = function (option) {
		this.dialog.style.backgroundColor = option.color.toCssColorString();
	};

	Object.defineProperties(DialogWithOutLineEX.prototype, {
		/**
		* 显隐控制
		*
		* @memberof DialogWithOutLineEX.prototype
		* @type {Boolean}
	   */
		show: {
			get: function () {
				if (this.dialog.style.display == "none") {
					return false;
				} else {
					return true;
				}
			},
			set: function (value) {
				if (value) {
					this.dialog.style.display = "inline";
				}
				else {
					this.dialog.style.display = "none";
				}
			}
		},
		/**
		* 要素id
		* @memberof DialogWithOutLineEX.prototype
		* @readonly
		* @type {String}
	   */
		id: {
			get: function () {
				return this._id;
			}
		},
		/**
		* 要素的data
		* @memberof DialogWithOutLineEX.prototype
		* @readonly
		* @type {Array<Entity>|Array<Primitive>}
	   */
		data: {
			get: function () {
				return [this.dialog];
			}
		},
		/**
	   * 要素的所属
	   * @memberof DialogWithOutLineEX.prototype
	   * @readonly
	   * @type {Array<Entity>|Array<Primitive>}
	  */
		owner: {
			get: function () {
				return this._owner;
			},
			set: function (value) {
				this._owner = value;
			}
		},
		/**
		* 动态替换要素内容
		* @memberof DialogWithOutLineEX.prototype
		* @readonly
		* @type {Object}
	   */
		dom: { //可以动态替换内容
			get: function () {

			},
			set: function (value) {

				if (this._contentdiv.firstChild) {
					this._contentdiv.removeChild(this._contentdiv.firstChild);
				}

				var dom = DomFactory[value.type](value.option);
				this._contentdiv.appendChild(dom);
			}
		}

	});

	/**
	 * 多dialog
	 * @alias MDialogWithOutLineEX
	 * @constructor
	 * @param {Viewer} viewer viewer对象
	 * @param {Array<Object>} option  数组的内容请参考{@link MDialogWithOutLineEX}
	 */
	function MDialogWithOutLineEX(viewer, option) {

		this.viewer = viewer;
		this.dialog = [];
		this._owner = option.owner ? option.owner : undefined;

		this._id = option.id ? option.id : CoreEX.MathEX.createUID();
		for (var o of option) {
			var d = new DialogWithOutLineEX(this.viewer, o);
			this.dialog.push(d);
		}

	}

	/**
	 * 销毁对象
	 * @return {boolean} 销毁成功返回true,否则返回false
	 */
	MDialogWithOutLineEX.prototype.destroy = function () {
		for (var d of this.dialog) {
			d.destroy();
		}
	};

	/**
	* 改变颜色
	* @param {Object} option 颜色参数
	* @param {SceneGIS.Color} option.color 颜色
	 */
	MDialogWithOutLineEX.prototype.changeColor = function (option) {
		for (var d of this.dialog) {
			d.changeColor(option);
		}
	};

	MDialogWithOutLineEX.prototype.getObj = function () {
		return this.dialog;
	};
	Object.defineProperties(MDialogWithOutLineEX.prototype, {
		/**
		* 显隐控制
		*
		* @memberof MDialogWithOutLineEX.prototype
		* @type {Boolean}
	   */
		show: {
			get: function () {
				if (this.dialog.length > -1) {
					return this.dialog[0].show;
				}
				return false;
			},
			set: function (value) {
				for (var d of this.dialog) {
					d.show = value;
				}
			}
		},
		/**
		* 要素id
		* @memberof MDialogWithOutLineEX.prototype
		* @readonly
		* @type {String}
	   */
		id: {
			get: function () {
				return this._id;
			}
		},
		/**
		* 要素的data
		* @memberof MDialogWithOutLineEX.prototype
		* @readonly
		* @type {Array<Entity>|Array<Primitive>}
	   */
		data: {
			get: function () {
				return this.dialog;
			}
		},
		/**
	   * 要素的所属
	   * @memberof MDialogWithOutLineEX.prototype
	   * @readonly
	   * @type {Array<Entity>|Array<Primitive>}
	  */
		owner: {
			get: function () {
				return this._owner;
			},
			set: function (value) {
				this._owner = value;
			}
		},
		divMDialogWithOutLine: {
			get: function () {

			},
			set: function (value) {
				for (var i = 0; i < this.dialog.length; i++) {
					this.dialog[i].dom = value[i].dom;
				}
			}
		}

	});

	/**
	 * Div弹窗
	 * @alias DialogWithOutLineEX
	 * @constructor
	 * @param {viewer} viewer  Viewer对象
	 * @param {Object} option  div 参数
	 * @param {Array} option.positions  位置
	 * @param {Number} [option.width=200]  宽度，默认200
	 * @param {Number} [option.height=50]  高度，默认50
	 * @param {Dom} [option.parentDiv]  父div，默认document.body
	 * @param {String} [option.divId]  divID
	 * @param {String} [option.transform='rotate(0deg)']  变换参数
	 * @param {String} [option.color="rgba(255,255,255,1)"]  颜色，默认#fff
	 * @param {String} [option.img]  背景图片
	 * @param {String} [option.text]  文字描述
	 * @param {Number} [option.padding_bottom]  底部距离
	 * @param {Number} [option.offsetx]  x偏移量
	 * @example
	 * var tip=new SceneGIS.DivEX(viewer,{
	*   "positions":[116.46,39.92,100],
		 "show":true,
		 "width": 50,
		 "height":50,
		 "offsetx":0
		});
	 */
	function DivEX(viewer, option) {
		if (!SceneGIS.defined(option.positions)) {
			throw new SceneGIS.DeveloperError('positions is required');
		}
		this.viewer = viewer;
		this._owner = option.owner ? option.owner : undefined;
		this.dialog = createElement(option, this);
		this._id = option.id ? option.id : CoreEX.MathEX.createUID();
		let scene = this.viewer.scene;
		var position;
		if (scene.planeView) {
			position = new SceneGIS.Cartesian3(option.positions[0], option.positions[1], option.positions[2]);
		} else {
			position = SceneGIS.Cartesian3.fromDegrees(option.positions[0], option.positions[1], option.positions[2]);
		}
		var scratch = new SceneGIS.Cartesian2(); //cesium二维笛卡尔 笛卡尔二维坐标系就是我们熟知的而二维坐标系；三维也如此


		this._parentDiv = option.parentDiv;

		var self = this;

		this.event = {
			"LEFTCLICK": []
		};
		if (!option.offsetx) {
			option.offsetx = -(option.width / 2);
		}
		this.vueupdate = function () {
			try {
				var canvasPosition = scene.cartesianToCanvasCoordinates(position, scratch); //cartesianToCanvasCoordinates 笛卡尔坐标（3维度）到画布坐标
				if (SceneGIS.defined(canvasPosition) && isNaN(canvasPosition.x) == false && isNaN(canvasPosition.y) == false) {
					self.dialog.style.left = (canvasPosition.x + option.offsetx) + "px";
					self.dialog.style.top = (canvasPosition.y - option.height) + "px";
				}
				else {

				}
			}
			catch (e) {
				console.log(e);
			}
		};
		this.viewer.scene.preRender.addEventListener(this.vueupdate);
	}

	/**
	 * 销毁对象
	 * @return {boolean} 销毁成功返回true,否则返回false
	 */
	DivEX.prototype.destroy = function () {
		this.viewer.scene.preRender.removeEventListener(this.vueupdate);
		if (this._parentDiv) {
			var parentDom = document.getElementById(option.parentDiv);
			parentDom.removeChild(this.dialog);
		}
		else {
			this.viewer.container.removeChild(this.dialog);
		}


	};

	function createElement(option, self) {
		var dialog = document.createElement("div");
		dialog.className = 'sg-gif';
		dialog.style.width = (option.width ? option.width : 200) + "px";
		if (!option.text || (option.text && option.text == "")) {
			dialog.style.height = (option.height ? option.height : 50) + "px";
		}
		else {
			dialog.style.height = "auto";
		}
		if (option.height) {
			dialog.style.height = option.height + "px";
		}
		if (option.padding_bottom) {
			dialog.style.paddingBottom = option.padding_bottom + "px";
		}
		if (option.divId) {
			dialog.id = option.divId;
		}
		//(option.height?option.height:50)+"px";

		dialog.style.background = option.img ? 'url(' + option.img + ')' : CoreEX.getAssetUrl("img/提升泵运行.png");
		dialog.style.position = 'absolute';
		dialog.style.backgroundSize = '100% 100%';
		dialog.style.backgroundRepeat = 'no-repeat';
		dialog.style.transform = option.transform ? option.transform : 'rotate(0deg)';
		dialog.style.textAlign = "center";
		dialog.style.lineHeight = dialog.style.height;
		dialog.style.color = option.color ? option.color : "rgba(255,255,255,1)";
		dialog.style.cursor = 'pointer';
		dialog.addEventListener('click', function () {
			//dialog.style.display="none";
			for (var f of self.event["LEFTCLICK"]) {
				f(self);
			}
			//this.event[type].push(fun);
		}, false);
		dialog.style.display = "table";
		var dialogcontent = document.createElement("div");
		//display:table-cell; vertical-align:middle;
		dialogcontent.style.display = "table-cell";
		dialogcontent.style.verticalAlign = "middle";
		dialog.appendChild(dialogcontent);
		if (option.text) {
			var pText = document.createTextNode(option.text ? option.text : "");
			dialogcontent.appendChild(pText);
		}

		if (option.parentDiv) {

			var parentDom = document.getElementById(option.parentDiv);
			parentDom.appendChild(dialog);
		}
		else {
			self.viewer.container.appendChild(dialog);
		}

		return dialog;
	}

	DivEX.prototype.addEvent = function (type, fun) {
		this.event[type].push(fun);
	};

	DivEX.prototype.getObj = function () {
		return [this.dialog];
	};

	/**
	* 改变颜色
	* @param {Object} option 颜色参数
	* @param {SceneGIS.Color} option.color 颜色
	 */
	DivEX.prototype.changeColor = function (option) {
		this.dialog.style.backgroundColor = option.color.toCssColorString();
	};

	Object.defineProperties(DivEX.prototype, {

		/**
		 * 显隐控制
		 * @memberof DivEX.prototype
		 * @type {Boolean}
		*/
		show: {
			get: function () {
				if (this.dialog.style.display == "none") {
					return false;
				}
				else {
					return true;
				}
			},
			set: function (value) {
				if (value) {
					this.dialog.style.display = "table";
				}
				else {
					this.dialog.style.display = "none";
				}
			}
		},
		/**
		 * 要素id
		 * @memberof DivEX.prototype
		 * @readonly
		 * @type {Boolean}
		*/
		id: {
			get: function () {
				return this._id;
			}
		},
		/**
		 * 要素的data
		 * @memberof  DivEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		*/
		data: {
			get: function () {
				return [this.dialog];
			}
		},
		/**
		 * 要素的所属
		 * @memberof DivEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		*/
		owner: {
			get: function () {
				return this._owner;
			},
			set: function (value) {
				this._owner = value;
			}
		},
		/**
		 * 要素的材质属性，改变颜色使用
		 * @type {Object}
		 */
		material: {
			get: function () {
				return this.dialog.style.backgroundColor;
			},
			set: function (value) {
				if (value instanceof SceneGIS.Color) {
					this.dialog.style.backgroundColor = value.toCssColorString();
				}
				else {
					this.dialog.style.backgroundColor = value;
				}

			}
		}

	});

	VueDialogEX.vue = undefined; //会在场景SceneEx初始化时赋值
	/**
	 * 动态修改Vue组件的data属性，只修改对象或者数组类属性，并且属性值必须具备，left，top，show的属性。
	 * left和top 用于绑定相关vue的位置，show用于控制显隐。可以用此类去动态创建VueEx对象。
	 * @constructor
	 * @param {Viewer} viewer viewer对象
	 * @param {Object} option  内部对象参数
	 * @param {Object} option.positions 位置
	 * @param {Number} option.offsetx 偏移值
	 * @param {Number} option.offsety 偏移值，最好给Vue组件高度
	 * @param {Object} option.propertyName Vue组件Data属性名字
	 * @param {Object|Array} option.propertyValue Vue组件Data属性值
	 * @param {Number} option.propertyValue.left 距离左边的距离
	 * @param {Number} option.propertyValue.top  距离上面的距离
	 * @param {Vue} vueObj 所在的Vue对象，如果没有给Vue对象，则使用SceneEx创建Cavas所在的组件。
	 * @example
	 * var vueObj=new VueDialogEX(viewer,{
	 *     "positions":[116.46,39.92,100],
	 *     offsetx:0,
	 *     offsety:0,
	 *     propertyName:"dialog",
	 *     propertyValue:{
	 *      left:0,
	 *      top:0,
	 *      show:true
	 *     }
	 * })
	 */
	function VueDialogEX(viewer, option, vueObj) {
		if (!SceneGIS.defined(option.positions)) {
			throw new SceneGIS.DeveloperError("positions is required");
		}
		let vue_ = vueObj ? vueObj : VueDialogEX.vue;
		this._owner = option.owner ? option.owner : undefined;
		var propertyName = option.propertyName;
		var propertyValue = option.propertyValue;
		var layerArray = [];

		if (propertyValue instanceof Array) {
			//如果是一个数组
			if (vue_[propertyName]) {
				vue_[propertyName].push(...propertyValue);
			}
			this.dialog = vue_[propertyName][vue_[propertyName].length - 1];
			layerArray = vue_[propertyName];
		} else {
			//否则，认为只是一个对象
			vue_[propertyName] = propertyValue;
			this.dialog = vue_[propertyName];
		}

		this.viewer = viewer;
		this.layerArray = layerArray;

		this._id = option.id ? option.id : CoreEX.MathEX.createUID();
		let scene = this.viewer.scene;
		var position;
		if (scene.planeView) {
			position = new SceneGIS.Cartesian3(option.positions[0], option.positions[1], option.positions[2]);
		} else {
			position = SceneGIS.Cartesian3.fromDegrees(option.positions[0], option.positions[1], option.positions[2]);
		}
		var scratch = new SceneGIS.Cartesian2(); //cesium二维笛卡尔 笛卡尔二维坐标系就是我们熟知的而二维坐标系；三维也如此

		var self = this;
		this.vueupdate = function () {
			try {
				var canvasPosition = scene.cartesianToCanvasCoordinates(
					position,
					scratch
				); //cartesianToCanvasCoordinates 笛卡尔坐标（3维度）到画布坐标
				if (SceneGIS.defined(canvasPosition)) {
					self.dialog.left = canvasPosition.x + option.offsetx;
					self.dialog.top = canvasPosition.y - option.offsety;
				} else {
				}
			} catch (e) {
				console.log(e);
			}
		};
		this.viewer.scene.preRender.addEventListener(this.vueupdate);
	}

	VueDialogEX.prototype.getObj = function () {
		return [this.dialog]; //这个对象不需要返回具体值用于建立事件字典
	};

	VueDialogEX.prototype.destroy = function () {
		if (this.layerArray) {
			var index = this.layerArray.findIndex((item) => item === this.dialog);
			if (index == -1) {
				return;
			}
			this.layerArray.splice(index, 1);
		} else {
			this.dialog.show = false;
		}
		this.viewer.scene.preRender.removeEventListener(this.vueupdate);
	};

	/**
	* 改变颜色
	* @param {Object} option 颜色参数
	* @param {SceneGIS.Color} option.color 颜色
	 */
	VueDialogEX.prototype.changeColor = function (option) {
		this.dialog.style.backgroundColor = option.color.toCssColorString();
	};

	Object.defineProperties(VueDialogEX.prototype, {
		/**
		 * 显隐控制
		 *
		 * @memberof VueDialogEX.prototype
		 * @type {Boolean}
		 */
		show: {
			get: function () {
				return this.dialog.show;
			},
			set: function (value) {
				this.dialog.show = value;
			},
		},
		/**
		 * 要素id
		 * @memberof VueDialogEX.prototype
		 * @readonly
		 * @type {String}
		 */
		id: {
			get: function () {
				return this._id;
			},
		},
		/**
		 * 要素的data
		 * @memberof VueDialogEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		data: {
			get: function () {
				return [this.dialog];
			},
		},
		/**
		 * 要素的所属
		 * @memberof VueDialogEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		owner: {
			get: function () {
				return this._owner;
			},
			set: function (value) {
				this._owner = value;
			},
		},
	});

	/**
	 * SceneGIS 自带的水面
	 * @alias WaterPolygonEX
	 * @constructor
	 * @param {Viewer} viewer Viewer对象
	 * @param {Object} option
	 * @param {Array} [option.positions] 带有经度，纬度，高度的坐标数组，或者平面坐标
	 * @param {Number} [option.height=2] 水深
	 * @param {Number} [option.extrudedHeight=0] 距离地面高度
	 * @example
	 * var option={
	 *  positions: [118.76149744144743, 32.04446913521202, 200, 118.76149744144743, 32.04446913521202, 0,118.66149744144743, 32.8446913521202, 0,118.76149744144743, 32.04446913521202],
	 * }
	 * var bull=new WaterPolygonEX(viewer,option);
	 */
	function WaterPolygonEX(viewer, option) {
		option = Object.assign({}, option);
		this.option = option;
		this._owner = option.owner ? option.owner : undefined;
		this._id = option.id ? option.id : CoreEX.MathEX.createUID();
		this.viewer = viewer;
		let scene = viewer.scene;
		//河道1多边形
		let polygon = new SceneGIS.PolygonGeometry({
			polygonHierarchy: new SceneGIS.PolygonHierarchy(
				Cartesian3EX.fromArrayHeights(option.positions, !scene.planeView)
			),
			extrudedHeight: option.extrudedHeight ? option.extrudedHeight : 0, //距离地面高度
			height: option.height ? option.height : 2, //水深
			vertexFormat: SceneGIS.EllipsoidSurfaceAppearance.VERTEX_FORMAT,
		});

		var pool = new SceneGIS.Primitive({
			geometryInstances: new SceneGIS.GeometryInstance({
				geometry: polygon,
			}),
			appearance: new SceneGIS.EllipsoidSurfaceAppearance({
				aboveGround: true,
			}),
			show: true,
		});
		var pool_Material = new SceneGIS.Material({
			fabric: {
				type: "Water",
				uniforms: {
					baseWaterColor: SceneGIS.Color.fromBytes(100, 200, 255, 255),
					normalMap: option.img,
					frequency: 7000.0,
					animationSpeed: 0.05,
					amplitude: 90.0,
					specularIntensity: 0.5,
				},
			},
		});
		pool.appearance.material = pool_Material;
		this.obj = this.viewer.scene.primitives.add(pool);
	}

	WaterPolygonEX.prototype.getObj = function () {
		return [this.obj];
	};

	/**
	 * 改变颜色
	 * @param {Object} option 颜色参数
	 * @param {SceneGIS.Color} option.color 颜色
	 */
	WaterPolygonEX.prototype.changeColor = function (option) {
		this.obj.color = option.color;
	};

	/**
	 * 删除相关对象
	 *
	 */
	WaterPolygonEX.prototype.destroy = function () {
		this.viewer.scene.primitives.remove(this.obj);
	};
	Object.defineProperties(WaterPolygonEX.prototype, {
		/**
		 * 显隐控制
		 *
		 * @memberof  WaterPolygonEX.prototype
		 * @type {Boolean}
		 */
		show: {
			get: function () {
				if (this.obj) {
					return this.obj.show;
				}
				return false;
			},
			set: function (value) {
				this.obj.show = value;
			},
		},
		/**
		 * 要素id
		 * @memberof  WaterPolygonEX.prototype
		 * @readonly
		 * @type {Boolean}
		 */
		id: {
			get: function () {
				return this._id;
			},
		},
		/**
		 * 要素的data
		 * @memberof   WaterPolygonEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		data: {
			get: function () {
				return [this.obj];
			},
		},
		/**
		 * 要素的所属
		 * @memberof  WaterPolygonEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		owner: {
			get: function () {
				return this._owner;
			},
			set: function (value) {
				this._owner = value;
				this.obj.owner = value;
			},
		},
	});

	/**
	 * 节点井的展示,暂时不支持平面坐标系
	 * @alias WaterLevelWellEX
	 * @constructor
	 * @param {Viewer} viewer Viewer对象
	 * @param {Object} option
	 * @param {Array} option.wellCenter 井中心点
	 * @param {Number} option.wellRadius 井半径
	 * @param {Number} option.wellHeight 井高度
	 * @param {Number} option.waterHeight 水高度
	 * @param {Array<Object>} option.pips 管线连接，看example
	 * @example
	 * var option=
	 *  {
	 *    "model":"",
	 *    "wellCenter": [119.18947498380192,34.83883938537642, 0],
	 *    "wellRadius":0.446,
	 *    "wellHeight":1,
	 *    "waterHeight":0.5,
	 *    "pips":[
	 *    	{
	 *   		  "start": [120, 30],
	 *  		  "end": [119, 31],
	 *  		  "height": 0.5,
	 *  		  "length": 2,
	 *  		  "radius": 0.1
	 *    	},
	 *    	{
	 *    		"start": [120, 30],
	 *  		  "end": [119, 29],
	 *  		  "height": 0.7,
	 *	  	  "length": 3,
	 *		   "radius": 0.07
	 *  	  },
	 *  	  {
	 *		   "start": [120, 30],
	 *		   "end": [121, 29.5],
	 *		   "height": 0.3,
	 *		   "length": 2.6,
	 *		   "radius": 0.15
	 *	   }
	 *    ]
	 *	}
	 * var bull=new WaterLevelWellEX(viewer,option);
	 */
	function WaterLevelWellEX(viewer, option) {
		// if (viewer.scene.planeView) return;
		this._id = option.id ? option.id : CoreEX.MathEX.createUID();
		this.viewer = viewer;
		this.model = option.model;
		let position = option.wellCenter;
		this.wellCenter = viewer.scene.planeView ? new SceneGIS.Cartesian3(position[0], position[1], position[2]) : new SceneGIS.Cartesian3.fromDegrees(
			option.wellCenter[0],
			option.wellCenter[1],
			option.wellCenter[2]
		);
		this.wellRadius = option.wellRadius;
		this.wellHeight = option.wellHeight;
		this.pips = [];
		for (var pip of option.pips) {
			this.pips.push({
				start: viewer.scene.planeView ? new SceneGIS.Cartesian3(pip.start[0], pip.start[1]) : new SceneGIS.Cartesian3.fromDegrees(pip.start[0], pip.start[1]),
				end: viewer.scene.planeView ? new SceneGIS.Cartesian3(pip.end[0], pip.end[1]) : new SceneGIS.Cartesian3.fromDegrees(pip.end[0], pip.end[1]),
				height: pip.height,
				length: pip.length,
				radius: pip.radius,
			});
		}
		this.waterHeight = option.waterHeight;
		if (this.viewer.scene.planeView === true) {
			this.modelMatrix = SceneGIS.Matrix4.fromTranslation(this.wellCenter, new SceneGIS.Matrix4());
		}
		else {
			this.modelMatrix = SceneGIS.Transforms.eastNorthUpToFixedFrame(this.wellCenter);
		}
		// this.modelMatrix = SceneGIS.Transforms.eastNorthUpToFixedFrame(this.wellCenter);
		this.primitivePips = [];
		this.primitiveWell;
		this.water;
		this.init();
	}

	WaterLevelWellEX.prototype.init = function () {
		this.initWell();
		this.initPips();
		let planeView = this.viewer.scene.planeView;
		var water = new SceneGIS.Primitive({
			geometryInstances: new SceneGIS.GeometryInstance({
				geometry: new SceneGIS.CircleGeometry({
					center: this.wellCenter,
					radius: this.wellRadius,
					height: this.waterHeight,
					planeView: planeView,
				}),
			}),
			appearance: new SceneGIS.EllipsoidSurfaceAppearance({
				aboveGround: true,
				material: new SceneGIS.Material({
					fabric: {
						type: "Water",
						uniforms: {
							baseWaterColor: new SceneGIS.Color(0.11765, 0.56471, 1, 0.3),
							normalMap: SceneGIS.buildModuleUrl(
								"Assets/Textures/waterNormals.jpg"
							),
							frequency: 100.0,
							animationSpeed: 0.005,
							amplitude: 5.0,
						},
					},
				}),
			}),
		});
		this.viewer.scene.primitives.add(water);
		this.water = water;
	};

	WaterLevelWellEX.prototype.initWell = function () {
		// 计算圆上的点
		var points = [];
		var min = [];
		var max = [];
		var modelToWorld;
		if (this.viewer.scene.planeView === true) {
			modelToWorld = SceneGIS.Matrix4.fromTranslation(this.wellCenter, new SceneGIS.Matrix4());
		}
		else {
			modelToWorld = SceneGIS.Transforms.eastNorthUpToFixedFrame(this.wellCenter);
		}

		var xAxis = SceneGIS.Matrix4.multiplyByPointAsVector(
			modelToWorld,
			SceneGIS.Cartesian3.UNIT_X,
			new SceneGIS.Cartesian3()
		);
		var yAxis = SceneGIS.Matrix4.multiplyByPointAsVector(
			modelToWorld,
			SceneGIS.Cartesian3.UNIT_Y,
			new SceneGIS.Cartesian3()
		);
		for (var i = 0; i <= 360; i++) {
			var radians = (i / 180) * Math.PI;
			var x = this.wellRadius * Math.cos(radians);
			var y = this.wellRadius * Math.sin(radians);
			var point = SceneGIS.Cartesian3.add(
				this.wellCenter,
				SceneGIS.Cartesian3.multiplyByScalar(xAxis, x, new SceneGIS.Cartesian3()),
				new SceneGIS.Cartesian3()
			);
			point = SceneGIS.Cartesian3.add(
				point,
				SceneGIS.Cartesian3.multiplyByScalar(yAxis, y, new SceneGIS.Cartesian3()),
				new SceneGIS.Cartesian3()
			);
			points.push(point);
			min.push(0);
			max.push(this.wellHeight);
		}
		var well = new SceneGIS.Primitive({
			geometryInstances: new SceneGIS.GeometryInstance({
				geometry: new SceneGIS.WallGeometry({
					positions: points,
					maximumHeights: max,
					minimumHeights: min,
					planeView: this.viewer.scene.planeView
				}),
			}),
			appearance: new SceneGIS.MaterialAppearance({
				material: new SceneGIS.Material({
					fabric: {
						type: "Color",
						uniforms: {
							color: new SceneGIS.Color(0.51, 0.8, 1.0, 1.0),
							height: this.waterHeight / this.wellHeight,
						},
						/*glsl*/
						source: `czm_material czm_getMaterial(czm_materialInput materialInput){
                            czm_material material = czm_getDefaultMaterial(materialInput);
                            float flag = step(height,materialInput.st.t);
                            flag==1.0?material.diffuse=vec3(1.0,1.0,1.0):material.diffuse=color.rgb;
                            // material.diffuse=flag*vec3(1.0,1.0,1.0)+color.rgb;
                            material.alpha=0.7;
                            return material;
                        }
                    `,
					},
				}),
			}),
		});

		this.viewer.scene.primitives.add(well);
		this.primitiveWell = well;
	};

	WaterLevelWellEX.prototype.initPips = function () {
		for (var i = 0; i < this.pips.length; i++) {
			var points = [];
			var min = [];
			var max = [];
			var zAxisWell = SceneGIS.Matrix4.multiplyByPointAsVector(
				this.modelMatrix,
				SceneGIS.Cartesian3.UNIT_Z,
				new SceneGIS.Cartesian3()
			);
			var center = SceneGIS.Cartesian3.add(
				this.wellCenter,
				SceneGIS.Cartesian3.multiplyByScalar(
					zAxisWell,
					this.pips[i].height,
					new SceneGIS.Cartesian3()
				),
				new SceneGIS.Cartesian3()
			);
			var vector = new SceneGIS.Cartesian3(
				this.pips[i].end.x - this.pips[i].start.x,
				this.pips[i].end.y - this.pips[i].start.y,
				this.pips[i].end.z - this.pips[i].start.z
			);
			var toModel = SceneGIS.Matrix4.inverse(
				this.modelMatrix,
				new SceneGIS.Matrix4()
			);
			var vectorInModel = SceneGIS.Matrix4.multiplyByPointAsVector(
				toModel,
				vector,
				new SceneGIS.Cartesian3()
			);
			vectorInModel.z = 0;
			SceneGIS.Cartesian3.normalize(vectorInModel, vectorInModel);
			SceneGIS.Matrix4.multiplyByPointAsVector(
				this.modelMatrix,
				vectorInModel,
				vector
			);
			SceneGIS.Cartesian3.normalize(vector, vector);
			SceneGIS.Cartesian3.add(
				center,
				SceneGIS.Cartesian3.multiplyByScalar(
					vector,
					this.pips[i].length / 2 + this.wellRadius,
					new SceneGIS.Cartesian3()
				),
				center
			);
			var modelToWorld;
			if (this.viewer.scene.planeView) {
				modelToWorld = SceneGIS.Matrix4.fromTranslation(center, new SceneGIS.Matrix4());
			}
			else {
				modelToWorld = SceneGIS.Transforms.eastNorthUpToFixedFrame(center);
			}

			var xAxis = SceneGIS.Matrix4.multiplyByPointAsVector(
				modelToWorld,
				SceneGIS.Cartesian3.UNIT_X,
				new SceneGIS.Cartesian3()
			);
			var yAxis = SceneGIS.Matrix4.multiplyByPointAsVector(
				modelToWorld,
				SceneGIS.Cartesian3.UNIT_Y,
				new SceneGIS.Cartesian3()
			);
			for (var j = 0; j <= 360; j++) {
				var radians = (j / 180) * Math.PI;
				var x = this.pips[i].radius * Math.cos(radians);
				var y = this.pips[i].radius * Math.sin(radians);
				var point = SceneGIS.Cartesian3.add(
					center,
					SceneGIS.Cartesian3.multiplyByScalar(
						xAxis,
						x,
						new SceneGIS.Cartesian3()
					),
					new SceneGIS.Cartesian3()
				);
				point = SceneGIS.Cartesian3.add(
					point,
					SceneGIS.Cartesian3.multiplyByScalar(
						yAxis,
						y,
						new SceneGIS.Cartesian3()
					),
					new SceneGIS.Cartesian3()
				);
				points.push(point);
				min.push(this.pips[i].height - this.pips[i].length / 2);
				max.push(this.pips[i].height + this.pips[i].length / 2);
			}
			//测试横下
			var worldToModel = SceneGIS.Matrix4.inverse(
				modelToWorld,
				new SceneGIS.Matrix4()
			);
			var angleWithX = SceneGIS.Cartesian3.angleBetween(
				vectorInModel,
				SceneGIS.Cartesian3.UNIT_X
			);
			if (vectorInModel.y > 0) {
				angleWithX = -angleWithX;
			}
			var rotate = SceneGIS.Matrix3.fromHeadingPitchRoll(
				new SceneGIS.HeadingPitchRoll(angleWithX, Math.PI / 2, 0),
				new SceneGIS.Matrix3()
			);
			var transform = SceneGIS.Matrix4.fromRotationTranslation(
				rotate,
				SceneGIS.Cartesian3.ZERO,
				new SceneGIS.Matrix4()
			);
			var newModelMatrix = modelToWorld.clone();
			SceneGIS.Matrix4.multiply(newModelMatrix, transform, newModelMatrix);
			var modelMatrix = SceneGIS.Matrix4.multiply(
				newModelMatrix,
				worldToModel,
				new SceneGIS.Matrix4()
			);

			var pip = new SceneGIS.Primitive({
				geometryInstances: new SceneGIS.GeometryInstance({
					geometry: new SceneGIS.WallGeometry({
						positions: points,
						maximumHeights: max,
						minimumHeights: min,
						planeView: this.viewer.scene.planeView
					}),
				}),
				modelMatrix: modelMatrix,
				appearance: new SceneGIS.MaterialAppearance({
					material: new SceneGIS.Material({
						fabric: {
							type: "Color",
							uniforms: {
								color: new SceneGIS.Color(0.51, 0.8, 1.0, 1.0),
								height:
									(this.waterHeight -
										(this.pips[i].height - this.pips[i].radius)) /
									(this.pips[i].radius * 2),
							},
							source: /*glsl*/ `
                        czm_material czm_getMaterial(czm_materialInput materialInput){
                            czm_material material = czm_getDefaultMaterial(materialInput);
                            float zero2half=1.0-smoothstep(0.0,0.5,materialInput.st.s);
                            float half2one=smoothstep(0.5,1.0,materialInput.st.s);
                            float s=fract(zero2half+half2one);
                            float flag = step(height,s);
                            // material.diffuse=flag*vec3(1.0,1.0,1.0)+color.rgb;
                            flag==1.0?material.diffuse=vec3(1.0,1.0,1.0):material.diffuse=color.rgb;
                            material.alpha=0.7;
                            return material;
                        }
                    `,
						},
					}),
				}),
			});

			this.viewer.scene.primitives.add(pip);
			this.primitivePips.push(pip);
		}
	};

	WaterLevelWellEX.prototype.updateWater = function (value) {
		if (value > this.wellHeight) {
			value = this.wellHeight;
		}
		this.waterHeight = value;
		this.primitiveWell.appearance.material.uniforms.height =
			this.waterHeight / this.wellHeight;
		for (var i = 0; i < this.primitivePips.length; i++) {
			this.primitivePips[i].appearance.material.uniforms.height =
				(this.waterHeight - (this.pips[i].height - this.pips[i].radius)) /
				(this.pips[i].radius * 2);
		}

		var water = new SceneGIS.Primitive({
			geometryInstances: new SceneGIS.GeometryInstance({
				geometry: new SceneGIS.CircleGeometry({
					center: this.wellCenter,
					radius: this.wellRadius,
					height: this.waterHeight,
					planeView: this.viewer.scene.planeView
				}),
			}),
			appearance: new SceneGIS.EllipsoidSurfaceAppearance({
				aboveGround: true,
				material: new SceneGIS.Material({
					fabric: {
						type: "Water",
						uniforms: {
							baseWaterColor: new SceneGIS.Color(0.11765, 0.56471, 1, 0.3),
							normalMap: SceneGIS.buildModuleUrl(
								"Assets/Textures/waterNormalsSmall.jpg"
							),
							frequency: 100.0,
							animationSpeed: 0.005,
							amplitude: 5.0,
						},
					},
				}),
			}),
		});
		this.viewer.scene.primitives.add(water);
		this.viewer.scene.primitives.remove(this.water);
		this.water = water;
	};

	/**
	 * 删除相关对象
	 */
	WaterLevelWellEX.prototype.destroy = function () {
		this.viewer.scene.primitives.remove(this.water);
		this.viewer.scene.primitives.remove(this.primitiveWell);
		while (this.primitivePips.length > 0) {
			this.viewer.scene.primitives.remove(this.primitivePips.pop());
		}
	};
	/**
	 * 改变颜色
	 * @param {Object} option 颜色参数
	 * @param {SceneGIS.Color} option.color 颜色
	 */
	WaterLevelWellEX.prototype.changeColor = function (option) {
		//this.obj.color = option.color;
	};
	Object.defineProperties(WaterLevelWellEX.prototype, {
		/**
		 * 显隐控制
		 *
		 * @memberof  WaterLevelWellEX.prototype
		 * @type {Boolean}
		 */
		show: {
			get: function () {
				if (this.primitiveWell) {
					return this.primitiveWell.show;
				}
				return false;
			},
			set: function (value) {
				this.primitiveWell.show = value;
				this.water.show = value;
				for (var pip of this.primitivePips) {
					pip.show = value;
				}
			},
		},

		currentWaterHeight: {
			get: function () {
				return this.waterHeight;
			},
			set: function (value) {
				this.updateWater(value);
			},
		},
		/**
		 * 要素id
		 * @memberof  WaterLevelWellEX.prototype
		 * @readonly
		 * @type {Boolean}
		 */
		id: {
			get: function () {
				return this._id;
			},
		},
		/**
		 * 要素的data
		 * @memberof   WaterLevelWellEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		data: {
			get: function () {
				let objs = [];
				objs.push(this.primitiveWell);
				objs.push(this.water);
				objs.concat(this.primitivePips);
				return objs;
			},
		},
		/**
		 * 要素的所属
		 * @memberof  WaterLevelWellEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		owner: {
			get: function () {
				return this._owner;
			},
			set: function (value) {
				this._owner = value;
				this.primitiveWell.owner = value;
				this.water.owner = value;
				for (var pip of this.primitivePips) {
					pip.owner = value;
				}
			},
		},
	});

	/**
	 * 添加gltf的模型，可以根据线调整位置
	 * @alias GlbEX
	 * @constructor
	 * @param {Viewer} viewer viewer 对象
	 * @param {Object} [option] 接下来的属性对象
	 * @param {Array} [option.positions] 位置
	 * @param {String} [option.url] glb路径
	 * @param {Number} [rotation] 旋转值，如果有该值，则不会根据坐标算方向
	 * @param {Number} [scale] 缩放值
	 * @example
	 *
	 * var option={
	 *  positions: [118.76149744144743, 32.04446913521202, 200, 118.76149744144743, 32.04446913521202, 0],
	 *  url: "./glb/zj.glb",
	 *  rotation:0,
	 *  scale:0.015
	 * }
	 * var bull=new GlbEX(viewer,option);
	 */

	function GlbEX(viewer, option) {
		if (!option) option = {};
		option = Object.assign({}, option);
		this._id = option.id ? option.id : CoreEX.MathEX.createUID();
		this.viewer = viewer;
		this.data = option;
		this.obj = undefined;
		this.glburl = option.url ? option.url : CoreEX.getAssetUrl("glb/zj.glb");
		this._owner = option.owner ? option.owner : undefined;
		this.create();
	}


	Object.defineProperties(GlbEX.prototype, {
		/**
		 * 显隐控制
		 *
		 * @memberof EntityEX.prototype
		 * @type {Boolean}
		 */
		show: {
			get: function () {
				if (this.obj) {
					return this.obj.show;
				}
				return false;
			},
			set: function (value) {
				this.obj.show = value;
			},
		},
		/**
		 * 要素id
		 * @memberof GlbEX.prototype
		 * @readonly
		 * @type {Boolean}
		 */
		id: {
			get: function () {
				return this._id;
			},
		},
		/**
		 * 要素的data
		 * @memberof  GlbEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		data: {
			get: function () {
				return [this.obj];
			},
		},
		/**
		 * 要素的所属
		 * @memberof GlbEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		owner: {
			get: function () {
				return this._owner;
			},
			set: function (value) {
				this._owner = value;
				this.obj.owner = value;
			},
		},
	});

	/** 创建实体
	 *
	 */
	GlbEX.prototype.create = function () {
		addGlb.bind(this)();
	};


	GlbEX.prototype.getObj = function () {
		return [this.obj];
	};

	/**
	* 改变颜色
	* @param {Object} option 颜色参数
	* @param {SceneGIS.Color} option.color 颜色
	 */
	GlbEX.prototype.changeColor = function (option) {
		this.obj.color = option.color;
	};

	/**
	 * 删除相关对象
	 *
	 */
	GlbEX.prototype.destroy = function () {
		this.viewer.scene.primitives.remove(this.obj);
	};

	/**
	 * 更新显隐等相关信息
	 */
	GlbEX.prototype.update = function () { };

	function addGlb() {
		var heading = 0;
		if (this.data.positions.length > 3) {
			heading = _getheading(
				this.data.positions[0],
				this.data.positions[1],
				this.data.positions[3],
				this.data.positions[4]
			);
		}
		let scene = this.viewer.scene;
		var modelMatrix;
		if (scene.planeView) {
			const translation = new SceneGIS.Cartesian3(this.data.positions[0],
				this.data.positions[1],
				this.data.positions[2]);
			modelMatrix = SceneGIS.Matrix4.fromTranslation(translation); //平面坐标系直接创建平移矩阵
		}
		else {
			modelMatrix = SceneGIS.Transforms.eastNorthUpToFixedFrame(
				SceneGIS.Cartesian3.fromDegrees(
					this.data.positions[0],
					this.data.positions[1],
					this.data.positions[2]
				)
			);
		}

		let r = this.data.rotation;
		let scale = this.data.scale;

		var m1 = SceneGIS.Matrix3.fromRotationZ(
			//旋转
			SceneGIS.define(r) ? r : SceneGIS.Math.toRadians(heading)
		);
		SceneGIS.Matrix4.multiplyByMatrix3(modelMatrix, m1, modelMatrix);
		this.obj = this.viewer.scene.primitives.add(
			SceneGIS.Model.fromGltf({
				url: this.glburl,
				modelMatrix: modelMatrix,
				scale: SceneGIS.define(scale) ? scale : 0.015,//缩放值
			})
		);
	}

	//计算方位角
	function _getheading(startLat, startLng, destLat, destLng) {
		startLat = SceneGIS.Math.toRadians(startLat);
		startLng = SceneGIS.Math.toRadians(startLng);
		destLat = SceneGIS.Math.toRadians(destLat);
		destLng = SceneGIS.Math.toRadians(destLng);

		let y = window.Math.sin(destLng - startLng) * window.Math.cos(destLat);
		let x =
			window.Math.cos(startLat) * window.Math.sin(destLat) -
			window.Math.sin(startLat) *
			window.Math.cos(destLat) *
			window.Math.cos(destLng - startLng);
		let brng = window.Math.atan2(y, x);
		let brngDgr = SceneGIS.Math.toDegrees(brng);

		return (brngDgr + 360) % 360;
	}

	/**
	 * 动态墙
	 * @alias DynamicWallEX
	 * @constructor
	 * @param {Viewer} viewer viewer 对象
	 * @param {Object} [option] 接下来的属性对象
	 * @param {Array} [option.positions] 带有经度，纬度，高度的坐标数组，或者平面坐标
	 * @param {Number} [option.height] 墙的高度
	 * @param {Color} [option.color] 对象颜色
	 * @example
	 * var option={
	 *  positions: [118.76149744144743, 32.04446913521202, 200, 118.76149744144743, 32.04446913521202, 0],
	 *  "height":100,
	 *  "color": "rgba(130, 204, 255, 1.0)"
	 * }
	 * var bull=new DynamicWallEX(viewer,option);
	 */
	function DynamicWallEX(viewer, option) {
		this.viewer = viewer;
		option = Object.assign({}, option);
		this._owner = option.owner ? option.owner : undefined;
		if (option.color instanceof SceneGIS.Color); else {
			option.color = SceneGIS.Color.fromCssColorString(option.color);
		}

		var self = this;
		this._wall = undefined;
		this._id = option.id ? option.id : CoreEX.MathEX.createUID();
		create.bind(self)(option);
	}

	function create(d) {
		var _maximumHeights = [];
		var _minimumHeights = [];

		var ps = d.positions;
		var n = ps.length / 3;
		for (var i = 0; i < n; i++) {
			_minimumHeights.push(0);
			_maximumHeights.push(d.height ? d.height : 50);
		}

		d.diffuseColor = new SceneGIS.Color(0.0, 0.0, 0.0, 1.0);
		var WallTrail = new PolylineTrail(d);
		new WallTrailLinkMaterialPropertyEX(d.color, WallTrail, 2000);

		let scene = this.viewer.scene;

		this._wall = this.viewer.scene.primitives.add(
			new SceneGIS.Primitive({
				geometryInstances: new SceneGIS.GeometryInstance({
					geometry: new SceneGIS.WallGeometry({
						positions: Cartesian3EX.fromArrayHeights(
							d.positions,
							!scene.planeView
						),
						maximumHeights: _maximumHeights,
						minimumHeights: _minimumHeights,
					}),
				}),
				appearance: new SceneGIS.MaterialAppearance({
					material: new SceneGIS.Material({
						fabric: {
							type: "dynamicWall",
							uniforms: {
								color: d.color, //new SceneGIS.Color(0.51, 0.8, 1.0, 1.0)
							},
							source: /*glsl*/ `
                        czm_material czm_getMaterial(czm_materialInput materialInput){
                            czm_material material = czm_getDefaultMaterial(materialInput);
                            if(materialInput.st.t<0.006){
                                vec4 fragColor;
                                fragColor.rgb = color.rgb / 1.0;
                                fragColor = czm_gammaCorrect(fragColor);
                                material.emission = fragColor.rgb;
                                material.emission*=1.5;
                                material.alpha=1.0;
                                return material;
                            }
                            material.diffuse = color.rgb;
                            material.alpha=1.0-(sin(materialInput.st.t*czm_pi/2.0)*0.9+0.1);
                            // material.alpha*=fract(materialInput.st.s+fract(czm_frameNumber/420.0))*0.5+0.5;
                            return material;
                        }
                    `,
						},
					}),
					faceForward: true,
				}),
			})
		);
	}

	DynamicWallEX.prototype.getObj = function () {
		return [this._wall];
	};

	/**
	 * 改变颜色
	 * @param {Object} option 颜色参数
	 * @param {SceneGIS.Color} option.color 颜色
	 */
	DynamicWallEX.prototype.changeColor = function (option) {
		this._wall.color = option.color;
	};

	/**
	 * 删除相关对象
	 *
	 */
	DynamicWallEX.prototype.destroy = function () {
		this.viewer.scene.primitives.remove(this._wall);
	};

	Object.defineProperties(DynamicWallEX.prototype, {
		/**
		 * 显隐控制
		 *
		 * @memberof DynamicWallEX.prototype
		 * @type {Boolean}
		 */
		show: {
			get: function () {
				if (this._wall) {
					return this._wall.show;
				}
				return false;
			},
			set: function (value) {
				this._wall.show = value;
			},
		},
		/**
		 * 要素id
		 * @memberof DynamicWallEX.prototype
		 * @readonly
		 * @type {Boolean}
		 */
		id: {
			get: function () {
				return this._id;
			},
		},
		/**
		 * 要素的data
		 * @memberof  DynamicWallEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		data: {
			get: function () {
				return [this._wall];
			},
		},
		/**
		 * 要素的所属
		 * @memberof DynamicWallEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		owner: {
			get: function () {
				return this._owner;
			},
			set: function (value) {
				this._owner = value;
				this._wall.owner = value;
			},
		},
	});

	/**
	 * 综合Entity类，暂时不支持平面坐标系
	 * @class SwEntityEX
	 * @constructor
	 * @param {Viewer} viewer 
	 * @param {Object} option  各个参数很多，详见例子
	 * @example
	 * 
	 *var option = {
	 *    positions: [118.76149744144743, 32.04446913521202, 200],
	 *    wall: {
	 *        name: "",
	 *        maximumHeight":10,
	 *        "minimumHeight":60,
	 *        show: true,
	 *        positions: [],
	 *        color":"rgba(11,99,174)",
	 *        "r":200,
	 *        step: 1,
	 *        "image":"./img/城市环绕.png"
	 *    },
	 *    model: {
	 *        "speed":1,
	 *        "startHeight":0,
	 *        "uri":"./glb/建筑03.glb",
	 *        "scale":0.02
	 *    },
	 *    ellipse: {
	 *        "step":0.01,
	 *       "minHeight":10,
	 *        "maxHeight":30,
	 *        minR":100,
	 *        "maxR":200,
	 *        image: "./img/xuanzhuan.png"
	 *    },
	 *    plane: {
	 *        "offsetHeight":350,
	 *        "width":500,
	 *        height":250,
	 *        image":"./img/污水厂.png",
	 *        text":"创联水务",
	 *        "fontSize":60
	 *    },
	 *};
	 * let ex=new SwEntityEX(viewer, option);
	 */
	function SwEntityEX(viewer, option) {
		// if (viewer.scene.planeView) return;
		this._objs = [];
		this._viewer = viewer;
		this._owner = option.owner ? option.owner : undefined;
		var viewModel = option.viewModel
			? option.viewModel
			: {
				show: true,
				glowOnly: false,
				contrast: 1,
				brightness: -0.2,
				delta: 0.1,
				sigma: 10.0,
				stepSize: 1.0,
			};
		var bloom = viewer.scene.postProcessStages.bloom;
		bloom.enabled = Boolean(viewModel.show);
		bloom.uniforms.glowOnly = Boolean(viewModel.glowOnly);
		bloom.uniforms.contrast = Number(viewModel.contrast);
		bloom.uniforms.brightness = Number(viewModel.brightness);
		bloom.uniforms.delta = Number(viewModel.delta);
		bloom.uniforms.sigma = Number(viewModel.sigma);
		bloom.uniforms.stepSize = Number(viewModel.stepSize);

		this._dataSource = new SceneGIS.CustomDataSource(); //换成自定义DataSource，避免被全局清除掉
		viewer.dataSources.add(this._dataSource);
		let ds = this._dataSource;
		if (option.model) {
			this._objs.push(modelAdd(viewer, ds, option));
		}

		if (option.wall) {
			this._objs.push(wallAdd(viewer, ds, option));
		}

		if (option.ellipse) {
			this._objs.push.apply(this._objs, ellipseAdd(viewer, ds, option));
		}

		if (option.plane) {
			this._objs.push(panelAdd(viewer, ds, option));
		}

		if (option.cylinder) {
			this._objs.push(cylinderAdd(viewer, ds, option));
		}

		if (option.tip) {
			this._objs.push(tipAdd(viewer, ds, option));
		}
		this._divmain = undefined;
	}

	function cylinderAdd(viewer, ds, option) {
		//var _height=1000;
		var p = option.positions;
		var paramter = option.cylinder;
		// var startHeight=option.model.startHeight;

		// var _height=option.model.startHeight?option.model.startHeight:0;
		// var speed=option.model.speed?option.model.speed:10;
		var _heading = 0;
		function innerHeading() {
			_heading += paramter.step;
			var hpr = new SceneGIS.HeadingPitchRoll(_heading, 0, 0);
			var center = viewer.scene.planeView ? new SceneGIS.Cartesian3(p[0], p[1], p[2]) : SceneGIS.Cartesian3.fromDegrees(p[0], p[1], p[2]);
			var ori = SceneGIS.Transforms.headingPitchRollQuaternion(center, hpr);
			return ori;
		}
		var imge_Material1 = new SceneGIS.ImageMaterialProperty({
			image: paramter.image, //require("@/assets/images/animate/t.png"),
			transparent: true,
			//,
			//,//paramter.transparent ,  //是否透明
			// color: paramter.color,//new SceneGIS.Color(10/255,61/255,110/255,1)
		});
		let entity2 = ds.entities.add({
			name: "text",
			id: option.id + "*" + CoreEX.MathEX.createUID(),
			orientation: new SceneGIS.CallbackProperty(innerHeading, false),
			cylinder: {
				length: paramter.length ? paramter.length : 1000,
				topRadius: paramter.topRadius ? paramter.topRadius : 1000,
				bottomRadius: paramter.bottomRadius ? paramter.bottomRadius : 0,
				slices: paramter.slices ? paramter.slices : 4,
				material: imge_Material1,
			},
			position: viewer.scene.planeView ? new SceneGIS.Cartesian3(p[0], p[1], p[2]) : SceneGIS.Cartesian3.fromDegrees(p[0], p[1], p[2]),
		});
		return entity2;
	}

	function tipAdd(viewer, ds, option) {
		var paramter = option.tip;
		paramter.positions = option.positions;
		var tip = new DivEX(viewer, paramter);

		return tip;
	}

	function modelAdd(viewer, ds, option) {
		//var _height=1000;
		var p = option.positions;
		option.model.startHeight;

		var _height = option.model.startHeight ? option.model.startHeight : 0;
		var speed = option.model.speed ? option.model.speed : 10;

		function innerHeight() {
			if (_height >= p[2]) {
				return viewer.scene.planeView ? new SceneGIS.Cartesian3(p[0], p[1], p[2]) : SceneGIS.Cartesian3.fromDegrees(p[0], p[1], p[2]);
			} else {
				_height += speed;
				return viewer.scene.planeView ? new SceneGIS.Cartesian3(p[0], p[1], _height) : SceneGIS.Cartesian3.fromDegrees(p[0], p[1], _height);
			}
		}

		let entity2 = ds.entities.add({
			name: "text",
			id: option.id + "*" + CoreEX.MathEX.createUID(),
			model: {
				uri: option.model.uri ? option.model.uri : CoreEX.getAssetUrl("glb/建筑03.glb"),
				scale: option.model.scale,
			},
			//viewFrom: new SceneGIS.Cartesian3(-100.0, 0.0, 100.0),
			position: new SceneGIS.CallbackProperty(innerHeight, false),
			// SceneGIS.Cartesian3.fromDegrees(-111.0, 40.0, 12000)
		});
		//viewer.flyTo(entity2);
		return entity2;
	}

	function wallAdd(viewer, ds, option) {
		var p = option.positions;
		var paramter = option.wall
			? option.wall
			: {
				name: "",
				maximumHeight: 1000,
				minimumHeight: 2000,
				show: true,
				positions: [],
				color: new SceneGIS.Color(10 / 255, 61 / 255, 110 / 255, 1),
				r: 20000,
				step: 1000,
			};
		if (paramter.color instanceof SceneGIS.Color); else {
			paramter.color = SceneGIS.Color.fromCssColorString(paramter.color);
		}
		var imge_Material1 = new SceneGIS.ImageMaterialProperty({
			image: paramter.image ? paramter.image : CoreEX.getAssetUrl("img/城市环绕.png"), //require("@/assets/images/animate/t.png"),
			transparent: true,
			//,
			//,//paramter.transparent ,  //是否透明
			// color: paramter.color,//new SceneGIS.Color(10/255,61/255,110/255,1)
		});

		var _p = viewer.scene.planeView ? new SceneGIS.Cartesian3(p[0], p[1], p[2]) : SceneGIS.Cartesian3.fromDegrees(p[0], p[1], p[2]);
		var modelToWorld = SceneGIS.Transforms.eastNorthUpToFixedFrame(_p);
		var xAxis = SceneGIS.Matrix4.multiplyByPointAsVector(
			modelToWorld,
			SceneGIS.Cartesian3.UNIT_X,
			new SceneGIS.Cartesian3()
		);
		var yAxis = SceneGIS.Matrix4.multiplyByPointAsVector(
			modelToWorld,
			SceneGIS.Cartesian3.UNIT_Y,
			new SceneGIS.Cartesian3()
		);

		var maxr = paramter.r;
		var _r = maxr;
		var step = paramter.step;
		var minimumHeights = [];
		var maximumHeights = [];

		function createPositions() {
			var _pos = [];
			if (_r >= maxr) {
				//var radians=10;
				step = -step;
			} else if (_r < 0) {
				step = -step;
			}
			_r += step;

			for (var i = 0; i <= 360; i++) {
				var radians = (i / 180) * Math.PI;
				var x = _r * Math.cos(radians);
				var y = _r * Math.sin(radians);
				var point = SceneGIS.Cartesian3.add(
					_p,
					SceneGIS.Cartesian3.multiplyByScalar(
						xAxis,
						x,
						new SceneGIS.Cartesian3()
					),
					new SceneGIS.Cartesian3()
				);
				point = SceneGIS.Cartesian3.add(
					point,
					SceneGIS.Cartesian3.multiplyByScalar(
						yAxis,
						y,
						new SceneGIS.Cartesian3()
					),
					new SceneGIS.Cartesian3()
				);
				_pos.push(point);
				minimumHeights.push(paramter.minimumHeight);
				maximumHeights.push(paramter.maximumHeight);
			}
			return _pos;
		}

		var e = ds.entities.add({
			id: option.id + "*" + CoreEX.MathEX.createUID(),
			wall: {
				positions: new SceneGIS.CallbackProperty(createPositions, false), //SceneGIS.Cartesian3.fromDegreesArray(paramter.positions),
				maximumHeights: maximumHeights,
				minimumHeights: minimumHeights,
				outline: false,
				outlineColor: SceneGIS.Color.LIGHTGRAY,
				outlineWidth: 4,
				material: imge_Material1,
			},
			name: paramter.name ? paramter.name : "",
			show: paramter.show,
		});

		return e;
	}

	function panelAdd(viewer, ds, option) {
		var p = option.positions;
		var plane = option.plane;
		var divmain = document.createElement("div");
		var divid = CoreEX.MathEX.createUID();
		divmain.id = divid;
		divmain.style.position = "absolute";
		divmain.style.top = 0 + "px";
		divmain.style.width = 500 + "px";
		divmain.style.height = 250 + "px";
		// divmain.style.display = "none";
		viewer.container.appendChild(divmain);
		//document.body.appendChild(divmain);

		var divbg = document.createElement("div");
		divbg.style.float = "left";
		divbg.style.width = "100%";
		divbg.style.height = "100%";
		divbg.style.background = plane.image ? "url(" + plane.image + ")" : CoreEX.getAssetUrl("img/污水厂.png");
		divbg.style.backgroundSize = "100% 100%";
		//divmain.appendChild(divbg);

		var img = document.createElement("img");
		var imgid = CoreEX.MathEX.createUID();
		img.id = imgid;

		var canvas1 = document.createElement("canvas");
		var canvas1id = CoreEX.MathEX.createUID();
		canvas1.id = canvas1id;
		canvas1.width = 500; //plane.width? plane.width:1000;
		canvas1.height = 250; //plane.height? plane.height:500;
		//var ctx1 =  canvas.getContext('2d');

		var canvas2 = document.createElement("canvas");
		var canvas2id = CoreEX.MathEX.createUID();
		canvas2.id = canvas2id;
		canvas2.width = 500; //plane.width? plane.width:1000;
		canvas2.height = 250; //plane.height? plane.height:500;
		var offsetHeight = option.plane.offsetHeight ? option.plane.offsetHeight : 0;
		function updatePlane() {
			var heading = viewer.camera.heading;
			heading += Math.PI;
			var x = Math.sin(heading);
			var y = Math.cos(heading);
			var dir = new SceneGIS.Cartesian3(x, y, 0);
			SceneGIS.Cartesian3.normalize(dir, dir);
			return new SceneGIS.Plane(dir, 0);
		}
		//var last = "#"+canvas1id;
		var canvas = canvas1;

		function drawCanvas() {
			var ctx1 = canvas.getContext("2d");
			ctx1.clearRect(0, 0, 500, 250);
			ctx1.drawImage(img, 0, 0);
			return canvas;
		}

		var container = divmain;
		var ops = {
			backgroundColor: null,
			width: 500,
			height: 250,
		};
		function htmlTocanvas() {
			// divmain.style.display = "block";
			html2canvas(container, ops)
				.then((canva) => {
					//viewer.container.removeChild(divmain);
					var imgSrc = canva.toDataURL("image/png");
					//var img = document.querySelector("#"+imgid);

					img.src = imgSrc;

					img.onload = () => {

						drawCanvas();
						var plane1 = new SceneGIS.Entity({
							id: option.id + "*" + CoreEX.MathEX.createUID(),
							position: SceneGIS.Cartesian3.fromDegrees(
								p[0],
								p[1],
								p[2] + offsetHeight
							),
							plane: {
								plane: new SceneGIS.CallbackProperty(
									updatePlane.bind(this),
									false
								),
								dimensions: new SceneGIS.Cartesian2(plane.width, plane.height),
								material:
									//SceneGIS.Color.WHITE
									new SceneGIS.ImageMaterialProperty({
										image: plane.image,
										transparent: true,
										// ,
										// color:SceneGIS.Color.WHITE
									}),
							},
						});
						ds.entities.add(plane1);
					};
				})
				.catch((e) => {
					console.log(e);
				});
		}

		htmlTocanvas();

	}

	//带有正反旋转效果
	function ellipseAdd(viewer, ds, option) {
		var p = option.positions;
		var ep = option.ellipse;
		var speed = 0;
		var step = ep.step ? ep.step : 2;
		//var height=ep.height?ep.height:1000;

		function rotation() {
			speed += step;
			return speed;
		}

		var speed1 = 0;
		function rotation1() {
			speed1 -= step;
			return speed1;
		}

		var objs = [];
		var e = ds.entities.add({
			id: option.id + "*" + CoreEX.MathEX.createUID(),
			position: viewer.scene.planeView ? new SceneGIS.Cartesian3(p[0], p[1], p[2]) : SceneGIS.Cartesian3.fromDegrees(p[0], p[1], p[2]),
			ellipse: {
				height: ep.minHeight,
				fill: true,
				semiMinorAxis: ep.minR, //1000
				semiMajorAxis: ep.minR,
				material:
					//SceneGIS.Color.BLUE.withAlpha(0.5),
					new SceneGIS.ImageMaterialProperty({
						image: ep.image ? ep.image : CoreEX.getAssetUrl("img/xuanzhuan.png"),
						repeat: new SceneGIS.Cartesian2(1, 1),
						//color: SceneGIS.Color.BLUE,
						transparent: 0.1,
					}),
				stRotation: new SceneGIS.CallbackProperty(rotation, false),
				zIndex: 2,
			},
		});
		objs.push(e);
		var e1 = ds.entities.add({
			id: option.id + "*" + CoreEX.MathEX.createUID(),
			position: viewer.scene.planeView ? new SceneGIS.Cartesian3(p[0], p[1], p[2]) : SceneGIS.Cartesian3.fromDegrees(p[0], p[1], p[2]),
			ellipse: {
				height: ep.maxHeight,
				fill: true,
				semiMinorAxis: ep.maxR, //20000
				semiMajorAxis: ep.maxR,
				material: new SceneGIS.ImageMaterialProperty({
					image: ep.image ? ep.image : CoreEX.getAssetUrl("img/xuanzhuan.png"),
					repeat: new SceneGIS.Cartesian2(1, 1),
					transparent: 0.1,
				}),
				stRotation: new SceneGIS.CallbackProperty(rotation1, false),
				zIndex: 2,
			},
		});
		objs.push(e1);
		return objs;
	}

	Object.defineProperties(SwEntityEX.prototype, {
		/**
		 * 显隐控制
		 *
		 * @memberof  SwEntityEX.prototype
		 * @type {Boolean}
		 */
		show: {
			get: function () {
				if (this._objs[0]) {
					return this._objs[0].show;
				}
				return false;
			},
			set: function (value) {
				for (var obj of this._objs) {
					if (obj) {
						obj.show = value;
					}
				}
				this._dataSource.show = value;
			},
		},
		/**
		 * 要素id
		 * @memberof  SwEntityEX.prototype
		 * @readonly
		 * @type {Boolean}
		 */
		id: {
			get: function () {
				return this._id;
			},
		},
		/**
		 * 要素的data
		 * @memberof   SwEntityEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		data: {
			get: function () {
				return this._objs;
			},
		},
		/**
		 * 要素的所属
		 * @memberof  SwEntityEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		owner: {
			get: function () {
				return this._owner;
			},
			set: function (value) {
				this._owner = value;

				for (var obj of this._objs) {
					if (obj) {
						obj.owner = value;
					}


				}
			},
		},
	});

	SwEntityEX.prototype.getObj = function () {
		return this._objs;
	};
	/**
	 * 改变颜色
	 * @param {Object} option 颜色参数
	 * @param {SceneGIS.Color} option.color 颜色
	 */
	SwEntityEX.prototype.changeColor = function (option) {
		// this.obj.color = option.color;
	};
	/**
	 * 销毁清除对象
	 */
	SwEntityEX.prototype.destroy = function () {
		for (var obj of this._objs) {
			if (obj instanceof DivEX) {
				obj.destroy();
			} else {
				if (!this._dataSource.entities.remove(obj));
			}
		}

		this.viewer.dataSources.remove(this._dataSource);

	};

	/**
	 *  绘制饼图类，暂时不支持平面坐标系
	 * @alias PieChartEX
	 * @constructor
	 * @param {Viewer} viewer 
	 * @param {Object} option  各个参数很多，详见例子
	 * @example
	 *var option = {
	 *"positions": [118.76149744144743, 32.04446913521202, 200],
	 *"polygon": {
	 *	"name": "",
	 *	"maximumHeight": 1000,
	 *	"minimumHeight": 2000,
	 *	"show": true,
	 *	"positions": [],
	 *	"color": "rgba(10,61,110)",
	 *	"r": 5000,
	 *	"step": 1000
	 *},
	 *"radiumiddle":"10",
	 *"text1":"已处理",
	 *"text2":"未处理",
	 *"line": {
	 *	"name": "PolylineTrailLink_1",
	 *	"positions": [
	 *		118.76149744144743,
	 *		32.04446913521202,
	 *		5000
	 *	],
	 *	"img": "./img/white_line.png",
	 *	"icon": "./img/污水厂.png",
	 *	"color": "rgba(213, 197, 63.0, 1.0)",
	 *	"repeat": 2,
	 *	"linewidth": 0.0,
	 *	"lineHeight": 400,
	 *	"fillrate": 1.0,
	 *	"nearDistance": 1000,
	 *	"farDistance": "Infinity",
	 *	"radius": 100
	 *}
	 *};
	 * let ex=new PieChartEX(viewer, option);
	 */
	function PieChartEX(viewer, option) {
		if (viewer.scene.planeView) return;
		this._objs = [];
		this._viewer = viewer;

		var viewModel = option.viewModel
			? option.viewModel
			: {
				show: true,
				glowOnly: false,
				contrast: 1,
				brightness: -0.2,
				delta: 0.1,
				sigma: 10.0,
				stepSize: 1.0,
			};
		var bloom = viewer.scene.postProcessStages.bloom;
		bloom.enabled = Boolean(viewModel.show);
		bloom.uniforms.glowOnly = Boolean(viewModel.glowOnly);
		bloom.uniforms.contrast = Number(viewModel.contrast);
		bloom.uniforms.brightness = Number(viewModel.brightness);
		bloom.uniforms.delta = Number(viewModel.delta);
		bloom.uniforms.sigma = Number(viewModel.sigma);
		bloom.uniforms.stepSize = Number(viewModel.stepSize);

		this._dataSource = new SceneGIS.CustomDataSource(); //换成自定义DataSource，避免被全局清除掉
		viewer.dataSources.add(this._dataSource);
		let ds = this._dataSource;


		if (option.polygon) {
			this._objs.push.apply(this._objs, polygonAdd(viewer, ds, option));
		}

		if (option.line) {
			//this._objs.push(lineAdd(viewer,option));
			this._objs.push.apply(this._objs, lineAdd(viewer, ds, option));
		}
		this._divmain = undefined;
	}

	function polygonAdd(viewer, ds, option) {
		var p = option.positions;
		var paramter = option.polygon
			? option.polygon
			: {
				name: "",
				show: true,
				positions: [],
				color: new SceneGIS.Color(10 / 255, 61 / 255, 110 / 255, 1),
				r: 20,
				step: 1000,
			};
		if (paramter.color instanceof SceneGIS.Color); else {
			paramter.color = SceneGIS.Color.fromCssColorString(paramter.color);
		}
		new SceneGIS.ImageMaterialProperty({
			image: paramter.image, //require("@/assets/images/animate/t.png"),
			transparent: true,
			//,
			//,//paramter.transparent ,  //是否透明
			// color: paramter.color,//new SceneGIS.Color(10/255,61/255,110/255,1)
		});

		var _p = SceneGIS.Cartesian3.fromDegrees(p[0], p[1], p[2]);
		var modelToWorld = SceneGIS.Transforms.eastNorthUpToFixedFrame(_p);
		var xAxis = SceneGIS.Matrix4.multiplyByPointAsVector(
			modelToWorld,
			SceneGIS.Cartesian3.UNIT_X,
			new SceneGIS.Cartesian3()
		);
		var yAxis = SceneGIS.Matrix4.multiplyByPointAsVector(
			modelToWorld,
			SceneGIS.Cartesian3.UNIT_Y,
			new SceneGIS.Cartesian3()
		);

		var maxr = paramter.r;
		var _r = maxr;
		paramter.step;
		var radiumiddle = 60;
		var radiusmax = 0;
		function createPositions() {
			var _pos = [];
			if (radiusmax <= radiumiddle) {
				//var radians=10;
				radiusmax += 1;
			}

			// _r +=step;
			_pos.push(_p);
			for (var i = 0; i <= radiusmax; i++) {
				var radians = (i / 180) * Math.PI;
				var x = _r * Math.cos(radians);
				var y = _r * Math.sin(radians);
				var point = SceneGIS.Cartesian3.add(
					_p,
					SceneGIS.Cartesian3.multiplyByScalar(
						xAxis,
						x,
						new SceneGIS.Cartesian3()
					),
					new SceneGIS.Cartesian3()
				);
				point = SceneGIS.Cartesian3.add(
					point,
					SceneGIS.Cartesian3.multiplyByScalar(
						yAxis,
						y,
						new SceneGIS.Cartesian3()
					),
					new SceneGIS.Cartesian3()
				);
				_pos.push(point);
			}
			_pos.push(_p);
			var hy = new SceneGIS.PolygonHierarchy(_pos);

			return hy;
		}
		function createPositions1() {
			var _pos = [];
			// _r +=step;
			_pos.push(_p);
			for (var i = radiusmax; i <= 360; i++) {
				var radians = (i / 180) * Math.PI;
				var x = _r * Math.cos(radians);
				var y = _r * Math.sin(radians);
				var point = SceneGIS.Cartesian3.add(
					_p,
					SceneGIS.Cartesian3.multiplyByScalar(
						xAxis,
						x,
						new SceneGIS.Cartesian3()
					),
					new SceneGIS.Cartesian3()
				);
				point = SceneGIS.Cartesian3.add(
					point,
					SceneGIS.Cartesian3.multiplyByScalar(
						yAxis,
						y,
						new SceneGIS.Cartesian3()
					),
					new SceneGIS.Cartesian3()
				);
				_pos.push(point);
			}
			_pos.push(_p);
			var hy = new SceneGIS.PolygonHierarchy(_pos);

			return hy;
		}

		var e = ds.entities.add({
			id: option.id + "*" + CoreEX.MathEX.createUID(),
			polygon: {
				hierarchy:
					//createPositions(),
					// SceneGIS.Cartesian3.fromDegreesArray([
					//     -108.0,
					//     42.0,
					//     -100.0,
					//     42.0,
					//     -104.0,
					//     40.0,
					//   ]),
					new SceneGIS.CallbackProperty(createPositions, false), //SceneGIS.Cartesian3.fromDegreesArray(paramter.positions),
				height: 1000,
				extrudedHeight: 2000,
				material: SceneGIS.Color.BLUE,
				closeTop: true,
				closeBottom: true,
			},
			name: paramter.name ? paramter.name : "",
			show: paramter.show,
		});
		var e1 = ds.entities.add({
			id: option.id + "*" + CoreEX.MathEX.createUID(),
			polygon: {
				hierarchy:
					//posAll[1],
					//createPositions(),
					// SceneGIS.Cartesian3.fromDegreesArray([
					//     -108.0,
					//     42.0,
					//     -100.0,
					//     42.0,
					//     -104.0,
					//     40.0,
					//   ]),
					new SceneGIS.CallbackProperty(createPositions1, false), //SceneGIS.Cartesian3.fromDegreesArray(paramter.positions),
				height: 1000,
				extrudedHeight: 2000,
				material: SceneGIS.Color.GREEN,
				closeTop: true,
				closeBottom: true,
			},
			name: paramter.name ? paramter.name : "",
			show: paramter.show,
		});

		return [e, e1];
	}

	function lineAdd(viewer, ds, option) {
		var d = option.line;
		d.diffuseColor = new SceneGIS.Color(0.0, 0.0, 0.0, 1.0);
		var PolylineTrail = new PolylineTrailEX(d);
		new PolylineTrailLinkMaterialPropertyEX(
			d.color,
			PolylineTrail,
			2000
		);
		//var positions=[118.71887715591848, 31.783134797714013,500,118.97392477305664, 31.963270718110504,500];

		SceneGIS.Cartesian3.fromDegreesArrayHeights(d.positions);
		// let item = ds.entities.add({
		//   name: d.name,
		//   polyline: {
		//     positions: SceneGIS.Cartesian3.fromDegreesArrayHeights(d.positions),
		//     width: 12,
		//     material: p,

		//     show:true
		//   }
		// });
		[d.positions[0], d.positions[1], d.positions[2]];
		var item1 = ds.entities.add({
			id: option.id + "*" + CoreEX.MathEX.createUID(),
			position: SceneGIS.Cartesian3.fromDegrees(
				d.positions[0],
				d.positions[1],
				d.positions[2]
			),
			label: {
				showBackground: true,
				text: "未超期(80%)",
				font: "15px sans-serif",
				backgroundColor: SceneGIS.Color.GREEN,
				show: true,
				pixelOffset: new SceneGIS.Cartesian2(50, 0),
			},
		});
		var item2 = ds.entities.add({
			id: option.id + "*" + CoreEX.MathEX.createUID(),
			position: SceneGIS.Cartesian3.fromDegrees(
				d.positions[0],
				d.positions[1],
				d.positions[2]
			),
			label: {
				showBackground: true,
				text: "超期(20%)",
				font: "15px sans-serif",
				show: true,
				backgroundColor: SceneGIS.Color.BLUE,
				pixelOffset: new SceneGIS.Cartesian2(-50, 0),
			},
		});
		return [item1, item2];
	}


	Object.defineProperties(PieChartEX.prototype, {
		/**
		 * 显隐控制
		 *
		 * @memberof  PieChartEX.prototype
		 * @type {Boolean}
		 */
		show: {
			get: function () {
				if (this._objs[0]) {
					return this._objs[0].show;
				}
				return false;
			},
			set: function (value) {
				for (var obj of this._objs) {
					obj.show = value;
				}
			},
		},
		/**
		 * 要素id
		 * @memberof  PieChartEX.prototype
		 * @readonly
		 * @type {Boolean}
		 */
		id: {
			get: function () {
				return this._id;
			},
		},
		/**
		 * 要素的data
		 * @memberof   PieChartEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		data: {
			get: function () {
				return this._objs;
			},
		},
		/**
		 * 要素的所属
		 * @memberof  PieChartEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		owner: {
			get: function () {
				return this._owner;
			},
			set: function (value) {
				this._owner = value;
				for (var obj of this._objs) {
					obj.owner = value;
				}
			},
		},
	});

	PieChartEX.prototype.getObj = function () {
		return this._objs;
	};

	/**
	 * 改变颜色
	 * @param {Object} option 颜色参数
	 * @param {SceneGIS.Color} option.color 颜色
	 */
	PieChartEX.prototype.changeColor = function (option) {
		// this.obj.color = option.color;
	};
	/**
	 * 销毁清除对象
	 */
	PieChartEX.prototype.destroy = function () {
		for (var obj of this._objs) {
			if (obj instanceof SceneGisDiv) {
				obj.destroy();
			} else {
				this._dataSource.entities.remove(obj);
			}
		}
		this.viewer.dataSources.remove(this._dataSource);
	};

	/**
	 * 水的对象，暂时不支持平面坐标系,内部调用的是SceneGIS.Water 对象
	 * @alias WaterEX
	 * @constructor
	 * @param {viewer} viewer 
	 * @param {Object} option 
	 * @param {Array} option.positions 位置
	 */
	function WaterEX(viewer, option) {
		// if (viewer.scene.planeView) return;
		option = Object.assign({}, option);
		this.option = option;
		this._id = option.id ? option.id : CoreEX.MathEX.createUID();
		this.viewer = viewer;
		this._owner = option.owner ? option.owner : undefined;

		//var color=new SceneGIS.Color.fromCssColorString(option.color)

		this.useHeight = option.useHeight;
		let polygonHierarchy = new SceneGIS.PolygonHierarchy(
			viewer.scene.planeView === true ? SceneGIS.Cartesian3.unpackArray(option.positions)
				: SceneGIS.Cartesian3.fromDegreesArrayHeights(option.positions)
		);
		let polygon = new SceneGIS.PolygonGeometry({
			polygonHierarchy: polygonHierarchy,
			vertexFormat: SceneGIS.EllipsoidSurfaceAppearance.VERTEX_FORMAT,
			planeView: viewer.scene.planeView,
		});

		let water = new SceneGIS.Water({
			geometry: polygon,
			clampToGround: true
		});

		this.obj = water;

	}
	WaterEX.prototype.update = function () {

	};

	WaterEX.prototype.getObj = function () {
		return [this.obj];
	};

	/**
	* 改变颜色
	* @param {Object} option 颜色参数
	* @param {SceneGIS.Color} option.color 颜色
	*/
	WaterEX.prototype.changeColor = function (option) {
		// this.obj.color = option.color;
	};
	/**
	 * 销毁清除对象
	 */
	WaterEX.prototype.destroy = function () {
		this.viewer.scene.primitives.remove(this.obj._primitive);
	};

	Object.defineProperties(WaterEX.prototype, {
		/**
	  * 显隐控制
	  *
	  * @memberof   WaterEX.prototype
	  * @type {Boolean}
	  */
		show: {
			get: function () {
				if (this.obj) {
					return this.obj._primitive.show;
				}
				return false;
			},
			set: function (value) {
				this.obj._primitive.show = value;
			}
		},
		/**
	   * 要素id
	   * @memberof   WaterEX.prototype
	   * @readonly
	   * @type {Boolean}
	   */
		id: {
			get: function () {
				return this._id;
			},
		},
		/**
		 * 要素的data
		 * @memberof    WaterEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		data: {
			get: function () {
				return [this.obj];
			},
		},
		/**
		 * 要素的所属
		 * @memberof   WaterEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		owner: {
			get: function () {
				return this._owner;
			},
			set: function (value) {
				this._owner = value;
			},
		},

	});

	/**
	 * PointMaterialType类型
	 *
	 * @enum {String}
	 */
	var PointMaterialType = {
		/**
		 * 图标标注
		 * @type {String}
		 */
		"icon": "icon",
		/**
		 * 旋转圆
		 * @type {String}
		 */
		"rotate": "rotate",
		/**
		 * 扩散圆
		 * @type {String}
		 */
		"spread": "spread",
		/**
		 * 闪点圆
		 * @type {String}
		 */
		"shine": "shine",
		/**
		 * 呼吸灯
		 * @type {String}
		 */
		"breathe": "breathe",


	};
	var PointMaterialType$1 = Object.freeze(PointMaterialType);

	/**
	 * 自定义点对象
	 * @alias PointEX
	 * @constructor
	 * @param {Viewer} viewer viewer对象
	 * @param {Object} option  内部对象参数，不同的对象不一样
	 * @param {String} option.id 对象id
	 * @param {Object} option.owner 是否显示
	 * @param {Object} option.position 位置
	 * @param {PointMaterialType} option.material 类型 {@link PointMaterialType}
	 * @param {String} option.image 图片
	 * @param {String} option.color 颜色
	 * @param {String} option.innerColor 呼吸灯的内颜色
	 * @param {String} option.outerColor 呼吸灯的外颜色
	 */
	function PointEX(viewer, option) {
		this._viewer = viewer;
		this._primitive = undefined;
		this._owner = option.owner ? option.owner : undefined;
		this._id = option.id ? option.id : CoreEX.MathEX.createUID();
		init$e.bind(this)(option);
	}

	function init$e(option) {
		let center_ = new SceneGIS.Cartesian3();
		let scene = this._viewer.scene;
		if (scene.planeView) {
			center_ = new SceneGIS.Cartesian3(option.position[0], option.position[1], option.position[2]);
		}
		else {
			center_ = SceneGIS.Cartesian3.fromDegrees(option.position[0], option.position[1]);
		}
		const circle = new SceneGIS.CircleGeometry({
			center: center_,
			radius: option.radius,
			vertexFormat: SceneGIS.VertexFormat.POSITION_NORMAL_AND_ST,
			planeView: scene.planeView
		});
		let material = getMaterial$2(option);
		if (!material) {
			console.error("customPoint类型的material错误");
			return;
		}
		this._primitive = this._viewer.scene.primitives.add(new SceneGIS.GroundPrimitive({
			geometryInstances: new SceneGIS.GeometryInstance({
				geometry: circle,
				id: option.id
			}),
			appearance: new SceneGIS.Appearance({
				material: material
			})
		}));
		this._primitive.owner = this.owner;
	}

	function getMaterial$2(option) {
		let material;
		switch (option.material) {
			case "icon": {
				material = new SceneGIS.Material({
					fabric: {
						type: 'point_icon',
						uniforms: {
							image: option.image,
						},
						source:/* glsl */`
                        uniform sampler2D image;
                        czm_material czm_getMaterial(czm_materialInput materialInput){
                            czm_material material = czm_getDefaultMaterial(materialInput);
                            vec4 color = texture2D(image, materialInput.st);
                            material.diffuse = color.rgb;
                            material.alpha = color.a;
                            return material;
                        }
                    `
					}
				});
				break;
			}
			case "rotate": {
				material = new SceneGIS.Material({
					fabric: {
						type: 'point_rotate',
						uniforms: {
							image: option.image,
						},
						source:/* glsl */`
                        uniform sampler2D image;
                        czm_material czm_getMaterial(czm_materialInput materialInput){
                            czm_material material = czm_getDefaultMaterial(materialInput);
                            vec2 st = materialInput.st;
                            st = st - vec2(.5,.5);
                            float angle = fract(czm_frameNumber / 360.0)*6.282;
                            st = vec2(st.s*cos(angle)-st.t*sin(angle),st.s*sin(angle)+st.t*cos(angle));
                            st = st + vec2(.5,.5);
                            vec4 color = texture2D(image, st);
                            material.diffuse = color.rgb;
                            material.alpha = color.a;
                            return material;
                        }
                    `
					}
				});
				break;
			}
			case "spread": {
				material = new SceneGIS.Material({
					fabric: {
						type: 'point_spread',
						uniforms: {
							color: SceneGIS.Color.fromCssColorString(option.color),
						},
						source:/* glsl */`
                        czm_material czm_getMaterial(czm_materialInput materialInput){
                            czm_material material = czm_getDefaultMaterial(materialInput);
                            vec2 st = materialInput.st;
                            float dis = length(vec2(st.s-.5,st.t-.5))*2.0;
                            float dynamicRadius=fract(czm_frameNumber / 180.0);
                            float alpha=0.0;
                            if(dis<dynamicRadius){
                                alpha=dis/dynamicRadius;
                                alpha=pow(alpha,2.0);
                            }
                            material.diffuse = color.rgb;
                            material.alpha = alpha;
                            return material;
                        }
                    `
					}
				});
				break;
			}
			case "shine": {
				material = new SceneGIS.Material({
					fabric: {
						type: 'point_shine',
						uniforms: {
							color: SceneGIS.Color.fromCssColorString(option.color),
						},
						source:/* glsl */`
                        czm_material czm_getMaterial(czm_materialInput materialInput){
                            czm_material material = czm_getDefaultMaterial(materialInput);
                            vec2 st = materialInput.st;
                            float dis = length(vec2(st.s-.5,st.t-.5))*2.0;
                            float dynamicRadius=fract(czm_frameNumber / 60.0)/2.0+.5;
                            float alpha=0.0;
                            if(dis>.5 && dis<dynamicRadius){
                                alpha=dis/dynamicRadius;
                                alpha=pow(alpha,3.0);
                            }
                            if(dis<=.5){
                                alpha=1.0;
                            }
                            material.diffuse = color.rgb;
                            material.alpha = alpha;
                            return material;
                        }
                    `
					}
				});
				break;
			}
			case "breathe": {
				material = new SceneGIS.Material({
					fabric: {
						type: 'point_breathe',
						uniforms: {
							innerColor: SceneGIS.Color.fromCssColorString(option.innerColor),
							outColor: SceneGIS.Color.fromCssColorString(option.outColor)
						},
						source:/* glsl */`
                        czm_material czm_getMaterial(czm_materialInput materialInput){
                            czm_material material = czm_getDefaultMaterial(materialInput);
                            vec2 st = materialInput.st;
                            float dis = length(vec2(st.s-.5,st.t-.5))*2.0;
                            float dynamicRadius=fract(czm_frameNumber / 120.0)*2.0-1.0;
                            dynamicRadius=abs(dynamicRadius)*.5+.5;
                            float alpha=0.0;
                            vec3 color;
                            if(dis<dynamicRadius){
                                alpha=.7;
                                float combine = dis/dynamicRadius;
                                combine=pow(combine,2.0);
                                color = mix(innerColor.rgb,outColor.rgb,combine);
                            }
                            material.diffuse = color;
                            material.alpha = alpha;
                            return material;
                        }
                    `
					}
				});
				break;
			}
		}
		return material;
	}

	Object.defineProperties(PointEX.prototype, {
		/**
		 * 显隐控制
		 *
		 * @memberof  PointEX.prototype
		 * @type {Boolean}
		 */
		show: {
			get: function () {
				if (this._primitive) {
					return this._primitive.show;
				}
				return false;
			},
			set: function (value) {
				this._primitive.show = value;
			},
		},
		/**
		 * 要素id
		 * @memberof  PointEX.prototype
		 * @readonly
		 * @type {Boolean}
		 */
		id: {
			get: function () {
				return this._id;
			},
		},
		/**
		 * 要素的data
		 * @memberof   PointEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		data: {
			get: function () {
				return [this._primitive];
			},
		},
		/**
		 * 要素的所属
		 * @memberof  PointEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		owner: {
			get: function () {
				return this._owner;
			},
			set: function (value) {
				this._owner = value;
				this._primitive.owner = this.owner;
			},
		},
		/**
		 * Viewer对象
		 * @memberof  PointEX.prototype
		 * @readonly
		 * @type {Viewer}
		 */
		viewer: {
			get: function () {
				return this._viewer;
			}
		},
	});

	PointEX.prototype.reset = function (oldOption, newOption) {
		if (oldOption.material != newOption.material) {
			let newMaterial = getMaterial$2(newOption);
			this._primitive.appearance.material = newMaterial;
		} else {
			updateMaterial$2(this._primitive.appearance.material, newOption);
		}
	};

	/**
	 * 改变颜色
	 * @param {Object} option 颜色参数
	 * @param {SceneGIS.Color} option.color 颜色
	 */
	PointEX.prototype.changeColor = function (option) {
		// this.obj.color = option.color;
	};
	/**
	 * 销毁清除对象
	 */
	PointEX.prototype.destroy = function () {
		this.viewer.scene.primitives.remove(this._primitive);
	};

	function updateMaterial$2(material, option) {
		switch (option.material) {
			case "icon": {
				material.uniforms.image = option.image;
				break;
			}
			case "rotate": {
				material.uniforms.image = option.image;
				break;
			}
			case "spread": {
				material.uniforms.color = SceneGIS.Color.fromCssColorString(option.color);
				break;
			}
			case "shine": {
				material.uniforms.color = SceneGIS.Color.fromCssColorString(option.color);
				break;
			}
			case "breathe": {
				material.uniforms.innerColor = SceneGIS.Color.fromCssColorString(option.innerColor);
				material.uniforms.outColor = SceneGIS.Color.fromCssColorString(option.outColor);
				break;
			}
		}
	}

	/**
	 * LineMaterialType类型
	 *
	 * @enum {String}
	 */
	var LineMaterialType = {
		/**
		 * 普通线
		 * @type {String}
		 */
		'color': 'color',
		/**
		 * 贴地箭头
		 * @type {String}
		 */
		'arrow': 'arrow',
		/**
		 * 贴地虚线
		 * @type {String}
		 */
		'dash': 'dash',
		/**
		 * 贴地轨迹
		 * @type {String}
		 */
		'trajectory': 'trajectory'



	};
	var LineMaterialType$1 = Object.freeze(LineMaterialType);

	/**
	 * 自定义贴地线
	 * @alias GroundLineEX
	 * @constructor
	 * @param {Viewer} viewer viewer对象
	 * @param {Object} option  内部对象参数，不同的对象不一样
	 * @param {String} option.id 对象id
	 * @param {Object} option.owner 是否显示
	 * @param {Object} option.position 位置
	 * @param {LineMaterialType} option.material 类型 {@link LineMaterialType}
	 * @param {String} option.color 颜色
	 * @param {String} option.gapColor 间隔颜色
	 * @param {Number} option.width 线宽
	 * @param {Number} option.dashLength dash的长度
	 * 
	 */
	function GroundLineEX(viewer, option) {
		this._viewer = viewer;
		this._primitive = undefined;
		this._owner = option.owner ? option.owner : undefined;
		this._id = option.id ? option.id : CoreEX.MathEX.createUID();
		init$d.bind(this)(option);
	}

	function init$d(option) {
		let scene = this._viewer.scene;
		let originPoints = [];
		if (scene.planeView) {
			for (let i = 0; i < option.positions.length; i += 2) {
				originPoints.push(new SceneGIS.Cartesian3(option.positions[i], option.positions[i + 1], option.positions[i + 2]));
			}
		}
		else {
			originPoints = SceneGIS.Cartesian3.fromDegreesArray(option.positions);
		}
		const polyline = new SceneGIS.GroundPolylineGeometry({
			positions: originPoints,
			width: option.width
		});
		let material = getMaterial$1(option);
		if (!material) {
			console.error("customGroundLine类型的material错误");
			return;
		}

		this._primitive = this._viewer.scene.groundPrimitives.add(new SceneGIS.GroundPolylinePrimitive({
			geometryInstances: new SceneGIS.GeometryInstance({
				geometry: polyline,
				id: option.id
			}),
			appearance: new SceneGIS.PolylineMaterialAppearance({
				material: material
			})
		}));
	}

	function getMaterial$1(option) {
		let material;
		switch (option.material) {
			case 'color': {
				material = new SceneGIS.Material({
					fabric: {
						type: 'Color',
						uniforms: {
							color: SceneGIS.Color.fromCssColorString(option.color),
						}
					}
				});
				break;
			}
			case 'arrow': {
				material = new SceneGIS.Material({
					fabric: {
						type: 'PolylineArrow',
						uniforms: {
							color: SceneGIS.Color.fromCssColorString(option.color),
						}
					}
				});
				break;
			}
			case 'dash': {
				material = new SceneGIS.Material({
					fabric: {
						type: 'PolylineDash',
						uniforms: {
							color: SceneGIS.Color.fromCssColorString(option.color),
							gapColor: SceneGIS.Color.fromCssColorString(option.gapColor),
							dashLength: option.dashLength
						}
					}
				});
				break;
			}
			case 'trajectory': {
				material = new SceneGIS.Material({
					fabric: {
						type: 'groundLine_trajectory',
						uniforms: {
							color: SceneGIS.Color.fromCssColorString(option.color),
						},
						source:/* glsl */`
                        czm_material czm_getMaterial(czm_materialInput materialInput){
                            czm_material material = czm_getDefaultMaterial(materialInput);
                            vec2 st =  materialInput.st;
                            float offset = fract(czm_frameNumber / 240.0);
                            st.s=fract(st.s-offset);
                            float alpha=st.s;
                            material.emission = color.rgb;
                            material.alpha = alpha;
                            return material;
                        }
                    `
					}
				});
				break;
			}
		}
		return material;
	}

	GroundLineEX.prototype.reset = function (oldOption, newOption) {
		if (oldOption.material != newOption.material) {
			let newMaterial = getMaterial$1(newOption);
			this._primitive.appearance.material = newMaterial;
		} else {
			updateMaterial$1(this._primitive.appearance.material, newOption);
		}
	};

	function updateMaterial$1(material, option) {
		switch (option.material) {
			case 'color': {
				material.uniforms.color = SceneGIS.Color.fromCssColorString(option.color);
				break;
			}
			case 'arrow': {
				material.uniforms.color = SceneGIS.Color.fromCssColorString(option.color);
				break;
			}
			case 'dash': {
				material.uniforms.color = SceneGIS.Color.fromCssColorString(option.color);
				material.uniforms.gapColor = SceneGIS.Color.fromCssColorString(option.gapColor);
				material.uniforms.dashLength = option.dashLength;
				break;
			}
			case 'trajectory': {
				material.uniforms.color = SceneGIS.Color.fromCssColorString(option.color);
				break;
			}
		}
	}

	Object.defineProperties(GroundLineEX.prototype, {
		/**
		 * 显隐控制
		 *
		 * @memberof  GroundLineEX.prototype
		 * @type {Boolean}
		 */
		show: {
			get: function () {
				if (this._primitive) {
					return this._primitive.show;
				}
				return false;
			},
			set: function (value) {
				this._primitive.show = value;
			},
		},
		/**
		 * 要素id
		 * @memberof  GroundLineEX.prototype
		 * @readonly
		 * @type {Boolean}
		 */
		id: {
			get: function () {
				return this._id;
			},
		},
		/**
		 * 要素的data
		 * @memberof   GroundLineEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		data: {
			get: function () {
				return [this._primitive];
			},
		},
		/**
		 * 要素的所属
		 * @memberof  GroundLineEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		owner: {
			get: function () {
				return this._owner;
			},
			set: function (value) {
				this._owner = value;
				this._primitive.owner = value;
			},
		},
	});
	/**
	 * 改变颜色
	 * @param {Object} option 颜色参数
	 * @param {SceneGIS.Color} option.color 颜色
	 */
	GroundLineEX.prototype.changeColor = function (option) {
		// this.obj.color = option.color;
	};
	/**
	 * 销毁清除对象
	 */
	GroundLineEX.prototype.destroy = function () {
		this._viewer.scene.groundPrimitives.remove(this._primitive);
	};

	/**
	 * 自定义线
	 * @alias LineEX
	 * @constructor
	 * @param {Viewer} viewer viewer对象
	 * @param {Object} option  内部对象参数，不同的对象不一样
	 * @param {String} option.id 对象id
	 * @param {Object} option.owner 是否显示
	 * @param {Object} option.positions 位置
	 * @param {String} option.type 类型 是否支持贝塞尔曲线，当值为"bezier"时，是贝塞尔曲线
	 * @param {LineMaterialType} option.material 类型 {@link LineMaterialType}
	 * @param {String} option.color 颜色
	 * @param {String} option.gapColor 间隔颜色
	 * @param {Number} option.width 线宽
	 * @param {Number} option.dashLength dash的长度
	*/
	function LineEX(viewer, option) {
		this._viewer = viewer;
		this._primitive = undefined;
		this._owner = option.owner ? option.owner : undefined;
		this._id = option.id ? option.id : CoreEX.MathEX.createUID();
		init$c.bind(this)(option);
	}

	function init$c(option) {
		let polyline;
		let scene = this._viewer.scene;
		let originPoints = [];
		if (scene.planeView) {
			for (let i = 0; i < option.positions.length; i += 3) {
				originPoints.push(new SceneGIS.Cartesian3(option.positions[i], option.positions[i + 1], option.positions[i + 2]));
			}
		}
		else {
			originPoints = SceneGIS.Cartesian3.fromDegreesArrayHeights(option.positions);
		}

		if (option.type == "bezier") {

			polyline = new SceneGIS.PolylineGeometry({
				positions: CreateBezierPoints$1(originPoints, originPoints.length * 3),
				width: option.width,
				arcType: SceneGIS.ArcType.NONE,
				vertexFormat: SceneGIS.PolylineMaterialAppearance.VERTEX_FORMAT,
				planeView: scene.planeView
			});
		} else {
			polyline = new SceneGIS.PolylineGeometry({
				positions: originPoints,
				width: option.width,
				arcType: SceneGIS.ArcType.NONE,
				vertexFormat: SceneGIS.PolylineMaterialAppearance.VERTEX_FORMAT,
				planeView: scene.planeView
			});
		}
		let material = getMaterial(option);
		if (!material) {
			console.error("customLine类型的material错误");
			return;
		}

		this._primitive = this._viewer.scene.primitives.add(new SceneGIS.Primitive({
			geometryInstances: new SceneGIS.GeometryInstance({
				geometry: polyline,
				id: option.id
			}),
			appearance: new SceneGIS.PolylineMaterialAppearance({
				material: material
			})
		}));
	}

	function getMaterial(option) {
		let material;
		switch (option.material) {
			case 'color': {
				material = new SceneGIS.Material({
					fabric: {
						type: 'Color',
						uniforms: {
							color: SceneGIS.Color.fromCssColorString(option.color),
						}
					}
				});
				break;
			}
			case 'arrow': {
				material = new SceneGIS.Material({
					fabric: {
						type: 'PolylineArrow',
						uniforms: {
							color: SceneGIS.Color.fromCssColorString(option.color),
						}
					}
				});
				break;
			}
			case 'dash': {
				material = new SceneGIS.Material({
					fabric: {
						type: 'PolylineDash',
						uniforms: {
							color: SceneGIS.Color.fromCssColorString(option.color),
							gapColor: SceneGIS.Color.fromCssColorString(option.gapColor),
							dashLength: option.dashLength
						}
					}
				});
				break;
			}
			case 'trajectory': {
				material = new SceneGIS.Material({
					fabric: {
						type: 'groundLine_trajectory',
						uniforms: {
							color: SceneGIS.Color.fromCssColorString(option.color),
						},
						source:/* glsl */`
                        czm_material czm_getMaterial(czm_materialInput materialInput){
                            czm_material material = czm_getDefaultMaterial(materialInput);
                            vec2 st =  materialInput.st;
                            float offset = fract(czm_frameNumber / 240.0);
                            st.s=fract(st.s-offset);
                            float alpha=st.s;
                            material.emission = color.rgb;
                            material.alpha = alpha;
                            return material;
                        }
                    `
					}
				});
				break;
			}
		}
		return material;
	}

	// 贝赛尔曲线算法
	function CreateBezierPoints$1(anchorpoints, pointsAmount) {
		var points = [];
		for (var i = 0; i < pointsAmount; i++) {
			var point = MultiPointBezier$1(anchorpoints, i / pointsAmount);
			points.push(point);
		}
		return points;
	}

	function MultiPointBezier$1(points, t) {
		var len = points.length;
		var x = 0, y = 0, z = 0;
		var erxiangshi = function (start, end) {
			var cs = 1, bcs = 1;
			while (end > 0) {
				cs *= start;
				bcs *= end;
				start--;
				end--;
			}
			return (cs / bcs);
		};
		for (var i = 0; i < len; i++) {
			var point = points[i];
			x += point.x * Math.pow((1 - t), (len - 1 - i)) * Math.pow(t, i) * (erxiangshi(len - 1, i));
			y += point.y * Math.pow((1 - t), (len - 1 - i)) * Math.pow(t, i) * (erxiangshi(len - 1, i));
			z += point.z * Math.pow((1 - t), (len - 1 - i)) * Math.pow(t, i) * (erxiangshi(len - 1, i));
		}
		return new SceneGIS.Cartesian3(x, y, z);
	}

	LineEX.prototype.reset = function (oldOption, newOption) {
		if (oldOption.material != newOption.material) {
			let newMaterial = getMaterial(newOption);
			this._primitive.appearance.material = newMaterial;
		} else {
			updateMaterial(this._primitive.appearance.material, newOption);
		}
	};

	function updateMaterial(material, option) {
		switch (option.material) {
			case 'color': {
				material.uniforms.color = SceneGIS.Color.fromCssColorString(option.color);
				break;
			}
			case 'arrow': {
				material.uniforms.color = SceneGIS.Color.fromCssColorString(option.color);
				break;
			}
			case 'dash': {
				material.uniforms.color = SceneGIS.Color.fromCssColorString(option.color);
				material.uniforms.gapColor = SceneGIS.Color.fromCssColorString(option.gapColor);
				material.uniforms.dashLength = option.dashLength;
				break;
			}
			case 'trajectory': {
				material.uniforms.color = SceneGIS.Color.fromCssColorString(option.color);
				break;
			}
		}
	}

	Object.defineProperties(LineEX.prototype, {
		/**
		 * 显隐控制
		 *
		 * @memberof  LineEX.prototype
		 * @type {Boolean}
		 */
		show: {
			get: function () {
				if (this._primitive) {
					return this._primitive.show;
				}
				return false;
			},
			set: function (value) {
				this._primitive.show = value;
			},
		},
		/**
		 * 要素id
		 * @memberof  LineEX.prototype
		 * @readonly
		 * @type {Boolean}
		 */
		id: {
			get: function () {
				return this._id;
			},
		},
		/**
		 * 要素的data
		 * @memberof   LineEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		data: {
			get: function () {
				return [this._primitive];
			},
		},
		/**
		 * 要素的所属
		 * @memberof  LineEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		owner: {
			get: function () {
				return this._owner;
			},
			set: function (value) {
				this._owner = value;
				this._primitive.owner = value;
			},
		},
	});

	/**
	 * 改变颜色
	 * @param {Object} option 颜色参数
	 * @param {SceneGIS.Color} option.color 颜色
	 */
	LineEX.prototype.changeColor = function (option) {
		// this.obj.color = option.color;
	};

	/**
	 * 销毁清除对象
	 */
	LineEX.prototype.destroy = function () {
		this._viewer.scene.primitives.remove(this._primitive);
	};

	/**
	 * PolygonType类型
	 *
	 * @enum {String}
	 */
	var PolygonType = {
		/**
		 * 普通面
		 * @type {String}
		 */
		'normal': 'normal',
		/**
		 * 墙
		 * @type {String}
		 */
		'wall': 'wall',
		/**
		 * 边框
		 * @type {String}
		 */
		'polygonOutline': 'polygonOutline'



	};
	var PolygonType$1 = Object.freeze(PolygonType);

	/**
	 * PolygonMaterialType类型
	 *
	 * @enum {String}
	 */
	var PolygonMaterialType = {
		/**
		 * 普通面
		 * @type {String}
		 */
		'color': 'color',
		/**
		 * 流动
		 * @type {String}
		 */
		'flow': 'flow',
		/**
		 * 水平流动
		 * @type {String}
		 */
		'flow_horizontal': 'flow_horizontal',
		/**
		 * 闪烁
		 * @type {String}
		 */
		"twinkle": "twinkle"



	};
	var PolygonMaterialType$1 = Object.freeze(PolygonMaterialType);

	/**
	 * 自定义面
	 * @alias PolygonEX
	 * @constructor
	 * @param {Viewer} viewer viewer对象
	 * @param {Object} option  内部对象参数，不同的对象不一样
	 * @param {String} option.id 对象id
	 * @param {Object} option.owner 是否显示
	 * @param {Object} option.positions 位置
	 * @param {PolygonType} option.type 类型 {@link PolygonType}
	 * @param {PolygonMaterialType} option.material 类型 {@link PolygonMaterialType}
	 * @param {String} option.color 颜色
	 * @param {String} option.topColor 顶面颜色
	 * @param {String} option.bottomColor 底面颜色
	 * @param {String} option.startColor 开始颜色
	 * @param {String} option.endColor 结束颜色
	 */
	function PolygonEX(viewer, option) {
		this._viewer = viewer;
		this._primitive = undefined;
		this._owner = option.owner ? option.owner : undefined;
		this._id = option.id ? option.id : CoreEX.MathEX.createUID();
		init$b.bind(this)(option);
	}

	function init$b(option) {
		if (!SceneGIS.defined(option.type)) {
			console.error("customPolygon需要type属性");
			return;
		}
		switch (option.type) {
			case "normal": {
				initPolygon.bind(this)(option);
				break;
			}
			case "wall": {
				initWall.bind(this)(option);
				break;
			}
			case "polygonOutline": {
				initPolygonOutline.bind(this)(option);
				break;
			}
			default: {
				console.error("未知的customPolygon.type");
				break;
			}
		}
	}

	function initPolygon(option) {
		let scene = this._viewer.scene;
		let originPoints = [];
		if (scene.planeView) {
			for (let i = 0; i < option.positions.length; i += 2) {
				originPoints.push(new SceneGIS.Cartesian3(option.positions[i], option.positions[i + 1], 0));
			}
		}
		else {
			originPoints = SceneGIS.Cartesian3.fromDegreesArray(option.positions);
		}

		const polygon = new SceneGIS.PolygonGeometry({
			polygonHierarchy: new SceneGIS.PolygonHierarchy(
				originPoints
			),
			vertexFormat: SceneGIS.VertexFormat.POSITION_NORMAL_AND_ST,
			planeView: scene.planeView
		});
		let material = getPolygonMaterial(option);
		if (!material) {
			console.error("customPolygon类型的material错误");
			return;
		}
		this._primitive = this._viewer.scene.primitives.add(
			new SceneGIS.GroundPrimitive({
				geometryInstances: new SceneGIS.GeometryInstance({
					geometry: polygon,
					id: option.id,
				}),
				appearance: new SceneGIS.Appearance({
					material: material,
				}),
			})
		);
	}

	function initWall(option) {
		let scene = this._viewer.scene;
		let originPoints = [];
		if (scene.planeView) {
			for (let i = 0; i < option.positions.length; i += 3) {
				originPoints.push(new SceneGIS.Cartesian3(option.positions[i], option.positions[i + 1], option.positions[i + 2]));
			}
		}
		else {
			originPoints = SceneGIS.Cartesian3.fromDegreesArrayHeights(option.positions);
		}
		const wall = new SceneGIS.WallGeometry({
			positions: originPoints,
			vertexFormat: SceneGIS.VertexFormat.POSITION_NORMAL_AND_ST,

			planeView: scene.planeView
		});
		let material = getWallMaterial(option);
		if (!material) {
			console.error("customPolygon类型的material错误");
			return;
		}
		this._primitive = this._viewer.scene.primitives.add(
			new SceneGIS.Primitive({
				geometryInstances: new SceneGIS.GeometryInstance({
					geometry: wall,
					id: option.id,
				}),
				appearance: new SceneGIS.MaterialAppearance({
					material: material,
				}),
			})
		);
	}

	function initPolygonOutline(option) {
		let scene = this._viewer.scene;
		let originPoints = [];
		if (scene.planeView) {
			for (let i = 0; i < option.positions.length; i += 3) {
				originPoints.push(new SceneGIS.Cartesian3(option.positions[i], option.positions[i + 1], option.positions[i + 2]));
			}
		}
		else {
			originPoints = SceneGIS.Cartesian3.fromDegreesArray(option.positions);
		}

		const polyline = new SceneGIS.PolylineGeometry({
			positions: originPoints,
			width: 1.0,
			vertexFormat: SceneGIS.PolylineMaterialAppearance.VERTEX_FORMAT,
			arcType: SceneGIS.ArcType.NONE,
			planeView: scene.planeView
		});
		let material = getPolygonOutlineMaterial(option);
		if (!material) {
			console.error("customPolygon类型的material错误");
			return;
		}
		this._primitive = this._viewer.scene.primitives.add(
			new SceneGIS.Primitive({
				geometryInstances: new SceneGIS.GeometryInstance({
					geometry: polyline,
					id: option.id,
				}),
				appearance: new SceneGIS.PolylineMaterialAppearance({
					material: material,
				}),
			})
		);
	}

	function getPolygonMaterial(option) {
		let material;
		switch (option.material) {
			case "color": {
				material = new SceneGIS.Material({
					fabric: {
						type: "Color",
						uniforms: {
							color: SceneGIS.Color.fromCssColorString(option.color),
						},
					},
				});
				break;
			}
		}
		return material;
	}

	function getWallMaterial(option) {
		let material;
		switch (option.material) {
			case "flow": {
				material = new SceneGIS.Material({
					fabric: {
						type: "flow",
						uniforms: {
							buttomColor: SceneGIS.Color.fromCssColorString(option.buttomColor),
							topColor: SceneGIS.Color.fromCssColorString(option.topColor),
						},
						source: /* glsl */ `
                        czm_material czm_getMaterial(czm_materialInput materialInput){
                            czm_material material = czm_getDefaultMaterial(materialInput);
                            vec2 st =  materialInput.st;
                            float offset = fract(czm_frameNumber / 240.0);
                            st.t=fract(st.t-offset);
                            vec4 color;
                            color=mix(buttomColor,topColor,st.t);
                            material.emission = color.rgb;
                            material.alpha = color.a;
                            return material;
                        }
                    `,
					},
				});
				break;
			}
			case "flow_horizontal": {
				material = new SceneGIS.Material({
					fabric: {
						type: "flow_horizontal",
						uniforms: {
							startColor: SceneGIS.Color.fromCssColorString(option.startColor),
							endColor: SceneGIS.Color.fromCssColorString(option.endColor),
						},
						source: /* glsl */ `
                        czm_material czm_getMaterial(czm_materialInput materialInput){
                            czm_material material = czm_getDefaultMaterial(materialInput);
                            vec2 st =  materialInput.st;
                            float offset = fract(czm_frameNumber / 240.0);
                            st.s=fract(st.s-offset);
                            vec4 color;
                            color=mix(startColor,endColor,st.s);
                            material.emission = color.rgb;
                            material.alpha = color.a;
                            return material;
                        }
                    `,
					},
				});
				break;
			}
		}
		return material;
	}

	function getPolygonOutlineMaterial(option) {
		let material;
		switch (option.material) {
			case "twinkle": {
				material = new SceneGIS.Material({
					fabric: {
						type: "polygonOutLine_twinkle",
						uniforms: {
							color: SceneGIS.Color.fromCssColorString(option.color),
						},
						source: /* glsl */ `
                        czm_material czm_getMaterial(czm_materialInput materialInput){
                            czm_material material = czm_getDefaultMaterial(materialInput);
                            float dynamicAlpha=abs(fract(czm_frameNumber / 120.0)*2.0-1.0);
                            material.diffuse = color.rgb;
                            material.alpha = dynamicAlpha;
                            return material;
                        }
                    `,
					},
				});
				break;
			}
			case "flow": {
				material = new SceneGIS.Material({
					fabric: {
						type: "polygonOutLine_flow",
						uniforms: {
							color: SceneGIS.Color.fromCssColorString(option.color),
						},
						source: /* glsl */ `
                        czm_material czm_getMaterial(czm_materialInput materialInput){
                            czm_material material = czm_getDefaultMaterial(materialInput);
                            vec2 st =  materialInput.st;
                            float offset = fract(czm_frameNumber / 240.0);
                            st.s=fract(st.s-offset);
                            float alpha=st.s;
                            material.emission = color.rgb;
                            material.alpha = alpha;
                            return material;
                        }
                    `,
					},
				});
				break;
			}
		}
		return material;
	}

	PolygonEX.prototype.reset = function (oldOption, newOption) {
		if (oldOption.material != newOption.material) {
			let newMaterial;
			switch (newOption.type) {
				case "normal": {
					newMaterial = getPolygonMaterial(newOption);
					break;
				}
				case "wall": {
					newMaterial = getWallMaterial(newOption);
					break;
				}
				case "polygonOutline": {
					newMaterial = getPolygonOutlineMaterial(newOption);
					break;
				}
			}
			this._primitive.appearance.material = newMaterial;
		} else {
			switch (newOption.type) {
				case "normal": {
					updatePolygonMaterial(this._primitive.appearance.material, newOption);
					break;
				}
				case "wall": {
					updateWallMaterial(this._primitive.appearance.material, newOption);
					break;
				}
				case "polygonOutline": {
					updatePolygonOutlineMaterial(
						this._primitive.appearance.material,
						newOption
					);
					break;
				}
			}
		}
	};

	function updatePolygonMaterial(material, option) {
		switch (option.material) {
			case "color": {
				material.uniforms.color = SceneGIS.Color.fromCssColorString(option.color);
				break;
			}
		}
	}

	function updateWallMaterial(material, option) {
		switch (option.material) {
			case "flow": {
				material.uniforms.buttomColor = SceneGIS.Color.fromCssColorString(
					option.buttomColor
				);
				material.uniforms.topColor = SceneGIS.Color.fromCssColorString(
					option.topColor
				);
				break;
			}
			case "flow_horizontal": {
				material.uniforms.startColor = SceneGIS.Color.fromCssColorString(
					option.startColor
				);
				material.uniforms.endColor = SceneGIS.Color.fromCssColorString(
					option.endColor
				);
				break;
			}
		}
		return material;
	}

	function updatePolygonOutlineMaterial(material, option) {
		switch (option.material) {
			case "twinkle": {
				material.uniforms.color = SceneGIS.Color.fromCssColorString(option.color);
				break;
			}
			case "flow": {
				material.uniforms.color = SceneGIS.Color.fromCssColorString(option.color);
				break;
			}
		}
	}

	Object.defineProperties(PolygonEX.prototype, {
		/**
		 * 显隐控制
		 *
		 * @memberof  PolygonEX.prototype
		 * @type {Boolean}
		 */
		show: {
			get: function () {
				if (this._primitive) {
					return this._primitive.show;
				}
				return false;
			},
			set: function (value) {
				this._primitive.show = value;
			},
		},
		/**
		 * 要素id
		 * @memberof  PolygonEX.prototype
		 * @readonly
		 * @type {Boolean}
		 */
		id: {
			get: function () {
				return this._id;
			},
		},
		/**
		 * 要素的data
		 * @memberof   PolygonEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		data: {
			get: function () {
				return [this._primitive];
			},
		},
		/**
		 * 要素的所属
		 * @memberof  PolygonEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		owner: {
			get: function () {
				return this._owner;
			},
			set: function (value) {
				this._owner = value;
				this._primitive.owner = value;
			},
		},
	});

	/**
	 * 改变颜色
	 * @param {Object} option 颜色参数
	 * @param {SceneGIS.Color} option.color 颜色
	 */
	PolygonEX.prototype.changeColor = function (option) {
		// this.obj.color = option.color;
	};

	/**
	 * 销毁清除对象
	 */
	PolygonEX.prototype.destroy = function () {
		this._viewer.scene.primitives.remove(this._primitive);
	};

	/**
	 * 流动线,不支持平面坐标系
	 * @alias FlowPolylineEX
	 * @constructor
	 * @param {Viewer} viewer viewer对象
	 * @param {Object} option  配置参数
	 * @param {String} option.id 对象id
	 * @param {Object} option.owner 对象所属
	 * @param {String} option.name 对象名称
	 * @param {Array<Number>} option.positions 对象坐标
	 * @param {Array<Number>} option.repeat 对象纹理重复次数
	 * @param {Number} [option.lineWidth=10] 对象线宽
	 * @param {Color} option.material 对象材质
	 * @param {String} [option.image] 图片
	 * 
	 */
	function FlowPolylineEX(viewer, option) {

		option = Object.assign({}, option);
		this.option = option;
		this._id = option.id ? option.id : CoreEX.MathEX.createUID();
		this.viewer = viewer;
		this._owner = option.owner ? option.owner : undefined;
		if (option.material instanceof SceneGIS.Color);
		else {
			option.material = SceneGIS.Color.fromCssColorString(option.material);
		}

		var material = new PolylineFlowImgMaterialProperty({
			repeat: new SceneGIS.Cartesian2(option.repeat[0], option.repeat[1]),
			color: option.material,
			image: option.image

		});

		this._dataSource = new SceneGIS.CustomDataSource(); //换成自定义DataSource，避免被全局清除掉
		viewer.dataSources.add(this._dataSource);
		let scene = this.viewer.scene;

		let originPoints = [];
		if (scene.planeView) {
			for (let i = 0; i < option.positions.length; i += 3) {
				originPoints.push(new SceneGIS.Cartesian3(option.positions[i], option.positions[i + 1], option.positions[i + 2]));
			}
		}
		else {
			originPoints = SceneGIS.Cartesian3.fromDegreesArrayHeights(option.positions);
		}

		this.obj = this._dataSource.entities.add({
			name: option.name,
			polyline: {
				positions: originPoints,
				width: option.lineWidth ? option.lineWidth : (option.linewidth ? option.linewidth : 10),
				material: material,
				clampToGround: true
			}
		});

	}

	FlowPolylineEX.prototype.getObj = function () {
		return [this.obj];
	};

	/**
	* 改变颜色
	* @param {Object} option 颜色参数
	* @param {SceneGIS.Color} option.color 颜色
	*/
	FlowPolylineEX.prototype.changeColor = function (option) {
		// this.obj.color = option.color;
	};
	/**
	 * 销毁清除对象
	 */
	FlowPolylineEX.prototype.destroy = function () {
		this._dataSource.entities.removeAll();
		this.viewer.dataSources.remove(this._dataSource);
	};

	Object.defineProperties(FlowPolylineEX.prototype, {
		/**
	   * 显隐控制
	   *
	   * @memberof   FlowPolylineEX.prototype
	   * @type {Boolean}
	   */
		show: {
			get: function () {
				if (this.obj) {
					return this.obj.show;
				}
				return false;
			},
			set: function (value) {
				this.obj.show = value;
			}
		},
		/**
		 * 要素id
		 * @memberof   FlowPolylineEX.prototype
		 * @readonly
		 * @type {Boolean}
		 */
		id: {
			get: function () {
				return this._id;
			},
		},
		/**
		 * 要素的data
		 * @memberof    FlowPolylineEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		data: {
			get: function () {
				return [this.obj];
			},
		},
		/**
		 * 要素的所属
		 * @memberof   FlowPolylineEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		owner: {
			get: function () {
				return this._owner;
			},
			set: function (value) {
				this._owner = value;
				this.obj.owner = value;
			},
		}

	});

	/**
	 * FeatureType类型
	 *
	 * @enum {String}
	 */
	var FeatureType = {
		/**
		 * div Tip标签
		 * @type {String}
		 */
		divTip: "divTip",
		/**
		 * div
		 * @type {String}
		 */
		div: "div",
		/**
		 * div弹窗
		 * @type {String}
		 */
		divDialogWithOutLine: "divDialogWithOutLine",
		/**
		 * 组合div弹窗
		 * @type {String}
		 */
		divMDialogWithOutLine: "divMDialogWithOutLine",
		/**
		 * vue组件
		 * @type {String}
		 */
		vueDialog: "vueDialog",
		/**
		 * gltf模型
		 * @type {String}
		 */
		glb: "glb",

		/**
		 * 动态墙
		 * @type {String}
		 */
		dynamicWall: "dynamicWall",
		/**
		 * 水面效果一
		 * @type {String}
		 */
		waterPolygon: "waterPolygon",
		/**
		 * 节点井
		 * @type {String}
		 */
		waterLevelWell: "waterLevelWell",
		/**
		 * 综合点
		 * @type {String}
		 */
		swEntity: "swEntity",
		/**
		 * carve的流动线
		 * @type {String}
		 */
		curveArrow: "curveArrow",
		/**
		 * 水面效果二
		 * @type {String}
		 */
		water: "water",
		/**
		 * 水面效果三
		 * @type {String}
		 */
		waterFilter: "waterFilter",
		/**
		 * 流动线
		 * @type {String}
		 */
		flowPolyline: "flowPolyline",

		/**
		 * 自定义点，里面仍分几个特效，请参照PointMaterialType枚举
		 * @type {String}
		 */
		customPoint: "customPoint",
		/**
		 * 自定义贴地线，里面仍分几个特效，请参照LineMaterialType枚举
		 * @type {String}
		 */
		customGroundLine: "customGroundLine",
		/**
		 * 自定义线，里面仍分几个特效，请参照LineMaterialType枚举
		 * @type {String}
		 */
		customLine: "customLine",
		/**
		 * 自定义面，里面仍分几个特效，请参照PolygonType枚举和PolygonMaterialType枚举
		 * @type {String}
		 */
		customPolygon: "customPolygon",

		/**
		* czml 对象
		* @type {String}
		*/
		czml: "czml",


		/**
		* 图片特效，有火焰和水面效果
		* @type {String}
		*/
		particleEffect: "particleEffect",

		/**
		* 喷泉特效
		* @type {String}
		*/
		fountain: "fountain",

		/**
		* 雷达模拟特效
		* @type {String}
		*/
		lidar: "lidar",


		/**
		   * 烟花特效
		   * @type {String}
		   */
		firework: "firework"

	};
	var FeatureType$1 = Object.freeze(FeatureType);

	/**
	 * 水的对象，暂时不支持平面坐标系,内部调用的是SceneGIS.Water 对象
	 * @alias WaterFilterEX
	 * @constructor
	 * @param {viewer} viewer 
	 * @param {Object} option 
	 * @param {Array} option.positions 位置
	 */
	function WaterFilterEX(viewer, option) {
		option = Object.assign({}, option);
		this.option = option;
		this._id = option.id ? option.id : CoreEX.MathEX.createUID();
		this.viewer = viewer;
		this._owner = option.owner ? option.owner : undefined;
		let scene = viewer.scene;
		//var color=new SceneGIS.Color.fromCssColorString(option.color)
		this.obj = [];
		// 生成淹没效果
		const polygon = new SceneGIS.PolygonGeometry({
			polygonHierarchy: new SceneGIS.PolygonHierarchy(
				viewer.scene.planeView === true ? SceneGIS.Cartesian3.unpackArray(option.positions)
					: SceneGIS.Cartesian3.fromDegreesArrayHeights(option.positions)),
			// SceneGIS.Cartesian3.fromDegreesArrayHeights(option.positions)),
		});
		let geomask = new SceneGIS.geojsonMask(
			{
				scene: scene,
				polygon: polygon
			}
		);
		this.reflector = new SceneGIS.Reflector({
			scene: scene,
		});
		this.water = new SceneGIS.WaterFilter(scene, this.reflector, geomask);

		this.obj.push(scene.primitives.add(this.reflector));
		this.obj.push(scene.primitives.add(this.water));
		this.removecallback = scene.preUpdate.addEventListener(() => {
			this.water.center = this.reflector._reflectPositionWC;
		});

		this.watergeomask = this.viewer.scene.primitives.add(geomask);
		this.obj.push(this.watergeomask);
		this.water.waterHeight = option.height ? option.height : 10;
		this.reflector.height = option.height ? option.height : 10;


	}
	WaterFilterEX.prototype.update = function () {

	};

	WaterFilterEX.prototype.getObj = function () {
		return this.obj;
	};

	/**
	* 改变颜色
	* @param {Object} option 颜色参数
	* @param {SceneGIS.Color} option.color 颜色
	*/
	WaterFilterEX.prototype.changeColor = function (option) {
		// this.obj.color = option.color;
	};
	/**
	 * 销毁清除对象
	 */
	WaterFilterEX.prototype.destroy = function () {
		if (this.removecallback && typeof (this.removecallback) === "function") {
			this.removecallback();
		}
		for (let obj of this.obj) {
			this.viewer.scene.primitives.remove(obj);
		}

	};

	Object.defineProperties(WaterFilterEX.prototype, {
		/**
	  * 显隐控制
	  *
	  * @memberof   WaterFilterEX.prototype
	  * @type {Boolean}
	  */
		show: {
			get: function () {
				if (this.obj) {
					return this.obj[0].show;
				}
				return false;
			},
			set: function (value) {
				for (let obj of this.obj) {
					obj.show = value;
				}
			}
		},
		/**
	   * 要素id
	   * @memberof   WaterFilterEX.prototype
	   * @readonly
	   * @type {Boolean}
	   */
		id: {
			get: function () {
				return this._id;
			},
		},
		/**
		 * 要素的data
		 * @memberof    WaterFilterEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		data: {
			get: function () {
				return this.obj;
			},
		},
		/**
		 * 要素的所属
		 * @memberof   WaterFilterEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		owner: {
			get: function () {
				return this._owner;
			},
			set: function (value) {
				this._owner = value;
				for (let obj of this.obj) {
					obj.owner = value;
				}
			},
		},

	});

	/**
	 * 图层类对象，用数组渲染，继承IEntityEX接口
	 * @class CzmlEntityEX
	 */
	class CzmlEntityEX {
		/**
		* @constructor
		* @param {Viewer} viewer viewer对象
		* @param {option}  传入入的参数
		**/
		constructor(viewer, option) {
			/**
			 * viewer对象
			 * @readonly
			 * @type {Viewer}
			 */
			this.viewer = viewer;

			this._show = SceneGIS.defaultValue(option.show, true);
			/**
			 * 要素id
			 * @readonly
			 * @type {Boolean}
			*/
			this.id = option.id = option.id ? option.id : CoreEX.MathEX.createUID();

			/**
			 * 要素的data
			 * @readonly
			 * @type {Array<Entity>|Array<Primitive>}
			*/
			this.data = [];

			/**
			 * 要素的所属对象
			 * @readonly
			 * @type {Object}
			*/
			this.owner = SceneGIS.defaultValue(option.owner, undefined);
			this._ds = undefined;
			this._promise = undefined;

			let czml = [];
			czml.push({
				id: "document",
				name: "CZML Custom Properties",
				version: "1.0",
			});

			czml.push(_.clone(option));
			let self = this;
			if (viewer._czmlDataSource) {
				this._ds = viewer._czmlDataSource;
				this._promise = this._ds.process(czml).then((ds) => {
					let es = ds.entities;
					let entity = es.getById(option.id);
					entity.owner = self.owner;
					self.data.push(entity);

				});
			}

		}
		/**
		 * 显隐控制
		 *
		 * @memberof CzmlEntityEX.prototype
		 * @type {Boolean}
		*/
		get show() {
			return this._show;
		}
		/**
		 * 显隐控制
		 *
		 * @memberof CzmlEntityEX.prototype
		 * @type {Boolean}
		*/
		set show(value) {
			this._show = value;
			let entity = this._ds.entities.getById(this.id);
			if (entity) {
				entity.show = value;
			}
			else {
				this._promise.then(() => {
					this._ds.entities.getById(this.id).show = value;
				});
			}

		}
		/**
		 * 销毁对象
		 * @return {boolean} 销毁成功返回true,否则返回false
		 */
		destroy() {
			//this._ds.entities.removeById(this.id);
			let entity = this._ds.entities.removeById(this.id);
			if (entity);
			else {
				this._promise.then(() => {
					this._ds.entities.removeById(this.id);
				});
			}
		}

		/**
		* 改变颜色
		* @return {boolean} 成功返回true,否则返回false
		*/
		changeColor(option) {
			throw new SceneGIS.DeveloperError('error');
		}
	}

	/**
	 * 粒子特效扩展类
	 * @class ParticleEffectEX
	 */
	class ParticleEffectEX {
		/**
		 * @constructor
		 * @param {Viewer} viewer viewer对象
		 * @param {option}  option 传入入的参数
		 * @param {Boolean} option.show 显隐控制
		 * @param {String} option.id 要素id
		 * @param {Array} option.positions 要素坐标数组
		 * @param {String} option.image 粒子图片
		 **/
		constructor(viewer, option) {
			this._particleSystem = undefined;
			/**
			 * viewer对象
			 * @readonly
			 * @type {Viewer}
			 */
			this.viewer = viewer;
			this._show = SceneGIS.defaultValue(option.show, true);
			/**
			 * 要素id
			 * @readonly
			 * @type {Boolean}
			 */
			this.id = option.id;

			/**
			 * 要素的data
			 * @readonly
			 * @type {Array<Entity>|Array<Primitive>}
			 */
			this.data = [];

			/**
			 * 要素的所属对象
			 * @readonly
			 * @type {Object}
			 */
			this.owner = undefined;
			let self = this;

			let positon1 = option.positions;
			let img = option.image;

			SceneGIS.Math.setRandomNumberSeed(3);
			//Set bounds of our simulation time
			var start = SceneGIS.JulianDate.fromDate(new Date(2015, 2, 25, 16));
			var stop = SceneGIS.JulianDate.addSeconds(
				start,
				120,
				new SceneGIS.JulianDate()
			);

			//Make sure viewer is at the desired time.
			viewer.clock.startTime = start.clone();
			viewer.clock.stopTime = stop.clone();
			viewer.clock.currentTime = start.clone();
			viewer.clock.clockRange = SceneGIS.ClockRange.LOOP_STOP; //Loop at the end
			viewer.clock.multiplier = 1;
			viewer.clock.shouldAnimate = true;

			var viewModel = {
				emissionRate: 20,
				minimumParticleLife: 1,
				maximumParticleLife: 2,
				minimumSpeed: 3.0,
				maximumSpeed: 9.5,
				startScale: 1,
				endScale: 6,
				particleSize: 0.5,
				gravity: -2,
			};
			const planeView = this.viewer.scene.planeView;
			function computeModelMatrix(entity, time) {
				return entity.computeModelMatrix(time, new SceneGIS.Matrix4(), planeView);
			}

			var emitterModelMatrix = new SceneGIS.Matrix4();
			var translation = new SceneGIS.Cartesian3();
			var rotation = new SceneGIS.Quaternion();
			var hpr = new SceneGIS.HeadingPitchRoll();
			var trs = new SceneGIS.TranslationRotationScale();

			function computeEmitterModelMatrix() {
				hpr = SceneGIS.HeadingPitchRoll.fromDegrees(0.0, 0.0, 0.0, hpr);
				trs.translation = SceneGIS.Cartesian3.fromElements(0, 0.0, 0, translation);
				trs.rotation = SceneGIS.Quaternion.fromHeadingPitchRoll(hpr, rotation);

				return SceneGIS.Matrix4.fromTranslationRotationScale(
					trs,
					emitterModelMatrix
				);
			}
			let pos1;
			if (planeView === true) {
				pos1 = new SceneGIS.Cartesian3(
					positon1[0],
					positon1[1],
					positon1[2]
				);
			} else {
				pos1 = SceneGIS.Cartesian3.fromDegrees(
					positon1[0],
					positon1[1],
					positon1[2]
				);
			}
			this.position = pos1.clone();
			var position = new SceneGIS.SampledPositionProperty();
			position.addSample(start, pos1);
			var entity = viewer.entities.add({
				position: pos1,
			});
			this._entity = entity;

			var scene = viewer.scene;
			var particleSystem = scene.primitives.add(
				new SceneGIS.ParticleSystem({
					image: img ? img : "./img/effects/fire.png",

					startColor: new SceneGIS.Color(1, 1, 1, 0.3),
					endColor: new SceneGIS.Color(0.8, 0.86, 1, 0.4),

					startScale: viewModel.startScale,
					endScale: viewModel.endScale,

					minimumParticleLife: viewModel.minimumParticleLife,
					maximumParticleLife: viewModel.maximumParticleLife,

					minimumSpeed: viewModel.minimumSpeed,
					maximumSpeed: viewModel.maximumSpeed,

					imageSize: new SceneGIS.Cartesian2(
						viewModel.particleSize,
						viewModel.particleSize
					),

					emissionRate: viewModel.emissionRate,

					lifetime: 6.0,

					emitter: new SceneGIS.CircleEmitter(0.2),

					emitterModelMatrix: computeEmitterModelMatrix(),

					updateCallback: applyGravity,
					// 是否以米为单位
					sizeInMeters: true,
				})
			);

			this._particleSystem = particleSystem;
			var gravityScratch = new SceneGIS.Cartesian3();

			function applyGravity(p, dt) {
				// We need to compute a local up vector for each particle in geocentric space.
				var position;
				if (planeView === true) {
					position = new SceneGIS.Cartesian3(0, 0, 1);
				} else {
					position = p.position;
				}

				SceneGIS.Cartesian3.normalize(position, gravityScratch);
				SceneGIS.Cartesian3.multiplyByScalar(
					gravityScratch,
					viewModel.gravity * dt,
					gravityScratch
				);

				p.velocity = SceneGIS.Cartesian3.add(
					p.velocity,
					gravityScratch,
					p.velocity
				);
			}
			this._update = function (scene, time) {
				if (!self._particleSystem) return;
				self._particleSystem.modelMatrix = computeModelMatrix(entity, time);

				// Account for any changes to the emitter model matrix.
				self._particleSystem.emitterModelMatrix = computeEmitterModelMatrix();
			};

			viewer.scene.preUpdate.addEventListener(this._update);

		}
		/**
		 * 显隐控制
		 *
		 * @memberof ParticleEffectEX.prototype
		 * @type {Boolean}
		 */
		get show() {
			return this._show;
		}
		/**
		 * 显隐控制
		 *
		 * @memberof ParticleEffectEX.prototype
		 * @type {Boolean}
		 */
		set show(value) {
			this._show = value;
			this._particleSystem.show = value;
			this._entity.show = value;
		}
		/**
		 * 销毁对象
		 * @return {boolean} 销毁成功返回true,否则返回false
		 */
		destroy() {
			this.viewer.scene.preUpdate.removeEventListener(this._update);
			this.viewer.entities.remove(this._entity);
			this.viewer.scene.primitives.remove(this._particleSystem);
		}

		/**
		 * 改变颜色
		 * @return {boolean} 成功返回true,否则返回false
		 */
		changeColor(option) {
			throw new SceneGIS.DeveloperError("error");
		}

	}

	var DefaultViewModel = {
		emissionRate: 40.0,
		gravity: -3.5,
		minimumParticleLife: 6,
		maximumParticleLife: 7,
		minimumSpeed: 9,
		maximumSpeed: 9.5,
		startScale: 1,
		endScale: 20,
		particleSize: 1,
	};
	/**
	 * 喷泉特效
	 * @class FountainEX
	 */
	class FountainEX {
		constructor(viewer, options = null) {
			this.map = viewer;
			this.scene = viewer.scene;
			this.location = options.location;
			this.image = options.image || CoreEX.getAssetUrl("img/fountain.png");
			this.model = options.model || CoreEX.getAssetUrl("img/fountain.glb");
			this.viewModel = options.viewModel || DefaultViewModel;
			this.fountainEntity = null;
			this.particleSystem = null;
			this.scale = options.scale || 0.04;

			this._show = SceneGIS.defaultValue(options.show, true);
			this.addFountainEX();

		}
		/**
		 * 显隐控制
		 *
		 * @memberof FountainEX.prototype
		 * @type {Boolean}
		 */
		get show() {
			return this._show;
		}
		/**
		 * 显隐控制
		 *
		 * @memberof FountainEX.prototype
		 * @type {Boolean}
		 */
		set show(value) {
			this._show = value;
			this.particleSystem.show = value;
			this.fountainEntity.show = value;
		}
		addFountainEX() {
			const self = this;
			const scene = this.scene;
			if (this.fountainEntity || this.particleSystem) {
				return;
			}
			var viewModel = {
				emissionRate: 40.0,
				gravity: -3.5,
				minimumParticleLife: 6,
				maximumParticleLife: 7,
				minimumSpeed: 9,
				maximumSpeed: 9.5,
				startScale: 1,
				endScale: 20,
				particleSize: 1,
			};
			const planeView = this.scene.planeView;
			function computeModelMatrix(entity, time) {
				return entity.computeModelMatrix(time, new SceneGIS.Matrix4(), planeView);
			}
			var emitterModelMatrix = new SceneGIS.Matrix4();
			var translation = new SceneGIS.Cartesian3();
			var rotation = new SceneGIS.Quaternion();
			var hpr = new SceneGIS.HeadingPitchRoll();
			var trs = new SceneGIS.TranslationRotationScale();
			function computeEmitterModelMatrix() {
				hpr = SceneGIS.HeadingPitchRoll.fromDegrees(0.0, 0.0, 0.0, hpr);
				trs.translation = SceneGIS.Cartesian3.fromElements(
					0,
					0,
					5.4,
					translation
				);
				trs.rotation = SceneGIS.Quaternion.fromHeadingPitchRoll(
					hpr,
					rotation
				);
				return SceneGIS.Matrix4.fromTranslationRotationScale(
					trs,
					emitterModelMatrix
				);
			}

			let pos1;
			if (planeView === true) {
				pos1 = new SceneGIS.Cartesian3(
					this.location[0],
					this.location[1],
					this.location[2]
				);
			} else {
				pos1 = SceneGIS.Cartesian3.fromDegrees(
					this.location[0],
					this.location[1],
					this.location[2]
				);
			}
			var entity = this.map.entities.add({
				position: pos1,
			});
			this.fountainEntity = this.map.entities.add({
				model: {
					uri: self.model,
					scale: this.scale,
				},
				position: pos1
			});
			this.particleSystem = scene.primitives.add(
				new SceneGIS.ParticleSystem({
					image: self.image,
					startColor: new SceneGIS.Color(1, 1, 1, 0.6),
					endColor: new SceneGIS.Color(0.8, 0.86, 1, 0.4),
					startScale: viewModel.startScale,
					endScale: viewModel.endScale,
					minimumParticleLife: viewModel.minimumParticleLife,
					maximumParticleLife: viewModel.maximumParticleLife,
					minimumSpeed: viewModel.minimumSpeed,
					maximumSpeed: viewModel.maximumSpeed,
					imageSize: new SceneGIS.Cartesian2(
						viewModel.particleSize,
						viewModel.particleSize
					),
					emissionRate: viewModel.emissionRate,
					lifetime: 16.0,
					emitter: new SceneGIS.CircleEmitter(0.2),
					emitterModelMatrix: computeEmitterModelMatrix(),
					updateCallback: applyGravity,
					sizeInMeters: true,
					performance: false,
				})
			);
			var gravityScratch = new SceneGIS.Cartesian3();
			function applyGravity(p, dt) {
				var position;
				if (planeView === true) {
					position = new SceneGIS.Cartesian3(0, 0, 1);
				} else {
					position = p.position;
				}
				SceneGIS.Cartesian3.normalize(position, gravityScratch);
				SceneGIS.Cartesian3.multiplyByScalar(
					gravityScratch,
					viewModel.gravity * dt,
					gravityScratch
				);
				p.velocity = SceneGIS.Cartesian3.add(
					p.velocity,
					gravityScratch,
					p.velocity
				);
			}
			this.map.scene.preUpdate.addEventListener(function (scene, time) {
				if (self.particleSystem) {
					self.particleSystem.modelMatrix = computeModelMatrix(entity, time);
					self.particleSystem.emitterModelMatrix = computeEmitterModelMatrix();
				}
			});
		}

		track() {
			if (this.fountainEntity) {
				map.trackedEntity = this.fountainEntity;
			}
		}

		destroy() {
			this.removeFountainEX();
		}

		removeFountainEX() {
			if (this.fountainEntity) {
				this.map.entities.remove(this.fountainEntity);
				this.fountainEntity = null;
			}
			if (this.particleSystem) {
				this.scene.primitives.remove(this.particleSystem);
				this.particleSystem = null;
			}
		}
	}

	/**
	 * 雷达仿真
	 * @class LidarEX
	 */
	class LidarEX {
		/**
		 * @constructor
		 * @param {Viewer} viewer viewer对象
		 * @param {option}  传入入的参数
		 **/
		constructor(viewer, option) {
			/**
			 * viewer对象
			 * @readonly
			 * @type {Viewer}
			 */
			this.viewer = viewer;
			this._show = SceneGIS.defaultValue(option.show, true);
			/**
			 * 要素id
			 * @readonly
			 * @type {Boolean}
			 */
			this.id = option.id;

			/**
			 * 要素的data
			 * @readonly
			 * @type {Array<Entity>|Array<Primitive>}
			 */
			this.data = [];

			/**
			 * 要素的所属对象
			 * @readonly
			 * @type {Object}
			 */
			this.owner = undefined;
			this.option = option;
			this._objs = [];
			this.init();
		}
		init() {
			var scene = this.viewer.scene;
			let positon = this.option.positions;

			const planeView = this.viewer.scene.planeView;

			// 1 雷达位置计算
			// 1.1 雷达的高度
			var length = planeView ? 40000.0 : 400000.0;

			// 1.2 地面位置(垂直地面)
			var positionOnEllipsoid = planeView ? new SceneGIS.Cartesian3(positon[0], positon[1], positon[2]) : SceneGIS.Cartesian3.fromDegrees(positon[0], positon[1]);

			// 1.3 中心位置
			var centerOnEllipsoid = planeView ? new SceneGIS.Cartesian3(positon[0], positon[1], length * 0.5) : SceneGIS.Cartesian3.fromDegrees(positon[0], positon[1], length * 0.5);

			// 1.4 顶部位置(卫星位置)
			var topOnEllipsoid = planeView ? new SceneGIS.Cartesian3(positon[0], positon[1], length) : SceneGIS.Cartesian3.fromDegrees(positon[0], positon[1], length);

			// 1.5 矩阵计算
			var modelMatrix;
			if (planeView === true) {
				modelMatrix = SceneGIS.Matrix4.multiplyByTranslation(
					SceneGIS.Matrix4.fromTranslation(positionOnEllipsoid, new SceneGIS.Matrix4()),
					new SceneGIS.Cartesian3(0.0, 0.0, length * 0.5),
					new SceneGIS.Matrix4()
				);
			} else {
				modelMatrix = SceneGIS.Matrix4.multiplyByTranslation(
					SceneGIS.Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid),
					new SceneGIS.Cartesian3(0.0, 0.0, length * 0.5),
					new SceneGIS.Matrix4()
				);
			}

			// 2 相机飞入特定位置
			this.viewer.camera.flyToBoundingSphere(
				new SceneGIS.BoundingSphere(centerOnEllipsoid, length)
			);

			// 3 创建卫星
			var imageUri =
				"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMjgzLjIzIiBoZWlnaHQ9IjIwNi42NiIgZmlsbC1ydWxlPSJldmVub2RkIiB2aWV3Qm94PSIwIDAgODUwMCAxMTAwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiA8ZGVmcz4KICA8bGluZWFyR3JhZGllbnQgaWQ9ImIiPgogICA8c3RvcCBvZmZzZXQ9IjAiLz4KICAgPHN0b3Agc3RvcC1vcGFjaXR5PSIwIiBvZmZzZXQ9IjEiLz4KICA8L2xpbmVhckdyYWRpZW50PgogIDxsaW5lYXJHcmFkaWVudCBpZD0iaCIgeDE9IjQ2NjEiIHgyPSI0MzcxLjkiIHkxPSIyMTYxLjIiIHkyPSIyMzk1LjYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KICAgPHN0b3Agc3RvcC1jb2xvcj0iIzQ1NDU4NSIgb2Zmc2V0PSIwIi8+CiAgIDxzdG9wIHN0b3AtY29sb3I9IiNiYWJhZmQiIG9mZnNldD0iMSIvPgogIDwvbGluZWFyR3JhZGllbnQ+CiAgPGxpbmVhckdyYWRpZW50IGlkPSJpIiB4MT0iNDY2OS45IiB4Mj0iNDU0My42IiB5MT0iMjI5Ny4xIiB5Mj0iMjU1Ni4xIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CiAgIDxzdG9wIHN0b3AtY29sb3I9IiMzYTNhNjMiIG9mZnNldD0iMCIvPgogICA8c3RvcCBzdG9wLWNvbG9yPSIjYmFiYWZkIiBvZmZzZXQ9IjEiLz4KICA8L2xpbmVhckdyYWRpZW50PgogIDxsaW5lYXJHcmFkaWVudCBpZD0iayIgeDE9IjU0MDguMiIgeDI9IjU0ODIuNiIgeTE9IjM1ODkuNSIgeTI9IjM5NjAuNSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCguMDU0OTA3IC45MzYwMiAuOTM2OTEgLjA3MjA4MyAxNzcuNDMgLTI3MTkpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CiAgIDxzdG9wIHN0b3AtY29sb3I9IiNkOWQ5ZDkiIHN0b3Atb3BhY2l0eT0iMCIgb2Zmc2V0PSIwIi8+CiAgIDxzdG9wIHN0b3AtY29sb3I9IiNmZmYiIG9mZnNldD0iLjYyOTYzIi8+CiAgIDxzdG9wIHN0b3AtY29sb3I9IiNlOWU5ZTkiIHN0b3Atb3BhY2l0eT0iMCIgb2Zmc2V0PSIxIi8+CiAgPC9saW5lYXJHcmFkaWVudD4KICA8bGluZWFyR3JhZGllbnQgaWQ9ImwiIHgxPSI1MzE5LjMiIHgyPSI1MzcxLjIiIHkxPSIzNTA4LjEiIHkyPSIzNTY5LjgiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoLjE1Mzg2IC45NDkxOCAxLjAyNDMgLjI3MjUzIC02NzIuMzcgLTM1MjUuMSkiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KICAgPHN0b3Agb2Zmc2V0PSIwIi8+CiAgIDxzdG9wIHN0b3AtY29sb3I9IiNmZmYiIG9mZnNldD0iLjUiLz4KICAgPHN0b3Agc3RvcC1jb2xvcj0iIzBkMDAwMCIgb2Zmc2V0PSIxIi8+CiAgPC9saW5lYXJHcmFkaWVudD4KICA8bGluZWFyR3JhZGllbnQgaWQ9ImEiPgogICA8c3RvcCBvZmZzZXQ9IjAiLz4KICAgPHN0b3Agc3RvcC1jb2xvcj0iI2ExYTFhMSIgb2Zmc2V0PSIuNSIvPgogICA8c3RvcCBvZmZzZXQ9IjEiLz4KICA8L2xpbmVhckdyYWRpZW50PgogIDxsaW5lYXJHcmFkaWVudCBpZD0iZiIgeDE9IjQ2NTguOSIgeDI9IjQ0OTcuOCIgeTE9IjIyODguNSIgeTI9IjI2MzMuNyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgogICA8c3RvcCBzdG9wLWNvbG9yPSIjNDU0NTg1IiBvZmZzZXQ9IjAiLz4KICAgPHN0b3Agc3RvcC1jb2xvcj0iI2ZmZiIgb2Zmc2V0PSIxIi8+CiAgPC9saW5lYXJHcmFkaWVudD4KICA8bGluZWFyR3JhZGllbnQgaWQ9ImciIHgxPSI1MDY0LjEiIHgyPSI0NzU5LjYiIHkxPSIyMzE4LjkiIHkyPSIyNjA1LjkiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KICAgPHN0b3Agc3RvcC1jb2xvcj0iIzUxNTE5YyIgb2Zmc2V0PSIwIi8+CiAgIDxzdG9wIHN0b3AtY29sb3I9IiNmM2YzZjkiIG9mZnNldD0iMSIvPgogIDwvbGluZWFyR3JhZGllbnQ+CiAgPGxpbmVhckdyYWRpZW50IGlkPSJqIiB4MT0iNDY3My4yIiB4Mj0iNDc4Ni40IiB5MT0iMTYyNy4xIiB5Mj0iMTg2NS42IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CiAgIDxzdG9wIG9mZnNldD0iMCIvPgogICA8c3RvcCBzdG9wLWNvbG9yPSIjZmZmYmZiIiBvZmZzZXQ9Ii4yNDA3NCIvPgogICA8c3RvcCBvZmZzZXQ9IjEiLz4KICA8L2xpbmVhckdyYWRpZW50PgogIDxsaW5lYXJHcmFkaWVudCBpZD0ibSIgeDI9IjAiIHkxPSI1MjUxLjciIHkyPSI0NTYwLjkiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoLjcwNjMyIC43MDc4OSAuNzA3ODkgLS43MDYzMiAtMjQ3Mi41IDMwOTIuMykiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4bGluazpocmVmPSIjYiIvPgogIDxsaW5lYXJHcmFkaWVudCBpZD0ibiIgeDE9IjQxNTcuNSIgeDI9IjQwNzkuNiIgeTE9IjE3ODYuOCIgeTI9IjIxNDQuNCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCguOTM5NjIgLjY3ODk3IC0uNjc4OTcgLjkzOTYyIDIyODQuNyAtMjk3NS4yKSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHhsaW5rOmhyZWY9IiNiIi8+CiAgPGxpbmVhckdyYWRpZW50IGlkPSJvIiB4MT0iNDg1MS43IiB4Mj0iNDg4Ni4yIiB5MT0iMTgzMS4zIiB5Mj0iMTgwMC44IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KC4wNzc0NjcgMS4xNTA2IC0xLjE2NjEgLS4yNzA1OCA2MjQyLjIgLTMyMzIuNCkiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4bGluazpocmVmPSIjYSIvPgogIDxsaW5lYXJHcmFkaWVudCBpZD0icCIgeDE9IjQ4NDUuNSIgeDI9IjQ4NzUuNCIgeTE9IjE4MjkuNSIgeTI9IjE4MDAuMSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgtLjAwNDg0NTUgLS42MTExOCAtLjcwMjQ0IC4wMDU1NjkxIDU5MjQuNSA0NjE5LjkpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeGxpbms6aHJlZj0iI2EiLz4KICA8bGluZWFyR3JhZGllbnQgaWQ9InEiIHgxPSI0ODQ1LjUiIHgyPSI0ODc1LjQiIHkxPSIxODI5LjUiIHkyPSIxODAwLjEiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoLjg0MjIxIC0uMDU4NTA0IC4wNjcyMzkgLjk2Nzk3IDYwMy42NCAzNjkuNTkpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeGxpbms6aHJlZj0iI2EiLz4KICA8cmFkaWFsR3JhZGllbnQgaWQ9ImMiIGN4PSI1MTAxLjQiIGN5PSIzNzIwIiByPSIzNTMuODIiIGZ4PSI1MDY4LjIiIGZ5PSIzNjUwLjEiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoLjI2MjYxIDIuMTE0IDEuNTkzNCAuMDgwODQ2IC0zMzMyLjUgLTg3NjEuNSkiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KICAgPHN0b3Agc3RvcC1jb2xvcj0iIzA1MDEwMSIgb2Zmc2V0PSIwIi8+CiAgIDxzdG9wIHN0b3AtY29sb3I9IiNmZmYiIG9mZnNldD0iMSIvPgogIDwvcmFkaWFsR3JhZGllbnQ+CiAgPHJhZGlhbEdyYWRpZW50IGlkPSJkIiBjeD0iNTA2My4xIiBjeT0iMzc0Ny41IiByPSIzMjkuMzYiIGZ4PSI1MTMyLjciIGZ5PSIzNjU0LjkiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoLS4wNzM5MDMgLS42NzM2NSAtLjU5NTI5IC4wMTE4NTMgNjUxMi41IDU3NDkuOSkiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KICAgPHN0b3Agc3RvcC1jb2xvcj0iI2M2YzZjNiIgb2Zmc2V0PSIwIi8+CiAgIDxzdG9wIHN0b3AtY29sb3I9IiMxYTFhMWEiIG9mZnNldD0iMSIvPgogIDwvcmFkaWFsR3JhZGllbnQ+CiAgPHJhZGlhbEdyYWRpZW50IGlkPSJlIiBjeD0iMzk3Ny42IiBjeT0iMjQxNS40IiByPSIxMTkuMTUiIGZ4PSIzOTY0LjQiIGZ5PSIyNDYxLjciIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoLTEuMjczMSAuNDA1ODcgLS4zNzA3MSAtMS4xNjI4IDEwNTU4IDMwMDAuNCkiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KICAgPHN0b3Agc3RvcC1jb2xvcj0iI2ZmZiIgb2Zmc2V0PSIwIi8+CiAgIDxzdG9wIHN0b3AtY29sb3I9IiMwNDAwMDAiIG9mZnNldD0iMSIvPgogIDwvcmFkaWFsR3JhZGllbnQ+CiA8L2RlZnM+CiA8ZyB0cmFuc2Zvcm09Im1hdHJpeCg3LjYwNzQgLS4yNTYwNCAuMjU2MDQgNy42MDc0IC0zMzM2MSAtNjY4NC44KSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCguODgzMzMgLjExMDYxIC0uMTY4MzUgLjg3OTQ5IDgyNy4xNCAtMTAxNSkiPgogICA8cGF0aCBkPSJtNDYxMS4yIDI1MDkuOCAyNzYuNTktMTYzLjM0LTQwMi45Mi0yMjAuOTMtMjYzLjA5IDExMS45NyAzODkuNDIgMjcyLjI5eiIgZmlsbD0iIzVlODg5ZCIvPgogICA8cGF0aCBkPSJtNDY0Ny41IDIyMzMuOS0xNjAuNDQtODkuNDM0LTkxLjM4MSA0MS4xMjggMTU1LjQ1IDEwMS4zNSA5Ni4zNy01My4wNDV6bS0zODEuNjMgOS4wMjYgMTYwLjc1IDExMi44NiAxMDYuNDctNTguODI2LTE1Ny4yNC0xMDIuNjYtMTA5Ljk3IDQ4LjYzMXptMjg0LjQgNjUuMTUzLTEwNS4xMiA1OS40MDEgMTY3LjEgMTE2LjA2IDExMC45My02My4yNTQtMTcyLjkxLTExMi4yMXptMTg5LjU5IDEwMS41OSAxMDkuNDktNjMuMjg5LTE4NC4zNS0xMDIuODYtOTYuODY5IDUzLjg1NCAxNzEuNzMgMTEyLjI5eiIgZmlsbD0idXJsKCNoKSIgZmlsbC1ydWxlPSJub256ZXJvIi8+CiAgPC9nPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KC41NzcyNSAuMjYwNDcgLS41NjE4NSAuODY4MDUgMjkyNC4zIC0xOTY3LjQpIj4KICAgPHBhdGggZD0ibTQ2MTEuMiAyNTA5LjggMjc2LjU5LTE2My4zNC0zNzUuMTktMjE5LjY2Yy05LjQwNjYtNC4zODI5LTE1Ljk4Ni01Ljc0LTI4Ljk1LTMuMTUyOGwtMjQ2LjM4IDEwNy4xMmMtNi4zMjY5IDQuMjM1OC02LjI4MiA5LjcyOTItMi4yMjM4IDE2LjAxNWwzNzYuMTUgMjYzLjAxeiIgZmlsbD0iIzNjNjg3ZSIvPgogICA8cGF0aCBkPSJtNDY1MS4zIDIyMzEuOC0xNTMuMzgtOTIuNjc5LTEwMi4xOSA0Ni41NDYgMTU1LjQ1IDEwMS4zNSAxMDAuMTItNTUuMjJ6bS0zODUuMzkgMTEuMjAxIDE2MC43NSAxMTIuODYgMTA2LjQ3LTU4LjgyNi0xNTcuMjQtMTAyLjY2LTEwOS45NyA0OC42MzF6bTI4NC40IDY1LjE1My0xMDUuMTIgNTkuNDAxIDE2Ny4xIDExNi4wNiAxMTAuOTMtNjMuMjU0LTE3Mi45MS0xMTIuMjF6bTE4OS41OSAxMDEuNTkgMTA5LjQ5LTYzLjI4OS0xODAuNi0xMDUuMDQtMTAwLjYyIDU2LjAyOSAxNzEuNzMgMTEyLjI5eiIgZmlsbD0idXJsKCNpKSIgZmlsbC1ydWxlPSJub256ZXJvIi8+CiAgPC9nPgogIDxwYXRoIGQ9Im00NjA0LjggMTY0Ny44Yy0xNi42MjYtMTUuNzU1LTEuMDcyLTI4LjE5IDEzLjc4Ny0xMy40OGwyOC4xNjQgMjAuOTZjMTcuOTM5IDEwLjgwMi01Ljg0OTUgMjguODE0LTE3LjkwNCAyMy4zMTlsLTI2LjQ3OS0yOS4wMzQgMi40MzIxLTEuNzY1eiIgZmlsbD0idXJsKCNwKSIgZmlsbC1ydWxlPSJub256ZXJvIi8+CiAgPHBhdGggZD0ibTQ2NDAuNSAxOTYwLjVjNTguMjkxLTM0LjY4MiA1MC40MTktMTYwLjkxLTUuODEyMi0yMTMuNzktNDMuOTg2LTQxLjcyLTEwMi4xOC01My4zNy0xNDIuODItMzAuNzA3bDMzNy4xOC0xNDkuM2M0NC42NTQtMjMuNTQyIDExNy42Mi0zMS4yNTIgMTY2LjgxIDIxLjE2NCAzMi4wNTYgMzQuMTU4IDQ3LjM2OCAxMjYuMTYtMTkuNjI5IDE3MC4xNGwtMzM1Ljc0IDIwMi41eiIgZmlsbD0idXJsKCNqKSIvPgogIDxwYXRoIGQ9Im00NDgzLjMgMTcyMi44YzQ0LjQtMzQuODE4IDEwMS43My0yNS4zMjkgMTUwLjI5IDIwLjczIDYwLjU3IDU4LjU3MyA3NS4xMzQgMTg4LjEzLTYuNDUyOCAyMjUuMDUtMTIwLjYxIDU0LjU3Mi0yNDYuNzEtMTY1LjExLTE0My44My0yNDUuNzh6IiBmaWxsPSJ1cmwoI2UpIi8+CiAgPHBhdGggZD0ibTQ2NDAuNSAxOTYwLjVjNTguMjkxLTM0LjY4MiA1MC40MTktMTYwLjkxLTUuODEyMi0yMTMuNzktNDMuOTg2LTQxLjcyLTEwMi4xOC01My4zNy0xNDIuODItMzAuNzA3bDMzNy4xOC0xNDkuM2M0NC42NTQtMjMuNTQyIDExNy42Mi0zMS4yNTIgMTY2LjgxIDIxLjE2NCAzMi4wNTYgMzQuMTU4IDQ3LjM2OCAxMjYuMTYtMTkuNjI5IDE3MC4xNGwtMzM1Ljc0IDIwMi41eiIgZmlsbD0idXJsKCNuKSIgZmlsbC1ydWxlPSJldmVub2RkIi8+CiAgPHBhdGggZD0ibTQ0MzYuMyAxODg0LjhjMjEuMTg0IDkuNjYzNCAyNS42MzMgMjUuNDI3IDM1LjE1NiA1Mi4yMDZsODMuODE3LTQ1LjQyOGMyNS43OTktMjMuNTI4LTYuMDY5Mi03MS4wMDMtMzMuNDY4LTYzLjQ3MmwtODUuNTA2IDU2LjY5NHoiIGZpbGw9InVybCgjbykiIGZpbGwtcnVsZT0ibm9uemVybyIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDEuMDE5NCAtLjAzODE3OSAtLjAwOTgyNDIgMS4zOTQzIDQwOC45NyAtMTAxMC41KSI+CiAgIDxwYXRoIGQ9Im00NjExLjIgMjUwOS44IDI3Ni41OS0xNjMuMzQtNDAyLjkyLTIyMC45My0yNjMuMDkgMTExLjk3IDM4OS40MiAyNzIuMjl6IiBmaWxsPSIjNWU4ODlkIi8+CiAgIDxwYXRoIGQ9Im00NjU0LjMgMjIzOC4zLTE2Ny4yNS05My43ODktOTEuMzgxIDQxLjEyOCAxNTguODUgMTAzLjEyIDk5Ljc3Ny01MC40NTR6bS0zODguNDQgNC42NzE2IDE2MC43NSAxMTIuODYgMTA4Ljc0LTU1LjQ0MS0xNTkuNTItMTA2LjA1LTEwOS45NyA0OC42MzF6bTI4Ny44MSA2Ni45MTYtMTA4LjUzIDU3LjYzOCAxNjcuMSAxMTYuMDYgMTEwLjkzLTYzLjI1NC0xNjkuNS0xMTAuNDR6bTE4Ni4xOSA5OS44MjggMTA5LjQ5LTYzLjI4OS0xNzQuMTQtOTcuNTcyLTEwMi41NCA1Mi44NSAxNjcuMTggMTA4LjAxeiIgZmlsbD0idXJsKCNmKSIgZmlsbC1ydWxlPSJub256ZXJvIi8+CiAgPC9nPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDEuMTI5MiAuMDQwOTI1IC4xNjA3MiAxLjU0MTcgLTUyMy45NCAtMTc0NC40KSI+CiAgIDxwYXRoIGQ9Im01MDIyLjIgMjYxMC45IDI2MS41LTE4NC40MWM0LjQxOTQtNi4xNTYzLTIuMjgzNS0xMC43MTgtOS4wNjYyLTE0LjEzOWwtMzc5LjU0LTYxLjkwOS0yNzYuMTUgMTY0LjM1IDM4MS4zOCA5OS40NzJjOC4wNzY1IDEuMzAyNSAxNS4zMSAwLjAwODUgMjEuODY5LTMuMzYyMnoiIGZpbGw9IiM2Zjk1YTkiLz4KICAgPHBhdGggZD0ibTUwNTMuMiAyMzkyLjQtMTU2Ljg2LTI3LjY5Ni05Ni4wMjcgNTguODQ4IDE1NC43MiAzNS4xMjggOTguMTYxLTY2LjI4MXptLTM4OS4yNCAxMTMuODkgMTU5LjYgNDIuNjc5IDExMi40My03Ny4xNzUtMTU2LjUtMzUuNjQzLTExNS41MiA3MC4xNHptMjg5LjEzLTMwLjY3OC0xMTEuMDggNzcuMjQxIDE2NS45NiA0My4zNzQgMTE3LjI0LTgxLjk1OC0xNzIuMTMtMzguNjU3em0xODkuODIgMjUuNDU4IDEwOC41OC03NS41OTUtMTc5LjU3LTI5LjY4MS05OS45MTQgNjYuMjEgMTcwLjkxIDM5LjA2NnoiIGZpbGw9InVybCgjZykiIGZpbGwtcnVsZT0ibm9uemVybyIvPgogIDwvZz4KICA8cGF0aCBkPSJtNDgzNS4zIDE4NjcuOGMyMy40NzEgMjEuMjE3IDQxLjExIDAuNzAyNSAxOS4yNjctMTguMTkzbC0zMS44NjgtMzYuNTUxYy0xNi43OS0yMy41NTQtNDEuMjY0IDEwLjc2MS0zMi40MTEgMjYuNzc2bDM1LjM0MyAyNi4xOSAzLjgyODctMS44NTI0IDUuODQxMiAzLjYyOTN6IiBmaWxsPSJ1cmwoI3EpIiBmaWxsLXJ1bGU9Im5vbnplcm8iLz4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCguOTk2MzMgLS4wODU1NzIgLjA4NTU3MiAuOTk2MzMgMjYzLjYxIC0zMC40MDQpIj4KICAgPHBhdGggZD0ibTQxNTEuMyAyODAzLjNjOTQuODU3LTI3LjM0MyAyNi4wNTYtMjEzLjc2LTE0OC4yOC00MDMuNjQtMTc1LjE4LTE4OS41OS0zOTcuOTMtMzI4LjA2LTQ4NS41OC0yODUuODMtNzkuNTg0IDM4LjMzOS0yNS4zNzcgMjEyLjM3IDE0OC43MiA0MDIuNDYgMTI5Ljc4IDEzOS40MiAzNjAuMTggMzIzLjA0IDQ4NS4xNCAyODcuMDJ6IiBmaWxsPSJ1cmwoI2MpIi8+CiAgIDxwYXRoIGQ9Im00MTU0LjcgMjc5NmM5NC44NTctMjcuMzQzIDI2Ljg4Ny0xODIuMzItMTMwLjg3LTM4My44OC0xNzUuNDQtMjI0LjE1LTM5Mi42MiA5NC4wNDQtMjU2LjkzIDE5Ni45MSAxMTMuMzQgODUuOTI0IDI2Mi44NCAyMjIuOTkgMzg3LjggMTg2Ljk3eiIgZmlsbD0idXJsKCNrKSIgb3BhY2l0eT0iLjUiLz4KICAgPHBhdGggZD0ibTM5NTAuNiAyMzcxLjRjNC4zOTAxLTUuNDIxMy0yNi45MjEtMzcuNzY4LTM0LjIxNS0zMi40NDRsLTI5OS4xOCAzMjEuMjRjLTExLjY4OSAxMy4wODQgMC43MzA4IDI0LjAzMiAxMi40OTYgMTEuMjc5bDMyMC45LTMwMC4wOHoiIGZpbGw9InVybCgjbCkiLz4KICAgPHBhdGggZD0ibTM1MTcuMyAyMTE0YzEyNC45Ni02Ny4zMiAzMzQuMjcgNC4xNDEgNDY5LjQxIDEyMy4xNiAxNDAuMDUgMTIzLjM0IDI0OS4zNSAzNTMuMyAyMDIuNyA1MjkuNyAyMy4xMzgtNjkuNzExLTQ4LjAyNC0yMTYuNDYtMTg2LjM3LTM2Ny4xNC0xNzUuMTgtMTg5LjU5LTM5Ni4xNy0zMjQuNTEtNDg1LjczLTI4NS43MnoiIGZpbGw9InVybCgjZCkiLz4KICAgPHBhdGggZD0ibTM5NTAuNiAyMzcxLjRjNC4zOTAxLTUuNDIxMy0yNi45MjEtMzcuNzY4LTM0LjIxNS0zMi40NDRsLTI5OS4xOCAzMjEuMjRjLTExLjY4OSAxMy4wODQgMC43MzA4IDI0LjAzMiAxMi40OTYgMTEuMjc5bDMyMC45LTMwMC4wOHoiIGZpbGw9InVybCgjbSkiLz4KICA8L2c+CiA8L2c+Cjwvc3ZnPgo=";
			var billboards = scene.primitives.add(new SceneGIS.BillboardCollection());
			billboards.add({
				// image : './Tutorials/satellite1.svg',
				image: imageUri,
				position: topOnEllipsoid,
				horizontalOrigin: SceneGIS.HorizontalOrigin.LEFT,
				verticalOrigin: SceneGIS.VerticalOrigin.BOTTOM,
				pixelOffset: new SceneGIS.Cartesian2(-10, 10),
				scale: 0.3,
			});
			this._objs.push(billboards);
			// 4 创建雷达放射波
			// 4.1 先创建Geometry
			var cylinderGeometry = new SceneGIS.CylinderGeometry({
				length: length,
				topRadius: 0.0,
				bottomRadius: length * 0.5,

				vertexFormat: SceneGIS.MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat,
				planeView: planeView,
			});

			// 4.2 创建GeometryInstance
			var redCone = new SceneGIS.GeometryInstance({
				geometry: cylinderGeometry,
				modelMatrix: modelMatrix,
			});

			// 4.3 创建Primitive
			var radar = scene.primitives.add(
				new SceneGIS.Primitive({
					geometryInstances: [redCone],

					appearance: new SceneGIS.MaterialAppearance({
						material: new SceneGIS.Material({
							fabric: {
								type: "VtxfShader1",
								uniforms: {
									color: new SceneGIS.Color(42 / 255, 106 / 255, 251 / 255, 1.0),
									repeat: 40.0,
									offset: 0,
									thickness: 0.2,
									// image : '../static/images/colorRange.png',
								},
								source: `
                            uniform vec4 color;
                            uniform float repeat;
                            uniform float offset;
                            uniform float thickness;
                            czm_material czm_getMaterial(czm_materialInput materialInput)
                            {
                                czm_material material = czm_getDefaultMaterial(materialInput);
                                float sp = 1.0/repeat;
                                vec2 st = materialInput.st;
                                float dis = distance(st, vec2(0.5));
                                float m = mod(dis + offset, sp);
                                float a = step(sp*(1.0-thickness), m);
                                material.diffuse = color.rgb;
                                material.alpha = a * color.a;
                                return material;
                            }
                        `,
							},
							translucent: false,
						}),
						faceForward: false, // 当绘制的三角面片法向不能朝向视点时，自动翻转法向，从而避免法向计算后发黑等问题
						closed: true, // 是否为封闭体，实际上执行的是是否进行背面裁剪
					}),
				})
			);

			this._objs.push(radar);
			// 5 动态修改雷达材质中的offset变量，从而实现动态效果。
			this.update = function () {
				var offset = radar.appearance.material.uniforms.offset;
				offset -= 0.001;
				if (offset > 1.0) {
					offset = 0.0;
				}
				radar.appearance.material.uniforms.offset = offset;
			};
			this.viewer.scene.preUpdate.addEventListener(this.update);
		}
		/**
		 * 显隐控制
		 *
		 * @memberof LidarEX.prototype
		 * @type {Boolean}
		 */
		get show() {
			return this._show;
		}
		/**
		 * 显隐控制
		 *
		 * @memberof LidarEX.prototype
		 * @type {Boolean}
		 */
		set show(value) {
			this._show = value;
			for (let obj of this._objs) {
				obj.show = value;
			}
		}
		/**
		 * 销毁对象
		 * @return {boolean} 销毁成功返回true,否则返回false
		 */
		destroy() {
			for (let obj of this._objs) {
				this.viewer.scene.primitives.remove(obj);
			}
			this.viewer.scene.preUpdate.removeEventListener(this.update);
		}

		/**
		 * 改变颜色
		 * @return {boolean} 成功返回true,否则返回false
		 */
		changeColor(option) {
			throw new SceneGIS.DeveloperError("error");
		}
	}

	/**
	 * 烟花特效
	 * @class FireworkEX
	 */
	class FireworkEX {
		/**
		 * @constructor
		 * @param {Viewer} viewer viewer对象
		 * @param {option}  传入入的参数
		 **/
		constructor(viewer, option) {
			/**
			 * viewer对象
			 * @readonly
			 * @type {Viewer}
			 */
			this.viewer = viewer;
			this._show = SceneGIS.defaultValue(option.show, true);
			/**
			 * 要素id
			 * @readonly
			 * @type {Boolean}
			 */
			this.id = option.id;

			/**
			 * 要素的data
			 * @readonly
			 * @type {Array<Entity>|Array<Primitive>}
			 */
			this.data = [];

			/**
			 * 要素的所属对象
			 * @readonly
			 * @type {Object}
			 */
			this.owner = undefined;
			this._objs = [];
			this.option = option;
			this.init();
		}
		/**
		 * 显隐控制
		 *
		 * @memberof FireworkEXprototype
		 * @type {Boolean}
		 */
		get show() {
			return this._show;
		}
		/**
		 * 显隐控制
		 *
		 * @memberof FireworkEXprototype
		 * @type {Boolean}
		 */
		set show(value) {
			this._show = value;
			for (let obj of this._objs) {
				obj.show = value;
			}

		}
		/**
		 * 销毁对象
		 * @return {boolean} 销毁成功返回true,否则返回false
		 */
		destroy() {
			for (let obj of this._objs) {
				this.viewer.scene.primitives.remove(obj);
			}

		}

		/**
		 * 改变颜色
		 * @return {boolean} 成功返回true,否则返回false
		 */
		changeColor(option) {
			throw new SceneGIS.DeveloperError("error");
		}

		/*private*/
		init() {
			let self = this;
			let _option = this.option;
			let position = _option.positions;

			const scene = this.viewer.scene;

			scene.debugShowFramesPerSecond = true;

			SceneGIS.Math.setRandomNumberSeed(315);

			const planeView = this.viewer.scene.planeView;
			let pos1;
			if (planeView === true) {
				pos1 = new SceneGIS.Cartesian3(
					position[0],
					position[1]
				);
			} else {
				pos1 = SceneGIS.Cartesian3.fromDegrees(
					position[0],
					position[1]
				);
			}
			var positionOnEllipsoid = planeView ? new SceneGIS.Cartesian3(position[0], position[1], position[2]) : SceneGIS.Cartesian3.fromDegrees(position[0], position[1]);
			let modelMatrix;
			if (planeView === true) {
				modelMatrix = SceneGIS.Matrix4.multiplyByTranslation(
					SceneGIS.Matrix4.fromTranslation(positionOnEllipsoid, new SceneGIS.Matrix4()),
					new SceneGIS.Cartesian3(0.0, 0.0, length * 0.5),
					new SceneGIS.Matrix4()
				);
			}
			else {
				modelMatrix = SceneGIS.Transforms.eastNorthUpToFixedFrame(pos1);
			}
			// const modelMatrix = SceneGIS.Transforms.eastNorthUpToFixedFrame(
			//  pos1
			// );
			const emitterInitialLocation = new SceneGIS.Cartesian3(0.0, 0.0, 100.0);

			let particleCanvas;

			function getImage() {
				if (!SceneGIS.defined(particleCanvas)) {
					particleCanvas = document.createElement("canvas");
					particleCanvas.width = 20;
					particleCanvas.height = 20;
					const context2D = particleCanvas.getContext("2d");
					context2D.beginPath();
					context2D.arc(8, 8, 8, 0, SceneGIS.Math.TWO_PI, true);
					context2D.closePath();
					context2D.fillStyle = "rgb(255, 255, 255)";
					context2D.fill();
				}
				return particleCanvas;
			}

			const minimumExplosionSize = SceneGIS.defaultValue(_option.minimumExplosionSize, 30.0);
			const maximumExplosionSize = SceneGIS.defaultValue(_option.maximumExplosionSize, 100.0);
			let _particlePixelSize = SceneGIS.defaultValue(_option.particlePixelSize, 7.0);
			const particlePixelSize = _particlePixelSize ? new SceneGIS.Cartesian2(_particlePixelSize, _particlePixelSize) : new SceneGIS.Cartesian2(7.0, 7.0);
			const burstSize = SceneGIS.defaultValue(_option.burstSize, 400.0);
			const lifetime = SceneGIS.defaultValue(_option.lifetime, 10.0);
			const numberOfFireworks = SceneGIS.defaultValue(_option.numberOfFireworks, 20.0);

			const emitterModelMatrixScratch = new SceneGIS.Matrix4();

			function createFirework(offset, color, bursts) {
				const position = SceneGIS.Cartesian3.add(
					emitterInitialLocation,
					offset,
					new SceneGIS.Cartesian3()
				);
				const emitterModelMatrix = SceneGIS.Matrix4.fromTranslation(
					position,
					emitterModelMatrixScratch
				);
				const particleToWorld = SceneGIS.Matrix4.multiply(
					modelMatrix,
					emitterModelMatrix,
					new SceneGIS.Matrix4()
				);
				const worldToParticle = SceneGIS.Matrix4.inverseTransformation(
					particleToWorld,
					particleToWorld
				);

				const size = SceneGIS.Math.randomBetween(
					minimumExplosionSize,
					maximumExplosionSize
				);
				const particlePositionScratch = new SceneGIS.Cartesian3();
				const force = function (particle) {
					const position = SceneGIS.Matrix4.multiplyByPoint(
						worldToParticle,
						particle.position,
						particlePositionScratch
					);
					if (SceneGIS.Cartesian3.magnitudeSquared(position) >= size * size) {
						SceneGIS.Cartesian3.clone(SceneGIS.Cartesian3.ZERO, particle.velocity);
					}
				};

				const normalSize =
					(size - minimumExplosionSize) /
					(maximumExplosionSize - minimumExplosionSize);
				const minLife = 0.3;
				const maxLife = 1.0;
				const life = normalSize * (maxLife - minLife) + minLife;

				let primitive = scene.primitives.add(
					new SceneGIS.ParticleSystem({
						image: getImage(),
						startColor: color,
						endColor: color.withAlpha(0.0),
						particleLife: life,
						speed: _option.speed ? _option.speed : 100.0,
						imageSize: particlePixelSize,
						emissionRate: 0,
						emitter: new SceneGIS.SphereEmitter(0.1),
						bursts: bursts,
						lifetime: lifetime,
						updateCallback: force,
						modelMatrix: modelMatrix,
						emitterModelMatrix: emitterModelMatrix,
					})
				);
				self._objs.push(primitive);
			}

			const xMin = -100.0;
			const xMax = 100.0;
			const yMin = -80.0;
			const yMax = 100.0;
			const zMin = -50.0;
			const zMax = 50.0;

			const colorOptions = [
				{
					minimumRed: 0.75,
					green: 0.0,
					minimumBlue: 0.8,
					alpha: 1.0,
				},
				{
					red: 0.0,
					minimumGreen: 0.75,
					minimumBlue: 0.8,
					alpha: 1.0,
				},
				{
					red: 0.0,
					green: 0.0,
					minimumBlue: 0.8,
					alpha: 1.0,
				},
				{
					minimumRed: 0.75,
					minimumGreen: 0.75,
					blue: 0.0,
					alpha: 1.0,
				},
			];

			for (let i = 0; i < numberOfFireworks; ++i) {
				const x = SceneGIS.Math.randomBetween(xMin, xMax);
				const y = SceneGIS.Math.randomBetween(yMin, yMax);
				const z = SceneGIS.Math.randomBetween(zMin, zMax);
				const offset = new SceneGIS.Cartesian3(x, y, z);
				const color = SceneGIS.Color.fromRandom(
					colorOptions[i % colorOptions.length]
				);

				const bursts = [];
				for (let j = 0; j < 3; ++j) {
					bursts.push(
						new SceneGIS.ParticleBurst({
							time: SceneGIS.Math.nextRandomNumber() * lifetime,
							minimum: burstSize,
							maximum: burstSize,
						})
					);
				}

				createFirework(offset, color, bursts);
			}

			const camera = this.viewer.scene.camera;
			const cameraOffset = new SceneGIS.Cartesian3(-300.0, 0.0, 0.0);
			camera.lookAtTransform(modelMatrix, cameraOffset);
			camera.lookAtTransform(SceneGIS.Matrix4.IDENTITY);

			const toFireworks = SceneGIS.Cartesian3.subtract(
				emitterInitialLocation,
				cameraOffset,
				new SceneGIS.Cartesian3()
			);
			SceneGIS.Cartesian3.normalize(toFireworks, toFireworks);
			// const angle =
			//   SceneGIS.Math.PI_OVER_TWO -
			//   Math.acos(SceneGIS.Cartesian3.dot(toFireworks, SceneGIS.Cartesian3.UNIT_Z));
			// camera.lookUp(angle);
		}
	}

	//以下为图层级别的实体

	let _propertyNames = [

	];
	let _propertyNamesInner = [];
	for (var prop in FeatureType$1) {
		_propertyNamesInner.push(prop);
		_propertyNames.push(prop);
	}
	/**
	 * 自定义实体，是部分图层的要素层
	 * @alias CustomEntity
	 * @constructor
	 * @param {Viewer} viewer viewer对象
	 * @param {Object} option  内部对象参数，不同的对象不一样
	 * @param {CustomEntity} option.popup 对象弹窗
	 * @param {CustomEntity} option.positions 对象位置
	 * @param {CustomEntity} option.show 对象是否显示
	 * @param {Object} option.row 对象属性
	 */
	function CustomEntity(viewer, option) {
		CheckEX.instanceOf("viewer", viewer, SceneGIS.Viewer);
		this._viewer = viewer;
		this._show = true;
		this._row = {};//对象属性
		this._option = option;
		this._positions = [];
		this._popup = undefined;//弹窗对象
		this._propertyNames = _propertyNames;
		this.merge(option);
		let show_ = SceneGIS.defaultValue(option.show, true);
		this.show = show_;
	}

	Object.defineProperties(CustomEntity.prototype, {
		/**
		 * 获取viewer
		 * @memberof CustomEntity.prototype
		 *
		 * @type {Viewer}
		 * @readonly
		 */
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		},
		/**
		 * 获取或设置是否显示
		 * @memberof CustomEntity.prototype
		 * @type {Boolean}
		 */
		show: {
			get: function () {
				return this._show;
			},
			set: function (value) {
				this._show = value;
				for (var prop of _propertyNames) {
					if (this[prop]) {
						this[prop].show = value;
					}
				}
			}
		},
		/**
		 * 对象id
		 * @memberof CustomEntity.prototype
		 * @type {String}
		 * @readonly
		 */
		id: {
			get: function () {
				return this._option.id;
			}
		},
		/**
		 * 对象属性
		 * @memberof CustomEntity.prototype
		 * @type {Object}
		 * @readonly
		 */
		row: {
			get: function () {
				return this._row;
			}
		},
		divTip: createPropertyTypeDescriptor("divTip", TipEX),
		div: createPropertyTypeDescriptor("div", DivEX),
		divDialogWithOutLine: createPropertyTypeDescriptor("divDialogWithOutLine", DialogWithOutLineEX),
		divMDialogWithOutLine: createPropertyTypeDescriptor("divMDialogWithOutLine", MDialogWithOutLineEX),
		vueDialog: createPropertyTypeDescriptor("vueDialog", VueDialogEX),
		glb: createPropertyTypeDescriptor("glb", GlbEX),
		dynamicWall: createPropertyTypeDescriptor("dynamicWall", DynamicWallEX),
		waterPolygon: createPropertyTypeDescriptor("  waterPolygon", WaterPolygonEX),
		waterLevelWell: createPropertyTypeDescriptor("waterLevelWell", WaterLevelWellEX),
		swEntity: createPropertyTypeDescriptor("swEntity", SwEntityEX),
		curveArrow: createPropertyTypeDescriptor("curveArrow", CurveArrowEX),

		pieChart: createPropertyTypeDescriptor("pieChart", PieChartEX),
		water: createPropertyTypeDescriptor("water", WaterEX),
		waterFilter: createPropertyTypeDescriptor("waterFilter", WaterFilterEX),
		flowPolyline: createPropertyTypeDescriptor("flowPolyline", FlowPolylineEX),

		customPoint: createPropertyTypeDescriptor("customPoint", PointEX),
		customGroundLine: createPropertyTypeDescriptor("customGroundLine", GroundLineEX),
		customLine: createPropertyTypeDescriptor("customLine", LineEX),
		customPolygon: createPropertyTypeDescriptor("customPolygon", PolygonEX),
		czml: createPropertyTypeDescriptor("czml", CzmlEntityEX),
		particleEffect: createPropertyTypeDescriptor("particleEffect", ParticleEffectEX),
		fountain: createPropertyTypeDescriptor("fountain", FountainEX),
		lidar: createPropertyTypeDescriptor("lidar", LidarEX),


		firework: createPropertyTypeDescriptor("firework", FireworkEX)
		//以下为图层的实体

	});
	/**
	 * 自定义实体的扩展
	 * @param {String} name 自定义实体的名称
	 * @param {Class} type 自定义实体的类型
	 */
	CustomEntity.add = function (name, type) {
		_propertyNames.push(name);
		Object.defineProperty(CustomEntity.prototype, name, createPropertyTypeDescriptor(name, type));
	};
	/**
	 * 自定义实体的删除
	 * @param {String} name 自定义实体的名称
	 */
	CustomEntity.remove = function (name) {
		if (_propertyNamesInner.indexOf(name) > -1) {
			SceneGIS.throwDeveloperError("内置实体不能删除");
		}
		let index = _propertyNames.indexOf(name);
		_propertyNames.splice(index, 1);
		delete CustomEntity.prototype[name];//删除对应的属性
	};

	var _featureZommpoint;
	/**
	 * 定位到实体
	 * @param {Viewer} viewer viewer对象
	 * @param {CustomEntity} feature  实体对象
	 * @param {Object} option  定位参数
	 * @param {SceneGIS.HeadingPitchRange} option.offset  定位偏移量，默认new SceneGIS.HeadingPitchRange(5, -0.785, 5)
	 * @param {Number} option.maximumHeight  定位最大高度
	 */
	CustomEntity.zoom = function (viewer, feature, option = {}) {
		var center = [];
		let position = feature._positions;
		var lon = 0, lat = 0, alt = 0;
		var index = 0;
		let scene = viewer.scene;
		for (var i = 0; i < position.length; i = i + 3) {
			lon += parseFloat(position[i]);
			lat += parseFloat(position[i + 1]);
			alt += parseFloat(position[i + 2]);
			index++;
		}
		center = [parseFloat(lon) / index, parseFloat(lat) / index, parseFloat(alt) / index];
		var centerjw;
		if (scene.planeView) {
			centerjw = new SceneGIS.Cartesian3(center[0], center[1], center[2]);
		} else {
			centerjw = SceneGIS.Cartesian3.fromDegrees(center[0], center[1], center[2]);
		}


		if (_featureZommpoint) {
			viewer.entities.remove(_featureZommpoint);
		}
		var hp = new SceneGIS.HeadingPitchRange(5, -0.785, 5);
		option.offset = SceneGIS.defaultValue(option.offset, hp);
		option.maximumHeight = SceneGIS.defaultValue(option.maximumHeight, 0);

		_featureZommpoint = viewer.entities.add({
			position: centerjw,
			point: {
				show: true
			}
		});
		viewer.flyTo(_featureZommpoint, option);

	};

	/**
	 * 高亮要素
	 * @param {CustomEntity} feature 要素id
	 * @param {option} option 高亮参数
	 * @param {SceneGIS.Color} [option.color=SceneGIS.Color.RED]  颜色,默认红色
	 */
	CustomEntity.highLight = function (feature, option = { color: SceneGIS.Color.RED }) {
		for (var i = 0; i < _propertyNames.length; i++) {
			_propertyNames[i];

		}
	};


	/**
	 * 创建属性描述符
	 * @param {Object} source 参数
	 */
	CustomEntity.prototype.merge = function (source) {
		//>>includeStart('debug', pragmas.debug);
		if (!SceneGIS.defined(source)) {
			throw new DeveloperError("source is required.");
		}
		//>>includeEnd('debug');

		//Name, show, and availability are not Property objects and are currently handled differently.
		//source.show is intentionally ignored because this.show always has a value.
		var propertyNames = _propertyNames;
		var sourcePropertyNames = SceneGIS.defined(source._propertyNames)
			? source._propertyNames
			: Object.keys(source);
		var propertyNamesLength = sourcePropertyNames.length;
		for (var i = 0; i < propertyNamesLength; i++) {
			var name = sourcePropertyNames[i];
			//Ignore parent when merging, this only happens at construction time.
			if (name === "parent" || name === "name" || name === "id") {
				continue;
			}
			var targetProperty = this[name];
			var sourceProperty = source[name];
			//Custom properties that are registered on the source entity must also
			//get registered on this entity.
			if (!SceneGIS.defined(targetProperty) && propertyNames.indexOf(name) === -1) {
				continue;
			}
			else {
				this[name] = sourceProperty;
			}

		}
	};

	/**
	 * 计算对象到相机的距离
	 * @param {Viewer} viewer 对象
	 * @param {CustomEntity} feature 
	 * @returns {Number} 距离
	 */
	CustomEntity.distanceToCamera = function (viewer, feature) {
		var center = [];
		let position = this._positions;
		var lon = 0, lat = 0, alt = 0;
		var index = 0;
		for (var i = 0; i < position.length; i = i + 3) {
			lon += parseFloat(position[i]);
			lat += parseFloat(position[i + 1]);
			alt += parseFloat(position[i + 2]);
			index++;
		}
		center = [parseFloat(lon) / index, parseFloat(lat) / index, parseFloat(alt) / index];
		var centerjw;
		if (scene.planeView) {
			centerjw = new SceneGIS.Cartesian3(center[0], center[1], center[2]);
		} else {
			centerjw == SceneGIS.Cartesian3.fromDegrees(center[0], center[1], center[2]);
		}
		var distance = SceneGIS.Cartesian3.distance(centerjw, viewer.camera.positionWC);//centerjw.distance()
		return distance;
	};

	/**
	 * 计算对象到相机的距离
	 * @param {Viewer} viewer 对象
	 * @param {CustomEntity} feature 
	 * @returns  {Number} 距离
	 */
	CustomEntity.prototype.distanceToCamera = CustomEntity.distanceToCamera;


	/**
	 * 销毁实体
	 */
	CustomEntity.prototype.destroy = function () {
		for (var prop of _propertyNames) {
			if (this[prop]) {
				this[prop];
				if (this[prop].destroy) {
					this[prop].destroy();
				}
				this[prop] = undefined;
			}

		}
		this._destroyPopup();
	};
	/**private 创建弹窗 */
	CustomEntity.prototype._createPopup = function () {
		if (this._popup) {
			this._destroyPopup();
		}
		if (this._option.popup) {
			this._popup = new CustomEntity(this._viewer, this._option.popup);
		}

	};
	/**private 销毁弹窗 */
	CustomEntity.prototype._destroyPopup = function () {
		if (this._popup) {
			this._popup.destroy();
			this._popup = undefined;
		}
	};

	/**
	 * @classdesc CustomEntityCollection类用于管理自定义实体集合。
	 */
	class CustomEntityCollection {
		constructor(viewer) {
			this.viewer = viewer;
			this._entities = new SceneGIS.AssociativeArray();
		}
		/**
		 * 添加对象
		 * @param {Object} entity
		 * @return {CustomEntity} 返回对象
		 */
		add(entity) {
			if (this.contains(entity.id)) {
				throw new SceneGIS.DeveloperError(`id为${entity.id}的对象已存在`);
			}
			let o;
			if (entity instanceof CustomEntity) {
				o = entity;
			}
			else {
				o = new CustomEntity(this.viewer, entity);
			}

			this._entities.set(entity.id, o);
			return o;
		}
		/**
		 * 删除对象
		 * @param {String} id
		 * @return {Boolean} 删除成功返回true,否则返回false
		 */
		remove(id) {
			let entity = this._entities.get(id);
			if (entity) {
				entity.destroy();
				this._entities.remove(id);
				return true;
			}
			return false;

		}
		/**
		 *删除全部
		 */
		removeAll() {
			this._entities.values.forEach(entity => {
				entity.destroy();
			});
			this._entities.removeAll();
		}
		/**
		 * 判断包含
		 * @param {String} id
		 */
		contains(id) {
			return this._entities.contains(id);
		}
		/**
		 * 根据id获取对象
		 * @param {String} id
		 * @return {Object} 返回对象
		 */
		get(id) {
			return this._entities.get(id);
		}
	}

	/**
	 * 图层类对象，用数组渲染，继承IEntityEX接口
	 * @class EchartsEntityEX
	 */
	class EchartsEntityEX {
		/**
		* @constructor
		* @param {Viewer} viewer viewer对象
		* @param {option}  传入入的参数
		**/
		constructor(viewer, option) {
			/**
			 * viewer对象
			 * @readonly
			 * @type {Viewer}
			 */
			this.viewer = viewer;

			this._show = SceneGIS.defaultValue(option.show, true);
			/**
			 * 要素id
			 * @readonly
			 * @type {Boolean}
			*/
			this.id = option.id;

			/**
			 * 要素的data
			 * @readonly
			 * @type {Array<Entity>|Array<Primitive>}
			*/
			this.data = [];

			/**
			 * 要素的所属对象
			 * @readonly
			 * @type {Object}
			*/
			this.owner = SceneGIS.defaultValue(option.owner, undefined);
			this._data = undefined;



		}
		/**
		 * 显隐控制
		 *
		 * @memberof EchartsEntityEX.prototype
		 * @type {Boolean}
		*/
		get show() {
			return this._show;
		}
		/**
		 * 显隐控制
		 *
		 * @memberof EchartsEntityEX.prototype
		 * @type {Boolean}
		*/
		set show(value) {
			this._show = value;
			this._ds.entities.getById(this.id).show = value;
		}
		/**
		 * 销毁对象
		 * @return {boolean} 销毁成功返回true,否则返回false
		 */
		destroy() {
			this._ds.entities.removeById(this.id);
		}

		/**
		* 改变颜色
		* @return {boolean} 成功返回true,否则返回false
		*/
		changeColor(option) {
			throw new SceneGIS.DeveloperError('error');
		}
	}

	/**
	 * 动态立体墙
	 *
	 * @alias FenceEX
	 * @constructor
	 * 
	 **/
	class FenceEX {
		/**
		*@param {Viewer} viewer viewer对象
		* @param {Array<Cartesian3> | Array<Object>}  点数组，可以是带有x,y,z属性的对象数组
		* @param {Number} fenceHeight 围墙高度
		* @param {Color} cesiumColor 围墙颜色 
		* @param {String | img} img 图片地址
		**/
		constructor(viewer, positions, fenceHeight, cesiumColor, img) {
			this.viewer = viewer;
			this.fenceHeight = fenceHeight;
			this._owner = option.owner ? option.owner : undefined;
			this.cesiumColor = cesiumColor;
			this.img = img ? img : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAz3SURBVHja7J1Jltw4DEQV9fL+d/RJ0Au7q9xuZ0mUABIA/195UVZyCARBaoDM7ACAPflgCAAwAADAAAAAAwAADAAAMAAAwAAAAAMAAAwAADAAAMAAAAADAAAMAAAwAADAAAAAAwAADAAAMAAAwAAAAAMAAAwAADAAAMAAAAADAAAMAAAwAADAAAAAAwAADAAAMAAAwAAAAAMAAAwAADAAAMAAAAADAAAMAAADAAAMAAAwAADAAAAAAwAADAAAMAAAwAAAAAMAAAwAADAAAMAAAAADAAAMAAAwAADAAAAAAwAADAAAMAAAwAAAAAMAAAwAADAAAMAAAAADAAAMAAAwAADAAAAAAwAADAAAMAAAwAAAAAMAAAwAADAAAMAAAAADAMAAAAADAAAMAAAwAADAAAAAAwAADAAAMAAAwAAAAAMAAAwAADAAAMAAAAADAAAMAAAwAADAAAAAAwAADAAAMAAAwAAAAAMAAAwAADAAAMAAAAADAAAMAAAwAAB4wOvHjx+a/Jt22HEcYvBzk32SItr365qfl+4v1NeC3xTBXyFusk+S4q6pKmPgYwCKERBsEzcQadcTDeBKcCvvSKHthCPrMTFvrzF4cR+R2MTB11wDKBxBBH9UjOpZ3OjbX7Enk2uju0khtedbAGiX6TgnfTZwFRGJJQ1gQsL9dsHYe9oX9t6IyxoqHGnfTQPQIqWrzgSvUsn47xLYzTKPkfZN2gLk8cxp55w1gv+spUa4z1G3V4RYiAE8bp3SjLo6K8m/c8IYzudIgQM9KpTRtlwzgIxR0zEhFS1NbzLq1YiN7wKs35ZwpLk01Nje7G0A2r4FdhyH9nUhDOaXAXyU61ymU5fC+YKOgxQkbuxLGMzdDEBL50AOg6Rq0lJWoZMsZG/UN9NaZwugW1pVgW4ZQodV01r3DEBt1rAqzbWlv4w3hQxiu0NAdBIWb9pkUpveHdDbDOCjgV6J1m4mum7V32kNsQ4ZgDYSqG0jVyWeiqxbkvF26bEBbLs9Y3Waa3TfCG36/RH10eSbLcCSm1M8mQXvZbU46AIfmFqq+zcZgHJMestNuZuSbG67saSOut/8i0A/Re8r/WkfVZx/9LfOI8gOAw3go3F82/eC1VYb65xr1SVXWfwhpHL1B2zEANRYsMT2qtWa+gPn14w7VdSIAXykEg5b0h55AnNXYnuzJgP4e3CrwsLQzJeszcjWrT+w/BBwfgagbOI7asxW8e4srD/waDR+qz9g3UTilwHceAqJtXmvVX/O/ZHQDyOqjQLknQFotfiUZ1RZ9SvHROJtkr8CZp8BNBaf0ik3VMDNEi5tapguGcC0Z9+etcRaanjFR1HYbaXdZo1OnUsG4La3i60/oFvt6ij2efUHdn2CT8vn6GLDTjKAyerPWX/AssVf9Dg7tu/t2TxJRFgsDOn1xAC0u5M72NL/pb7xs28zx4Ds46IBaJEmmI+d9qPzl3w0+zwDaLfznS/ak/tLShcIEW9IbheO5i6WZAZQMb3S8BwEV32Uo9q8X2dWeHwIrSVwSd/CIB1OdpS2T9ZncVXuqNhop/SZAbj8sEqNc7U+saetG32WdZJfx3F8OLyHVS0NIJjqxpOFtanoZ7+ejPPrOA7JtXPEVqHdkUV2QAmDSQ23rU+av9NdgKXBpCdXzbAyUX8g06rhdjB6zwBquKa1kBIJ1VydZNK24lVx1QDsz5/3GafQ0SZ0mmZTzmobekwz3B8mG9DtJwFFjCY/VfjPJ2cLtdtXGBMf6yi5bHEGMF/0Nkcpzz85G7MYza0/kPexjhzZFAbgEZCnqlLJtEetfvjnJCmt3sLqD+i7+gNZDcD8pnyC3NjJrNNJvfoDE0ucntcfuHcIWGQN2PaDH/tkZZR+ebg48jowApqWkTEr+WTPGQABSUBurJO/G0DmtHh5274tH0NAQq4t0i0DUOJg1eqB1uKWcWhROSNzmr3pTwJmCVZS37z1Bzr6nXlPSjZBZTkDsIt/pAL1B3qu2TmCnwWgigH8mjtXBy1Sf+DeX+9df8AuDhx7H3cDsJh7qRqaMOoPRH05Y3H9AbvYPkX1mROTMwNQhi0AUxQR7rq/p50ysU3qD7AFgOWRf1R7HjbBtmNjrWAAFUQ7dn6yvv7ArU5Tf8A/qM9H52vUMYBVE3b+orrbSSP1B1oHtu6OfV0DyDev9lj5BbTavP5A0tU6NoSmG0Cx+gM2rUXsW3dIw+UXBD5ym2oAvv1O8VIA9E4Iby8Ai+oPDDNkAE8H2rffWh3U2iwY0nZg4cPRTo5QxABUW1ZbJOJJ6w9UsdW4BSCpsn4aQNZl47xd2wR288DbbwFIEnM/DUB5RXlznCrWK4Qm2zWPD5/Pqj+Q/jagXJyc4I+Tc0pztdntqlp/oNTrwETyirxS4VMy0OoBnVB/4PoWoE+qt3l81/RHrdJJ7/oDl0S0ygAK325b6O08515gdLJPUobCIN/HkC0P7oinOHhRfdPM0GOivV6cWlsZyC7G0MKwUFwLeFHdO7CLjKDfkWDE8+bVDgGBwAZHIg3ALv2Fkk563voDpPJQwgDOJ536A4kb8HhQWfELzJ63AayZdCRUzYAsXeLTLOG62pU1h4DF3ZP6A6HKNYK/zhZg+X3a1M++UX9gjk5yvafOGcBfJz1IeFpuF8WEla/+gEX3KWLWuzzWcccA7u3z1VT922FXpzbNISCPdczLALil0x6hk0bnBlcMoPxnssBRtO+vYQOX1+xOU38gJgOwLWyyS9DLYY7fX0PUH+hjAE77N/UJni4Zu/+nmUvs2eudMuTNAKxCDBWrP5BJq2z5Ntry/WsAYZNe/6EutjHRKz4JYVCbLjT29evP1Gmgec44LLDVxhbr1B8Ya9Ngv1J+Eoz1Nr85UH+gx3HEXAOoW39g51SehKpxpjPXAPrVH8jmJLyCS2xfmelPnbzsOD60vJVdMkIR2GFCIX3889fkoJOXojMA1prpq/6XSCrtbVRUSIq2A/v9X/reI5XzDODtqHCLLWKPrglBw8ydTIaZ47ORb6fz6lOaiw2gQqH0dHv03CFG8J8NUI3PqVWoDJR9mbqxWlN/gMzOO7DvTfQfBhBXgKDgMhU4WdQfYLuWQ+x/GEBcAYI9XBhYrWvRZQtgAwmJ0rWc+gObrdZ7GMDMF0fmFBuj/kCETGxiG8jqHhqADcREv8FGPgHmLy1rIfUHhl8HFjExTwsJ6w/Yxb/OLwuC/9MARBznzP51MSAn1h/QcaSuP5BbBAnHo99zAD3qD4xlZNQfSNGnBfUHDAOY47I2uRFkZNfrD3SUnr27ppx/sveTgN4rLTTfpHstAI6dD057shmA7awytmHXrmHHYUqnk5r1B7wLgyzqLg+8Jwh6e1h/4LIS5FieaPf6A6+j7ovYfRbyvP5lA1OgIn0qrBr/Fl/cAuSfzQLPdVhBJWqj6Oq4EfMyAKX3BwUOklO38w8ipMimnJQgRwOIeXV98XnD8fSbLXwut3xmZxM7oIxKeF39Pc2ZmalRQMjlD6bg+gPaXWT3bwMquRT5gOzet1Rx92ADyBwlShpMc08BCAEyqZQGYAV1qzY/st/hQbWCplM/CPtaoDt03mR1Sl1/QJX1dq2Gu5wM4GP46uX22CkbXLHUtmbHGDdHTybiWv0BGzOAec8GWpw82VZ0CLGELctl3NKjYXwtHuMe5p42hkLrD9im9Qda9fLGIaDfq17UH4heVULrD6hvWLTGHhqA36teehwIbVRH+Oyeyi/S2iuZ+FReUirXNtt0cDDdgy8C+QZCzfoD2iPeWh5SuHwTUFV6qt4K3XFtsvaDGitcPf3dMhmACIQwDS6sP6D2a3a+j1RYhAHseqDiLpOk9QecGif/v77fpryaja0/EHIIuN+BSo76AzZ16HvVH1DazGPiS2OfGcBJAQJW/ZTBIE6yH6/6W9cf+MoANP4jiK/ZWcGetr23jL/OAM6XfMRH3lFtG2ZPrpHzENK3/sDXGYAQn/PGH8OMngIPzSpe8JnrD7w5BOQlTAdJKHXwVN3eqJ5UMzfvzW1A7ahQy9xCl99VwzhhnYrIAJJqYNVTVYv15tttt6uxxWmwmxp5EMiWi111B7ph/QF1CwZVNrobItNgBtD4w5ghqYU97xNnMQlyT1XvQNItwD1xF6pHoqTtippM4AwgXtwJ98LbbUm6bwd2Mrvu3wMwNEvPQ4ev9Dpidb4HgNb3TcOL1B8oGR6nBhA65NQfQIpDHVOY0e26ITw1gMECBL6SVXpFklzPD7GsJ7YlM7LrZwAxb55yetximQqtP3AUrT9QoZWWuDBImvoD1qj+QGzDNKHPJFmuo5v4EDC0/sDgRUKHiCwI8p4BQEKnG09I5pnM8mSJpycxACzj2v/wixXLk6JTfwADYP2YHSuaMC3bDeoM4T43gGYRgxvGSeGBVDRmDmO/tHP9gX8GABdT4aBM6LURAAAAAElFTkSuQmCC";
			this.setPositions(positions);
			this.createEntity();
		}

		get owner() {
			return this._owner;
		}

		set owner(value) {
			this.dynamicSceneGisFenceEntity.owner = value;
		}

		setPositions(value) {
			this.positions = value ? value : [];
			this.initHeights();
		}

		initHeights() {
			let minimumHeights = [];
			this.positions.forEach(position => {
				const cartographic = SceneGIS.Cartographic.fromCartesian(position);
				if (cartographic.height < 0) {
					minimumHeights.push(0);
				}
				else {
					minimumHeights.push(cartographic.height);
				}

			});

			let maximumHeights = []; //最大高度集合
			let dayMaximumHeights = []; //动态最大高度集合 长度与最大高度对应
			for (let i = 0; i < minimumHeights.length; i++) {
				maximumHeights.push(minimumHeights[i] + this.fenceHeight);
				dayMaximumHeights.push(minimumHeights[i]);
			}

			this.minimumHeights = minimumHeights;
			this.maximumHeights = maximumHeights;
			this.dayMaximumHeights = dayMaximumHeights;
		}

		createEntity() {
			//this.initSceneGisFence();
			this.initDynamicSceneGisFence();
		}

		initSceneGisFence() {
			this.fenceEntity = this.viewer.entities.add({
				wall: {
					positions: new SceneGIS.CallbackProperty(e => {
						return this.positions
					}, false),
					minimumHeights: new SceneGIS.CallbackProperty(e => {
						return this.minimumHeights
					}, false),
					maximumHeights: new SceneGIS.CallbackProperty(e => {
						return this.maximumHeights
					}, false),
					material: new SceneGIS.ImageMaterialProperty({
						image: this.img,
						transparent: true,
						color: this.cesiumColor || SceneGIS.Color.RED
					})
				}
			});
		}

		initDynamicSceneGisFence() {
			var zj = true;
			this.dynamicSceneGisFenceEntity = this.viewer.entities.add({
				wall: {
					positions: new SceneGIS.CallbackProperty(e => {
						return this.positions
					}, false),
					minimumHeights: new SceneGIS.CallbackProperty(e => {
						return this.minimumHeights;
					}, false),
					maximumHeights: new SceneGIS.CallbackProperty(e => {
						for (let i = 0; i < this.minimumHeights.length; i++) {
							if (zj) {
								this.dayMaximumHeights[i] += this.fenceHeight * 0.004;
							}
							else {
								this.dayMaximumHeights[i] -= this.fenceHeight * 0.004;
							}

							if (this.dayMaximumHeights[i] > this.maximumHeights[i]) {
								zj = false;
							}
							else
								if (this.dayMaximumHeights[i] < this.minimumHeights[i] + this.fenceHeight * 0.004) {
									zj = true;
								}
						}
						return this.dayMaximumHeights;
					}, false),
					material: new SceneGIS.ImageMaterialProperty({
						image: this.img,
						transparent: true,
						color: this.cesiumColor || SceneGIS.Color.RED
					})
				}
			});

			//this.viewer.flyTo(this.dynamicSceneGisFenceEntity)
		}

		//移除动态墙体对象
		remove() {
			this.viewer.entities.remove(this.fenceEntity);
			this.viewer.entities.remove(this.dynamicSceneGisFenceEntity);
		}
	}

	/**
	 * 这个是所有Ex对象的接口,所有Ex对象都要继承这个接口。
	 *
	 * @alias IEntityEX
	 */
	class IEntityEX {
		/**
		* @constructor
		* @param {Viewer} viewer viewer对象
		* @param {option}  传入入的参数
		**/
		constructor(viewer, option) {
			/**
			 * viewer对象
			 * @readonly
			 * @type {Viewer}
			 */
			this.viewer = viewer;
			this._show = SceneGIS.defaultValue(option.show, true);
			/**
			 * 要素id
			 * @readonly
			 * @type {Boolean}
			*/
			this.id = option.id;

			/**
			 * 要素的data
			 * @readonly
			 * @type {Array<Entity>|Array<Primitive>}
			*/
			this.data = [];

			/**
			 * 要素的所属对象
			 * @readonly
			 * @type {Object}
			*/
			this.owner = undefined;

			/**
			 * 要素的材质属性，改变颜色使用
			 * @type {Object}
			 */
			this.material = undefined;
		}
		/**
		 * 显隐控制
		 *
		 * @memberof IEntityEX.prototype
		 * @type {Boolean}
		*/
		get show() {
			return this._show;
		}
		/**
		 * 显隐控制
		 *
		 * @memberof IEntityEX.prototype
		 * @type {Boolean}
		*/
		set show(value) {
			this._show = value;
		}
		/**
		 * 销毁对象
		 * @return {boolean} 销毁成功返回true,否则返回false
		 */
		destroy() {
			throw new SceneGIS.DeveloperError('error');
		}

		/**
		* 改变颜色
		* @return {boolean} 成功返回true,否则返回false
		*/
		changeColor(option) {
			throw new SceneGIS.DeveloperError('error');
		}

	}

	/**
	 * Ecahrt图表辅助类对接Echarts 数据
	 * @class EchartsLayerEX
	 * @param {SceneGIS.Viewer} viewer
	 * @param {Object} echarts 参照echarts官网的图表配置项|json文件路径
	 * @param {Object} option 图层节点配置参数

	 */
	function EchartsLayerEX(viewer, echarts, option) {
		CheckEX.instanceOf(`图层${option.id}的 viewer`, viewer, SceneGIS.Viewer);
		this._map = viewer;
		if (echarts) {
			this.load(echarts, option);
		}

	}
	Object.defineProperties(EchartsLayerEX.prototype, {
		/**
	   * 图层是否打开
	   * @memberof EchartsLayerEX.prototype
	   * @type {Boolean}
	   */
		visible: {
			//表示图层是否可见
			get: function () {
				return this._visible;
			},
			set: function (value) {
				this._visible = value;
				this.show = value;
			},
		},
		/**
		 * 图层是否显示
		 * @memberof EchartsLayerEX.prototype
		 * @type {Boolean}
		 */
		show: {
			get: function () {
				return this._show;
			},
			set: function (value) {
				if (this._visible == false && value == true) {
					return;
				}
				if (value) {
					this.option.visible = true;
					this.load(this._echarts, this.option);
					//this.showf();
				}
				else {
					this.dispose();
				}
				//设置显隐
			},
		},
	});

	/**
	 * 创建图表图层
	 * @param {Object|String} options 参照echarts官网的图表配置项|json文件路径
	 * @param {Object} option 图层节点配置参数
	 */
	EchartsLayerEX.prototype.load = function (echarts, option) {
		this.dispose();
		this._visible = SceneGIS.defined(option.visible) ? option.visible : true;
		this._echarts = echarts;
		this.option = option;
		if (!this._visible) {
			return;
		}
		this._overlay = this._createChartOverlay();
		let options = echarts;
		if (options) {
			this._registerMap();
		}

		if (typeof options == "string" && options.constructor == String) {
			let self = this;
			axios(options).then((res) => {
				self.options = res.data;
				self._overlay.setOption(self.options || {});
			});
		} else {
			this.options = options;
			this._overlay.setOption(this.options || {});
		}
	};
	/**
	 * 更改HTML元素的指针属性:none-该元素永远不会成为鼠标事件的target; auto-元素会响应指针事件
	 * @param {Object} element HTNL元素
	 */
	EchartsLayerEX.prototype._changeEvent = function (element) {
		if (element) {
			if (element.style.pointerEvents === "none") {
				element.style.pointerEvents = "auto";
			} else {
				element.style.pointerEvents = "none";
			}
		}
	};
	/**
	 * 销毁资源
	 */
	EchartsLayerEX.prototype.dispose = function () {
		this._echartsContainer &&
			(this._map.container.removeChild(this._echartsContainer),
				(this._echartsContainer = null)),
			this._overlay && (this._overlay.dispose(), (this._overlay = null));
	};
	/**
	 * 销毁资源
	 */
	EchartsLayerEX.prototype.destroy = function () {
		this.dispose();
	};

	/**
	 * 更新图表属性
	 * @param {Object} option 参考ECharts配置项
	 */
	EchartsLayerEX.prototype.updateOverlay = function (option) {
		if (typeof option == "string" && option.constructor == String) {
			let self = this;
			axios(option).then((res) => {
				self.options = res.data;
				self._overlay.setOption(self.options || {});
			});
		} else {
			this._overlay && this._overlay.setOption(option);
		}
	};

	/**
	 * 获取viewer
	 * @returns viewer
	 */
	EchartsLayerEX.prototype.getMap = function () {
		return this._map;
	};

	/**
	 * 获取图表图层对象
	 * @returns 图表图层对象
	 */
	EchartsLayerEX.prototype.getOverlay = function () {
		return this._overlay;
	};

	/**
	 * 图表显示
	 */
	EchartsLayerEX.prototype.showf = function () {
		this._echartsContainer &&
			// (this._echartsContainer.style.visibility = "visible");
			(this._echartsContainer.style.display = "block");
	};

	/**
	 * 图表隐藏
	 */
	EchartsLayerEX.prototype.hide = function () {
		this._echartsContainer &&
			//(this._echartsContainer.style.visibility = "hidden");
			(this._echartsContainer.style.display = "none");
	};

	/**
	 * 移除图表
	 */
	EchartsLayerEX.prototype.remove = function () {
		this._chart.clear();
		if (this._echartsContainer.parentNode)
			this._echartsContainer.parentNode.removeChild(this._echartsContainer);
		this._map = undefined;
	};

	/**
	 * 调整图表尺寸与viewer尺寸相同
	 */
	EchartsLayerEX.prototype.resize = function () {
		const me = this;
		const otherResize = window.onresize;
		window.onresize = function () {
			//解决跟其他调用处的冲突
			if (otherResize && typeof otherResize === "function") {
				otherResize();
			}
			const scene = me._map.scene;
			if (me._echartsContainer) {
				me._echartsContainer.style.width = scene.canvas.clientWidth;
				me._echartsContainer.style.height = scene.canvas.clientHeight;
				me._chart.resize();
				me.updateOverlay(me.options);
			}
		};
	};

	/** @private */
	EchartsLayerEX.prototype._createChartOverlay = function () {
		const scene = this._map.scene;
		scene.canvas.setAttribute("tabIndex", 0);
		const ele = document.createElement("div");
		this.element = ele;
		this.resize();
		const self = this;
		document.onkeydown = function (ev) {
			ev = ev || window.event;
			if (
				String.fromCharCode(ev.keyCode) === "c" ||
				String.fromCharCode(ev.keyCode) === "C"
			) {
				self._changeEvent(self.element);
			}
		};
		document.onmousedown = function (event) {
			if (event.button === 1) {
				self._changeEvent(self.element);
			}
		};
		this.element.oncontextmenu = function () {
			event.returnValue = false;
		};

		return (
			(ele.style.position = "absolute"),
			(ele.style.top = "0px"),
			(ele.style.left = "0px"),
			(ele.style.width = `${scene.canvas.width}px`),
			(ele.style.height = `${scene.canvas.height}px`),
			(ele.style.pointerEvents = "none"),
			ele.setAttribute("id", "echarts"),
			ele.setAttribute("class", "echartMap"),
			this._map.container.appendChild(ele),
			(this._echartsContainer = ele),
			(echarts.glMap = scene),
			(this._chart = echarts.init(ele))
		);
	};

	/** @private */
	EchartsLayerEX.prototype._registerMap = function () {
		const self = this;
		if (!this._isRegistered) {
			echarts.registerCoordinateSystem("GLMap", GLMapCoordSys),
				echarts.registerAction(
					{
						type: "GLMapRoam",
						event: "GLMapRoam",
						update: "updateLayout",
					},
					function (t, e) { }
				),
				echarts.extendComponentModel({
					type: "GLMap",
					getBMap: function () {
						return this.__GLMap;
					},
					defaultOption: { roam: !1 },
				}),
				echarts.extendComponentView({
					type: "GLMap",
					init: function (t, e) {
						this.api = e;
						echarts.glMap.postRender.addEventListener(this.moveHandler, this);
						this.mapEventHandler = new SceneGIS.ScreenSpaceEventHandler(
							echarts.glMap.canvas
						);
						this.mapEventHandler.setInputAction(
							this.middleClick,
							SceneGIS.ScreenSpaceEventType.MIDDLE_CLICK
						);
					},
					middleClick: function () {
						self._changeEvent(self.element);
					},
					moveHandler: function (t, e) {
						this.api.dispatchAction({ type: "GLMapRoam" });
					},
					render: function (t, e, i) { },
					dispose: function (t) {
						if (this.mapEventHandler) {
							this.mapEventHandler.removeInputAction(
								SceneGIS.ScreenSpaceEventType.MIDDLE_CLICK
							);
						}
						echarts.glMap.postRender.removeEventListener(this.moveHandler, this);
					},
				});

			this._isRegistered = true;
		}
	};

	/** @private */
	function GLMapCoordSys(GLMap, api) {
		this._GLMap = GLMap;
		this.planeView = GLMap.planeView;
		this.dimensions = ["lng", "lat"];
		this._mapOffset = [0, 0];
		this._api = api;
	}
	GLMapCoordSys.prototype.dimensions = ["lng", "lat"];

	GLMapCoordSys.prototype.setMapOffset = function (mapOffset) {
		this._mapOffset = mapOffset;
	};

	GLMapCoordSys.prototype.getBMap = function () {
		return this._GLMap;
	};

	GLMapCoordSys.prototype.dataToPoint = function (data) {
		const _echartsHeight = this._GLMap.echartsHeight;
		const e = [99999, 99999],
			i = this.planeView === true ? new SceneGIS.Cartesian3(data[0], data[1], _echartsHeight)
				: SceneGIS.Cartesian3.fromDegrees(data[0], data[1], _echartsHeight);
		if (!i) {
			return e;
		}
		const n = this._GLMap.cartesianToCanvasCoordinates(i);
		if (!n) {
			return e;
		}
		return [n.x - this._mapOffset[0], n.y - this._mapOffset[1]];
		// return (
		//   !(
		//     SceneGIS.Cartesian3.angleBetween(this._GLMap.camera.position, i) >
		//     SceneGIS.Math.toRadians(75)
		//   ) && [n.x - this._mapOffset[0], n.y - this._mapOffset[1]]
		// );
	};

	GLMapCoordSys.prototype.pointToData = function (pt) {
		const mapOffset = this._mapOffset;
		pt = this._bmap.project([pt[0] + mapOffset[0], pt[1] + mapOffset[1]]);
		return [pt.lng, pt.lat];
	};

	GLMapCoordSys.prototype.getViewRect = function () {
		const api = this._api;
		return new echarts.graphic.BoundingRect(
			0,
			0,
			api.getWidth(),
			api.getHeight()
		);
	};

	GLMapCoordSys.prototype.getRoamTransform = function () {
		return echarts.matrix.create();
	};

	GLMapCoordSys.dimensions = GLMapCoordSys.prototype.dimensions;

	GLMapCoordSys.create = function (ecModel, api) {
		let coordSys;

		ecModel.eachComponent("GLMap", function (GLMapModel) {
			api.getZr().painter.getViewportRoot();
			const GLMap = echarts.glMap;
			coordSys = new GLMapCoordSys(GLMap, api);
			coordSys.setMapOffset(GLMapModel.__mapOffset || [0, 0]);
			GLMapModel.coordinateSystem = coordSys;
		});

		ecModel.eachSeries(function (seriesModel) {
			if (seriesModel.get("coordinateSystem") === "GLMap") {
				seriesModel.coordinateSystem = coordSys;
			}
		});
	};

	/**
	 * @module helpers
	 */
	/**
	 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
	 *
	 * @memberof helpers
	 * @type {number}
	 */
	var earthRadius = 6371008.8;
	/**
	 * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
	 *
	 * @memberof helpers
	 * @type {Object}
	 */
	var factors = {
		centimeters: earthRadius * 100,
		centimetres: earthRadius * 100,
		degrees: earthRadius / 111325,
		feet: earthRadius * 3.28084,
		inches: earthRadius * 39.37,
		kilometers: earthRadius / 1000,
		kilometres: earthRadius / 1000,
		meters: earthRadius,
		metres: earthRadius,
		miles: earthRadius / 1609.344,
		millimeters: earthRadius * 1000,
		millimetres: earthRadius * 1000,
		nauticalmiles: earthRadius / 1852,
		radians: 1,
		yards: earthRadius * 1.0936,
	};
	/**
	 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
	 *
	 * @name feature
	 * @param {Geometry} geometry input geometry
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature} a GeoJSON Feature
	 * @example
	 * var geometry = {
	 *   "type": "Point",
	 *   "coordinates": [110, 50]
	 * };
	 *
	 * var feature = turf.feature(geometry);
	 *
	 * //=feature
	 */
	function feature(geom, properties, options) {
		if (options === void 0) { options = {}; }
		var feat = { type: "Feature" };
		if (options.id === 0 || options.id) {
			feat.id = options.id;
		}
		if (options.bbox) {
			feat.bbox = options.bbox;
		}
		feat.properties = properties || {};
		feat.geometry = geom;
		return feat;
	}
	/**
	 * Creates a {@link Point} {@link Feature} from a Position.
	 *
	 * @name point
	 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<Point>} a Point feature
	 * @example
	 * var point = turf.point([-75.343, 39.984]);
	 *
	 * //=point
	 */
	function point(coordinates, properties, options) {
		if (options === void 0) { options = {}; }
		if (!coordinates) {
			throw new Error("coordinates is required");
		}
		if (!Array.isArray(coordinates)) {
			throw new Error("coordinates must be an Array");
		}
		if (coordinates.length < 2) {
			throw new Error("coordinates must be at least 2 numbers long");
		}
		if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
			throw new Error("coordinates must contain numbers");
		}
		var geom = {
			type: "Point",
			coordinates: coordinates,
		};
		return feature(geom, properties, options);
	}
	/**
	 * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
	 *
	 * @name polygon
	 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<Polygon>} Polygon Feature
	 * @example
	 * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
	 *
	 * //=polygon
	 */
	function polygon(coordinates, properties, options) {
		if (options === void 0) { options = {}; }
		for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
			var ring = coordinates_1[_i];
			if (ring.length < 4) {
				throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
			}
			for (var j = 0; j < ring[ring.length - 1].length; j++) {
				// Check if first point of Polygon contains two numbers
				if (ring[ring.length - 1][j] !== ring[0][j]) {
					throw new Error("First and last Position are not equivalent.");
				}
			}
		}
		var geom = {
			type: "Polygon",
			coordinates: coordinates,
		};
		return feature(geom, properties, options);
	}
	/**
	 * Creates a {@link LineString} {@link Feature} from an Array of Positions.
	 *
	 * @name lineString
	 * @param {Array<Array<number>>} coordinates an array of Positions
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<LineString>} LineString Feature
	 * @example
	 * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});
	 * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});
	 *
	 * //=linestring1
	 * //=linestring2
	 */
	function lineString(coordinates, properties, options) {
		if (options === void 0) { options = {}; }
		if (coordinates.length < 2) {
			throw new Error("coordinates must be an array of two or more positions");
		}
		var geom = {
			type: "LineString",
			coordinates: coordinates,
		};
		return feature(geom, properties, options);
	}
	/**
	 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
	 *
	 * @name featureCollection
	 * @param {Feature[]} features input features
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {FeatureCollection} FeatureCollection of Features
	 * @example
	 * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});
	 * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});
	 * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});
	 *
	 * var collection = turf.featureCollection([
	 *   locationA,
	 *   locationB,
	 *   locationC
	 * ]);
	 *
	 * //=collection
	 */
	function featureCollection(features, options) {
		if (options === void 0) { options = {}; }
		var fc = { type: "FeatureCollection" };
		if (options.id) {
			fc.id = options.id;
		}
		if (options.bbox) {
			fc.bbox = options.bbox;
		}
		fc.features = features;
		return fc;
	}
	/**
	 * Creates a {@link Feature<MultiPolygon>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name multiPolygon
	 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<MultiPolygon>} a multipolygon feature
	 * @throws {Error} if no coordinates are passed
	 * @example
	 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
	 *
	 * //=multiPoly
	 *
	 */
	function multiPolygon(coordinates, properties, options) {
		if (options === void 0) { options = {}; }
		var geom = {
			type: "MultiPolygon",
			coordinates: coordinates,
		};
		return feature(geom, properties, options);
	}
	/**
	 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
	 *
	 * @name radiansToLength
	 * @param {number} radians in radians across the sphere
	 * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
	 * meters, kilometres, kilometers.
	 * @returns {number} distance
	 */
	function radiansToLength(radians, units) {
		if (units === void 0) { units = "kilometers"; }
		var factor = factors[units];
		if (!factor) {
			throw new Error(units + " units is invalid");
		}
		return radians * factor;
	}
	/**
	 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
	 *
	 * @name lengthToRadians
	 * @param {number} distance in real units
	 * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
	 * meters, kilometres, kilometers.
	 * @returns {number} radians
	 */
	function lengthToRadians(distance, units) {
		if (units === void 0) { units = "kilometers"; }
		var factor = factors[units];
		if (!factor) {
			throw new Error(units + " units is invalid");
		}
		return distance / factor;
	}
	/**
	 * Converts an angle in radians to degrees
	 *
	 * @name radiansToDegrees
	 * @param {number} radians angle in radians
	 * @returns {number} degrees between 0 and 360 degrees
	 */
	function radiansToDegrees(radians) {
		var degrees = radians % (2 * Math.PI);
		return (degrees * 180) / Math.PI;
	}
	/**
	 * Converts an angle in degrees to radians
	 *
	 * @name degreesToRadians
	 * @param {number} degrees angle between 0 and 360 degrees
	 * @returns {number} angle in radians
	 */
	function degreesToRadians(degrees) {
		var radians = degrees % 360;
		return (radians * Math.PI) / 180;
	}
	/**
	 * isNumber
	 *
	 * @param {*} num Number to validate
	 * @returns {boolean} true/false
	 * @example
	 * turf.isNumber(123)
	 * //=true
	 * turf.isNumber('foo')
	 * //=false
	 */
	function isNumber(num) {
		return !isNaN(num) && num !== null && !Array.isArray(num);
	}
	/**
	 * isObject
	 *
	 * @param {*} input variable to validate
	 * @returns {boolean} true/false
	 * @example
	 * turf.isObject({elevation: 10})
	 * //=true
	 * turf.isObject('foo')
	 * //=false
	 */
	function isObject(input) {
		return !!input && input.constructor === Object;
	}

	/**
	 * Callback for coordEach
	 *
	 * @callback coordEachCallback
	 * @param {Array<number>} currentCoord The current coordinate being processed.
	 * @param {number} coordIndex The current index of the coordinate being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 * @param {number} geometryIndex The current index of the Geometry being processed.
	 */

	/**
	 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
	 *
	 * @name coordEach
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)
	 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
	 * @returns {void}
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {"foo": "bar"}),
	 *   turf.point([36, 53], {"hello": "world"})
	 * ]);
	 *
	 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
	 *   //=currentCoord
	 *   //=coordIndex
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 * });
	 */
	function coordEach(geojson, callback, excludeWrapCoord) {
		// Handles null Geometry -- Skips this GeoJSON
		if (geojson === null) return;
		var j,
			k,
			l,
			geometry,
			stopG,
			coords,
			geometryMaybeCollection,
			wrapShrink = 0,
			coordIndex = 0,
			isGeometryCollection,
			type = geojson.type,
			isFeatureCollection = type === "FeatureCollection",
			isFeature = type === "Feature",
			stop = isFeatureCollection ? geojson.features.length : 1;

		// This logic may look a little weird. The reason why it is that way
		// is because it's trying to be fast. GeoJSON supports multiple kinds
		// of objects at its root: FeatureCollection, Features, Geometries.
		// This function has the responsibility of handling all of them, and that
		// means that some of the `for` loops you see below actually just don't apply
		// to certain inputs. For instance, if you give this just a
		// Point geometry, then both loops are short-circuited and all we do
		// is gradually rename the input until it's called 'geometry'.
		//
		// This also aims to allocate as few resources as possible: just a
		// few numbers and booleans, rather than any temporary arrays as would
		// be required with the normalization approach.
		for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
			geometryMaybeCollection = isFeatureCollection
				? geojson.features[featureIndex].geometry
				: isFeature
					? geojson.geometry
					: geojson;
			isGeometryCollection = geometryMaybeCollection
				? geometryMaybeCollection.type === "GeometryCollection"
				: false;
			stopG = isGeometryCollection
				? geometryMaybeCollection.geometries.length
				: 1;

			for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
				var multiFeatureIndex = 0;
				var geometryIndex = 0;
				geometry = isGeometryCollection
					? geometryMaybeCollection.geometries[geomIndex]
					: geometryMaybeCollection;

				// Handles null Geometry -- Skips this geometry
				if (geometry === null) continue;
				coords = geometry.coordinates;
				var geomType = geometry.type;

				wrapShrink =
					excludeWrapCoord &&
						(geomType === "Polygon" || geomType === "MultiPolygon")
						? 1
						: 0;

				switch (geomType) {
					case null:
						break;
					case "Point":
						if (
							callback(
								coords,
								coordIndex,
								featureIndex,
								multiFeatureIndex,
								geometryIndex
							) === false
						)
							return false;
						coordIndex++;
						multiFeatureIndex++;
						break;
					case "LineString":
					case "MultiPoint":
						for (j = 0; j < coords.length; j++) {
							if (
								callback(
									coords[j],
									coordIndex,
									featureIndex,
									multiFeatureIndex,
									geometryIndex
								) === false
							)
								return false;
							coordIndex++;
							if (geomType === "MultiPoint") multiFeatureIndex++;
						}
						if (geomType === "LineString") multiFeatureIndex++;
						break;
					case "Polygon":
					case "MultiLineString":
						for (j = 0; j < coords.length; j++) {
							for (k = 0; k < coords[j].length - wrapShrink; k++) {
								if (
									callback(
										coords[j][k],
										coordIndex,
										featureIndex,
										multiFeatureIndex,
										geometryIndex
									) === false
								)
									return false;
								coordIndex++;
							}
							if (geomType === "MultiLineString") multiFeatureIndex++;
							if (geomType === "Polygon") geometryIndex++;
						}
						if (geomType === "Polygon") multiFeatureIndex++;
						break;
					case "MultiPolygon":
						for (j = 0; j < coords.length; j++) {
							geometryIndex = 0;
							for (k = 0; k < coords[j].length; k++) {
								for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
									if (
										callback(
											coords[j][k][l],
											coordIndex,
											featureIndex,
											multiFeatureIndex,
											geometryIndex
										) === false
									)
										return false;
									coordIndex++;
								}
								geometryIndex++;
							}
							multiFeatureIndex++;
						}
						break;
					case "GeometryCollection":
						for (j = 0; j < geometry.geometries.length; j++)
							if (
								coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===
								false
							)
								return false;
						break;
					default:
						throw new Error("Unknown Geometry Type");
				}
			}
		}
	}

	/**
	 * Callback for featureEach
	 *
	 * @callback featureEachCallback
	 * @param {Feature<any>} currentFeature The current Feature being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 */

	/**
	 * Iterate over features in any GeoJSON object, similar to
	 * Array.forEach.
	 *
	 * @name featureEach
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentFeature, featureIndex)
	 * @returns {void}
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {foo: 'bar'}),
	 *   turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.featureEach(features, function (currentFeature, featureIndex) {
	 *   //=currentFeature
	 *   //=featureIndex
	 * });
	 */
	function featureEach(geojson, callback) {
		if (geojson.type === "Feature") {
			callback(geojson, 0);
		} else if (geojson.type === "FeatureCollection") {
			for (var i = 0; i < geojson.features.length; i++) {
				if (callback(geojson.features[i], i) === false) break;
			}
		}
	}

	/**
	 * Callback for geomEach
	 *
	 * @callback geomEachCallback
	 * @param {Geometry} currentGeometry The current Geometry being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {Object} featureProperties The current Feature Properties being processed.
	 * @param {Array<number>} featureBBox The current Feature BBox being processed.
	 * @param {number|string} featureId The current Feature Id being processed.
	 */

	/**
	 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
	 *
	 * @name geomEach
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
	 * @returns {void}
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
	 *   //=currentGeometry
	 *   //=featureIndex
	 *   //=featureProperties
	 *   //=featureBBox
	 *   //=featureId
	 * });
	 */
	function geomEach(geojson, callback) {
		var i,
			j,
			g,
			geometry,
			stopG,
			geometryMaybeCollection,
			isGeometryCollection,
			featureProperties,
			featureBBox,
			featureId,
			featureIndex = 0,
			isFeatureCollection = geojson.type === "FeatureCollection",
			isFeature = geojson.type === "Feature",
			stop = isFeatureCollection ? geojson.features.length : 1;

		// This logic may look a little weird. The reason why it is that way
		// is because it's trying to be fast. GeoJSON supports multiple kinds
		// of objects at its root: FeatureCollection, Features, Geometries.
		// This function has the responsibility of handling all of them, and that
		// means that some of the `for` loops you see below actually just don't apply
		// to certain inputs. For instance, if you give this just a
		// Point geometry, then both loops are short-circuited and all we do
		// is gradually rename the input until it's called 'geometry'.
		//
		// This also aims to allocate as few resources as possible: just a
		// few numbers and booleans, rather than any temporary arrays as would
		// be required with the normalization approach.
		for (i = 0; i < stop; i++) {
			geometryMaybeCollection = isFeatureCollection
				? geojson.features[i].geometry
				: isFeature
					? geojson.geometry
					: geojson;
			featureProperties = isFeatureCollection
				? geojson.features[i].properties
				: isFeature
					? geojson.properties
					: {};
			featureBBox = isFeatureCollection
				? geojson.features[i].bbox
				: isFeature
					? geojson.bbox
					: undefined;
			featureId = isFeatureCollection
				? geojson.features[i].id
				: isFeature
					? geojson.id
					: undefined;
			isGeometryCollection = geometryMaybeCollection
				? geometryMaybeCollection.type === "GeometryCollection"
				: false;
			stopG = isGeometryCollection
				? geometryMaybeCollection.geometries.length
				: 1;

			for (g = 0; g < stopG; g++) {
				geometry = isGeometryCollection
					? geometryMaybeCollection.geometries[g]
					: geometryMaybeCollection;

				// Handle null Geometry
				if (geometry === null) {
					if (
						callback(
							null,
							featureIndex,
							featureProperties,
							featureBBox,
							featureId
						) === false
					)
						return false;
					continue;
				}
				switch (geometry.type) {
					case "Point":
					case "LineString":
					case "MultiPoint":
					case "Polygon":
					case "MultiLineString":
					case "MultiPolygon": {
						if (
							callback(
								geometry,
								featureIndex,
								featureProperties,
								featureBBox,
								featureId
							) === false
						)
							return false;
						break;
					}
					case "GeometryCollection": {
						for (j = 0; j < geometry.geometries.length; j++) {
							if (
								callback(
									geometry.geometries[j],
									featureIndex,
									featureProperties,
									featureBBox,
									featureId
								) === false
							)
								return false;
						}
						break;
					}
					default:
						throw new Error("Unknown Geometry Type");
				}
			}
			// Only increase `featureIndex` per each feature
			featureIndex++;
		}
	}

	/**
	 * Callback for geomReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback geomReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Geometry} currentGeometry The current Geometry being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {Object} featureProperties The current Feature Properties being processed.
	 * @param {Array<number>} featureBBox The current Feature BBox being processed.
	 * @param {number|string} featureId The current Feature Id being processed.
	 */

	/**
	 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
	 *
	 * @name geomReduce
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
	 *   //=previousValue
	 *   //=currentGeometry
	 *   //=featureIndex
	 *   //=featureProperties
	 *   //=featureBBox
	 *   //=featureId
	 *   return currentGeometry
	 * });
	 */
	function geomReduce(geojson, callback, initialValue) {
		var previousValue = initialValue;
		geomEach(
			geojson,
			function (
				currentGeometry,
				featureIndex,
				featureProperties,
				featureBBox,
				featureId
			) {
				if (featureIndex === 0 && initialValue === undefined)
					previousValue = currentGeometry;
				else
					previousValue = callback(
						previousValue,
						currentGeometry,
						featureIndex,
						featureProperties,
						featureBBox,
						featureId
					);
			}
		);
		return previousValue;
	}

	/**
	 * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.
	 *
	 * @name bbox
	 * @param {GeoJSON} geojson any GeoJSON object
	 * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order
	 * @example
	 * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);
	 * var bbox = turf.bbox(line);
	 * var bboxPolygon = turf.bboxPolygon(bbox);
	 *
	 * //addToMap
	 * var addToMap = [line, bboxPolygon]
	 */
	function bbox(geojson) {
		var result = [Infinity, Infinity, -Infinity, -Infinity];
		coordEach(geojson, function (coord) {
			if (result[0] > coord[0]) {
				result[0] = coord[0];
			}
			if (result[1] > coord[1]) {
				result[1] = coord[1];
			}
			if (result[2] < coord[0]) {
				result[2] = coord[0];
			}
			if (result[3] < coord[1]) {
				result[3] = coord[1];
			}
		});
		return result;
	}
	bbox["default"] = bbox;

	/**
	 * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
	 *
	 * @name getCoord
	 * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers
	 * @returns {Array<number>} coordinates
	 * @example
	 * var pt = turf.point([10, 10]);
	 *
	 * var coord = turf.getCoord(pt);
	 * //= [10, 10]
	 */
	function getCoord(coord) {
		if (!coord) {
			throw new Error("coord is required");
		}
		if (!Array.isArray(coord)) {
			if (coord.type === "Feature" &&
				coord.geometry !== null &&
				coord.geometry.type === "Point") {
				return coord.geometry.coordinates;
			}
			if (coord.type === "Point") {
				return coord.coordinates;
			}
		}
		if (Array.isArray(coord) &&
			coord.length >= 2 &&
			!Array.isArray(coord[0]) &&
			!Array.isArray(coord[1])) {
			return coord;
		}
		throw new Error("coord must be GeoJSON Point or an Array of numbers");
	}
	/**
	 * Unwrap coordinates from a Feature, Geometry Object or an Array
	 *
	 * @name getCoords
	 * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array
	 * @returns {Array<any>} coordinates
	 * @example
	 * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);
	 *
	 * var coords = turf.getCoords(poly);
	 * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]
	 */
	function getCoords(coords) {
		if (Array.isArray(coords)) {
			return coords;
		}
		// Feature
		if (coords.type === "Feature") {
			if (coords.geometry !== null) {
				return coords.geometry.coordinates;
			}
		}
		else {
			// Geometry
			if (coords.coordinates) {
				return coords.coordinates;
			}
		}
		throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
	}
	/**
	 * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.
	 * Internally this uses {@link geojsonType} to judge geometry types.
	 *
	 * @name collectionOf
	 * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged
	 * @param {string} type expected GeoJSON type
	 * @param {string} name name of calling function
	 * @throws {Error} if value is not the expected type.
	 */
	function collectionOf(featureCollection, type, name) {
		if (!featureCollection) {
			throw new Error("No featureCollection passed");
		}
		if (!name) {
			throw new Error(".collectionOf() requires a name");
		}
		if (!featureCollection || featureCollection.type !== "FeatureCollection") {
			throw new Error("Invalid input to " + name + ", FeatureCollection required");
		}
		for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {
			var feature = _a[_i];
			if (!feature || feature.type !== "Feature" || !feature.geometry) {
				throw new Error("Invalid input to " + name + ", Feature with geometry required");
			}
			if (!feature.geometry || feature.geometry.type !== type) {
				throw new Error("Invalid input to " +
					name +
					": must be a " +
					type +
					", given " +
					feature.geometry.type);
			}
		}
	}
	/**
	 * Get Geometry from Feature or Geometry Object
	 *
	 * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
	 * @returns {Geometry|null} GeoJSON Geometry Object
	 * @throws {Error} if geojson is not a Feature or Geometry Object
	 * @example
	 * var point = {
	 *   "type": "Feature",
	 *   "properties": {},
	 *   "geometry": {
	 *     "type": "Point",
	 *     "coordinates": [110, 40]
	 *   }
	 * }
	 * var geom = turf.getGeom(point)
	 * //={"type": "Point", "coordinates": [110, 40]}
	 */
	function getGeom(geojson) {
		if (geojson.type === "Feature") {
			return geojson.geometry;
		}
		return geojson;
	}

	// http://en.wikipedia.org/wiki/Haversine_formula
	/**
	 * Takes a {@link Point} and calculates the location of a destination point given a distance in
	 * degrees, radians, miles, or kilometers; and bearing in degrees.
	 * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
	 *
	 * @name destination
	 * @param {Coord} origin starting point
	 * @param {number} distance distance from the origin point
	 * @param {number} bearing ranging from -180 to 180
	 * @param {Object} [options={}] Optional parameters
	 * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians
	 * @param {Object} [options.properties={}] Translate properties to Point
	 * @returns {Feature<Point>} destination point
	 * @example
	 * var point = turf.point([-75.343, 39.984]);
	 * var distance = 50;
	 * var bearing = 90;
	 * var options = {units: 'miles'};
	 *
	 * var destination = turf.destination(point, distance, bearing, options);
	 *
	 * //addToMap
	 * var addToMap = [point, destination]
	 * destination.properties['marker-color'] = '#f00';
	 * point.properties['marker-color'] = '#0f0';
	 */
	function destination(origin, distance, bearing, options) {
		if (options === void 0) { options = {}; }
		// Handle input
		var coordinates1 = getCoord(origin);
		var longitude1 = degreesToRadians(coordinates1[0]);
		var latitude1 = degreesToRadians(coordinates1[1]);
		var bearingRad = degreesToRadians(bearing);
		var radians = lengthToRadians(distance, options.units);
		// Main
		var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +
			Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));
		var longitude2 = longitude1 +
			Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));
		var lng = radiansToDegrees(longitude2);
		var lat = radiansToDegrees(latitude2);
		return point([lng, lat], options.properties);
	}

	/**
	 * Takes a {@link Point} and calculates the circle polygon given a radius in degrees, radians, miles, or kilometers; and steps for precision.
	 *
	 * @name circle
	 * @param {Feature<Point>|number[]} center center point
	 * @param {number} radius radius of the circle
	 * @param {Object} [options={}] Optional parameters
	 * @param {number} [options.steps=64] number of steps
	 * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians
	 * @param {Object} [options.properties={}] properties
	 * @returns {Feature<Polygon>} circle polygon
	 * @example
	 * var center = [-75.343, 39.984];
	 * var radius = 5;
	 * var options = {steps: 10, units: 'kilometers', properties: {foo: 'bar'}};
	 * var circle = turf.circle(center, radius, options);
	 *
	 * //addToMap
	 * var addToMap = [turf.point(center), circle]
	 */
	function circle(center, radius, options) {
		if (options === void 0) { options = {}; }
		// default params
		var steps = options.steps || 64;
		var properties = options.properties
			? options.properties
			: !Array.isArray(center) && center.type === "Feature" && center.properties
				? center.properties
				: {};
		// main
		var coordinates = [];
		for (var i = 0; i < steps; i++) {
			coordinates.push(destination(center, radius, (i * -360) / steps, options).geometry
				.coordinates);
		}
		coordinates.push(coordinates[0]);
		return polygon([coordinates], properties);
	}

	/**
	 * Takes a {@link Feature} or {@link FeatureCollection} and returns the absolute center point of all features.
	 *
	 * @name center
	 * @param {GeoJSON} geojson GeoJSON to be centered
	 * @param {Object} [options={}] Optional parameters
	 * @param {Object} [options.properties={}] Translate GeoJSON Properties to Point
	 * @param {Object} [options.bbox={}] Translate GeoJSON BBox to Point
	 * @param {Object} [options.id={}] Translate GeoJSON Id to Point
	 * @returns {Feature<Point>} a Point feature at the absolute center point of all input features
	 * @example
	 * var features = turf.points([
	 *   [-97.522259, 35.4691],
	 *   [-97.502754, 35.463455],
	 *   [-97.508269, 35.463245]
	 * ]);
	 *
	 * var center = turf.center(features);
	 *
	 * //addToMap
	 * var addToMap = [features, center]
	 * center.properties['marker-size'] = 'large';
	 * center.properties['marker-color'] = '#000';
	 */
	function center(geojson, options) {
		if (options === void 0) { options = {}; }
		var ext = bbox(geojson);
		var x = (ext[0] + ext[2]) / 2;
		var y = (ext[1] + ext[3]) / 2;
		return point([x, y], options.properties, options);
	}

	// Note: change RADIUS => earthRadius
	var RADIUS = 6378137;
	/**
	 * Takes one or more features and returns their area in square meters.
	 *
	 * @name area
	 * @param {GeoJSON} geojson input GeoJSON feature(s)
	 * @returns {number} area in square meters
	 * @example
	 * var polygon = turf.polygon([[[125, -15], [113, -22], [154, -27], [144, -15], [125, -15]]]);
	 *
	 * var area = turf.area(polygon);
	 *
	 * //addToMap
	 * var addToMap = [polygon]
	 * polygon.properties.area = area
	 */
	function area(geojson) {
		return geomReduce(geojson, function (value, geom) {
			return value + calculateArea(geom);
		}, 0);
	}
	/**
	 * Calculate Area
	 *
	 * @private
	 * @param {Geometry} geom GeoJSON Geometries
	 * @returns {number} area
	 */
	function calculateArea(geom) {
		var total = 0;
		var i;
		switch (geom.type) {
			case "Polygon":
				return polygonArea(geom.coordinates);
			case "MultiPolygon":
				for (i = 0; i < geom.coordinates.length; i++) {
					total += polygonArea(geom.coordinates[i]);
				}
				return total;
			case "Point":
			case "MultiPoint":
			case "LineString":
			case "MultiLineString":
				return 0;
		}
		return 0;
	}
	function polygonArea(coords) {
		var total = 0;
		if (coords && coords.length > 0) {
			total += Math.abs(ringArea(coords[0]));
			for (var i = 1; i < coords.length; i++) {
				total -= Math.abs(ringArea(coords[i]));
			}
		}
		return total;
	}
	/**
	 * @private
	 * Calculate the approximate area of the polygon were it projected onto the earth.
	 * Note that this area will be positive if ring is oriented clockwise, otherwise it will be negative.
	 *
	 * Reference:
	 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for Polygons on a Sphere",
	 * JPL Publication 07-03, Jet Propulsion
	 * Laboratory, Pasadena, CA, June 2007 https://trs.jpl.nasa.gov/handle/2014/40409
	 *
	 * @param {Array<Array<number>>} coords Ring Coordinates
	 * @returns {number} The approximate signed geodesic area of the polygon in square meters.
	 */
	function ringArea(coords) {
		var p1;
		var p2;
		var p3;
		var lowerIndex;
		var middleIndex;
		var upperIndex;
		var i;
		var total = 0;
		var coordsLength = coords.length;
		if (coordsLength > 2) {
			for (i = 0; i < coordsLength; i++) {
				if (i === coordsLength - 2) {
					// i = N-2
					lowerIndex = coordsLength - 2;
					middleIndex = coordsLength - 1;
					upperIndex = 0;
				}
				else if (i === coordsLength - 1) {
					// i = N-1
					lowerIndex = coordsLength - 1;
					middleIndex = 0;
					upperIndex = 1;
				}
				else {
					// i = 0 to N-3
					lowerIndex = i;
					middleIndex = i + 1;
					upperIndex = i + 2;
				}
				p1 = coords[lowerIndex];
				p2 = coords[middleIndex];
				p3 = coords[upperIndex];
				total += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));
			}
			total = (total * RADIUS * RADIUS) / 2;
		}
		return total;
	}
	function rad(num) {
		return (num * Math.PI) / 180;
	}

	/**
	 * Takes a ring and return true or false whether or not the ring is clockwise or counter-clockwise.
	 *
	 * @name booleanClockwise
	 * @param {Feature<LineString>|LineString|Array<Array<number>>} line to be evaluated
	 * @returns {boolean} true/false
	 * @example
	 * var clockwiseRing = turf.lineString([[0,0],[1,1],[1,0],[0,0]]);
	 * var counterClockwiseRing = turf.lineString([[0,0],[1,0],[1,1],[0,0]]);
	 *
	 * turf.booleanClockwise(clockwiseRing)
	 * //=true
	 * turf.booleanClockwise(counterClockwiseRing)
	 * //=false
	 */
	function booleanClockwise(line) {
		var ring = getCoords(line);
		var sum = 0;
		var i = 1;
		var prev;
		var cur;
		while (i < ring.length) {
			prev = cur || ring[0];
			cur = ring[i];
			sum += (cur[0] - prev[0]) * (cur[1] + prev[1]);
			i++;
		}
		return sum > 0;
	}

	function constant(x) {
		return function () {
			return x;
		};
	}

	function x(d) {
		return d[0];
	}

	function y(d) {
		return d[1];
	}

	function RedBlackTree() {
		this._ = null; // root node
	}

	function RedBlackNode(node) {
		node.U = // parent node
			node.C = // color - true for red, false for black
			node.L = // left node
			node.R = // right node
			node.P = // previous node
			node.N = null; // next node
	}

	RedBlackTree.prototype = {
		constructor: RedBlackTree,

		insert: function (after, node) {
			var parent, grandpa, uncle;

			if (after) {
				node.P = after;
				node.N = after.N;
				if (after.N) after.N.P = node;
				after.N = node;
				if (after.R) {
					after = after.R;
					while (after.L) after = after.L;
					after.L = node;
				} else {
					after.R = node;
				}
				parent = after;
			} else if (this._) {
				after = RedBlackFirst(this._);
				node.P = null;
				node.N = after;
				after.P = after.L = node;
				parent = after;
			} else {
				node.P = node.N = null;
				this._ = node;
				parent = null;
			}
			node.L = node.R = null;
			node.U = parent;
			node.C = true;

			after = node;
			while (parent && parent.C) {
				grandpa = parent.U;
				if (parent === grandpa.L) {
					uncle = grandpa.R;
					if (uncle && uncle.C) {
						parent.C = uncle.C = false;
						grandpa.C = true;
						after = grandpa;
					} else {
						if (after === parent.R) {
							RedBlackRotateLeft(this, parent);
							after = parent;
							parent = after.U;
						}
						parent.C = false;
						grandpa.C = true;
						RedBlackRotateRight(this, grandpa);
					}
				} else {
					uncle = grandpa.L;
					if (uncle && uncle.C) {
						parent.C = uncle.C = false;
						grandpa.C = true;
						after = grandpa;
					} else {
						if (after === parent.L) {
							RedBlackRotateRight(this, parent);
							after = parent;
							parent = after.U;
						}
						parent.C = false;
						grandpa.C = true;
						RedBlackRotateLeft(this, grandpa);
					}
				}
				parent = after.U;
			}
			this._.C = false;
		},

		remove: function (node) {
			if (node.N) node.N.P = node.P;
			if (node.P) node.P.N = node.N;
			node.N = node.P = null;

			var parent = node.U,
				sibling,
				left = node.L,
				right = node.R,
				next,
				red;

			if (!left) next = right;
			else if (!right) next = left;
			else next = RedBlackFirst(right);

			if (parent) {
				if (parent.L === node) parent.L = next;
				else parent.R = next;
			} else {
				this._ = next;
			}

			if (left && right) {
				red = next.C;
				next.C = node.C;
				next.L = left;
				left.U = next;
				if (next !== right) {
					parent = next.U;
					next.U = node.U;
					node = next.R;
					parent.L = node;
					next.R = right;
					right.U = next;
				} else {
					next.U = parent;
					parent = next;
					node = next.R;
				}
			} else {
				red = node.C;
				node = next;
			}

			if (node) node.U = parent;
			if (red) return;
			if (node && node.C) { node.C = false; return; }

			do {
				if (node === this._) break;
				if (node === parent.L) {
					sibling = parent.R;
					if (sibling.C) {
						sibling.C = false;
						parent.C = true;
						RedBlackRotateLeft(this, parent);
						sibling = parent.R;
					}
					if ((sibling.L && sibling.L.C)
						|| (sibling.R && sibling.R.C)) {
						if (!sibling.R || !sibling.R.C) {
							sibling.L.C = false;
							sibling.C = true;
							RedBlackRotateRight(this, sibling);
							sibling = parent.R;
						}
						sibling.C = parent.C;
						parent.C = sibling.R.C = false;
						RedBlackRotateLeft(this, parent);
						node = this._;
						break;
					}
				} else {
					sibling = parent.L;
					if (sibling.C) {
						sibling.C = false;
						parent.C = true;
						RedBlackRotateRight(this, parent);
						sibling = parent.L;
					}
					if ((sibling.L && sibling.L.C)
						|| (sibling.R && sibling.R.C)) {
						if (!sibling.L || !sibling.L.C) {
							sibling.R.C = false;
							sibling.C = true;
							RedBlackRotateLeft(this, sibling);
							sibling = parent.L;
						}
						sibling.C = parent.C;
						parent.C = sibling.L.C = false;
						RedBlackRotateRight(this, parent);
						node = this._;
						break;
					}
				}
				sibling.C = true;
				node = parent;
				parent = parent.U;
			} while (!node.C);

			if (node) node.C = false;
		}
	};

	function RedBlackRotateLeft(tree, node) {
		var p = node,
			q = node.R,
			parent = p.U;

		if (parent) {
			if (parent.L === p) parent.L = q;
			else parent.R = q;
		} else {
			tree._ = q;
		}

		q.U = parent;
		p.U = q;
		p.R = q.L;
		if (p.R) p.R.U = p;
		q.L = p;
	}

	function RedBlackRotateRight(tree, node) {
		var p = node,
			q = node.L,
			parent = p.U;

		if (parent) {
			if (parent.L === p) parent.L = q;
			else parent.R = q;
		} else {
			tree._ = q;
		}

		q.U = parent;
		p.U = q;
		p.L = q.R;
		if (p.L) p.L.U = p;
		q.R = p;
	}

	function RedBlackFirst(node) {
		while (node.L) node = node.L;
		return node;
	}

	function createEdge(left, right, v0, v1) {
		var edge = [null, null],
			index = edges.push(edge) - 1;
		edge.left = left;
		edge.right = right;
		if (v0) setEdgeEnd(edge, left, right, v0);
		if (v1) setEdgeEnd(edge, right, left, v1);
		cells[left.index].halfedges.push(index);
		cells[right.index].halfedges.push(index);
		return edge;
	}

	function createBorderEdge(left, v0, v1) {
		var edge = [v0, v1];
		edge.left = left;
		return edge;
	}

	function setEdgeEnd(edge, left, right, vertex) {
		if (!edge[0] && !edge[1]) {
			edge[0] = vertex;
			edge.left = left;
			edge.right = right;
		} else if (edge.left === right) {
			edge[1] = vertex;
		} else {
			edge[0] = vertex;
		}
	}

	// Liang–Barsky line clipping.
	function clipEdge(edge, x0, y0, x1, y1) {
		var a = edge[0],
			b = edge[1],
			ax = a[0],
			ay = a[1],
			bx = b[0],
			by = b[1],
			t0 = 0,
			t1 = 1,
			dx = bx - ax,
			dy = by - ay,
			r;

		r = x0 - ax;
		if (!dx && r > 0) return;
		r /= dx;
		if (dx < 0) {
			if (r < t0) return;
			if (r < t1) t1 = r;
		} else if (dx > 0) {
			if (r > t1) return;
			if (r > t0) t0 = r;
		}

		r = x1 - ax;
		if (!dx && r < 0) return;
		r /= dx;
		if (dx < 0) {
			if (r > t1) return;
			if (r > t0) t0 = r;
		} else if (dx > 0) {
			if (r < t0) return;
			if (r < t1) t1 = r;
		}

		r = y0 - ay;
		if (!dy && r > 0) return;
		r /= dy;
		if (dy < 0) {
			if (r < t0) return;
			if (r < t1) t1 = r;
		} else if (dy > 0) {
			if (r > t1) return;
			if (r > t0) t0 = r;
		}

		r = y1 - ay;
		if (!dy && r < 0) return;
		r /= dy;
		if (dy < 0) {
			if (r > t1) return;
			if (r > t0) t0 = r;
		} else if (dy > 0) {
			if (r < t0) return;
			if (r < t1) t1 = r;
		}

		if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

		if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
		if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
		return true;
	}

	function connectEdge(edge, x0, y0, x1, y1) {
		var v1 = edge[1];
		if (v1) return true;

		var v0 = edge[0],
			left = edge.left,
			right = edge.right,
			lx = left[0],
			ly = left[1],
			rx = right[0],
			ry = right[1],
			fx = (lx + rx) / 2,
			fy = (ly + ry) / 2,
			fm,
			fb;

		if (ry === ly) {
			if (fx < x0 || fx >= x1) return;
			if (lx > rx) {
				if (!v0) v0 = [fx, y0];
				else if (v0[1] >= y1) return;
				v1 = [fx, y1];
			} else {
				if (!v0) v0 = [fx, y1];
				else if (v0[1] < y0) return;
				v1 = [fx, y0];
			}
		} else {
			fm = (lx - rx) / (ry - ly);
			fb = fy - fm * fx;
			if (fm < -1 || fm > 1) {
				if (lx > rx) {
					if (!v0) v0 = [(y0 - fb) / fm, y0];
					else if (v0[1] >= y1) return;
					v1 = [(y1 - fb) / fm, y1];
				} else {
					if (!v0) v0 = [(y1 - fb) / fm, y1];
					else if (v0[1] < y0) return;
					v1 = [(y0 - fb) / fm, y0];
				}
			} else {
				if (ly < ry) {
					if (!v0) v0 = [x0, fm * x0 + fb];
					else if (v0[0] >= x1) return;
					v1 = [x1, fm * x1 + fb];
				} else {
					if (!v0) v0 = [x1, fm * x1 + fb];
					else if (v0[0] < x0) return;
					v1 = [x0, fm * x0 + fb];
				}
			}
		}

		edge[0] = v0;
		edge[1] = v1;
		return true;
	}

	function clipEdges(x0, y0, x1, y1) {
		var i = edges.length,
			edge;

		while (i--) {
			if (!connectEdge(edge = edges[i], x0, y0, x1, y1)
				|| !clipEdge(edge, x0, y0, x1, y1)
				|| !(Math.abs(edge[0][0] - edge[1][0]) > epsilon$2
					|| Math.abs(edge[0][1] - edge[1][1]) > epsilon$2)) {
				delete edges[i];
			}
		}
	}

	function createCell(site) {
		return cells[site.index] = {
			site: site,
			halfedges: []
		};
	}

	function cellHalfedgeAngle(cell, edge) {
		var site = cell.site,
			va = edge.left,
			vb = edge.right;
		if (site === vb) vb = va, va = site;
		if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
		if (site === va) va = edge[1], vb = edge[0];
		else va = edge[0], vb = edge[1];
		return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
	}

	function cellHalfedgeStart(cell, edge) {
		return edge[+(edge.left !== cell.site)];
	}

	function cellHalfedgeEnd(cell, edge) {
		return edge[+(edge.left === cell.site)];
	}

	function sortCellHalfedges() {
		for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
			if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
				var index = new Array(m),
					array = new Array(m);
				for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
				index.sort(function (i, j) { return array[j] - array[i]; });
				for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];
				for (j = 0; j < m; ++j) halfedges[j] = array[j];
			}
		}
	}

	function clipCells(x0, y0, x1, y1) {
		var nCells = cells.length,
			iCell,
			cell,
			site,
			iHalfedge,
			halfedges,
			nHalfedges,
			start,
			startX,
			startY,
			end,
			endX,
			endY,
			cover = true;

		for (iCell = 0; iCell < nCells; ++iCell) {
			if (cell = cells[iCell]) {
				site = cell.site;
				halfedges = cell.halfedges;
				iHalfedge = halfedges.length;

				// Remove any dangling clipped edges.
				while (iHalfedge--) {
					if (!edges[halfedges[iHalfedge]]) {
						halfedges.splice(iHalfedge, 1);
					}
				}

				// Insert any border edges as necessary.
				iHalfedge = 0, nHalfedges = halfedges.length;
				while (iHalfedge < nHalfedges) {
					end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
					start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
					if (Math.abs(endX - startX) > epsilon$2 || Math.abs(endY - startY) > epsilon$2) {
						halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,
							Math.abs(endX - x0) < epsilon$2 && y1 - endY > epsilon$2 ? [x0, Math.abs(startX - x0) < epsilon$2 ? startY : y1]
								: Math.abs(endY - y1) < epsilon$2 && x1 - endX > epsilon$2 ? [Math.abs(startY - y1) < epsilon$2 ? startX : x1, y1]
									: Math.abs(endX - x1) < epsilon$2 && endY - y0 > epsilon$2 ? [x1, Math.abs(startX - x1) < epsilon$2 ? startY : y0]
										: Math.abs(endY - y0) < epsilon$2 && endX - x0 > epsilon$2 ? [Math.abs(startY - y0) < epsilon$2 ? startX : x0, y0]
											: null)) - 1);
						++nHalfedges;
					}
				}

				if (nHalfedges) cover = false;
			}
		}

		// If there weren’t any edges, have the closest site cover the extent.
		// It doesn’t matter which corner of the extent we measure!
		if (cover) {
			var dx, dy, d2, dc = Infinity;

			for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
				if (cell = cells[iCell]) {
					site = cell.site;
					dx = site[0] - x0;
					dy = site[1] - y0;
					d2 = dx * dx + dy * dy;
					if (d2 < dc) dc = d2, cover = cell;
				}
			}

			if (cover) {
				var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
				cover.halfedges.push(
					edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
					edges.push(createBorderEdge(site, v01, v11)) - 1,
					edges.push(createBorderEdge(site, v11, v10)) - 1,
					edges.push(createBorderEdge(site, v10, v00)) - 1
				);
			}
		}

		// Lastly delete any cells with no edges; these were entirely clipped.
		for (iCell = 0; iCell < nCells; ++iCell) {
			if (cell = cells[iCell]) {
				if (!cell.halfedges.length) {
					delete cells[iCell];
				}
			}
		}
	}

	var circlePool = [];

	var firstCircle;

	function Circle() {
		RedBlackNode(this);
		this.x =
			this.y =
			this.arc =
			this.site =
			this.cy = null;
	}

	function attachCircle(arc) {
		var lArc = arc.P,
			rArc = arc.N;

		if (!lArc || !rArc) return;

		var lSite = lArc.site,
			cSite = arc.site,
			rSite = rArc.site;

		if (lSite === rSite) return;

		var bx = cSite[0],
			by = cSite[1],
			ax = lSite[0] - bx,
			ay = lSite[1] - by,
			cx = rSite[0] - bx,
			cy = rSite[1] - by;

		var d = 2 * (ax * cy - ay * cx);
		if (d >= -epsilon2) return;

		var ha = ax * ax + ay * ay,
			hc = cx * cx + cy * cy,
			x = (cy * ha - ay * hc) / d,
			y = (ax * hc - cx * ha) / d;

		var circle = circlePool.pop() || new Circle;
		circle.arc = arc;
		circle.site = cSite;
		circle.x = x + bx;
		circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

		arc.circle = circle;

		var before = null,
			node = circles._;

		while (node) {
			if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {
				if (node.L) node = node.L;
				else { before = node.P; break; }
			} else {
				if (node.R) node = node.R;
				else { before = node; break; }
			}
		}

		circles.insert(before, circle);
		if (!before) firstCircle = circle;
	}

	function detachCircle(arc) {
		var circle = arc.circle;
		if (circle) {
			if (!circle.P) firstCircle = circle.N;
			circles.remove(circle);
			circlePool.push(circle);
			RedBlackNode(circle);
			arc.circle = null;
		}
	}

	var beachPool = [];

	function Beach() {
		RedBlackNode(this);
		this.edge =
			this.site =
			this.circle = null;
	}

	function createBeach(site) {
		var beach = beachPool.pop() || new Beach;
		beach.site = site;
		return beach;
	}

	function detachBeach(beach) {
		detachCircle(beach);
		beaches.remove(beach);
		beachPool.push(beach);
		RedBlackNode(beach);
	}

	function removeBeach(beach) {
		var circle = beach.circle,
			x = circle.x,
			y = circle.cy,
			vertex = [x, y],
			previous = beach.P,
			next = beach.N,
			disappearing = [beach];

		detachBeach(beach);

		var lArc = previous;
		while (lArc.circle
			&& Math.abs(x - lArc.circle.x) < epsilon$2
			&& Math.abs(y - lArc.circle.cy) < epsilon$2) {
			previous = lArc.P;
			disappearing.unshift(lArc);
			detachBeach(lArc);
			lArc = previous;
		}

		disappearing.unshift(lArc);
		detachCircle(lArc);

		var rArc = next;
		while (rArc.circle
			&& Math.abs(x - rArc.circle.x) < epsilon$2
			&& Math.abs(y - rArc.circle.cy) < epsilon$2) {
			next = rArc.N;
			disappearing.push(rArc);
			detachBeach(rArc);
			rArc = next;
		}

		disappearing.push(rArc);
		detachCircle(rArc);

		var nArcs = disappearing.length,
			iArc;
		for (iArc = 1; iArc < nArcs; ++iArc) {
			rArc = disappearing[iArc];
			lArc = disappearing[iArc - 1];
			setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
		}

		lArc = disappearing[0];
		rArc = disappearing[nArcs - 1];
		rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);

		attachCircle(lArc);
		attachCircle(rArc);
	}

	function addBeach(site) {
		var x = site[0],
			directrix = site[1],
			lArc,
			rArc,
			dxl,
			dxr,
			node = beaches._;

		while (node) {
			dxl = leftBreakPoint(node, directrix) - x;
			if (dxl > epsilon$2) node = node.L; else {
				dxr = x - rightBreakPoint(node, directrix);
				if (dxr > epsilon$2) {
					if (!node.R) {
						lArc = node;
						break;
					}
					node = node.R;
				} else {
					if (dxl > -epsilon$2) {
						lArc = node.P;
						rArc = node;
					} else if (dxr > -epsilon$2) {
						lArc = node;
						rArc = node.N;
					} else {
						lArc = rArc = node;
					}
					break;
				}
			}
		}

		createCell(site);
		var newArc = createBeach(site);
		beaches.insert(lArc, newArc);

		if (!lArc && !rArc) return;

		if (lArc === rArc) {
			detachCircle(lArc);
			rArc = createBeach(lArc.site);
			beaches.insert(newArc, rArc);
			newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
			attachCircle(lArc);
			attachCircle(rArc);
			return;
		}

		if (!rArc) { // && lArc
			newArc.edge = createEdge(lArc.site, newArc.site);
			return;
		}

		// else lArc !== rArc
		detachCircle(lArc);
		detachCircle(rArc);

		var lSite = lArc.site,
			ax = lSite[0],
			ay = lSite[1],
			bx = site[0] - ax,
			by = site[1] - ay,
			rSite = rArc.site,
			cx = rSite[0] - ax,
			cy = rSite[1] - ay,
			d = 2 * (bx * cy - by * cx),
			hb = bx * bx + by * by,
			hc = cx * cx + cy * cy,
			vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];

		setEdgeEnd(rArc.edge, lSite, rSite, vertex);
		newArc.edge = createEdge(lSite, site, null, vertex);
		rArc.edge = createEdge(site, rSite, null, vertex);
		attachCircle(lArc);
		attachCircle(rArc);
	}

	function leftBreakPoint(arc, directrix) {
		var site = arc.site,
			rfocx = site[0],
			rfocy = site[1],
			pby2 = rfocy - directrix;

		if (!pby2) return rfocx;

		var lArc = arc.P;
		if (!lArc) return -Infinity;

		site = lArc.site;
		var lfocx = site[0],
			lfocy = site[1],
			plby2 = lfocy - directrix;

		if (!plby2) return lfocx;

		var hl = lfocx - rfocx,
			aby2 = 1 / pby2 - 1 / plby2,
			b = hl / plby2;

		if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;

		return (rfocx + lfocx) / 2;
	}

	function rightBreakPoint(arc, directrix) {
		var rArc = arc.N;
		if (rArc) return leftBreakPoint(rArc, directrix);
		var site = arc.site;
		return site[1] === directrix ? site[0] : Infinity;
	}

	var epsilon$2 = 1e-6;
	var epsilon2 = 1e-12;
	var beaches;
	var cells;
	var circles;
	var edges;

	function triangleArea(a, b, c) {
		return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
	}

	function lexicographic(a, b) {
		return b[1] - a[1]
			|| b[0] - a[0];
	}

	function Diagram(sites, extent) {
		var site = sites.sort(lexicographic).pop(),
			x,
			y,
			circle;

		edges = [];
		cells = new Array(sites.length);
		beaches = new RedBlackTree;
		circles = new RedBlackTree;

		while (true) {
			circle = firstCircle;
			if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {
				if (site[0] !== x || site[1] !== y) {
					addBeach(site);
					x = site[0], y = site[1];
				}
				site = sites.pop();
			} else if (circle) {
				removeBeach(circle.arc);
			} else {
				break;
			}
		}

		sortCellHalfedges();

		if (extent) {
			var x0 = +extent[0][0],
				y0 = +extent[0][1],
				x1 = +extent[1][0],
				y1 = +extent[1][1];
			clipEdges(x0, y0, x1, y1);
			clipCells(x0, y0, x1, y1);
		}

		this.edges = edges;
		this.cells = cells;

		beaches =
			circles =
			edges =
			cells = null;
	}

	Diagram.prototype = {
		constructor: Diagram,

		polygons: function () {
			var edges = this.edges;

			return this.cells.map(function (cell) {
				var polygon = cell.halfedges.map(function (i) { return cellHalfedgeStart(cell, edges[i]); });
				polygon.data = cell.site.data;
				return polygon;
			});
		},

		triangles: function () {
			var triangles = [],
				edges = this.edges;

			this.cells.forEach(function (cell, i) {
				if (!(m = (halfedges = cell.halfedges).length)) return;
				var site = cell.site,
					halfedges,
					j = -1,
					m,
					s0,
					e1 = edges[halfedges[m - 1]],
					s1 = e1.left === site ? e1.right : e1.left;

				while (++j < m) {
					s0 = s1;
					e1 = edges[halfedges[j]];
					s1 = e1.left === site ? e1.right : e1.left;
					if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
						triangles.push([site.data, s0.data, s1.data]);
					}
				}
			});

			return triangles;
		},

		links: function () {
			return this.edges.filter(function (edge) {
				return edge.right;
			}).map(function (edge) {
				return {
					source: edge.left.data,
					target: edge.right.data
				};
			});
		},

		find: function (x, y, radius) {
			var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;

			// Use the previously-found cell, or start with an arbitrary one.
			while (!(cell = that.cells[i1])) if (++i1 >= n) return null;
			var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;

			// Traverse the half-edges to find a closer cell, if any.
			do {
				cell = that.cells[i0 = i1], i1 = null;
				cell.halfedges.forEach(function (e) {
					var edge = that.edges[e], v = edge.left;
					if ((v === cell.site || !v) && !(v = edge.right)) return;
					var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
					if (v2 < d2) d2 = v2, i1 = v.index;
				});
			} while (i1 !== null);

			that._found = i0;

			return radius == null || d2 <= radius * radius ? cell.site : null;
		}
	};

	function voronoi$1() {
		var x$1 = x,
			y$1 = y,
			extent = null;

		function voronoi(data) {
			return new Diagram(data.map(function (d, i) {
				var s = [Math.round(x$1(d, i, data) / epsilon$2) * epsilon$2, Math.round(y$1(d, i, data) / epsilon$2) * epsilon$2];
				s.index = i;
				s.data = d;
				return s;
			}), extent);
		}

		voronoi.polygons = function (data) {
			return voronoi(data).polygons();
		};

		voronoi.links = function (data) {
			return voronoi(data).links();
		};

		voronoi.triangles = function (data) {
			return voronoi(data).triangles();
		};

		voronoi.x = function (_) {
			return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant(+_), voronoi) : x$1;
		};

		voronoi.y = function (_) {
			return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant(+_), voronoi) : y$1;
		};

		voronoi.extent = function (_) {
			return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
		};

		voronoi.size = function (_) {
			return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
		};

		return voronoi;
	}

	/**
	 * @private
	 * @param {Array<Array<number>>} coords representing a polygon
	 * @returns {Feature<Polygon>} polygon
	 */
	function coordsToPolygon(coords) {
		coords = coords.slice();
		coords.push(coords[0]);
		return polygon([coords]);
	}

	/**
	 * Takes a FeatureCollection of points, and a bounding box, and returns a FeatureCollection
	 * of Voronoi polygons.
	 *
	 * The Voronoi algorithim used comes from the d3-voronoi package.
	 *
	 * @name voronoi
	 * @param {FeatureCollection<Point>} points to find the Voronoi polygons around.
	 * @param {Object} [options={}] Optional parameters
	 * @param {number[]} [options.bbox=[-180, -85, 180, -85]] clipping rectangle, in [minX, minY, maxX, MaxY] order.
	 * @returns {FeatureCollection<Polygon>} a set of polygons, one per input point.
	 * @example
	 * var options = {
	 *   bbox: [-70, 40, -60, 60]
	 * };
	 * var points = turf.randomPoint(100, options);
	 * var voronoiPolygons = turf.voronoi(points, options);
	 *
	 * //addToMap
	 * var addToMap = [voronoiPolygons, points];
	 */
	function voronoi(points, options) {
		// Optional params
		options = options || {};
		if (!isObject(options)) throw new Error("options is invalid");
		var bbox = options.bbox || [-180, -85, 180, 85];

		// Input Validation
		if (!points) throw new Error("points is required");
		if (!Array.isArray(bbox)) throw new Error("bbox is invalid");
		collectionOf(points, "Point", "points");

		// Main
		return featureCollection(
			voronoi$1()
				.x(function (feature) {
					return feature.geometry.coordinates[0];
				})
				.y(function (feature) {
					return feature.geometry.coordinates[1];
				})
				.extent([
					[bbox[0], bbox[1]],
					[bbox[2], bbox[3]],
				])
				.polygons(points.features)
				.map(coordsToPolygon)
		);
	}

	(undefined && undefined.__spreadArrays) || function () {
		for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
		for (var r = Array(s), k = 0, i = 0; i < il; i++)
			for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
				r[k] = a[j];
		return r;
	};
	/**
	 * Returns a random position within a {@link bounding box}.
	 *
	 * @name randomPosition
	 * @param {Array<number>} [bbox=[-180, -90, 180, 90]] a bounding box inside of which positions are placed.
	 * @returns {Array<number>} Position [longitude, latitude]
	 * @example
	 * var position = turf.randomPosition([-180, -90, 180, 90])
	 * // => position
	 */
	function randomPosition(bbox) {
		if (Array.isArray(bbox)) {
			return coordInBBox(bbox);
		}
		if (bbox && bbox.bbox) {
			return coordInBBox(bbox.bbox);
		}
		return [lon(), lat()];
	}
	/**
	 * Returns a random {@link point}.
	 *
	 * @name randomPoint
	 * @param {number} [count=1] how many geometries will be generated
	 * @param {Object} [options={}] Optional parameters
	 * @param {Array<number>} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.
	 * @returns {FeatureCollection<Point>} GeoJSON FeatureCollection of points
	 * @example
	 * var points = turf.randomPoint(25, {bbox: [-180, -90, 180, 90]})
	 * // => points
	 */
	function randomPoint(count, options) {
		if (options === void 0) { options = {}; }
		if (count === undefined || count === null) {
			count = 1;
		}
		var features = [];
		for (var i = 0; i < count; i++) {
			features.push(point(randomPosition(options.bbox)));
		}
		return featureCollection(features);
	}
	function rnd() {
		return Math.random() - 0.5;
	}
	function lon() {
		return rnd() * 360;
	}
	function lat() {
		return rnd() * 180;
	}
	function coordInBBox(bbox) {
		return [
			Math.random() * (bbox[2] - bbox[0]) + bbox[0],
			Math.random() * (bbox[3] - bbox[1]) + bbox[1],
		];
	}

	/**
	 * splaytree v3.1.2
	 * Fast Splay tree for Node and browser
	 *
	 * @author Alexander Milevski <info@w8r.name>
	 * @license MIT
	 * @preserve
	 */

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */

	function __generator(thisArg, body) {
		var _ = { label: 0, sent: function () { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
		return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
		function verb(n) { return function (v) { return step([n, v]); }; }
		function step(op) {
			if (f) throw new TypeError("Generator is already executing.");
			while (_) try {
				if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
				if (y = 0, t) op = [op[0] & 2, t.value];
				switch (op[0]) {
					case 0: case 1: t = op; break;
					case 4: _.label++; return { value: op[1], done: false };
					case 5: _.label++; y = op[1]; op = [0]; continue;
					case 7: op = _.ops.pop(); _.trys.pop(); continue;
					default:
						if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
						if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
						if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
						if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
						if (t[2]) _.ops.pop();
						_.trys.pop(); continue;
				}
				op = body.call(thisArg, _);
			} catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
			if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
		}
	}

	var Node$1 = /** @class */ (function () {
		function Node(key, data) {
			this.next = null;
			this.key = key;
			this.data = data;
			this.left = null;
			this.right = null;
		}
		return Node;
	}());

	/* follows "An implementation of top-down splaying"
	 * by D. Sleator <sleator@cs.cmu.edu> March 1992
	 */
	function DEFAULT_COMPARE(a, b) {
		return a > b ? 1 : a < b ? -1 : 0;
	}
	/**
	 * Simple top down splay, not requiring i to be in the tree t.
	 */
	function splay(i, t, comparator) {
		var N = new Node$1(null, null);
		var l = N;
		var r = N;
		while (true) {
			var cmp = comparator(i, t.key);
			//if (i < t.key) {
			if (cmp < 0) {
				if (t.left === null)
					break;
				//if (i < t.left.key) {
				if (comparator(i, t.left.key) < 0) {
					var y = t.left; /* rotate right */
					t.left = y.right;
					y.right = t;
					t = y;
					if (t.left === null)
						break;
				}
				r.left = t; /* link right */
				r = t;
				t = t.left;
				//} else if (i > t.key) {
			}
			else if (cmp > 0) {
				if (t.right === null)
					break;
				//if (i > t.right.key) {
				if (comparator(i, t.right.key) > 0) {
					var y = t.right; /* rotate left */
					t.right = y.left;
					y.left = t;
					t = y;
					if (t.right === null)
						break;
				}
				l.right = t; /* link left */
				l = t;
				t = t.right;
			}
			else
				break;
		}
		/* assemble */
		l.right = t.left;
		r.left = t.right;
		t.left = N.right;
		t.right = N.left;
		return t;
	}
	function insert(i, data, t, comparator) {
		var node = new Node$1(i, data);
		if (t === null) {
			node.left = node.right = null;
			return node;
		}
		t = splay(i, t, comparator);
		var cmp = comparator(i, t.key);
		if (cmp < 0) {
			node.left = t.left;
			node.right = t;
			t.left = null;
		}
		else if (cmp >= 0) {
			node.right = t.right;
			node.left = t;
			t.right = null;
		}
		return node;
	}
	function split(key, v, comparator) {
		var left = null;
		var right = null;
		if (v) {
			v = splay(key, v, comparator);
			var cmp = comparator(v.key, key);
			if (cmp === 0) {
				left = v.left;
				right = v.right;
			}
			else if (cmp < 0) {
				right = v.right;
				v.right = null;
				left = v;
			}
			else {
				left = v.left;
				v.left = null;
				right = v;
			}
		}
		return { left: left, right: right };
	}
	function merge$1(left, right, comparator) {
		if (right === null)
			return left;
		if (left === null)
			return right;
		right = splay(left.key, right, comparator);
		right.left = left;
		return right;
	}
	/**
	 * Prints level of the tree
	 */
	function printRow(root, prefix, isTail, out, printNode) {
		if (root) {
			out("" + prefix + (isTail ? '└── ' : '├── ') + printNode(root) + "\n");
			var indent = prefix + (isTail ? '    ' : '│   ');
			if (root.left)
				printRow(root.left, indent, false, out, printNode);
			if (root.right)
				printRow(root.right, indent, true, out, printNode);
		}
	}
	var Tree = /** @class */ (function () {
		function Tree(comparator) {
			if (comparator === void 0) { comparator = DEFAULT_COMPARE; }
			this._root = null;
			this._size = 0;
			this._comparator = comparator;
		}
		/**
		 * Inserts a key, allows duplicates
		 */
		Tree.prototype.insert = function (key, data) {
			this._size++;
			return this._root = insert(key, data, this._root, this._comparator);
		};
		/**
		 * Adds a key, if it is not present in the tree
		 */
		Tree.prototype.add = function (key, data) {
			var node = new Node$1(key, data);
			if (this._root === null) {
				node.left = node.right = null;
				this._size++;
				this._root = node;
			}
			var comparator = this._comparator;
			var t = splay(key, this._root, comparator);
			var cmp = comparator(key, t.key);
			if (cmp === 0)
				this._root = t;
			else {
				if (cmp < 0) {
					node.left = t.left;
					node.right = t;
					t.left = null;
				}
				else if (cmp > 0) {
					node.right = t.right;
					node.left = t;
					t.right = null;
				}
				this._size++;
				this._root = node;
			}
			return this._root;
		};
		/**
		 * @param  {Key} key
		 * @return {Node|null}
		 */
		Tree.prototype.remove = function (key) {
			this._root = this._remove(key, this._root, this._comparator);
		};
		/**
		 * Deletes i from the tree if it's there
		 */
		Tree.prototype._remove = function (i, t, comparator) {
			var x;
			if (t === null)
				return null;
			t = splay(i, t, comparator);
			var cmp = comparator(i, t.key);
			if (cmp === 0) { /* found it */
				if (t.left === null) {
					x = t.right;
				}
				else {
					x = splay(i, t.left, comparator);
					x.right = t.right;
				}
				this._size--;
				return x;
			}
			return t; /* It wasn't there */
		};
		/**
		 * Removes and returns the node with smallest key
		 */
		Tree.prototype.pop = function () {
			var node = this._root;
			if (node) {
				while (node.left)
					node = node.left;
				this._root = splay(node.key, this._root, this._comparator);
				this._root = this._remove(node.key, this._root, this._comparator);
				return { key: node.key, data: node.data };
			}
			return null;
		};
		/**
		 * Find without splaying
		 */
		Tree.prototype.findStatic = function (key) {
			var current = this._root;
			var compare = this._comparator;
			while (current) {
				var cmp = compare(key, current.key);
				if (cmp === 0)
					return current;
				else if (cmp < 0)
					current = current.left;
				else
					current = current.right;
			}
			return null;
		};
		Tree.prototype.find = function (key) {
			if (this._root) {
				this._root = splay(key, this._root, this._comparator);
				if (this._comparator(key, this._root.key) !== 0)
					return null;
			}
			return this._root;
		};
		Tree.prototype.contains = function (key) {
			var current = this._root;
			var compare = this._comparator;
			while (current) {
				var cmp = compare(key, current.key);
				if (cmp === 0)
					return true;
				else if (cmp < 0)
					current = current.left;
				else
					current = current.right;
			}
			return false;
		};
		Tree.prototype.forEach = function (visitor, ctx) {
			var current = this._root;
			var Q = []; /* Initialize stack s */
			var done = false;
			while (!done) {
				if (current !== null) {
					Q.push(current);
					current = current.left;
				}
				else {
					if (Q.length !== 0) {
						current = Q.pop();
						visitor.call(ctx, current);
						current = current.right;
					}
					else
						done = true;
				}
			}
			return this;
		};
		/**
		 * Walk key range from `low` to `high`. Stops if `fn` returns a value.
		 */
		Tree.prototype.range = function (low, high, fn, ctx) {
			var Q = [];
			var compare = this._comparator;
			var node = this._root;
			var cmp;
			while (Q.length !== 0 || node) {
				if (node) {
					Q.push(node);
					node = node.left;
				}
				else {
					node = Q.pop();
					cmp = compare(node.key, high);
					if (cmp > 0) {
						break;
					}
					else if (compare(node.key, low) >= 0) {
						if (fn.call(ctx, node))
							return this; // stop if smth is returned
					}
					node = node.right;
				}
			}
			return this;
		};
		/**
		 * Returns array of keys
		 */
		Tree.prototype.keys = function () {
			var keys = [];
			this.forEach(function (_a) {
				var key = _a.key;
				return keys.push(key);
			});
			return keys;
		};
		/**
		 * Returns array of all the data in the nodes
		 */
		Tree.prototype.values = function () {
			var values = [];
			this.forEach(function (_a) {
				var data = _a.data;
				return values.push(data);
			});
			return values;
		};
		Tree.prototype.min = function () {
			if (this._root)
				return this.minNode(this._root).key;
			return null;
		};
		Tree.prototype.max = function () {
			if (this._root)
				return this.maxNode(this._root).key;
			return null;
		};
		Tree.prototype.minNode = function (t) {
			if (t === void 0) { t = this._root; }
			if (t)
				while (t.left)
					t = t.left;
			return t;
		};
		Tree.prototype.maxNode = function (t) {
			if (t === void 0) { t = this._root; }
			if (t)
				while (t.right)
					t = t.right;
			return t;
		};
		/**
		 * Returns node at given index
		 */
		Tree.prototype.at = function (index) {
			var current = this._root;
			var done = false;
			var i = 0;
			var Q = [];
			while (!done) {
				if (current) {
					Q.push(current);
					current = current.left;
				}
				else {
					if (Q.length > 0) {
						current = Q.pop();
						if (i === index)
							return current;
						i++;
						current = current.right;
					}
					else
						done = true;
				}
			}
			return null;
		};
		Tree.prototype.next = function (d) {
			var root = this._root;
			var successor = null;
			if (d.right) {
				successor = d.right;
				while (successor.left)
					successor = successor.left;
				return successor;
			}
			var comparator = this._comparator;
			while (root) {
				var cmp = comparator(d.key, root.key);
				if (cmp === 0)
					break;
				else if (cmp < 0) {
					successor = root;
					root = root.left;
				}
				else
					root = root.right;
			}
			return successor;
		};
		Tree.prototype.prev = function (d) {
			var root = this._root;
			var predecessor = null;
			if (d.left !== null) {
				predecessor = d.left;
				while (predecessor.right)
					predecessor = predecessor.right;
				return predecessor;
			}
			var comparator = this._comparator;
			while (root) {
				var cmp = comparator(d.key, root.key);
				if (cmp === 0)
					break;
				else if (cmp < 0)
					root = root.left;
				else {
					predecessor = root;
					root = root.right;
				}
			}
			return predecessor;
		};
		Tree.prototype.clear = function () {
			this._root = null;
			this._size = 0;
			return this;
		};
		Tree.prototype.toList = function () {
			return toList(this._root);
		};
		/**
		 * Bulk-load items. Both array have to be same size
		 */
		Tree.prototype.load = function (keys, values, presort) {
			if (values === void 0) { values = []; }
			if (presort === void 0) { presort = false; }
			var size = keys.length;
			var comparator = this._comparator;
			// sort if needed
			if (presort)
				sort(keys, values, 0, size - 1, comparator);
			if (this._root === null) { // empty tree
				this._root = loadRecursive(keys, values, 0, size);
				this._size = size;
			}
			else { // that re-builds the whole tree from two in-order traversals
				var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);
				size = this._size + size;
				this._root = sortedListToBST({ head: mergedList }, 0, size);
			}
			return this;
		};
		Tree.prototype.isEmpty = function () { return this._root === null; };
		Object.defineProperty(Tree.prototype, "size", {
			get: function () { return this._size; },
			enumerable: true,
			configurable: true
		});
		Object.defineProperty(Tree.prototype, "root", {
			get: function () { return this._root; },
			enumerable: true,
			configurable: true
		});
		Tree.prototype.toString = function (printNode) {
			if (printNode === void 0) { printNode = function (n) { return String(n.key); }; }
			var out = [];
			printRow(this._root, '', true, function (v) { return out.push(v); }, printNode);
			return out.join('');
		};
		Tree.prototype.update = function (key, newKey, newData) {
			var comparator = this._comparator;
			var _a = split(key, this._root, comparator), left = _a.left, right = _a.right;
			if (comparator(key, newKey) < 0) {
				right = insert(newKey, newData, right, comparator);
			}
			else {
				left = insert(newKey, newData, left, comparator);
			}
			this._root = merge$1(left, right, comparator);
		};
		Tree.prototype.split = function (key) {
			return split(key, this._root, this._comparator);
		};
		Tree.prototype[Symbol.iterator] = function () {
			var current, Q, done;
			return __generator(this, function (_a) {
				switch (_a.label) {
					case 0:
						current = this._root;
						Q = [];
						done = false;
						_a.label = 1;
					case 1:
						if (!!done) return [3 /*break*/, 6];
						if (!(current !== null)) return [3 /*break*/, 2];
						Q.push(current);
						current = current.left;
						return [3 /*break*/, 5];
					case 2:
						if (!(Q.length !== 0)) return [3 /*break*/, 4];
						current = Q.pop();
						return [4 /*yield*/, current];
					case 3:
						_a.sent();
						current = current.right;
						return [3 /*break*/, 5];
					case 4:
						done = true;
						_a.label = 5;
					case 5: return [3 /*break*/, 1];
					case 6: return [2 /*return*/];
				}
			});
		};
		return Tree;
	}());
	function loadRecursive(keys, values, start, end) {
		var size = end - start;
		if (size > 0) {
			var middle = start + Math.floor(size / 2);
			var key = keys[middle];
			var data = values[middle];
			var node = new Node$1(key, data);
			node.left = loadRecursive(keys, values, start, middle);
			node.right = loadRecursive(keys, values, middle + 1, end);
			return node;
		}
		return null;
	}
	function createList(keys, values) {
		var head = new Node$1(null, null);
		var p = head;
		for (var i = 0; i < keys.length; i++) {
			p = p.next = new Node$1(keys[i], values[i]);
		}
		p.next = null;
		return head.next;
	}
	function toList(root) {
		var current = root;
		var Q = [];
		var done = false;
		var head = new Node$1(null, null);
		var p = head;
		while (!done) {
			if (current) {
				Q.push(current);
				current = current.left;
			}
			else {
				if (Q.length > 0) {
					current = p = p.next = Q.pop();
					current = current.right;
				}
				else
					done = true;
			}
		}
		p.next = null; // that'll work even if the tree was empty
		return head.next;
	}
	function sortedListToBST(list, start, end) {
		var size = end - start;
		if (size > 0) {
			var middle = start + Math.floor(size / 2);
			var left = sortedListToBST(list, start, middle);
			var root = list.head;
			root.left = left;
			list.head = list.head.next;
			root.right = sortedListToBST(list, middle + 1, end);
			return root;
		}
		return null;
	}
	function mergeLists(l1, l2, compare) {
		var head = new Node$1(null, null); // dummy
		var p = head;
		var p1 = l1;
		var p2 = l2;
		while (p1 !== null && p2 !== null) {
			if (compare(p1.key, p2.key) < 0) {
				p.next = p1;
				p1 = p1.next;
			}
			else {
				p.next = p2;
				p2 = p2.next;
			}
			p = p.next;
		}
		if (p1 !== null) {
			p.next = p1;
		}
		else if (p2 !== null) {
			p.next = p2;
		}
		return head.next;
	}
	function sort(keys, values, left, right, compare) {
		if (left >= right)
			return;
		var pivot = keys[(left + right) >> 1];
		var i = left - 1;
		var j = right + 1;
		while (true) {
			do
				i++;
			while (compare(keys[i], pivot) < 0);
			do
				j--;
			while (compare(keys[j], pivot) > 0);
			if (i >= j)
				break;
			var tmp = keys[i];
			keys[i] = keys[j];
			keys[j] = tmp;
			tmp = values[i];
			values[i] = values[j];
			values[j] = tmp;
		}
		sort(keys, values, left, j, compare);
		sort(keys, values, j + 1, right, compare);
	}

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError("Cannot call a class as a function");
		}
	}

	function _defineProperties(target, props) {
		for (var i = 0; i < props.length; i++) {
			var descriptor = props[i];
			descriptor.enumerable = descriptor.enumerable || false;
			descriptor.configurable = true;
			if ("value" in descriptor) descriptor.writable = true;
			Object.defineProperty(target, descriptor.key, descriptor);
		}
	}

	function _createClass(Constructor, protoProps, staticProps) {
		if (protoProps) _defineProperties(Constructor.prototype, protoProps);
		if (staticProps) _defineProperties(Constructor, staticProps);
		return Constructor;
	}

	/**
	 * A bounding box has the format:
	 *
	 *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }
	 *
	 */
	var isInBbox = function isInBbox(bbox, point) {
		return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;
	};
	/* Returns either null, or a bbox (aka an ordered pair of points)
	 * If there is only one point of overlap, a bbox with identical points
	 * will be returned */

	var getBboxOverlap = function getBboxOverlap(b1, b2) {
		// check if the bboxes overlap at all
		if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null; // find the middle two X values

		var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;
		var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x; // find the middle two Y values

		var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;
		var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y; // put those middle values together to get the overlap

		return {
			ll: {
				x: lowerX,
				y: lowerY
			},
			ur: {
				x: upperX,
				y: upperY
			}
		};
	};

	/* Javascript doesn't do integer math. Everything is
	 * floating point with percision Number.EPSILON.
	 *
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON
	 */
	var epsilon$1 = Number.EPSILON; // IE Polyfill

	if (epsilon$1 === undefined) epsilon$1 = Math.pow(2, -52);
	var EPSILON_SQ = epsilon$1 * epsilon$1;
	/* FLP comparator */

	var cmp = function cmp(a, b) {
		// check if they're both 0
		if (-epsilon$1 < a && a < epsilon$1) {
			if (-epsilon$1 < b && b < epsilon$1) {
				return 0;
			}
		} // check if they're flp equal


		var ab = a - b;

		if (ab * ab < EPSILON_SQ * a * b) {
			return 0;
		} // normal comparison


		return a < b ? -1 : 1;
	};

	/**
	 * This class rounds incoming values sufficiently so that
	 * floating points problems are, for the most part, avoided.
	 *
	 * Incoming points are have their x & y values tested against
	 * all previously seen x & y values. If either is 'too close'
	 * to a previously seen value, it's value is 'snapped' to the
	 * previously seen value.
	 *
	 * All points should be rounded by this class before being
	 * stored in any data structures in the rest of this algorithm.
	 */

	var PtRounder = /*#__PURE__*/function () {
		function PtRounder() {
			_classCallCheck(this, PtRounder);

			this.reset();
		}

		_createClass(PtRounder, [{
			key: "reset",
			value: function reset() {
				this.xRounder = new CoordRounder();
				this.yRounder = new CoordRounder();
			}
		}, {
			key: "round",
			value: function round(x, y) {
				return {
					x: this.xRounder.round(x),
					y: this.yRounder.round(y)
				};
			}
		}]);

		return PtRounder;
	}();

	var CoordRounder = /*#__PURE__*/function () {
		function CoordRounder() {
			_classCallCheck(this, CoordRounder);

			this.tree = new Tree(); // preseed with 0 so we don't end up with values < Number.EPSILON

			this.round(0);
		} // Note: this can rounds input values backwards or forwards.
		//       You might ask, why not restrict this to just rounding
		//       forwards? Wouldn't that allow left endpoints to always
		//       remain left endpoints during splitting (never change to
		//       right). No - it wouldn't, because we snap intersections
		//       to endpoints (to establish independence from the segment
		//       angle for t-intersections).


		_createClass(CoordRounder, [{
			key: "round",
			value: function round(coord) {
				var node = this.tree.add(coord);
				var prevNode = this.tree.prev(node);

				if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {
					this.tree.remove(coord);
					return prevNode.key;
				}

				var nextNode = this.tree.next(node);

				if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {
					this.tree.remove(coord);
					return nextNode.key;
				}

				return coord;
			}
		}]);

		return CoordRounder;
	}(); // singleton available by import


	var rounder = new PtRounder();

	/* Cross Product of two vectors with first point at origin */

	var crossProduct = function crossProduct(a, b) {
		return a.x * b.y - a.y * b.x;
	};
	/* Dot Product of two vectors with first point at origin */

	var dotProduct = function dotProduct(a, b) {
		return a.x * b.x + a.y * b.y;
	};
	/* Comparator for two vectors with same starting point */

	var compareVectorAngles = function compareVectorAngles(basePt, endPt1, endPt2) {
		var v1 = {
			x: endPt1.x - basePt.x,
			y: endPt1.y - basePt.y
		};
		var v2 = {
			x: endPt2.x - basePt.x,
			y: endPt2.y - basePt.y
		};
		var kross = crossProduct(v1, v2);
		return cmp(kross, 0);
	};
	var length$1 = function length(v) {
		return Math.sqrt(dotProduct(v, v));
	};
	/* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */

	var sineOfAngle = function sineOfAngle(pShared, pBase, pAngle) {
		var vBase = {
			x: pBase.x - pShared.x,
			y: pBase.y - pShared.y
		};
		var vAngle = {
			x: pAngle.x - pShared.x,
			y: pAngle.y - pShared.y
		};
		return crossProduct(vAngle, vBase) / length$1(vAngle) / length$1(vBase);
	};
	/* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */

	var cosineOfAngle = function cosineOfAngle(pShared, pBase, pAngle) {
		var vBase = {
			x: pBase.x - pShared.x,
			y: pBase.y - pShared.y
		};
		var vAngle = {
			x: pAngle.x - pShared.x,
			y: pAngle.y - pShared.y
		};
		return dotProduct(vAngle, vBase) / length$1(vAngle) / length$1(vBase);
	};
	/* Get the x coordinate where the given line (defined by a point and vector)
	 * crosses the horizontal line with the given y coordiante.
	 * In the case of parrallel lines (including overlapping ones) returns null. */

	var horizontalIntersection = function horizontalIntersection(pt, v, y) {
		if (v.y === 0) return null;
		return {
			x: pt.x + v.x / v.y * (y - pt.y),
			y: y
		};
	};
	/* Get the y coordinate where the given line (defined by a point and vector)
	 * crosses the vertical line with the given x coordiante.
	 * In the case of parrallel lines (including overlapping ones) returns null. */

	var verticalIntersection = function verticalIntersection(pt, v, x) {
		if (v.x === 0) return null;
		return {
			x: x,
			y: pt.y + v.y / v.x * (x - pt.x)
		};
	};
	/* Get the intersection of two lines, each defined by a base point and a vector.
	 * In the case of parrallel lines (including overlapping ones) returns null. */

	var intersection = function intersection(pt1, v1, pt2, v2) {
		// take some shortcuts for vertical and horizontal lines
		// this also ensures we don't calculate an intersection and then discover
		// it's actually outside the bounding box of the line
		if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);
		if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);
		if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);
		if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y); // General case for non-overlapping segments.
		// This algorithm is based on Schneider and Eberly.
		// http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244

		var kross = crossProduct(v1, v2);
		if (kross == 0) return null;
		var ve = {
			x: pt2.x - pt1.x,
			y: pt2.y - pt1.y
		};
		var d1 = crossProduct(ve, v1) / kross;
		var d2 = crossProduct(ve, v2) / kross; // take the average of the two calculations to minimize rounding error

		var x1 = pt1.x + d2 * v1.x,
			x2 = pt2.x + d1 * v2.x;
		var y1 = pt1.y + d2 * v1.y,
			y2 = pt2.y + d1 * v2.y;
		var x = (x1 + x2) / 2;
		var y = (y1 + y2) / 2;
		return {
			x: x,
			y: y
		};
	};

	var SweepEvent = /*#__PURE__*/function () {
		_createClass(SweepEvent, null, [{
			key: "compare",
			// for ordering sweep events in the sweep event queue
			value: function compare(a, b) {
				// favor event with a point that the sweep line hits first
				var ptCmp = SweepEvent.comparePoints(a.point, b.point);
				if (ptCmp !== 0) return ptCmp; // the points are the same, so link them if needed

				if (a.point !== b.point) a.link(b); // favor right events over left

				if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1; // we have two matching left or right endpoints
				// ordering of this case is the same as for their segments

				return Segment.compare(a.segment, b.segment);
			} // for ordering points in sweep line order

		}, {
			key: "comparePoints",
			value: function comparePoints(aPt, bPt) {
				if (aPt.x < bPt.x) return -1;
				if (aPt.x > bPt.x) return 1;
				if (aPt.y < bPt.y) return -1;
				if (aPt.y > bPt.y) return 1;
				return 0;
			} // Warning: 'point' input will be modified and re-used (for performance)

		}]);

		function SweepEvent(point, isLeft) {
			_classCallCheck(this, SweepEvent);

			if (point.events === undefined) point.events = [this]; else point.events.push(this);
			this.point = point;
			this.isLeft = isLeft; // this.segment, this.otherSE set by factory
		}

		_createClass(SweepEvent, [{
			key: "link",
			value: function link(other) {
				if (other.point === this.point) {
					throw new Error('Tried to link already linked events');
				}

				var otherEvents = other.point.events;

				for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {
					var evt = otherEvents[i];
					this.point.events.push(evt);
					evt.point = this.point;
				}

				this.checkForConsuming();
			}
			/* Do a pass over our linked events and check to see if any pair
			 * of segments match, and should be consumed. */

		}, {
			key: "checkForConsuming",
			value: function checkForConsuming() {
				// FIXME: The loops in this method run O(n^2) => no good.
				//        Maintain little ordered sweep event trees?
				//        Can we maintaining an ordering that avoids the need
				//        for the re-sorting with getLeftmostComparator in geom-out?
				// Compare each pair of events to see if other events also match
				var numEvents = this.point.events.length;

				for (var i = 0; i < numEvents; i++) {
					var evt1 = this.point.events[i];
					if (evt1.segment.consumedBy !== undefined) continue;

					for (var j = i + 1; j < numEvents; j++) {
						var evt2 = this.point.events[j];
						if (evt2.consumedBy !== undefined) continue;
						if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;
						evt1.segment.consume(evt2.segment);
					}
				}
			}
		}, {
			key: "getAvailableLinkedEvents",
			value: function getAvailableLinkedEvents() {
				// point.events is always of length 2 or greater
				var events = [];

				for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {
					var evt = this.point.events[i];

					if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
						events.push(evt);
					}
				}

				return events;
			}
			/**
			 * Returns a comparator function for sorting linked events that will
			 * favor the event that will give us the smallest left-side angle.
			 * All ring construction starts as low as possible heading to the right,
			 * so by always turning left as sharp as possible we'll get polygons
			 * without uncessary loops & holes.
			 *
			 * The comparator function has a compute cache such that it avoids
			 * re-computing already-computed values.
			 */

		}, {
			key: "getLeftmostComparator",
			value: function getLeftmostComparator(baseEvent) {
				var _this = this;

				var cache = new Map();

				var fillCache = function fillCache(linkedEvent) {
					var nextEvent = linkedEvent.otherSE;
					cache.set(linkedEvent, {
						sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),
						cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)
					});
				};

				return function (a, b) {
					if (!cache.has(a)) fillCache(a);
					if (!cache.has(b)) fillCache(b);

					var _cache$get = cache.get(a),
						asine = _cache$get.sine,
						acosine = _cache$get.cosine;

					var _cache$get2 = cache.get(b),
						bsine = _cache$get2.sine,
						bcosine = _cache$get2.cosine; // both on or above x-axis


					if (asine >= 0 && bsine >= 0) {
						if (acosine < bcosine) return 1;
						if (acosine > bcosine) return -1;
						return 0;
					} // both below x-axis


					if (asine < 0 && bsine < 0) {
						if (acosine < bcosine) return -1;
						if (acosine > bcosine) return 1;
						return 0;
					} // one above x-axis, one below


					if (bsine < asine) return -1;
					if (bsine > asine) return 1;
					return 0;
				};
			}
		}]);

		return SweepEvent;
	}();

	// segments and sweep events when all else is identical

	var segmentId = 0;

	var Segment = /*#__PURE__*/function () {
		_createClass(Segment, null, [{
			key: "compare",

			/* This compare() function is for ordering segments in the sweep
			 * line tree, and does so according to the following criteria:
			 *
			 * Consider the vertical line that lies an infinestimal step to the
			 * right of the right-more of the two left endpoints of the input
			 * segments. Imagine slowly moving a point up from negative infinity
			 * in the increasing y direction. Which of the two segments will that
			 * point intersect first? That segment comes 'before' the other one.
			 *
			 * If neither segment would be intersected by such a line, (if one
			 * or more of the segments are vertical) then the line to be considered
			 * is directly on the right-more of the two left inputs.
			 */
			value: function compare(a, b) {
				var alx = a.leftSE.point.x;
				var blx = b.leftSE.point.x;
				var arx = a.rightSE.point.x;
				var brx = b.rightSE.point.x; // check if they're even in the same vertical plane

				if (brx < alx) return 1;
				if (arx < blx) return -1;
				var aly = a.leftSE.point.y;
				var bly = b.leftSE.point.y;
				var ary = a.rightSE.point.y;
				var bry = b.rightSE.point.y; // is left endpoint of segment B the right-more?

				if (alx < blx) {
					// are the two segments in the same horizontal plane?
					if (bly < aly && bly < ary) return 1;
					if (bly > aly && bly > ary) return -1; // is the B left endpoint colinear to segment A?

					var aCmpBLeft = a.comparePoint(b.leftSE.point);
					if (aCmpBLeft < 0) return 1;
					if (aCmpBLeft > 0) return -1; // is the A right endpoint colinear to segment B ?

					var bCmpARight = b.comparePoint(a.rightSE.point);
					if (bCmpARight !== 0) return bCmpARight; // colinear segments, consider the one with left-more
					// left endpoint to be first (arbitrary?)

					return -1;
				} // is left endpoint of segment A the right-more?


				if (alx > blx) {
					if (aly < bly && aly < bry) return -1;
					if (aly > bly && aly > bry) return 1; // is the A left endpoint colinear to segment B?

					var bCmpALeft = b.comparePoint(a.leftSE.point);
					if (bCmpALeft !== 0) return bCmpALeft; // is the B right endpoint colinear to segment A?

					var aCmpBRight = a.comparePoint(b.rightSE.point);
					if (aCmpBRight < 0) return 1;
					if (aCmpBRight > 0) return -1; // colinear segments, consider the one with left-more
					// left endpoint to be first (arbitrary?)

					return 1;
				} // if we get here, the two left endpoints are in the same
				// vertical plane, ie alx === blx
				// consider the lower left-endpoint to come first


				if (aly < bly) return -1;
				if (aly > bly) return 1; // left endpoints are identical
				// check for colinearity by using the left-more right endpoint
				// is the A right endpoint more left-more?

				if (arx < brx) {
					var _bCmpARight = b.comparePoint(a.rightSE.point);

					if (_bCmpARight !== 0) return _bCmpARight;
				} // is the B right endpoint more left-more?


				if (arx > brx) {
					var _aCmpBRight = a.comparePoint(b.rightSE.point);

					if (_aCmpBRight < 0) return 1;
					if (_aCmpBRight > 0) return -1;
				}

				if (arx !== brx) {
					// are these two [almost] vertical segments with opposite orientation?
					// if so, the one with the lower right endpoint comes first
					var ay = ary - aly;
					var ax = arx - alx;
					var by = bry - bly;
					var bx = brx - blx;
					if (ay > ax && by < bx) return 1;
					if (ay < ax && by > bx) return -1;
				} // we have colinear segments with matching orientation
				// consider the one with more left-more right endpoint to be first


				if (arx > brx) return 1;
				if (arx < brx) return -1; // if we get here, two two right endpoints are in the same
				// vertical plane, ie arx === brx
				// consider the lower right-endpoint to come first

				if (ary < bry) return -1;
				if (ary > bry) return 1; // right endpoints identical as well, so the segments are idential
				// fall back on creation order as consistent tie-breaker

				if (a.id < b.id) return -1;
				if (a.id > b.id) return 1; // identical segment, ie a === b

				return 0;
			}
			/* Warning: a reference to ringWindings input will be stored,
			 *  and possibly will be later modified */

		}]);

		function Segment(leftSE, rightSE, rings, windings) {
			_classCallCheck(this, Segment);

			this.id = ++segmentId;
			this.leftSE = leftSE;
			leftSE.segment = this;
			leftSE.otherSE = rightSE;
			this.rightSE = rightSE;
			rightSE.segment = this;
			rightSE.otherSE = leftSE;
			this.rings = rings;
			this.windings = windings; // left unset for performance, set later in algorithm
			// this.ringOut, this.consumedBy, this.prev
		}

		_createClass(Segment, [{
			key: "replaceRightSE",

			/* When a segment is split, the rightSE is replaced with a new sweep event */
			value: function replaceRightSE(newRightSE) {
				this.rightSE = newRightSE;
				this.rightSE.segment = this;
				this.rightSE.otherSE = this.leftSE;
				this.leftSE.otherSE = this.rightSE;
			}
		}, {
			key: "bbox",
			value: function bbox() {
				var y1 = this.leftSE.point.y;
				var y2 = this.rightSE.point.y;
				return {
					ll: {
						x: this.leftSE.point.x,
						y: y1 < y2 ? y1 : y2
					},
					ur: {
						x: this.rightSE.point.x,
						y: y1 > y2 ? y1 : y2
					}
				};
			}
			/* A vector from the left point to the right */

		}, {
			key: "vector",
			value: function vector() {
				return {
					x: this.rightSE.point.x - this.leftSE.point.x,
					y: this.rightSE.point.y - this.leftSE.point.y
				};
			}
		}, {
			key: "isAnEndpoint",
			value: function isAnEndpoint(pt) {
				return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;
			}
			/* Compare this segment with a point.
			 *
			 * A point P is considered to be colinear to a segment if there
			 * exists a distance D such that if we travel along the segment
			 * from one * endpoint towards the other a distance D, we find
			 * ourselves at point P.
			 *
			 * Return value indicates:
			 *
			 *   1: point lies above the segment (to the left of vertical)
			 *   0: point is colinear to segment
			 *  -1: point lies below the segment (to the right of vertical)
			 */

		}, {
			key: "comparePoint",
			value: function comparePoint(point) {
				if (this.isAnEndpoint(point)) return 0;
				var lPt = this.leftSE.point;
				var rPt = this.rightSE.point;
				var v = this.vector(); // Exactly vertical segments.

				if (lPt.x === rPt.x) {
					if (point.x === lPt.x) return 0;
					return point.x < lPt.x ? 1 : -1;
				} // Nearly vertical segments with an intersection.
				// Check to see where a point on the line with matching Y coordinate is.


				var yDist = (point.y - lPt.y) / v.y;
				var xFromYDist = lPt.x + yDist * v.x;
				if (point.x === xFromYDist) return 0; // General case.
				// Check to see where a point on the line with matching X coordinate is.

				var xDist = (point.x - lPt.x) / v.x;
				var yFromXDist = lPt.y + xDist * v.y;
				if (point.y === yFromXDist) return 0;
				return point.y < yFromXDist ? -1 : 1;
			}
			/**
			 * Given another segment, returns the first non-trivial intersection
			 * between the two segments (in terms of sweep line ordering), if it exists.
			 *
			 * A 'non-trivial' intersection is one that will cause one or both of the
			 * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
			 *
			 *   * endpoint of segA with endpoint of segB --> trivial
			 *   * endpoint of segA with point along segB --> non-trivial
			 *   * endpoint of segB with point along segA --> non-trivial
			 *   * point along segA with point along segB --> non-trivial
			 *
			 * If no non-trivial intersection exists, return null
			 * Else, return null.
			 */

		}, {
			key: "getIntersection",
			value: function getIntersection(other) {
				// If bboxes don't overlap, there can't be any intersections
				var tBbox = this.bbox();
				var oBbox = other.bbox();
				var bboxOverlap = getBboxOverlap(tBbox, oBbox);
				if (bboxOverlap === null) return null; // We first check to see if the endpoints can be considered intersections.
				// This will 'snap' intersections to endpoints if possible, and will
				// handle cases of colinearity.

				var tlp = this.leftSE.point;
				var trp = this.rightSE.point;
				var olp = other.leftSE.point;
				var orp = other.rightSE.point; // does each endpoint touch the other segment?
				// note that we restrict the 'touching' definition to only allow segments
				// to touch endpoints that lie forward from where we are in the sweep line pass

				var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
				var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
				var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
				var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0; // do left endpoints match?

				if (touchesThisLSE && touchesOtherLSE) {
					// these two cases are for colinear segments with matching left
					// endpoints, and one segment being longer than the other
					if (touchesThisRSE && !touchesOtherRSE) return trp;
					if (!touchesThisRSE && touchesOtherRSE) return orp; // either the two segments match exactly (two trival intersections)
					// or just on their left endpoint (one trivial intersection

					return null;
				} // does this left endpoint matches (other doesn't)


				if (touchesThisLSE) {
					// check for segments that just intersect on opposing endpoints
					if (touchesOtherRSE) {
						if (tlp.x === orp.x && tlp.y === orp.y) return null;
					} // t-intersection on left endpoint


					return tlp;
				} // does other left endpoint matches (this doesn't)


				if (touchesOtherLSE) {
					// check for segments that just intersect on opposing endpoints
					if (touchesThisRSE) {
						if (trp.x === olp.x && trp.y === olp.y) return null;
					} // t-intersection on left endpoint


					return olp;
				} // trivial intersection on right endpoints


				if (touchesThisRSE && touchesOtherRSE) return null; // t-intersections on just one right endpoint

				if (touchesThisRSE) return trp;
				if (touchesOtherRSE) return orp; // None of our endpoints intersect. Look for a general intersection between
				// infinite lines laid over the segments

				var pt = intersection(tlp, this.vector(), olp, other.vector()); // are the segments parrallel? Note that if they were colinear with overlap,
				// they would have an endpoint intersection and that case was already handled above

				if (pt === null) return null; // is the intersection found between the lines not on the segments?

				if (!isInBbox(bboxOverlap, pt)) return null; // round the the computed point if needed

				return rounder.round(pt.x, pt.y);
			}
			/**
			 * Split the given segment into multiple segments on the given points.
			 *  * Each existing segment will retain its leftSE and a new rightSE will be
			 *    generated for it.
			 *  * A new segment will be generated which will adopt the original segment's
			 *    rightSE, and a new leftSE will be generated for it.
			 *  * If there are more than two points given to split on, new segments
			 *    in the middle will be generated with new leftSE and rightSE's.
			 *  * An array of the newly generated SweepEvents will be returned.
			 *
			 * Warning: input array of points is modified
			 */

		}, {
			key: "split",
			value: function split(point) {
				var newEvents = [];
				var alreadyLinked = point.events !== undefined;
				var newLeftSE = new SweepEvent(point, true);
				var newRightSE = new SweepEvent(point, false);
				var oldRightSE = this.rightSE;
				this.replaceRightSE(newRightSE);
				newEvents.push(newRightSE);
				newEvents.push(newLeftSE);
				var newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice()); // when splitting a nearly vertical downward-facing segment,
				// sometimes one of the resulting new segments is vertical, in which
				// case its left and right events may need to be swapped

				if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
					newSeg.swapEvents();
				}

				if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
					this.swapEvents();
				} // in the point we just used to create new sweep events with was already
				// linked to other events, we need to check if either of the affected
				// segments should be consumed


				if (alreadyLinked) {
					newLeftSE.checkForConsuming();
					newRightSE.checkForConsuming();
				}

				return newEvents;
			}
			/* Swap which event is left and right */

		}, {
			key: "swapEvents",
			value: function swapEvents() {
				var tmpEvt = this.rightSE;
				this.rightSE = this.leftSE;
				this.leftSE = tmpEvt;
				this.leftSE.isLeft = true;
				this.rightSE.isLeft = false;

				for (var i = 0, iMax = this.windings.length; i < iMax; i++) {
					this.windings[i] *= -1;
				}
			}
			/* Consume another segment. We take their rings under our wing
			 * and mark them as consumed. Use for perfectly overlapping segments */

		}, {
			key: "consume",
			value: function consume(other) {
				var consumer = this;
				var consumee = other;

				while (consumer.consumedBy) {
					consumer = consumer.consumedBy;
				}

				while (consumee.consumedBy) {
					consumee = consumee.consumedBy;
				}

				var cmp = Segment.compare(consumer, consumee);
				if (cmp === 0) return; // already consumed
				// the winner of the consumption is the earlier segment
				// according to sweep line ordering

				if (cmp > 0) {
					var tmp = consumer;
					consumer = consumee;
					consumee = tmp;
				} // make sure a segment doesn't consume it's prev


				if (consumer.prev === consumee) {
					var _tmp = consumer;
					consumer = consumee;
					consumee = _tmp;
				}

				for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {
					var ring = consumee.rings[i];
					var winding = consumee.windings[i];
					var index = consumer.rings.indexOf(ring);

					if (index === -1) {
						consumer.rings.push(ring);
						consumer.windings.push(winding);
					} else consumer.windings[index] += winding;
				}

				consumee.rings = null;
				consumee.windings = null;
				consumee.consumedBy = consumer; // mark sweep events consumed as to maintain ordering in sweep event queue

				consumee.leftSE.consumedBy = consumer.leftSE;
				consumee.rightSE.consumedBy = consumer.rightSE;
			}
			/* The first segment previous segment chain that is in the result */

		}, {
			key: "prevInResult",
			value: function prevInResult() {
				if (this._prevInResult !== undefined) return this._prevInResult;
				if (!this.prev) this._prevInResult = null; else if (this.prev.isInResult()) this._prevInResult = this.prev; else this._prevInResult = this.prev.prevInResult();
				return this._prevInResult;
			}
		}, {
			key: "beforeState",
			value: function beforeState() {
				if (this._beforeState !== undefined) return this._beforeState;
				if (!this.prev) this._beforeState = {
					rings: [],
					windings: [],
					multiPolys: []
				}; else {
					var seg = this.prev.consumedBy || this.prev;
					this._beforeState = seg.afterState();
				}
				return this._beforeState;
			}
		}, {
			key: "afterState",
			value: function afterState() {
				if (this._afterState !== undefined) return this._afterState;
				var beforeState = this.beforeState();
				this._afterState = {
					rings: beforeState.rings.slice(0),
					windings: beforeState.windings.slice(0),
					multiPolys: []
				};
				var ringsAfter = this._afterState.rings;
				var windingsAfter = this._afterState.windings;
				var mpsAfter = this._afterState.multiPolys; // calculate ringsAfter, windingsAfter

				for (var i = 0, iMax = this.rings.length; i < iMax; i++) {
					var ring = this.rings[i];
					var winding = this.windings[i];
					var index = ringsAfter.indexOf(ring);

					if (index === -1) {
						ringsAfter.push(ring);
						windingsAfter.push(winding);
					} else windingsAfter[index] += winding;
				} // calcualte polysAfter


				var polysAfter = [];
				var polysExclude = [];

				for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {
					if (windingsAfter[_i] === 0) continue; // non-zero rule

					var _ring = ringsAfter[_i];
					var poly = _ring.poly;
					if (polysExclude.indexOf(poly) !== -1) continue;
					if (_ring.isExterior) polysAfter.push(poly); else {
						if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);

						var _index = polysAfter.indexOf(_ring.poly);

						if (_index !== -1) polysAfter.splice(_index, 1);
					}
				} // calculate multiPolysAfter


				for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {
					var mp = polysAfter[_i2].multiPoly;
					if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);
				}

				return this._afterState;
			}
			/* Is this segment part of the final result? */

		}, {
			key: "isInResult",
			value: function isInResult() {
				// if we've been consumed, we're not in the result
				if (this.consumedBy) return false;
				if (this._isInResult !== undefined) return this._isInResult;
				var mpsBefore = this.beforeState().multiPolys;
				var mpsAfter = this.afterState().multiPolys;

				switch (operation.type) {
					case 'union':
						{
							// UNION - included iff:
							//  * On one side of us there is 0 poly interiors AND
							//  * On the other side there is 1 or more.
							var noBefores = mpsBefore.length === 0;
							var noAfters = mpsAfter.length === 0;
							this._isInResult = noBefores !== noAfters;
							break;
						}

					case 'intersection':
						{
							// INTERSECTION - included iff:
							//  * on one side of us all multipolys are rep. with poly interiors AND
							//  * on the other side of us, not all multipolys are repsented
							//    with poly interiors
							var least;
							var most;

							if (mpsBefore.length < mpsAfter.length) {
								least = mpsBefore.length;
								most = mpsAfter.length;
							} else {
								least = mpsAfter.length;
								most = mpsBefore.length;
							}

							this._isInResult = most === operation.numMultiPolys && least < most;
							break;
						}

					case 'xor':
						{
							// XOR - included iff:
							//  * the difference between the number of multipolys represented
							//    with poly interiors on our two sides is an odd number
							var diff = Math.abs(mpsBefore.length - mpsAfter.length);
							this._isInResult = diff % 2 === 1;
							break;
						}

					case 'difference':
						{
							// DIFFERENCE included iff:
							//  * on exactly one side, we have just the subject
							var isJustSubject = function isJustSubject(mps) {
								return mps.length === 1 && mps[0].isSubject;
							};

							this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
							break;
						}

					default:
						throw new Error("Unrecognized operation type found ".concat(operation.type));
				}

				return this._isInResult;
			}
		}], [{
			key: "fromRing",
			value: function fromRing(pt1, pt2, ring) {
				var leftPt, rightPt, winding; // ordering the two points according to sweep line ordering

				var cmpPts = SweepEvent.comparePoints(pt1, pt2);

				if (cmpPts < 0) {
					leftPt = pt1;
					rightPt = pt2;
					winding = 1;
				} else if (cmpPts > 0) {
					leftPt = pt2;
					rightPt = pt1;
					winding = -1;
				} else throw new Error("Tried to create degenerate segment at [".concat(pt1.x, ", ").concat(pt1.y, "]"));

				var leftSE = new SweepEvent(leftPt, true);
				var rightSE = new SweepEvent(rightPt, false);
				return new Segment(leftSE, rightSE, [ring], [winding]);
			}
		}]);

		return Segment;
	}();

	var RingIn = /*#__PURE__*/function () {
		function RingIn(geomRing, poly, isExterior) {
			_classCallCheck(this, RingIn);

			if (!Array.isArray(geomRing) || geomRing.length === 0) {
				throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
			}

			this.poly = poly;
			this.isExterior = isExterior;
			this.segments = [];

			if (typeof geomRing[0][0] !== 'number' || typeof geomRing[0][1] !== 'number') {
				throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
			}

			var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);
			this.bbox = {
				ll: {
					x: firstPoint.x,
					y: firstPoint.y
				},
				ur: {
					x: firstPoint.x,
					y: firstPoint.y
				}
			};
			var prevPoint = firstPoint;

			for (var i = 1, iMax = geomRing.length; i < iMax; i++) {
				if (typeof geomRing[i][0] !== 'number' || typeof geomRing[i][1] !== 'number') {
					throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
				}

				var point = rounder.round(geomRing[i][0], geomRing[i][1]); // skip repeated points

				if (point.x === prevPoint.x && point.y === prevPoint.y) continue;
				this.segments.push(Segment.fromRing(prevPoint, point, this));
				if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;
				if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;
				if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;
				if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;
				prevPoint = point;
			} // add segment from last to first if last is not the same as first


			if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {
				this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));
			}
		}

		_createClass(RingIn, [{
			key: "getSweepEvents",
			value: function getSweepEvents() {
				var sweepEvents = [];

				for (var i = 0, iMax = this.segments.length; i < iMax; i++) {
					var segment = this.segments[i];
					sweepEvents.push(segment.leftSE);
					sweepEvents.push(segment.rightSE);
				}

				return sweepEvents;
			}
		}]);

		return RingIn;
	}();
	var PolyIn = /*#__PURE__*/function () {
		function PolyIn(geomPoly, multiPoly) {
			_classCallCheck(this, PolyIn);

			if (!Array.isArray(geomPoly)) {
				throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
			}

			this.exteriorRing = new RingIn(geomPoly[0], this, true); // copy by value

			this.bbox = {
				ll: {
					x: this.exteriorRing.bbox.ll.x,
					y: this.exteriorRing.bbox.ll.y
				},
				ur: {
					x: this.exteriorRing.bbox.ur.x,
					y: this.exteriorRing.bbox.ur.y
				}
			};
			this.interiorRings = [];

			for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {
				var ring = new RingIn(geomPoly[i], this, false);
				if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;
				if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;
				if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;
				if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;
				this.interiorRings.push(ring);
			}

			this.multiPoly = multiPoly;
		}

		_createClass(PolyIn, [{
			key: "getSweepEvents",
			value: function getSweepEvents() {
				var sweepEvents = this.exteriorRing.getSweepEvents();

				for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
					var ringSweepEvents = this.interiorRings[i].getSweepEvents();

					for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {
						sweepEvents.push(ringSweepEvents[j]);
					}
				}

				return sweepEvents;
			}
		}]);

		return PolyIn;
	}();
	var MultiPolyIn = /*#__PURE__*/function () {
		function MultiPolyIn(geom, isSubject) {
			_classCallCheck(this, MultiPolyIn);

			if (!Array.isArray(geom)) {
				throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
			}

			try {
				// if the input looks like a polygon, convert it to a multipolygon
				if (typeof geom[0][0][0] === 'number') geom = [geom];
			} catch (ex) {// The input is either malformed or has empty arrays.
				// In either case, it will be handled later on.
			}

			this.polys = [];
			this.bbox = {
				ll: {
					x: Number.POSITIVE_INFINITY,
					y: Number.POSITIVE_INFINITY
				},
				ur: {
					x: Number.NEGATIVE_INFINITY,
					y: Number.NEGATIVE_INFINITY
				}
			};

			for (var i = 0, iMax = geom.length; i < iMax; i++) {
				var poly = new PolyIn(geom[i], this);
				if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;
				if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;
				if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;
				if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;
				this.polys.push(poly);
			}

			this.isSubject = isSubject;
		}

		_createClass(MultiPolyIn, [{
			key: "getSweepEvents",
			value: function getSweepEvents() {
				var sweepEvents = [];

				for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
					var polySweepEvents = this.polys[i].getSweepEvents();

					for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {
						sweepEvents.push(polySweepEvents[j]);
					}
				}

				return sweepEvents;
			}
		}]);

		return MultiPolyIn;
	}();

	var RingOut = /*#__PURE__*/function () {
		_createClass(RingOut, null, [{
			key: "factory",

			/* Given the segments from the sweep line pass, compute & return a series
			 * of closed rings from all the segments marked to be part of the result */
			value: function factory(allSegments) {
				var ringsOut = [];

				for (var i = 0, iMax = allSegments.length; i < iMax; i++) {
					var segment = allSegments[i];
					if (!segment.isInResult() || segment.ringOut) continue;
					var prevEvent = null;
					var event = segment.leftSE;
					var nextEvent = segment.rightSE;
					var events = [event];
					var startingPoint = event.point;
					var intersectionLEs = [];
					/* Walk the chain of linked events to form a closed ring */

					while (true) {
						prevEvent = event;
						event = nextEvent;
						events.push(event);
						/* Is the ring complete? */

						if (event.point === startingPoint) break;

						while (true) {
							var availableLEs = event.getAvailableLinkedEvents();
							/* Did we hit a dead end? This shouldn't happen. Indicates some earlier
							 * part of the algorithm malfunctioned... please file a bug report. */

							if (availableLEs.length === 0) {
								var firstPt = events[0].point;
								var lastPt = events[events.length - 1].point;
								throw new Error("Unable to complete output ring starting at [".concat(firstPt.x, ",") + " ".concat(firstPt.y, "]. Last matching segment found ends at") + " [".concat(lastPt.x, ", ").concat(lastPt.y, "]."));
							}
							/* Only one way to go, so cotinue on the path */


							if (availableLEs.length === 1) {
								nextEvent = availableLEs[0].otherSE;
								break;
							}
							/* We must have an intersection. Check for a completed loop */


							var indexLE = null;

							for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {
								if (intersectionLEs[j].point === event.point) {
									indexLE = j;
									break;
								}
							}
							/* Found a completed loop. Cut that off and make a ring */


							if (indexLE !== null) {
								var intersectionLE = intersectionLEs.splice(indexLE)[0];
								var ringEvents = events.splice(intersectionLE.index);
								ringEvents.unshift(ringEvents[0].otherSE);
								ringsOut.push(new RingOut(ringEvents.reverse()));
								continue;
							}
							/* register the intersection */


							intersectionLEs.push({
								index: events.length,
								point: event.point
							});
							/* Choose the left-most option to continue the walk */

							var comparator = event.getLeftmostComparator(prevEvent);
							nextEvent = availableLEs.sort(comparator)[0].otherSE;
							break;
						}
					}

					ringsOut.push(new RingOut(events));
				}

				return ringsOut;
			}
		}]);

		function RingOut(events) {
			_classCallCheck(this, RingOut);

			this.events = events;

			for (var i = 0, iMax = events.length; i < iMax; i++) {
				events[i].segment.ringOut = this;
			}

			this.poly = null;
		}

		_createClass(RingOut, [{
			key: "getGeom",
			value: function getGeom() {
				// Remove superfluous points (ie extra points along a straight line),
				var prevPt = this.events[0].point;
				var points = [prevPt];

				for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {
					var _pt = this.events[i].point;
					var _nextPt = this.events[i + 1].point;
					if (compareVectorAngles(_pt, prevPt, _nextPt) === 0) continue;
					points.push(_pt);
					prevPt = _pt;
				} // ring was all (within rounding error of angle calc) colinear points


				if (points.length === 1) return null; // check if the starting point is necessary

				var pt = points[0];
				var nextPt = points[1];
				if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();
				points.push(points[0]);
				var step = this.isExteriorRing() ? 1 : -1;
				var iStart = this.isExteriorRing() ? 0 : points.length - 1;
				var iEnd = this.isExteriorRing() ? points.length : -1;
				var orderedPoints = [];

				for (var _i = iStart; _i != iEnd; _i += step) {
					orderedPoints.push([points[_i].x, points[_i].y]);
				}

				return orderedPoints;
			}
		}, {
			key: "isExteriorRing",
			value: function isExteriorRing() {
				if (this._isExteriorRing === undefined) {
					var enclosing = this.enclosingRing();
					this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
				}

				return this._isExteriorRing;
			}
		}, {
			key: "enclosingRing",
			value: function enclosingRing() {
				if (this._enclosingRing === undefined) {
					this._enclosingRing = this._calcEnclosingRing();
				}

				return this._enclosingRing;
			}
			/* Returns the ring that encloses this one, if any */

		}, {
			key: "_calcEnclosingRing",
			value: function _calcEnclosingRing() {
				// start with the ealier sweep line event so that the prevSeg
				// chain doesn't lead us inside of a loop of ours
				var leftMostEvt = this.events[0];

				for (var i = 1, iMax = this.events.length; i < iMax; i++) {
					var evt = this.events[i];
					if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;
				}

				var prevSeg = leftMostEvt.segment.prevInResult();
				var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;

				while (true) {
					// no segment found, thus no ring can enclose us
					if (!prevSeg) return null; // no segments below prev segment found, thus the ring of the prev
					// segment must loop back around and enclose us

					if (!prevPrevSeg) return prevSeg.ringOut; // if the two segments are of different rings, the ring of the prev
					// segment must either loop around us or the ring of the prev prev
					// seg, which would make us and the ring of the prev peers

					if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
						if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {
							return prevSeg.ringOut;
						} else return prevSeg.ringOut.enclosingRing();
					} // two segments are from the same ring, so this was a penisula
					// of that ring. iterate downward, keep searching


					prevSeg = prevPrevSeg.prevInResult();
					prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
				}
			}
		}]);

		return RingOut;
	}();
	var PolyOut = /*#__PURE__*/function () {
		function PolyOut(exteriorRing) {
			_classCallCheck(this, PolyOut);

			this.exteriorRing = exteriorRing;
			exteriorRing.poly = this;
			this.interiorRings = [];
		}

		_createClass(PolyOut, [{
			key: "addInterior",
			value: function addInterior(ring) {
				this.interiorRings.push(ring);
				ring.poly = this;
			}
		}, {
			key: "getGeom",
			value: function getGeom() {
				var geom = [this.exteriorRing.getGeom()]; // exterior ring was all (within rounding error of angle calc) colinear points

				if (geom[0] === null) return null;

				for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
					var ringGeom = this.interiorRings[i].getGeom(); // interior ring was all (within rounding error of angle calc) colinear points

					if (ringGeom === null) continue;
					geom.push(ringGeom);
				}

				return geom;
			}
		}]);

		return PolyOut;
	}();
	var MultiPolyOut = /*#__PURE__*/function () {
		function MultiPolyOut(rings) {
			_classCallCheck(this, MultiPolyOut);

			this.rings = rings;
			this.polys = this._composePolys(rings);
		}

		_createClass(MultiPolyOut, [{
			key: "getGeom",
			value: function getGeom() {
				var geom = [];

				for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
					var polyGeom = this.polys[i].getGeom(); // exterior ring was all (within rounding error of angle calc) colinear points

					if (polyGeom === null) continue;
					geom.push(polyGeom);
				}

				return geom;
			}
		}, {
			key: "_composePolys",
			value: function _composePolys(rings) {
				var polys = [];

				for (var i = 0, iMax = rings.length; i < iMax; i++) {
					var ring = rings[i];
					if (ring.poly) continue;
					if (ring.isExteriorRing()) polys.push(new PolyOut(ring)); else {
						var enclosingRing = ring.enclosingRing();
						if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));
						enclosingRing.poly.addInterior(ring);
					}
				}

				return polys;
			}
		}]);

		return MultiPolyOut;
	}();

	/**
	 * NOTE:  We must be careful not to change any segments while
	 *        they are in the SplayTree. AFAIK, there's no way to tell
	 *        the tree to rebalance itself - thus before splitting
	 *        a segment that's in the tree, we remove it from the tree,
	 *        do the split, then re-insert it. (Even though splitting a
	 *        segment *shouldn't* change its correct position in the
	 *        sweep line tree, the reality is because of rounding errors,
	 *        it sometimes does.)
	 */

	var SweepLine = /*#__PURE__*/function () {
		function SweepLine(queue) {
			var comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;

			_classCallCheck(this, SweepLine);

			this.queue = queue;
			this.tree = new Tree(comparator);
			this.segments = [];
		}

		_createClass(SweepLine, [{
			key: "process",
			value: function process(event) {
				var segment = event.segment;
				var newEvents = []; // if we've already been consumed by another segment,
				// clean up our body parts and get out

				if (event.consumedBy) {
					if (event.isLeft) this.queue.remove(event.otherSE); else this.tree.remove(segment);
					return newEvents;
				}

				var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);
				if (!node) throw new Error("Unable to find segment #".concat(segment.id, " ") + "[".concat(segment.leftSE.point.x, ", ").concat(segment.leftSE.point.y, "] -> ") + "[".concat(segment.rightSE.point.x, ", ").concat(segment.rightSE.point.y, "] ") + 'in SweepLine tree. Please submit a bug report.');
				var prevNode = node;
				var nextNode = node;
				var prevSeg = undefined;
				var nextSeg = undefined; // skip consumed segments still in tree

				while (prevSeg === undefined) {
					prevNode = this.tree.prev(prevNode);
					if (prevNode === null) prevSeg = null; else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;
				} // skip consumed segments still in tree


				while (nextSeg === undefined) {
					nextNode = this.tree.next(nextNode);
					if (nextNode === null) nextSeg = null; else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;
				}

				if (event.isLeft) {
					// Check for intersections against the previous segment in the sweep line
					var prevMySplitter = null;

					if (prevSeg) {
						var prevInter = prevSeg.getIntersection(segment);

						if (prevInter !== null) {
							if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;

							if (!prevSeg.isAnEndpoint(prevInter)) {
								var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);

								for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
									newEvents.push(newEventsFromSplit[i]);
								}
							}
						}
					} // Check for intersections against the next segment in the sweep line


					var nextMySplitter = null;

					if (nextSeg) {
						var nextInter = nextSeg.getIntersection(segment);

						if (nextInter !== null) {
							if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;

							if (!nextSeg.isAnEndpoint(nextInter)) {
								var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);

								for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {
									newEvents.push(_newEventsFromSplit[_i]);
								}
							}
						}
					} // For simplicity, even if we find more than one intersection we only
					// spilt on the 'earliest' (sweep-line style) of the intersections.
					// The other intersection will be handled in a future process().


					if (prevMySplitter !== null || nextMySplitter !== null) {
						var mySplitter = null;
						if (prevMySplitter === null) mySplitter = nextMySplitter; else if (nextMySplitter === null) mySplitter = prevMySplitter; else {
							var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);
							mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
						} // Rounding errors can cause changes in ordering,
						// so remove afected segments and right sweep events before splitting

						this.queue.remove(segment.rightSE);
						newEvents.push(segment.rightSE);

						var _newEventsFromSplit2 = segment.split(mySplitter);

						for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {
							newEvents.push(_newEventsFromSplit2[_i2]);
						}
					}

					if (newEvents.length > 0) {
						// We found some intersections, so re-do the current event to
						// make sure sweep line ordering is totally consistent for later
						// use with the segment 'prev' pointers
						this.tree.remove(segment);
						newEvents.push(event);
					} else {
						// done with left event
						this.segments.push(segment);
						segment.prev = prevSeg;
					}
				} else {
					// event.isRight
					// since we're about to be removed from the sweep line, check for
					// intersections between our previous and next segments
					if (prevSeg && nextSeg) {
						var inter = prevSeg.getIntersection(nextSeg);

						if (inter !== null) {
							if (!prevSeg.isAnEndpoint(inter)) {
								var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);

								for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {
									newEvents.push(_newEventsFromSplit3[_i3]);
								}
							}

							if (!nextSeg.isAnEndpoint(inter)) {
								var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);

								for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {
									newEvents.push(_newEventsFromSplit4[_i4]);
								}
							}
						}
					}

					this.tree.remove(segment);
				}

				return newEvents;
			}
			/* Safely split a segment that is currently in the datastructures
			 * IE - a segment other than the one that is currently being processed. */

		}, {
			key: "_splitSafely",
			value: function _splitSafely(seg, pt) {
				// Rounding errors can cause changes in ordering,
				// so remove afected segments and right sweep events before splitting
				// removeNode() doesn't work, so have re-find the seg
				// https://github.com/w8r/splay-tree/pull/5
				this.tree.remove(seg);
				var rightSE = seg.rightSE;
				this.queue.remove(rightSE);
				var newEvents = seg.split(pt);
				newEvents.push(rightSE); // splitting can trigger consumption

				if (seg.consumedBy === undefined) this.tree.insert(seg);
				return newEvents;
			}
		}]);

		return SweepLine;
	}();

	var POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;
	var POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;
	var Operation = /*#__PURE__*/function () {
		function Operation() {
			_classCallCheck(this, Operation);
		}

		_createClass(Operation, [{
			key: "run",
			value: function run(type, geom, moreGeoms) {
				operation.type = type;
				rounder.reset();
				/* Convert inputs to MultiPoly objects */

				var multipolys = [new MultiPolyIn(geom, true)];

				for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {
					multipolys.push(new MultiPolyIn(moreGeoms[i], false));
				}

				operation.numMultiPolys = multipolys.length;
				/* BBox optimization for difference operation
				 * If the bbox of a multipolygon that's part of the clipping doesn't
				 * intersect the bbox of the subject at all, we can just drop that
				 * multiploygon. */

				if (operation.type === 'difference') {
					// in place removal
					var subject = multipolys[0];
					var _i = 1;

					while (_i < multipolys.length) {
						if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null) _i++; else multipolys.splice(_i, 1);
					}
				}
				/* BBox optimization for intersection operation
				 * If we can find any pair of multipolygons whose bbox does not overlap,
				 * then the result will be empty. */


				if (operation.type === 'intersection') {
					// TODO: this is O(n^2) in number of polygons. By sorting the bboxes,
					//       it could be optimized to O(n * ln(n))
					for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {
						var mpA = multipolys[_i2];

						for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {
							if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];
						}
					}
				}
				/* Put segment endpoints in a priority queue */


				var queue = new Tree(SweepEvent.compare);

				for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {
					var sweepEvents = multipolys[_i3].getSweepEvents();

					for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {
						queue.insert(sweepEvents[_j]);

						if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
							// prevents an infinite loop, an otherwise common manifestation of bugs
							throw new Error('Infinite loop when putting segment endpoints in a priority queue ' + '(queue size too big). Please file a bug report.');
						}
					}
				}
				/* Pass the sweep line over those endpoints */


				var sweepLine = new SweepLine(queue);
				var prevQueueSize = queue.size;
				var node = queue.pop();

				while (node) {
					var evt = node.key;

					if (queue.size === prevQueueSize) {
						// prevents an infinite loop, an otherwise common manifestation of bugs
						var seg = evt.segment;
						throw new Error("Unable to pop() ".concat(evt.isLeft ? 'left' : 'right', " SweepEvent ") + "[".concat(evt.point.x, ", ").concat(evt.point.y, "] from segment #").concat(seg.id, " ") + "[".concat(seg.leftSE.point.x, ", ").concat(seg.leftSE.point.y, "] -> ") + "[".concat(seg.rightSE.point.x, ", ").concat(seg.rightSE.point.y, "] from queue. ") + 'Please file a bug report.');
					}

					if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
						// prevents an infinite loop, an otherwise common manifestation of bugs
						throw new Error('Infinite loop when passing sweep line over endpoints ' + '(queue size too big). Please file a bug report.');
					}

					if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {
						// prevents an infinite loop, an otherwise common manifestation of bugs
						throw new Error('Infinite loop when passing sweep line over endpoints ' + '(too many sweep line segments). Please file a bug report.');
					}

					var newEvents = sweepLine.process(evt);

					for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {
						var _evt = newEvents[_i4];
						if (_evt.consumedBy === undefined) queue.insert(_evt);
					}

					prevQueueSize = queue.size;
					node = queue.pop();
				} // free some memory we don't need anymore


				rounder.reset();
				/* Collect and compile segments we're keeping into a multipolygon */

				var ringsOut = RingOut.factory(sweepLine.segments);
				var result = new MultiPolyOut(ringsOut);
				return result.getGeom();
			}
		}]);

		return Operation;
	}(); // singleton available by import

	var operation = new Operation();

	var union = function union(geom) {
		for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			moreGeoms[_key - 1] = arguments[_key];
		}

		return operation.run('union', geom, moreGeoms);
	};

	var intersection$1 = function intersection(geom) {
		for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
			moreGeoms[_key2 - 1] = arguments[_key2];
		}

		return operation.run('intersection', geom, moreGeoms);
	};

	var xor = function xor(geom) {
		for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
			moreGeoms[_key3 - 1] = arguments[_key3];
		}

		return operation.run('xor', geom, moreGeoms);
	};

	var difference = function difference(subjectGeom) {
		for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
			clippingGeoms[_key4 - 1] = arguments[_key4];
		}

		return operation.run('difference', subjectGeom, clippingGeoms);
	};

	var index = {
		union: union,
		intersection: intersection$1,
		xor: xor,
		difference: difference
	};

	var polygonClipping = index;

	/* Polyfill service v3.13.0
	 * For detailed credits and licence information see http://github.com/financial-times/polyfill-service
	 *
	 * - Array.prototype.fill, License: CC0 */

	if (!('fill' in Array.prototype)) {
		Object.defineProperty(Array.prototype, 'fill', {
			configurable: true,
			value: function fill(value) {
				if (this === undefined || this === null) {
					throw new TypeError(this + ' is not an object')
				}

				var arrayLike = Object(this);

				var length = Math.max(Math.min(arrayLike.length, 9007199254740991), 0) || 0;

				var relativeStart = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;

				relativeStart = relativeStart < 0 ? Math.max(length + relativeStart, 0) : Math.min(relativeStart, length);

				var relativeEnd = 2 in arguments && arguments[2] !== undefined ? parseInt(Number(arguments[2]), 10) || 0 : length;

				relativeEnd = relativeEnd < 0 ? Math.max(length + arguments[2], 0) : Math.min(relativeEnd, length);

				while (relativeStart < relativeEnd) {
					arrayLike[relativeStart] = value;

					++relativeStart;
				}

				return arrayLike
			},
			writable: true
		});
	}

	/**
	 * Polyfill for IE support
	 */
	Number.isFinite = Number.isFinite || function (value) {
		return typeof value === 'number' && isFinite(value)
	};

	Number.isInteger = Number.isInteger || function (val) {
		return typeof val === 'number' &&
			isFinite(val) &&
			Math.floor(val) === val
	};

	Number.parseFloat = Number.parseFloat || parseFloat;

	Number.isNaN = Number.isNaN || function (value) {
		return value !== value // eslint-disable-line
	};

	/**
	 * Polyfill for IE support
	 */
	Math.trunc = Math.trunc || function (x) {
		return x < 0 ? Math.ceil(x) : Math.floor(x)
	};

	var NumberUtil = function NumberUtil() { };

	NumberUtil.prototype.interfaces_ = function interfaces_() {
		return []
	};
	NumberUtil.prototype.getClass = function getClass() {
		return NumberUtil
	};
	NumberUtil.prototype.equalsWithTolerance = function equalsWithTolerance(x1, x2, tolerance) {
		return Math.abs(x1 - x2) <= tolerance
	};

	var IllegalArgumentException = (function (Error) {
		function IllegalArgumentException(message) {
			Error.call(this, message);
			this.name = 'IllegalArgumentException';
			this.message = message;
			this.stack = (new Error()).stack;
		}

		if (Error) IllegalArgumentException.__proto__ = Error;
		IllegalArgumentException.prototype = Object.create(Error && Error.prototype);
		IllegalArgumentException.prototype.constructor = IllegalArgumentException;

		return IllegalArgumentException;
	}(Error));

	var Double = function Double() { };

	var staticAccessors$1 = { MAX_VALUE: { configurable: true } };

	Double.isNaN = function isNaN(n) { return Number.isNaN(n) };
	Double.doubleToLongBits = function doubleToLongBits(n) { return n };
	Double.longBitsToDouble = function longBitsToDouble(n) { return n };
	Double.isInfinite = function isInfinite(n) { return !Number.isFinite(n) };
	staticAccessors$1.MAX_VALUE.get = function () { return Number.MAX_VALUE };

	Object.defineProperties(Double, staticAccessors$1);

	var Comparable = function Comparable() { };

	var Clonable = function Clonable() { };

	var Comparator = function Comparator() { };

	function Serializable() { }

	// import Assert from '../util/Assert'

	var Coordinate = function Coordinate() {
		this.x = null;
		this.y = null;
		this.z = null;
		if (arguments.length === 0) {
			this.x = 0.0;
			this.y = 0.0;
			this.z = Coordinate.NULL_ORDINATE;
		} else if (arguments.length === 1) {
			var c = arguments[0];
			this.x = c.x;
			this.y = c.y;
			this.z = c.z;
		} else if (arguments.length === 2) {
			this.x = arguments[0];
			this.y = arguments[1];
			this.z = Coordinate.NULL_ORDINATE;
		} else if (arguments.length === 3) {
			this.x = arguments[0];
			this.y = arguments[1];
			this.z = arguments[2];
		}
	};

	var staticAccessors = { DimensionalComparator: { configurable: true }, serialVersionUID: { configurable: true }, NULL_ORDINATE: { configurable: true }, X: { configurable: true }, Y: { configurable: true }, Z: { configurable: true } };
	Coordinate.prototype.setOrdinate = function setOrdinate(ordinateIndex, value) {
		switch (ordinateIndex) {
			case Coordinate.X:
				this.x = value;
				break
			case Coordinate.Y:
				this.y = value;
				break
			case Coordinate.Z:
				this.z = value;
				break
			default:
				throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex)
		}
	};
	Coordinate.prototype.equals2D = function equals2D() {
		if (arguments.length === 1) {
			var other = arguments[0];
			if (this.x !== other.x) {
				return false
			}
			if (this.y !== other.y) {
				return false
			}
			return true
		} else if (arguments.length === 2) {
			var c = arguments[0];
			var tolerance = arguments[1];
			if (!NumberUtil.equalsWithTolerance(this.x, c.x, tolerance)) {
				return false
			}
			if (!NumberUtil.equalsWithTolerance(this.y, c.y, tolerance)) {
				return false
			}
			return true
		}
	};
	Coordinate.prototype.getOrdinate = function getOrdinate(ordinateIndex) {
		switch (ordinateIndex) {
			case Coordinate.X:
				return this.x
			case Coordinate.Y:
				return this.y
			case Coordinate.Z:
				return this.z
		}
		throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex)
	};
	Coordinate.prototype.equals3D = function equals3D(other) {
		return this.x === other.x &&
			this.y === other.y &&
			((this.z === other.z || Double.isNaN(this.z)) &&
				Double.isNaN(other.z))
	};
	Coordinate.prototype.equals = function equals(other) {
		if (!(other instanceof Coordinate)) {
			return false
		}
		return this.equals2D(other)
	};
	Coordinate.prototype.equalInZ = function equalInZ(c, tolerance) {
		return NumberUtil.equalsWithTolerance(this.z, c.z, tolerance)
	};
	Coordinate.prototype.compareTo = function compareTo(o) {
		var other = o;
		if (this.x < other.x) { return -1 }
		if (this.x > other.x) { return 1 }
		if (this.y < other.y) { return -1 }
		if (this.y > other.y) { return 1 }
		return 0
	};
	Coordinate.prototype.clone = function clone() {
		// try {
		// var coord = null
		// return coord
		// } catch (e) {
		// if (e instanceof CloneNotSupportedException) {
		//   Assert.shouldNeverReachHere("this shouldn't happen because this class is Cloneable")
		//   return null
		// } else throw e
		// } finally {}
	};
	Coordinate.prototype.copy = function copy() {
		return new Coordinate(this)
	};
	Coordinate.prototype.toString = function toString() {
		return '(' + this.x + ', ' + this.y + ', ' + this.z + ')'
	};
	Coordinate.prototype.distance3D = function distance3D(c) {
		var dx = this.x - c.x;
		var dy = this.y - c.y;
		var dz = this.z - c.z;
		return Math.sqrt(dx * dx + dy * dy + dz * dz)
	};
	Coordinate.prototype.distance = function distance(c) {
		var dx = this.x - c.x;
		var dy = this.y - c.y;
		return Math.sqrt(dx * dx + dy * dy)
	};
	Coordinate.prototype.hashCode = function hashCode() {
		var result = 17;
		result = 37 * result + Coordinate.hashCode(this.x);
		result = 37 * result + Coordinate.hashCode(this.y);
		return result
	};
	Coordinate.prototype.setCoordinate = function setCoordinate(other) {
		this.x = other.x;
		this.y = other.y;
		this.z = other.z;
	};
	Coordinate.prototype.interfaces_ = function interfaces_() {
		return [Comparable, Clonable, Serializable]
	};
	Coordinate.prototype.getClass = function getClass() {
		return Coordinate
	};
	Coordinate.hashCode = function hashCode() {
		if (arguments.length === 1) {
			var x = arguments[0];
			var f = Double.doubleToLongBits(x);
			return Math.trunc((f ^ f) >>> 32)
		}
	};
	staticAccessors.DimensionalComparator.get = function () { return DimensionalComparator };
	staticAccessors.serialVersionUID.get = function () { return 6683108902428366910 };
	staticAccessors.NULL_ORDINATE.get = function () { return Double.NaN };
	staticAccessors.X.get = function () { return 0 };
	staticAccessors.Y.get = function () { return 1 };
	staticAccessors.Z.get = function () { return 2 };

	Object.defineProperties(Coordinate, staticAccessors);

	var DimensionalComparator = function DimensionalComparator(dimensionsToTest) {
		this._dimensionsToTest = 2;
		if (arguments.length === 0); else if (arguments.length === 1) {
			var dimensionsToTest$1 = arguments[0];
			if (dimensionsToTest$1 !== 2 && dimensionsToTest$1 !== 3) { throw new IllegalArgumentException('only 2 or 3 dimensions may be specified') }
			this._dimensionsToTest = dimensionsToTest$1;
		}
	};
	DimensionalComparator.prototype.compare = function compare(o1, o2) {
		var c1 = o1;
		var c2 = o2;
		var compX = DimensionalComparator.compare(c1.x, c2.x);
		if (compX !== 0) { return compX }
		var compY = DimensionalComparator.compare(c1.y, c2.y);
		if (compY !== 0) { return compY }
		if (this._dimensionsToTest <= 2) { return 0 }
		var compZ = DimensionalComparator.compare(c1.z, c2.z);
		return compZ
	};
	DimensionalComparator.prototype.interfaces_ = function interfaces_() {
		return [Comparator]
	};
	DimensionalComparator.prototype.getClass = function getClass() {
		return DimensionalComparator
	};
	DimensionalComparator.compare = function compare(a, b) {
		if (a < b) { return -1 }
		if (a > b) { return 1 }
		if (Double.isNaN(a)) {
			if (Double.isNaN(b)) { return 0 }
			return -1
		}
		if (Double.isNaN(b)) { return 1 }
		return 0
	};

	// import hasInterface from '../../../../hasInterface'
	// import CoordinateSequence from './CoordinateSequence'

	var CoordinateSequenceFactory = function CoordinateSequenceFactory() { };

	CoordinateSequenceFactory.prototype.create = function create() {
		// if (arguments.length === 1) {
		// if (arguments[0] instanceof Array) {
		//   let coordinates = arguments[0]
		// } else if (hasInterface(arguments[0], CoordinateSequence)) {
		//   let coordSeq = arguments[0]
		// }
		// } else if (arguments.length === 2) {
		// let size = arguments[0]
		// let dimension = arguments[1]
		// }
	};
	CoordinateSequenceFactory.prototype.interfaces_ = function interfaces_() {
		return []
	};
	CoordinateSequenceFactory.prototype.getClass = function getClass() {
		return CoordinateSequenceFactory
	};

	var Location = function Location() { };

	var staticAccessors$4 = { INTERIOR: { configurable: true }, BOUNDARY: { configurable: true }, EXTERIOR: { configurable: true }, NONE: { configurable: true } };

	Location.prototype.interfaces_ = function interfaces_() {
		return []
	};
	Location.prototype.getClass = function getClass() {
		return Location
	};
	Location.toLocationSymbol = function toLocationSymbol(locationValue) {
		switch (locationValue) {
			case Location.EXTERIOR:
				return 'e'
			case Location.BOUNDARY:
				return 'b'
			case Location.INTERIOR:
				return 'i'
			case Location.NONE:
				return '-'
		}
		throw new IllegalArgumentException('Unknown location value: ' + locationValue)
	};
	staticAccessors$4.INTERIOR.get = function () { return 0 };
	staticAccessors$4.BOUNDARY.get = function () { return 1 };
	staticAccessors$4.EXTERIOR.get = function () { return 2 };
	staticAccessors$4.NONE.get = function () { return -1 };

	Object.defineProperties(Location, staticAccessors$4);

	var hasInterface = function (o, i) {
		return o.interfaces_ && o.interfaces_().indexOf(i) > -1
	};

	var MathUtil = function MathUtil() { };

	var staticAccessors$5 = { LOG_10: { configurable: true } };

	MathUtil.prototype.interfaces_ = function interfaces_() {
		return []
	};
	MathUtil.prototype.getClass = function getClass() {
		return MathUtil
	};
	MathUtil.log10 = function log10(x) {
		var ln = Math.log(x);
		if (Double.isInfinite(ln)) { return ln }
		if (Double.isNaN(ln)) { return ln }
		return ln / MathUtil.LOG_10
	};
	MathUtil.min = function min(v1, v2, v3, v4) {
		var min = v1;
		if (v2 < min) { min = v2; }
		if (v3 < min) { min = v3; }
		if (v4 < min) { min = v4; }
		return min
	};
	MathUtil.clamp = function clamp() {
		if (typeof arguments[2] === 'number' && (typeof arguments[0] === 'number' && typeof arguments[1] === 'number')) {
			var x = arguments[0];
			var min = arguments[1];
			var max = arguments[2];
			if (x < min) { return min }
			if (x > max) { return max }
			return x
		} else if (Number.isInteger(arguments[2]) && (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1]))) {
			var x$1 = arguments[0];
			var min$1 = arguments[1];
			var max$1 = arguments[2];
			if (x$1 < min$1) { return min$1 }
			if (x$1 > max$1) { return max$1 }
			return x$1
		}
	};
	MathUtil.wrap = function wrap(index, max) {
		if (index < 0) {
			return max - -index % max
		}
		return index % max
	};
	MathUtil.max = function max() {
		if (arguments.length === 3) {
			var v1 = arguments[0];
			var v2 = arguments[1];
			var v3 = arguments[2];
			var max = v1;
			if (v2 > max) { max = v2; }
			if (v3 > max) { max = v3; }
			return max
		} else if (arguments.length === 4) {
			var v1$1 = arguments[0];
			var v2$1 = arguments[1];
			var v3$1 = arguments[2];
			var v4 = arguments[3];
			var max$1 = v1$1;
			if (v2$1 > max$1) { max$1 = v2$1; }
			if (v3$1 > max$1) { max$1 = v3$1; }
			if (v4 > max$1) { max$1 = v4; }
			return max$1
		}
	};
	MathUtil.average = function average(x1, x2) {
		return (x1 + x2) / 2.0
	};
	staticAccessors$5.LOG_10.get = function () { return Math.log(10) };

	Object.defineProperties(MathUtil, staticAccessors$5);

	var StringBuffer = function StringBuffer(str) {
		this.str = str;
	};
	StringBuffer.prototype.append = function append(e) {
		this.str += e;
	};

	StringBuffer.prototype.setCharAt = function setCharAt(i, c) {
		this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);
	};

	StringBuffer.prototype.toString = function toString(e) {
		return this.str
	};

	var Integer = function Integer(value) {
		this.value = value;
	};
	Integer.prototype.intValue = function intValue() {
		return this.value
	};
	Integer.prototype.compareTo = function compareTo(o) {
		if (this.value < o) { return -1 }
		if (this.value > o) { return 1 }
		return 0
	};
	Integer.isNaN = function isNaN(n) { return Number.isNaN(n) };

	var Character = function Character() { };

	Character.isWhitespace = function isWhitespace(c) { return ((c <= 32 && c >= 0) || c === 127) };
	Character.toUpperCase = function toUpperCase(c) { return c.toUpperCase() };

	var DD = function DD() {
		this._hi = 0.0;
		this._lo = 0.0;
		if (arguments.length === 0) {
			this.init(0.0);
		} else if (arguments.length === 1) {
			if (typeof arguments[0] === 'number') {
				var x = arguments[0];
				this.init(x);
			} else if (arguments[0] instanceof DD) {
				var dd = arguments[0];
				this.init(dd);
			} else if (typeof arguments[0] === 'string') {
				var str = arguments[0];
				DD.call(this, DD.parse(str));
			}
		} else if (arguments.length === 2) {
			var hi = arguments[0];
			var lo = arguments[1];
			this.init(hi, lo);
		}
	};

	var staticAccessors$7 = { PI: { configurable: true }, TWO_PI: { configurable: true }, PI_2: { configurable: true }, E: { configurable: true }, NaN: { configurable: true }, EPS: { configurable: true }, SPLIT: { configurable: true }, MAX_PRINT_DIGITS: { configurable: true }, TEN: { configurable: true }, ONE: { configurable: true }, SCI_NOT_EXPONENT_CHAR: { configurable: true }, SCI_NOT_ZERO: { configurable: true } };
	DD.prototype.le = function le(y) {
		return (this._hi < y._hi || this._hi === y._hi) && this._lo <= y._lo
	};
	DD.prototype.extractSignificantDigits = function extractSignificantDigits(insertDecimalPoint, magnitude) {
		var y = this.abs();
		var mag = DD.magnitude(y._hi);
		var scale = DD.TEN.pow(mag);
		y = y.divide(scale);
		if (y.gt(DD.TEN)) {
			y = y.divide(DD.TEN);
			mag += 1;
		} else if (y.lt(DD.ONE)) {
			y = y.multiply(DD.TEN);
			mag -= 1;
		}
		var decimalPointPos = mag + 1;
		var buf = new StringBuffer();
		var numDigits = DD.MAX_PRINT_DIGITS - 1;
		for (var i = 0; i <= numDigits; i++) {
			if (insertDecimalPoint && i === decimalPointPos) {
				buf.append('.');
			}
			var digit = Math.trunc(y._hi);
			if (digit < 0) {
				break
			}
			var rebiasBy10 = false;
			var digitChar = 0;
			if (digit > 9) {
				rebiasBy10 = true;
				digitChar = '9';
			} else {
				digitChar = '0' + digit;
			}
			buf.append(digitChar);
			y = y.subtract(DD.valueOf(digit)).multiply(DD.TEN);
			if (rebiasBy10) { y.selfAdd(DD.TEN); }
			var continueExtractingDigits = true;
			var remMag = DD.magnitude(y._hi);
			if (remMag < 0 && Math.abs(remMag) >= numDigits - i) { continueExtractingDigits = false; }
			if (!continueExtractingDigits) { break }
		}
		magnitude[0] = mag;
		return buf.toString()
	};
	DD.prototype.sqr = function sqr() {
		return this.multiply(this)
	};
	DD.prototype.doubleValue = function doubleValue() {
		return this._hi + this._lo
	};
	DD.prototype.subtract = function subtract() {
		if (arguments[0] instanceof DD) {
			var y = arguments[0];
			return this.add(y.negate())
		} else if (typeof arguments[0] === 'number') {
			var y$1 = arguments[0];
			return this.add(-y$1)
		}
	};
	DD.prototype.equals = function equals() {
		if (arguments.length === 1) {
			var y = arguments[0];
			return this._hi === y._hi && this._lo === y._lo
		}
	};
	DD.prototype.isZero = function isZero() {
		return this._hi === 0.0 && this._lo === 0.0
	};
	DD.prototype.selfSubtract = function selfSubtract() {
		if (arguments[0] instanceof DD) {
			var y = arguments[0];
			if (this.isNaN()) { return this }
			return this.selfAdd(-y._hi, -y._lo)
		} else if (typeof arguments[0] === 'number') {
			var y$1 = arguments[0];
			if (this.isNaN()) { return this }
			return this.selfAdd(-y$1, 0.0)
		}
	};
	DD.prototype.getSpecialNumberString = function getSpecialNumberString() {
		if (this.isZero()) { return '0.0' }
		if (this.isNaN()) { return 'NaN ' }
		return null
	};
	DD.prototype.min = function min(x) {
		if (this.le(x)) {
			return this
		} else {
			return x
		}
	};
	DD.prototype.selfDivide = function selfDivide() {
		if (arguments.length === 1) {
			if (arguments[0] instanceof DD) {
				var y = arguments[0];
				return this.selfDivide(y._hi, y._lo)
			} else if (typeof arguments[0] === 'number') {
				var y$1 = arguments[0];
				return this.selfDivide(y$1, 0.0)
			}
		} else if (arguments.length === 2) {
			var yhi = arguments[0];
			var ylo = arguments[1];
			var hc = null;
			var tc = null;
			var hy = null;
			var ty = null;
			var C = null;
			var c = null;
			var U = null;
			var u = null;
			C = this._hi / yhi;
			c = DD.SPLIT * C;
			hc = c - C;
			u = DD.SPLIT * yhi;
			hc = c - hc;
			tc = C - hc;
			hy = u - yhi;
			U = C * yhi;
			hy = u - hy;
			ty = yhi - hy;
			u = hc * hy - U + hc * ty + tc * hy + tc * ty;
			c = (this._hi - U - u + this._lo - C * ylo) / yhi;
			u = C + c;
			this._hi = u;
			this._lo = C - u + c;
			return this
		}
	};
	DD.prototype.dump = function dump() {
		return 'DD<' + this._hi + ', ' + this._lo + '>'
	};
	DD.prototype.divide = function divide() {
		if (arguments[0] instanceof DD) {
			var y = arguments[0];
			var hc = null;
			var tc = null;
			var hy = null;
			var ty = null;
			var C = null;
			var c = null;
			var U = null;
			var u = null;
			C = this._hi / y._hi;
			c = DD.SPLIT * C;
			hc = c - C;
			u = DD.SPLIT * y._hi;
			hc = c - hc;
			tc = C - hc;
			hy = u - y._hi;
			U = C * y._hi;
			hy = u - hy;
			ty = y._hi - hy;
			u = hc * hy - U + hc * ty + tc * hy + tc * ty;
			c = (this._hi - U - u + this._lo - C * y._lo) / y._hi;
			u = C + c;
			var zhi = u;
			var zlo = C - u + c;
			return new DD(zhi, zlo)
		} else if (typeof arguments[0] === 'number') {
			var y$1 = arguments[0];
			if (Double.isNaN(y$1)) { return DD.createNaN() }
			return DD.copy(this).selfDivide(y$1, 0.0)
		}
	};
	DD.prototype.ge = function ge(y) {
		return (this._hi > y._hi || this._hi === y._hi) && this._lo >= y._lo
	};
	DD.prototype.pow = function pow(exp) {
		if (exp === 0.0) { return DD.valueOf(1.0) }
		var r = new DD(this);
		var s = DD.valueOf(1.0);
		var n = Math.abs(exp);
		if (n > 1) {
			while (n > 0) {
				if (n % 2 === 1) {
					s.selfMultiply(r);
				}
				n /= 2;
				if (n > 0) { r = r.sqr(); }
			}
		} else {
			s = r;
		}
		if (exp < 0) { return s.reciprocal() }
		return s
	};
	DD.prototype.ceil = function ceil() {
		if (this.isNaN()) { return DD.NaN }
		var fhi = Math.ceil(this._hi);
		var flo = 0.0;
		if (fhi === this._hi) {
			flo = Math.ceil(this._lo);
		}
		return new DD(fhi, flo)
	};
	DD.prototype.compareTo = function compareTo(o) {
		var other = o;
		if (this._hi < other._hi) { return -1 }
		if (this._hi > other._hi) { return 1 }
		if (this._lo < other._lo) { return -1 }
		if (this._lo > other._lo) { return 1 }
		return 0
	};
	DD.prototype.rint = function rint() {
		if (this.isNaN()) { return this }
		var plus5 = this.add(0.5);
		return plus5.floor()
	};
	DD.prototype.setValue = function setValue() {
		if (arguments[0] instanceof DD) {
			var value = arguments[0];
			this.init(value);
			return this
		} else if (typeof arguments[0] === 'number') {
			var value$1 = arguments[0];
			this.init(value$1);
			return this
		}
	};
	DD.prototype.max = function max(x) {
		if (this.ge(x)) {
			return this
		} else {
			return x
		}
	};
	DD.prototype.sqrt = function sqrt() {
		if (this.isZero()) { return DD.valueOf(0.0) }
		if (this.isNegative()) {
			return DD.NaN
		}
		var x = 1.0 / Math.sqrt(this._hi);
		var ax = this._hi * x;
		var axdd = DD.valueOf(ax);
		var diffSq = this.subtract(axdd.sqr());
		var d2 = diffSq._hi * (x * 0.5);
		return axdd.add(d2)
	};
	DD.prototype.selfAdd = function selfAdd() {
		if (arguments.length === 1) {
			if (arguments[0] instanceof DD) {
				var y = arguments[0];
				return this.selfAdd(y._hi, y._lo)
			} else if (typeof arguments[0] === 'number') {
				var y$1 = arguments[0];
				var H = null;
				var h = null;
				var S = null;
				var s = null;
				var e = null;
				var f = null;
				S = this._hi + y$1;
				e = S - this._hi;
				s = S - e;
				s = y$1 - e + (this._hi - s);
				f = s + this._lo;
				H = S + f;
				h = f + (S - H);
				this._hi = H + h;
				this._lo = h + (H - this._hi);
				return this
			}
		} else if (arguments.length === 2) {
			var yhi = arguments[0];
			var ylo = arguments[1];
			var H$1 = null;
			var h$1 = null;
			var T = null;
			var t = null;
			var S$1 = null;
			var s$1 = null;
			var e$1 = null;
			var f$1 = null;
			S$1 = this._hi + yhi;
			T = this._lo + ylo;
			e$1 = S$1 - this._hi;
			f$1 = T - this._lo;
			s$1 = S$1 - e$1;
			t = T - f$1;
			s$1 = yhi - e$1 + (this._hi - s$1);
			t = ylo - f$1 + (this._lo - t);
			e$1 = s$1 + T;
			H$1 = S$1 + e$1;
			h$1 = e$1 + (S$1 - H$1);
			e$1 = t + h$1;
			var zhi = H$1 + e$1;
			var zlo = e$1 + (H$1 - zhi);
			this._hi = zhi;
			this._lo = zlo;
			return this
		}
	};
	DD.prototype.selfMultiply = function selfMultiply() {
		if (arguments.length === 1) {
			if (arguments[0] instanceof DD) {
				var y = arguments[0];
				return this.selfMultiply(y._hi, y._lo)
			} else if (typeof arguments[0] === 'number') {
				var y$1 = arguments[0];
				return this.selfMultiply(y$1, 0.0)
			}
		} else if (arguments.length === 2) {
			var yhi = arguments[0];
			var ylo = arguments[1];
			var hx = null;
			var tx = null;
			var hy = null;
			var ty = null;
			var C = null;
			var c = null;
			C = DD.SPLIT * this._hi;
			hx = C - this._hi;
			c = DD.SPLIT * yhi;
			hx = C - hx;
			tx = this._hi - hx;
			hy = c - yhi;
			C = this._hi * yhi;
			hy = c - hy;
			ty = yhi - hy;
			c = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi);
			var zhi = C + c;
			hx = C - zhi;
			var zlo = c + hx;
			this._hi = zhi;
			this._lo = zlo;
			return this
		}
	};
	DD.prototype.selfSqr = function selfSqr() {
		return this.selfMultiply(this)
	};
	DD.prototype.floor = function floor() {
		if (this.isNaN()) { return DD.NaN }
		var fhi = Math.floor(this._hi);
		var flo = 0.0;
		if (fhi === this._hi) {
			flo = Math.floor(this._lo);
		}
		return new DD(fhi, flo)
	};
	DD.prototype.negate = function negate() {
		if (this.isNaN()) { return this }
		return new DD(-this._hi, -this._lo)
	};
	DD.prototype.clone = function clone() {
		// try {
		// return null
		// } catch (ex) {
		// if (ex instanceof CloneNotSupportedException) {
		//   return null
		// } else throw ex
		// } finally {}
	};
	DD.prototype.multiply = function multiply() {
		if (arguments[0] instanceof DD) {
			var y = arguments[0];
			if (y.isNaN()) { return DD.createNaN() }
			return DD.copy(this).selfMultiply(y)
		} else if (typeof arguments[0] === 'number') {
			var y$1 = arguments[0];
			if (Double.isNaN(y$1)) { return DD.createNaN() }
			return DD.copy(this).selfMultiply(y$1, 0.0)
		}
	};
	DD.prototype.isNaN = function isNaN() {
		return Double.isNaN(this._hi)
	};
	DD.prototype.intValue = function intValue() {
		return Math.trunc(this._hi)
	};
	DD.prototype.toString = function toString() {
		var mag = DD.magnitude(this._hi);
		if (mag >= -3 && mag <= 20) { return this.toStandardNotation() }
		return this.toSciNotation()
	};
	DD.prototype.toStandardNotation = function toStandardNotation() {
		var specialStr = this.getSpecialNumberString();
		if (specialStr !== null) { return specialStr }
		var magnitude = new Array(1).fill(null);
		var sigDigits = this.extractSignificantDigits(true, magnitude);
		var decimalPointPos = magnitude[0] + 1;
		var num = sigDigits;
		if (sigDigits.charAt(0) === '.') {
			num = '0' + sigDigits;
		} else if (decimalPointPos < 0) {
			num = '0.' + DD.stringOfChar('0', -decimalPointPos) + sigDigits;
		} else if (sigDigits.indexOf('.') === -1) {
			var numZeroes = decimalPointPos - sigDigits.length;
			var zeroes = DD.stringOfChar('0', numZeroes);
			num = sigDigits + zeroes + '.0';
		}
		if (this.isNegative()) { return '-' + num }
		return num
	};
	DD.prototype.reciprocal = function reciprocal() {
		var hc = null;
		var tc = null;
		var hy = null;
		var ty = null;
		var C = null;
		var c = null;
		var U = null;
		var u = null;
		C = 1.0 / this._hi;
		c = DD.SPLIT * C;
		hc = c - C;
		u = DD.SPLIT * this._hi;
		hc = c - hc;
		tc = C - hc;
		hy = u - this._hi;
		U = C * this._hi;
		hy = u - hy;
		ty = this._hi - hy;
		u = hc * hy - U + hc * ty + tc * hy + tc * ty;
		c = (1.0 - U - u - C * this._lo) / this._hi;
		var zhi = C + c;
		var zlo = C - zhi + c;
		return new DD(zhi, zlo)
	};
	DD.prototype.toSciNotation = function toSciNotation() {
		if (this.isZero()) { return DD.SCI_NOT_ZERO }
		var specialStr = this.getSpecialNumberString();
		if (specialStr !== null) { return specialStr }
		var magnitude = new Array(1).fill(null);
		var digits = this.extractSignificantDigits(false, magnitude);
		var expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude[0];
		if (digits.charAt(0) === '0') {
			throw new Error('Found leading zero: ' + digits)
		}
		var trailingDigits = '';
		if (digits.length > 1) { trailingDigits = digits.substring(1); }
		var digitsWithDecimal = digits.charAt(0) + '.' + trailingDigits;
		if (this.isNegative()) { return '-' + digitsWithDecimal + expStr }
		return digitsWithDecimal + expStr
	};
	DD.prototype.abs = function abs() {
		if (this.isNaN()) { return DD.NaN }
		if (this.isNegative()) { return this.negate() }
		return new DD(this)
	};
	DD.prototype.isPositive = function isPositive() {
		return (this._hi > 0.0 || this._hi === 0.0) && this._lo > 0.0
	};
	DD.prototype.lt = function lt(y) {
		return (this._hi < y._hi || this._hi === y._hi) && this._lo < y._lo
	};
	DD.prototype.add = function add() {
		if (arguments[0] instanceof DD) {
			var y = arguments[0];
			return DD.copy(this).selfAdd(y)
		} else if (typeof arguments[0] === 'number') {
			var y$1 = arguments[0];
			return DD.copy(this).selfAdd(y$1)
		}
	};
	DD.prototype.init = function init() {
		if (arguments.length === 1) {
			if (typeof arguments[0] === 'number') {
				var x = arguments[0];
				this._hi = x;
				this._lo = 0.0;
			} else if (arguments[0] instanceof DD) {
				var dd = arguments[0];
				this._hi = dd._hi;
				this._lo = dd._lo;
			}
		} else if (arguments.length === 2) {
			var hi = arguments[0];
			var lo = arguments[1];
			this._hi = hi;
			this._lo = lo;
		}
	};
	DD.prototype.gt = function gt(y) {
		return (this._hi > y._hi || this._hi === y._hi) && this._lo > y._lo
	};
	DD.prototype.isNegative = function isNegative() {
		return (this._hi < 0.0 || this._hi === 0.0) && this._lo < 0.0
	};
	DD.prototype.trunc = function trunc() {
		if (this.isNaN()) { return DD.NaN }
		if (this.isPositive()) { return this.floor(); } else { return this.ceil() }
	};
	DD.prototype.signum = function signum() {
		if (this._hi > 0) { return 1 }
		if (this._hi < 0) { return -1 }
		if (this._lo > 0) { return 1 }
		if (this._lo < 0) { return -1 }
		return 0
	};
	DD.prototype.interfaces_ = function interfaces_() {
		return [Serializable, Comparable, Clonable]
	};
	DD.prototype.getClass = function getClass() {
		return DD
	};
	DD.sqr = function sqr(x) {
		return DD.valueOf(x).selfMultiply(x)
	};
	DD.valueOf = function valueOf() {
		if (typeof arguments[0] === 'string') {
			var str = arguments[0];
			return DD.parse(str)
		} else if (typeof arguments[0] === 'number') {
			var x = arguments[0];
			return new DD(x)
		}
	};
	DD.sqrt = function sqrt(x) {
		return DD.valueOf(x).sqrt()
	};
	DD.parse = function parse(str) {
		var i = 0;
		var strlen = str.length;
		while (Character.isWhitespace(str.charAt(i))) { i++; }
		var isNegative = false;
		if (i < strlen) {
			var signCh = str.charAt(i);
			if (signCh === '-' || signCh === '+') {
				i++;
				if (signCh === '-') { isNegative = true; }
			}
		}
		var val = new DD();
		var numDigits = 0;
		var numBeforeDec = 0;
		var exp = 0;
		while (true) {
			if (i >= strlen) { break }
			var ch = str.charAt(i);
			i++;
			if (Character.isDigit(ch)) {
				var d = ch - '0';
				val.selfMultiply(DD.TEN);
				val.selfAdd(d);
				numDigits++;
				continue
			}
			if (ch === '.') {
				numBeforeDec = numDigits;
				continue
			}
			if (ch === 'e' || ch === 'E') {
				var expStr = str.substring(i);
				try {
					exp = Integer.parseInt(expStr);
				} catch (ex) {
					if (ex instanceof Error) {
						throw new Error('Invalid exponent ' + expStr + ' in string ' + str)
					} else { throw ex }
				} finally { }
				break
			}
			throw new Error("Unexpected character '" + ch + "' at position " + i + ' in string ' + str)
		}
		var val2 = val;
		var numDecPlaces = numDigits - numBeforeDec - exp;
		if (numDecPlaces === 0) {
			val2 = val;
		} else if (numDecPlaces > 0) {
			var scale = DD.TEN.pow(numDecPlaces);
			val2 = val.divide(scale);
		} else if (numDecPlaces < 0) {
			var scale$1 = DD.TEN.pow(-numDecPlaces);
			val2 = val.multiply(scale$1);
		}
		if (isNegative) {
			return val2.negate()
		}
		return val2
	};
	DD.createNaN = function createNaN() {
		return new DD(Double.NaN, Double.NaN)
	};
	DD.copy = function copy(dd) {
		return new DD(dd)
	};
	DD.magnitude = function magnitude(x) {
		var xAbs = Math.abs(x);
		var xLog10 = Math.log(xAbs) / Math.log(10);
		var xMag = Math.trunc(Math.floor(xLog10));
		var xApprox = Math.pow(10, xMag);
		if (xApprox * 10 <= xAbs) { xMag += 1; }
		return xMag
	};
	DD.stringOfChar = function stringOfChar(ch, len) {
		var buf = new StringBuffer();
		for (var i = 0; i < len; i++) {
			buf.append(ch);
		}
		return buf.toString()
	};
	staticAccessors$7.PI.get = function () { return new DD(3.141592653589793116e+00, 1.224646799147353207e-16) };
	staticAccessors$7.TWO_PI.get = function () { return new DD(6.283185307179586232e+00, 2.449293598294706414e-16) };
	staticAccessors$7.PI_2.get = function () { return new DD(1.570796326794896558e+00, 6.123233995736766036e-17) };
	staticAccessors$7.E.get = function () { return new DD(2.718281828459045091e+00, 1.445646891729250158e-16) };
	staticAccessors$7.NaN.get = function () { return new DD(Double.NaN, Double.NaN) };
	staticAccessors$7.EPS.get = function () { return 1.23259516440783e-32 };
	staticAccessors$7.SPLIT.get = function () { return 134217729.0 };
	staticAccessors$7.MAX_PRINT_DIGITS.get = function () { return 32 };
	staticAccessors$7.TEN.get = function () { return DD.valueOf(10.0) };
	staticAccessors$7.ONE.get = function () { return DD.valueOf(1.0) };
	staticAccessors$7.SCI_NOT_EXPONENT_CHAR.get = function () { return 'E' };
	staticAccessors$7.SCI_NOT_ZERO.get = function () { return '0.0E0' };

	Object.defineProperties(DD, staticAccessors$7);

	var CGAlgorithmsDD = function CGAlgorithmsDD() { };

	var staticAccessors$6 = { DP_SAFE_EPSILON: { configurable: true } };

	CGAlgorithmsDD.prototype.interfaces_ = function interfaces_() {
		return []
	};
	CGAlgorithmsDD.prototype.getClass = function getClass() {
		return CGAlgorithmsDD
	};
	CGAlgorithmsDD.orientationIndex = function orientationIndex(p1, p2, q) {
		var index = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);
		if (index <= 1) { return index }
		var dx1 = DD.valueOf(p2.x).selfAdd(-p1.x);
		var dy1 = DD.valueOf(p2.y).selfAdd(-p1.y);
		var dx2 = DD.valueOf(q.x).selfAdd(-p2.x);
		var dy2 = DD.valueOf(q.y).selfAdd(-p2.y);
		return dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum()
	};
	CGAlgorithmsDD.signOfDet2x2 = function signOfDet2x2(x1, y1, x2, y2) {
		var det = x1.multiply(y2).selfSubtract(y1.multiply(x2));
		return det.signum()
	};
	CGAlgorithmsDD.intersection = function intersection(p1, p2, q1, q2) {
		var denom1 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p2.x).selfSubtract(p1.x));
		var denom2 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p2.y).selfSubtract(p1.y));
		var denom = denom1.subtract(denom2);
		var numx1 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));
		var numx2 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));
		var numx = numx1.subtract(numx2);
		var fracP = numx.selfDivide(denom).doubleValue();
		var x = DD.valueOf(p1.x).selfAdd(DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(fracP)).doubleValue();
		var numy1 = DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));
		var numy2 = DD.valueOf(p2.y).selfSubtract(p1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));
		var numy = numy1.subtract(numy2);
		var fracQ = numy.selfDivide(denom).doubleValue();
		var y = DD.valueOf(q1.y).selfAdd(DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(fracQ)).doubleValue();
		return new Coordinate(x, y)
	};
	CGAlgorithmsDD.orientationIndexFilter = function orientationIndexFilter(pa, pb, pc) {
		var detsum = null;
		var detleft = (pa.x - pc.x) * (pb.y - pc.y);
		var detright = (pa.y - pc.y) * (pb.x - pc.x);
		var det = detleft - detright;
		if (detleft > 0.0) {
			if (detright <= 0.0) {
				return CGAlgorithmsDD.signum(det)
			} else {
				detsum = detleft + detright;
			}
		} else if (detleft < 0.0) {
			if (detright >= 0.0) {
				return CGAlgorithmsDD.signum(det)
			} else {
				detsum = -detleft - detright;
			}
		} else {
			return CGAlgorithmsDD.signum(det)
		}
		var errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;
		if (det >= errbound || -det >= errbound) {
			return CGAlgorithmsDD.signum(det)
		}
		return 2
	};
	CGAlgorithmsDD.signum = function signum(x) {
		if (x > 0) { return 1 }
		if (x < 0) { return -1 }
		return 0
	};
	staticAccessors$6.DP_SAFE_EPSILON.get = function () { return 1e-15 };

	Object.defineProperties(CGAlgorithmsDD, staticAccessors$6);

	var CoordinateSequence = function CoordinateSequence() { };

	var staticAccessors$8 = { X: { configurable: true }, Y: { configurable: true }, Z: { configurable: true }, M: { configurable: true } };

	staticAccessors$8.X.get = function () { return 0 };
	staticAccessors$8.Y.get = function () { return 1 };
	staticAccessors$8.Z.get = function () { return 2 };
	staticAccessors$8.M.get = function () { return 3 };
	CoordinateSequence.prototype.setOrdinate = function setOrdinate(index, ordinateIndex, value) { };
	CoordinateSequence.prototype.size = function size() { };
	CoordinateSequence.prototype.getOrdinate = function getOrdinate(index, ordinateIndex) { };
	CoordinateSequence.prototype.getCoordinate = function getCoordinate() { };
	CoordinateSequence.prototype.getCoordinateCopy = function getCoordinateCopy(i) { };
	CoordinateSequence.prototype.getDimension = function getDimension() { };
	CoordinateSequence.prototype.getX = function getX(index) { };
	CoordinateSequence.prototype.clone = function clone() { };
	CoordinateSequence.prototype.expandEnvelope = function expandEnvelope(env) { };
	CoordinateSequence.prototype.copy = function copy() { };
	CoordinateSequence.prototype.getY = function getY(index) { };
	CoordinateSequence.prototype.toCoordinateArray = function toCoordinateArray() { };
	CoordinateSequence.prototype.interfaces_ = function interfaces_() {
		return [Clonable]
	};
	CoordinateSequence.prototype.getClass = function getClass() {
		return CoordinateSequence
	};

	Object.defineProperties(CoordinateSequence, staticAccessors$8);

	var Exception = function Exception() { };

	var NotRepresentableException = (function (Exception$$1) {
		function NotRepresentableException() {
			Exception$$1.call(this, 'Projective point not representable on the Cartesian plane.');
		}

		if (Exception$$1) NotRepresentableException.__proto__ = Exception$$1;
		NotRepresentableException.prototype = Object.create(Exception$$1 && Exception$$1.prototype);
		NotRepresentableException.prototype.constructor = NotRepresentableException;
		NotRepresentableException.prototype.interfaces_ = function interfaces_() {
			return []
		};
		NotRepresentableException.prototype.getClass = function getClass() {
			return NotRepresentableException
		};

		return NotRepresentableException;
	}(Exception));

	var System = function System() { };

	System.arraycopy = function arraycopy(src, srcPos, dest, destPos, len) {
		var c = 0;
		for (var i = srcPos; i < srcPos + len; i++) {
			dest[destPos + c] = src[i];
			c++;
		}
	};

	System.getProperty = function getProperty(name) {
		return {
			'line.separator': '\n'
		}[name]
	};

	var HCoordinate = function HCoordinate() {
		this.x = null;
		this.y = null;
		this.w = null;
		if (arguments.length === 0) {
			this.x = 0.0;
			this.y = 0.0;
			this.w = 1.0;
		} else if (arguments.length === 1) {
			var p = arguments[0];
			this.x = p.x;
			this.y = p.y;
			this.w = 1.0;
		} else if (arguments.length === 2) {
			if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
				var _x = arguments[0];
				var _y = arguments[1];
				this.x = _x;
				this.y = _y;
				this.w = 1.0;
			} else if (arguments[0] instanceof HCoordinate && arguments[1] instanceof HCoordinate) {
				var p1 = arguments[0];
				var p2 = arguments[1];
				this.x = p1.y * p2.w - p2.y * p1.w;
				this.y = p2.x * p1.w - p1.x * p2.w;
				this.w = p1.x * p2.y - p2.x * p1.y;
			} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
				var p1$1 = arguments[0];
				var p2$1 = arguments[1];
				this.x = p1$1.y - p2$1.y;
				this.y = p2$1.x - p1$1.x;
				this.w = p1$1.x * p2$1.y - p2$1.x * p1$1.y;
			}
		} else if (arguments.length === 3) {
			var _x$1 = arguments[0];
			var _y$1 = arguments[1];
			var _w = arguments[2];
			this.x = _x$1;
			this.y = _y$1;
			this.w = _w;
		} else if (arguments.length === 4) {
			var p1$2 = arguments[0];
			var p2$2 = arguments[1];
			var q1 = arguments[2];
			var q2 = arguments[3];
			var px = p1$2.y - p2$2.y;
			var py = p2$2.x - p1$2.x;
			var pw = p1$2.x * p2$2.y - p2$2.x * p1$2.y;
			var qx = q1.y - q2.y;
			var qy = q2.x - q1.x;
			var qw = q1.x * q2.y - q2.x * q1.y;
			this.x = py * qw - qy * pw;
			this.y = qx * pw - px * qw;
			this.w = px * qy - qx * py;
		}
	};
	HCoordinate.prototype.getY = function getY() {
		var a = this.y / this.w;
		if (Double.isNaN(a) || Double.isInfinite(a)) {
			throw new NotRepresentableException()
		}
		return a
	};
	HCoordinate.prototype.getX = function getX() {
		var a = this.x / this.w;
		if (Double.isNaN(a) || Double.isInfinite(a)) {
			throw new NotRepresentableException()
		}
		return a
	};
	HCoordinate.prototype.getCoordinate = function getCoordinate() {
		var p = new Coordinate();
		p.x = this.getX();
		p.y = this.getY();
		return p
	};
	HCoordinate.prototype.interfaces_ = function interfaces_() {
		return []
	};
	HCoordinate.prototype.getClass = function getClass() {
		return HCoordinate
	};
	HCoordinate.intersection = function intersection(p1, p2, q1, q2) {
		var px = p1.y - p2.y;
		var py = p2.x - p1.x;
		var pw = p1.x * p2.y - p2.x * p1.y;
		var qx = q1.y - q2.y;
		var qy = q2.x - q1.x;
		var qw = q1.x * q2.y - q2.x * q1.y;
		var x = py * qw - qy * pw;
		var y = qx * pw - px * qw;
		var w = px * qy - qx * py;
		var xInt = x / w;
		var yInt = y / w;
		if (Double.isNaN(xInt) || (Double.isInfinite(xInt) || Double.isNaN(yInt)) || Double.isInfinite(yInt)) {
			throw new NotRepresentableException()
		}
		return new Coordinate(xInt, yInt)
	};

	var Envelope = function Envelope() {
		this._minx = null;
		this._maxx = null;
		this._miny = null;
		this._maxy = null;
		if (arguments.length === 0) {
			this.init();
		} else if (arguments.length === 1) {
			if (arguments[0] instanceof Coordinate) {
				var p = arguments[0];
				this.init(p.x, p.x, p.y, p.y);
			} else if (arguments[0] instanceof Envelope) {
				var env = arguments[0];
				this.init(env);
			}
		} else if (arguments.length === 2) {
			var p1 = arguments[0];
			var p2 = arguments[1];
			this.init(p1.x, p2.x, p1.y, p2.y);
		} else if (arguments.length === 4) {
			var x1 = arguments[0];
			var x2 = arguments[1];
			var y1 = arguments[2];
			var y2 = arguments[3];
			this.init(x1, x2, y1, y2);
		}
	};

	var staticAccessors$9 = { serialVersionUID: { configurable: true } };
	Envelope.prototype.getArea = function getArea() {
		return this.getWidth() * this.getHeight()
	};
	Envelope.prototype.equals = function equals(other) {
		if (!(other instanceof Envelope)) {
			return false
		}
		var otherEnvelope = other;
		if (this.isNull()) {
			return otherEnvelope.isNull()
		}
		return this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY()
	};
	Envelope.prototype.intersection = function intersection(env) {
		if (this.isNull() || env.isNull() || !this.intersects(env)) { return new Envelope() }
		var intMinX = this._minx > env._minx ? this._minx : env._minx;
		var intMinY = this._miny > env._miny ? this._miny : env._miny;
		var intMaxX = this._maxx < env._maxx ? this._maxx : env._maxx;
		var intMaxY = this._maxy < env._maxy ? this._maxy : env._maxy;
		return new Envelope(intMinX, intMaxX, intMinY, intMaxY)
	};
	Envelope.prototype.isNull = function isNull() {
		return this._maxx < this._minx
	};
	Envelope.prototype.getMaxX = function getMaxX() {
		return this._maxx
	};
	Envelope.prototype.covers = function covers() {
		if (arguments.length === 1) {
			if (arguments[0] instanceof Coordinate) {
				var p = arguments[0];
				return this.covers(p.x, p.y)
			} else if (arguments[0] instanceof Envelope) {
				var other = arguments[0];
				if (this.isNull() || other.isNull()) {
					return false
				}
				return other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy
			}
		} else if (arguments.length === 2) {
			var x = arguments[0];
			var y = arguments[1];
			if (this.isNull()) { return false }
			return x >= this._minx && x <= this._maxx && y >= this._miny && y <= this._maxy
		}
	};
	Envelope.prototype.intersects = function intersects() {
		if (arguments.length === 1) {
			if (arguments[0] instanceof Envelope) {
				var other = arguments[0];
				if (this.isNull() || other.isNull()) {
					return false
				}
				return !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny)
			} else if (arguments[0] instanceof Coordinate) {
				var p = arguments[0];
				return this.intersects(p.x, p.y)
			}
		} else if (arguments.length === 2) {
			var x = arguments[0];
			var y = arguments[1];
			if (this.isNull()) { return false }
			return !(x > this._maxx || x < this._minx || y > this._maxy || y < this._miny)
		}
	};
	Envelope.prototype.getMinY = function getMinY() {
		return this._miny
	};
	Envelope.prototype.getMinX = function getMinX() {
		return this._minx
	};
	Envelope.prototype.expandToInclude = function expandToInclude() {
		if (arguments.length === 1) {
			if (arguments[0] instanceof Coordinate) {
				var p = arguments[0];
				this.expandToInclude(p.x, p.y);
			} else if (arguments[0] instanceof Envelope) {
				var other = arguments[0];
				if (other.isNull()) {
					return null
				}
				if (this.isNull()) {
					this._minx = other.getMinX();
					this._maxx = other.getMaxX();
					this._miny = other.getMinY();
					this._maxy = other.getMaxY();
				} else {
					if (other._minx < this._minx) {
						this._minx = other._minx;
					}
					if (other._maxx > this._maxx) {
						this._maxx = other._maxx;
					}
					if (other._miny < this._miny) {
						this._miny = other._miny;
					}
					if (other._maxy > this._maxy) {
						this._maxy = other._maxy;
					}
				}
			}
		} else if (arguments.length === 2) {
			var x = arguments[0];
			var y = arguments[1];
			if (this.isNull()) {
				this._minx = x;
				this._maxx = x;
				this._miny = y;
				this._maxy = y;
			} else {
				if (x < this._minx) {
					this._minx = x;
				}
				if (x > this._maxx) {
					this._maxx = x;
				}
				if (y < this._miny) {
					this._miny = y;
				}
				if (y > this._maxy) {
					this._maxy = y;
				}
			}
		}
	};
	Envelope.prototype.minExtent = function minExtent() {
		if (this.isNull()) { return 0.0 }
		var w = this.getWidth();
		var h = this.getHeight();
		if (w < h) { return w }
		return h
	};
	Envelope.prototype.getWidth = function getWidth() {
		if (this.isNull()) {
			return 0
		}
		return this._maxx - this._minx
	};
	Envelope.prototype.compareTo = function compareTo(o) {
		var env = o;
		if (this.isNull()) {
			if (env.isNull()) { return 0 }
			return -1
		} else {
			if (env.isNull()) { return 1 }
		}
		if (this._minx < env._minx) { return -1 }
		if (this._minx > env._minx) { return 1 }
		if (this._miny < env._miny) { return -1 }
		if (this._miny > env._miny) { return 1 }
		if (this._maxx < env._maxx) { return -1 }
		if (this._maxx > env._maxx) { return 1 }
		if (this._maxy < env._maxy) { return -1 }
		if (this._maxy > env._maxy) { return 1 }
		return 0
	};
	Envelope.prototype.translate = function translate(transX, transY) {
		if (this.isNull()) {
			return null
		}
		this.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);
	};
	Envelope.prototype.toString = function toString() {
		return 'Env[' + this._minx + ' : ' + this._maxx + ', ' + this._miny + ' : ' + this._maxy + ']'
	};
	Envelope.prototype.setToNull = function setToNull() {
		this._minx = 0;
		this._maxx = -1;
		this._miny = 0;
		this._maxy = -1;
	};
	Envelope.prototype.getHeight = function getHeight() {
		if (this.isNull()) {
			return 0
		}
		return this._maxy - this._miny
	};
	Envelope.prototype.maxExtent = function maxExtent() {
		if (this.isNull()) { return 0.0 }
		var w = this.getWidth();
		var h = this.getHeight();
		if (w > h) { return w }
		return h
	};
	Envelope.prototype.expandBy = function expandBy() {
		if (arguments.length === 1) {
			var distance = arguments[0];
			this.expandBy(distance, distance);
		} else if (arguments.length === 2) {
			var deltaX = arguments[0];
			var deltaY = arguments[1];
			if (this.isNull()) { return null }
			this._minx -= deltaX;
			this._maxx += deltaX;
			this._miny -= deltaY;
			this._maxy += deltaY;
			if (this._minx > this._maxx || this._miny > this._maxy) { this.setToNull(); }
		}
	};
	Envelope.prototype.contains = function contains() {
		if (arguments.length === 1) {
			if (arguments[0] instanceof Envelope) {
				var other = arguments[0];
				return this.covers(other)
			} else if (arguments[0] instanceof Coordinate) {
				var p = arguments[0];
				return this.covers(p)
			}
		} else if (arguments.length === 2) {
			var x = arguments[0];
			var y = arguments[1];
			return this.covers(x, y)
		}
	};
	Envelope.prototype.centre = function centre() {
		if (this.isNull()) { return null }
		return new Coordinate((this.getMinX() + this.getMaxX()) / 2.0, (this.getMinY() + this.getMaxY()) / 2.0)
	};
	Envelope.prototype.init = function init() {
		if (arguments.length === 0) {
			this.setToNull();
		} else if (arguments.length === 1) {
			if (arguments[0] instanceof Coordinate) {
				var p = arguments[0];
				this.init(p.x, p.x, p.y, p.y);
			} else if (arguments[0] instanceof Envelope) {
				var env = arguments[0];
				this._minx = env._minx;
				this._maxx = env._maxx;
				this._miny = env._miny;
				this._maxy = env._maxy;
			}
		} else if (arguments.length === 2) {
			var p1 = arguments[0];
			var p2 = arguments[1];
			this.init(p1.x, p2.x, p1.y, p2.y);
		} else if (arguments.length === 4) {
			var x1 = arguments[0];
			var x2 = arguments[1];
			var y1 = arguments[2];
			var y2 = arguments[3];
			if (x1 < x2) {
				this._minx = x1;
				this._maxx = x2;
			} else {
				this._minx = x2;
				this._maxx = x1;
			}
			if (y1 < y2) {
				this._miny = y1;
				this._maxy = y2;
			} else {
				this._miny = y2;
				this._maxy = y1;
			}
		}
	};
	Envelope.prototype.getMaxY = function getMaxY() {
		return this._maxy
	};
	Envelope.prototype.distance = function distance(env) {
		if (this.intersects(env)) { return 0 }
		var dx = 0.0;
		if (this._maxx < env._minx) { dx = env._minx - this._maxx; } else if (this._minx > env._maxx) { dx = this._minx - env._maxx; }
		var dy = 0.0;
		if (this._maxy < env._miny) { dy = env._miny - this._maxy; } else if (this._miny > env._maxy) { dy = this._miny - env._maxy; }
		if (dx === 0.0) { return dy }
		if (dy === 0.0) { return dx }
		return Math.sqrt(dx * dx + dy * dy)
	};
	Envelope.prototype.hashCode = function hashCode() {
		var result = 17;
		result = 37 * result + Coordinate.hashCode(this._minx);
		result = 37 * result + Coordinate.hashCode(this._maxx);
		result = 37 * result + Coordinate.hashCode(this._miny);
		result = 37 * result + Coordinate.hashCode(this._maxy);
		return result
	};
	Envelope.prototype.interfaces_ = function interfaces_() {
		return [Comparable, Serializable]
	};
	Envelope.prototype.getClass = function getClass() {
		return Envelope
	};
	Envelope.intersects = function intersects() {
		if (arguments.length === 3) {
			var p1 = arguments[0];
			var p2 = arguments[1];
			var q = arguments[2];
			if (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && (q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y))) {
				return true
			}
			return false
		} else if (arguments.length === 4) {
			var p1$1 = arguments[0];
			var p2$1 = arguments[1];
			var q1 = arguments[2];
			var q2 = arguments[3];
			var minq = Math.min(q1.x, q2.x);
			var maxq = Math.max(q1.x, q2.x);
			var minp = Math.min(p1$1.x, p2$1.x);
			var maxp = Math.max(p1$1.x, p2$1.x);
			if (minp > maxq) { return false }
			if (maxp < minq) { return false }
			minq = Math.min(q1.y, q2.y);
			maxq = Math.max(q1.y, q2.y);
			minp = Math.min(p1$1.y, p2$1.y);
			maxp = Math.max(p1$1.y, p2$1.y);
			if (minp > maxq) { return false }
			if (maxp < minq) { return false }
			return true
		}
	};
	staticAccessors$9.serialVersionUID.get = function () { return 5873921885273102420 };

	Object.defineProperties(Envelope, staticAccessors$9);

	var regExes = {
		'typeStr': /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
		'emptyTypeStr': /^\s*(\w+)\s*EMPTY\s*$/,
		'spaces': /\s+/,
		'parenComma': /\)\s*,\s*\(/,
		'doubleParenComma': /\)\s*\)\s*,\s*\(\s*\(/, // can't use {2} here
		'trimParens': /^\s*\(?(.*?)\)?\s*$/
	};

	/**
	 * Class for reading and writing Well-Known Text.
	 *
	 * NOTE: Adapted from OpenLayers 2.11 implementation.
	 */

	/** Create a new parser for WKT
	 *
	 * @param {GeometryFactory} geometryFactory
	 * @return An instance of WKTParser.
	 * @constructor
	 * @private
	 */
	var WKTParser = function WKTParser(geometryFactory) {
		this.geometryFactory = geometryFactory || new GeometryFactory();
	};
	/**
	 * Deserialize a WKT string and return a geometry. Supports WKT for POINT,
	 * MULTIPOINT, LINESTRING, LINEARRING, MULTILINESTRING, POLYGON, MULTIPOLYGON,
	 * and GEOMETRYCOLLECTION.
	 *
	 * @param {String} wkt A WKT string.
	 * @return {Geometry} A geometry instance.
	 * @private
	 */
	WKTParser.prototype.read = function read(wkt) {
		var geometry, type, str;
		wkt = wkt.replace(/[\n\r]/g, ' ');
		var matches = regExes.typeStr.exec(wkt);
		if (wkt.search('EMPTY') !== -1) {
			matches = regExes.emptyTypeStr.exec(wkt);
			matches[2] = undefined;
		}
		if (matches) {
			type = matches[1].toLowerCase();
			str = matches[2];
			if (parse$1[type]) {
				geometry = parse$1[type].apply(this, [str]);
			}
		}

		if (geometry === undefined) { throw new Error('Could not parse WKT ' + wkt) }

		return geometry
	};

	/**
	 * Serialize a geometry into a WKT string.
	 *
	 * @param {Geometry} geometry A feature or array of features.
	 * @return {String} The WKT string representation of the input geometries.
	 * @private
	 */
	WKTParser.prototype.write = function write(geometry) {
		return this.extractGeometry(geometry)
	};

	/**
	 * Entry point to construct the WKT for a single Geometry object.
	 *
	 * @param {Geometry} geometry
	 * @return {String} A WKT string of representing the geometry.
	 * @private
	 */
	WKTParser.prototype.extractGeometry = function extractGeometry(geometry) {
		var type = geometry.getGeometryType().toLowerCase();
		if (!extract$1[type]) {
			return null
		}
		var wktType = type.toUpperCase();
		var data;
		if (geometry.isEmpty()) {
			data = wktType + ' EMPTY';
		} else {
			data = wktType + '(' + extract$1[type].apply(this, [geometry]) + ')';
		}
		return data
	};

	/**
	 * Object with properties corresponding to the geometry types. Property values
	 * are functions that do the actual data extraction.
	 * @private
	 */
	var extract$1 = {
		coordinate: function coordinate(coordinate$1) {
			return coordinate$1.x + ' ' + coordinate$1.y
		},

		/**
		 * Return a space delimited string of point coordinates.
		 *
		 * @param {Point}
		 *          point
		 * @return {String} A string of coordinates representing the point.
		 */
		point: function point(point$1) {
			return extract$1.coordinate.call(this, point$1._coordinates._coordinates[0])
		},

		/**
		 * Return a comma delimited string of point coordinates from a multipoint.
		 *
		 * @param {MultiPoint}
		 *          multipoint
		 * @return {String} A string of point coordinate strings representing the
		 *         multipoint.
		 */
		multipoint: function multipoint(multipoint$1) {
			var this$1$1 = this;

			var array = [];
			for (var i = 0, len = multipoint$1._geometries.length; i < len; ++i) {
				array.push('(' + extract$1.point.apply(this$1$1, [multipoint$1._geometries[i]]) + ')');
			}
			return array.join(',')
		},

		/**
		 * Return a comma delimited string of point coordinates from a line.
		 *
		 * @param {LineString} linestring
		 * @return {String} A string of point coordinate strings representing the linestring.
		 */
		linestring: function linestring(linestring$1) {
			var this$1$1 = this;

			var array = [];
			for (var i = 0, len = linestring$1._points._coordinates.length; i < len; ++i) {
				array.push(extract$1.coordinate.apply(this$1$1, [linestring$1._points._coordinates[i]]));
			}
			return array.join(',')
		},

		linearring: function linearring(linearring$1) {
			var this$1$1 = this;

			var array = [];
			for (var i = 0, len = linearring$1._points._coordinates.length; i < len; ++i) {
				array.push(extract$1.coordinate.apply(this$1$1, [linearring$1._points._coordinates[i]]));
			}
			return array.join(',')
		},

		/**
		 * Return a comma delimited string of linestring strings from a
		 * multilinestring.
		 *
		 * @param {MultiLineString} multilinestring
		 * @return {String} A string of of linestring strings representing the multilinestring.
		 */
		multilinestring: function multilinestring(multilinestring$1) {
			var this$1$1 = this;

			var array = [];
			for (var i = 0, len = multilinestring$1._geometries.length; i < len; ++i) {
				array.push('(' +
					extract$1.linestring.apply(this$1$1, [multilinestring$1._geometries[i]]) +
					')');
			}
			return array.join(',')
		},

		/**
		 * Return a comma delimited string of linear ring arrays from a polygon.
		 *
		 * @param {Polygon} polygon
		 * @return {String} An array of linear ring arrays representing the polygon.
		 */
		polygon: function polygon(polygon$1) {
			var this$1$1 = this;

			var array = [];
			array.push('(' + extract$1.linestring.apply(this, [polygon$1._shell]) + ')');
			for (var i = 0, len = polygon$1._holes.length; i < len; ++i) {
				array.push('(' + extract$1.linestring.apply(this$1$1, [polygon$1._holes[i]]) + ')');
			}
			return array.join(',')
		},

		/**
		 * Return an array of polygon arrays from a multipolygon.
		 *
		 * @param {MultiPolygon} multipolygon
		 * @return {String} An array of polygon arrays representing the multipolygon.
		 */
		multipolygon: function multipolygon(multipolygon$1) {
			var this$1$1 = this;

			var array = [];
			for (var i = 0, len = multipolygon$1._geometries.length; i < len; ++i) {
				array.push('(' + extract$1.polygon.apply(this$1$1, [multipolygon$1._geometries[i]]) + ')');
			}
			return array.join(',')
		},

		/**
		 * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an
		 * geometrycollection.
		 *
		 * @param {GeometryCollection} collection
		 * @return {String} internal WKT representation of the collection.
		 */
		geometrycollection: function geometrycollection(collection) {
			var this$1$1 = this;

			var array = [];
			for (var i = 0, len = collection._geometries.length; i < len; ++i) {
				array.push(this$1$1.extractGeometry(collection._geometries[i]));
			}
			return array.join(',')
		}
	};

	/**
	 * Object with properties corresponding to the geometry types. Property values
	 * are functions that do the actual parsing.
	 * @private
	 */
	var parse$1 = {
		/**
		 * Return point geometry given a point WKT fragment.
		 *
		 * @param {String} str A WKT fragment representing the point.
		 * @return {Point} A point geometry.
		 * @private
		 */
		point: function point(str) {
			if (str === undefined) {
				return this.geometryFactory.createPoint()
			}

			var coords = str.trim().split(regExes.spaces);
			return this.geometryFactory.createPoint(new Coordinate(Number.parseFloat(coords[0]),
				Number.parseFloat(coords[1])))
		},

		/**
		 * Return a multipoint geometry given a multipoint WKT fragment.
		 *
		 * @param {String} str A WKT fragment representing the multipoint.
		 * @return {Point} A multipoint feature.
		 * @private
		 */
		multipoint: function multipoint(str) {
			var this$1$1 = this;

			if (str === undefined) {
				return this.geometryFactory.createMultiPoint()
			}

			var point;
			var points = str.trim().split(',');
			var components = [];
			for (var i = 0, len = points.length; i < len; ++i) {
				point = points[i].replace(regExes.trimParens, '$1');
				components.push(parse$1.point.apply(this$1$1, [point]));
			}
			return this.geometryFactory.createMultiPoint(components)
		},

		/**
		 * Return a linestring geometry given a linestring WKT fragment.
		 *
		 * @param {String} str A WKT fragment representing the linestring.
		 * @return {LineString} A linestring geometry.
		 * @private
		 */
		linestring: function linestring(str) {
			if (str === undefined) {
				return this.geometryFactory.createLineString()
			}

			var points = str.trim().split(',');
			var components = [];
			var coords;
			for (var i = 0, len = points.length; i < len; ++i) {
				coords = points[i].trim().split(regExes.spaces);
				components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));
			}
			return this.geometryFactory.createLineString(components)
		},

		/**
		 * Return a linearring geometry given a linearring WKT fragment.
		 *
		 * @param {String} str A WKT fragment representing the linearring.
		 * @return {LinearRing} A linearring geometry.
		 * @private
		 */
		linearring: function linearring(str) {
			if (str === undefined) {
				return this.geometryFactory.createLinearRing()
			}

			var points = str.trim().split(',');
			var components = [];
			var coords;
			for (var i = 0, len = points.length; i < len; ++i) {
				coords = points[i].trim().split(regExes.spaces);
				components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));
			}
			return this.geometryFactory.createLinearRing(components)
		},

		/**
		 * Return a multilinestring geometry given a multilinestring WKT fragment.
		 *
		 * @param {String} str A WKT fragment representing the multilinestring.
		 * @return {MultiLineString} A multilinestring geometry.
		 * @private
		 */
		multilinestring: function multilinestring(str) {
			var this$1$1 = this;

			if (str === undefined) {
				return this.geometryFactory.createMultiLineString()
			}

			var line;
			var lines = str.trim().split(regExes.parenComma);
			var components = [];
			for (var i = 0, len = lines.length; i < len; ++i) {
				line = lines[i].replace(regExes.trimParens, '$1');
				components.push(parse$1.linestring.apply(this$1$1, [line]));
			}
			return this.geometryFactory.createMultiLineString(components)
		},

		/**
		 * Return a polygon geometry given a polygon WKT fragment.
		 *
		 * @param {String} str A WKT fragment representing the polygon.
		 * @return {Polygon} A polygon geometry.
		 * @private
		 */
		polygon: function polygon(str) {
			var this$1$1 = this;

			if (str === undefined) {
				return this.geometryFactory.createPolygon()
			}

			var ring, linestring, linearring;
			var rings = str.trim().split(regExes.parenComma);
			var shell;
			var holes = [];
			for (var i = 0, len = rings.length; i < len; ++i) {
				ring = rings[i].replace(regExes.trimParens, '$1');
				linestring = parse$1.linestring.apply(this$1$1, [ring]);
				linearring = this$1$1.geometryFactory.createLinearRing(linestring._points);
				if (i === 0) {
					shell = linearring;
				} else {
					holes.push(linearring);
				}
			}
			return this.geometryFactory.createPolygon(shell, holes)
		},

		/**
		 * Return a multipolygon geometry given a multipolygon WKT fragment.
		 *
		 * @param {String} str A WKT fragment representing the multipolygon.
		 * @return {MultiPolygon} A multipolygon geometry.
		 * @private
		 */
		multipolygon: function multipolygon(str) {
			var this$1$1 = this;

			if (str === undefined) {
				return this.geometryFactory.createMultiPolygon()
			}

			var polygon;
			var polygons = str.trim().split(regExes.doubleParenComma);
			var components = [];
			for (var i = 0, len = polygons.length; i < len; ++i) {
				polygon = polygons[i].replace(regExes.trimParens, '$1');
				components.push(parse$1.polygon.apply(this$1$1, [polygon]));
			}
			return this.geometryFactory.createMultiPolygon(components)
		},

		/**
		 * Return a geometrycollection given a geometrycollection WKT fragment.
		 *
		 * @param {String} str A WKT fragment representing the geometrycollection.
		 * @return {GeometryCollection}
		 * @private
		 */
		geometrycollection: function geometrycollection(str) {
			var this$1$1 = this;

			if (str === undefined) {
				return this.geometryFactory.createGeometryCollection()
			}

			// separate components of the collection with |
			str = str.replace(/,\s*([A-Za-z])/g, '|$1');
			var wktArray = str.trim().split('|');
			var components = [];
			for (var i = 0, len = wktArray.length; i < len; ++i) {
				components.push(this$1$1.read(wktArray[i]));
			}
			return this.geometryFactory.createGeometryCollection(components)
		}
	};

	/**
	 * Writes the Well-Known Text representation of a {@link Geometry}. The
	 * Well-Known Text format is defined in the <A
	 * HREF="http://www.opengis.org/techno/specs.htm"> OGC Simple Features
	 * Specification for SQL</A>.
	 * <p>
	 * The <code>WKTWriter</code> outputs coordinates rounded to the precision
	 * model. Only the maximum number of decimal places necessary to represent the
	 * ordinates to the required precision will be output.
	 * <p>
	 * The SFS WKT spec does not define a special tag for {@link LinearRing}s.
	 * Under the spec, rings are output as <code>LINESTRING</code>s.
	 */

	/**
	 * @param {GeometryFactory} geometryFactory
	 * @constructor
	 */
	var WKTWriter = function WKTWriter(geometryFactory) {
		this.parser = new WKTParser(geometryFactory);
	};

	/**
	 * Converts a <code>Geometry</code> to its Well-known Text representation.
	 *
	 * @param {Geometry} geometry a <code>Geometry</code> to process.
	 * @return {string} a <Geometry Tagged Text> string (see the OpenGIS Simple
	 *       Features Specification).
	 * @memberof WKTWriter
	 */
	WKTWriter.prototype.write = function write(geometry) {
		return this.parser.write(geometry)
	};
	/**
	 * Generates the WKT for a <tt>LINESTRING</tt> specified by two
	 * {@link Coordinate}s.
	 *
	 * @param p0 the first coordinate.
	 * @param p1 the second coordinate.
	 *
	 * @return the WKT.
	 * @private
	 */
	WKTWriter.toLineString = function toLineString(p0, p1) {
		if (arguments.length !== 2) {
			throw new Error('Not implemented')
		}
		return 'LINESTRING ( ' + p0.x + ' ' + p0.y + ', ' + p1.x + ' ' + p1.y + ' )'
	};

	var RuntimeException = (function (Error) {
		function RuntimeException(message) {
			Error.call(this, message);
			this.name = 'RuntimeException';
			this.message = message;
			this.stack = (new Error()).stack;
		}

		if (Error) RuntimeException.__proto__ = Error;
		RuntimeException.prototype = Object.create(Error && Error.prototype);
		RuntimeException.prototype.constructor = RuntimeException;

		return RuntimeException;
	}(Error));

	var AssertionFailedException = (function (RuntimeException$$1) {
		function AssertionFailedException() {
			RuntimeException$$1.call(this);
			if (arguments.length === 0) {
				RuntimeException$$1.call(this);
			} else if (arguments.length === 1) {
				var message = arguments[0];
				RuntimeException$$1.call(this, message);
			}
		}

		if (RuntimeException$$1) AssertionFailedException.__proto__ = RuntimeException$$1;
		AssertionFailedException.prototype = Object.create(RuntimeException$$1 && RuntimeException$$1.prototype);
		AssertionFailedException.prototype.constructor = AssertionFailedException;
		AssertionFailedException.prototype.interfaces_ = function interfaces_() {
			return []
		};
		AssertionFailedException.prototype.getClass = function getClass() {
			return AssertionFailedException
		};

		return AssertionFailedException;
	}(RuntimeException));

	var Assert = function Assert() { };

	Assert.prototype.interfaces_ = function interfaces_() {
		return []
	};
	Assert.prototype.getClass = function getClass() {
		return Assert
	};
	Assert.shouldNeverReachHere = function shouldNeverReachHere() {
		if (arguments.length === 0) {
			Assert.shouldNeverReachHere(null);
		} else if (arguments.length === 1) {
			var message = arguments[0];
			throw new AssertionFailedException('Should never reach here' + (message !== null ? ': ' + message : ''))
		}
	};
	Assert.isTrue = function isTrue() {
		var assertion;
		var message;
		if (arguments.length === 1) {
			assertion = arguments[0];
			Assert.isTrue(assertion, null);
		} else if (arguments.length === 2) {
			assertion = arguments[0];
			message = arguments[1];
			if (!assertion) {
				if (message === null) {
					throw new AssertionFailedException()
				} else {
					throw new AssertionFailedException(message)
				}
			}
		}
	};
	Assert.equals = function equals() {
		var expectedValue;
		var actualValue;
		var message;
		if (arguments.length === 2) {
			expectedValue = arguments[0];
			actualValue = arguments[1];
			Assert.equals(expectedValue, actualValue, null);
		} else if (arguments.length === 3) {
			expectedValue = arguments[0];
			actualValue = arguments[1];
			message = arguments[2];
			if (!actualValue.equals(expectedValue)) {
				throw new AssertionFailedException('Expected ' + expectedValue + ' but encountered ' + actualValue + (message !== null ? ': ' + message : ''))
			}
		}
	};

	var LineIntersector = function LineIntersector() {
		this._result = null;
		this._inputLines = Array(2).fill().map(function () { return Array(2); });
		this._intPt = new Array(2).fill(null);
		this._intLineIndex = null;
		this._isProper = null;
		this._pa = null;
		this._pb = null;
		this._precisionModel = null;
		this._intPt[0] = new Coordinate();
		this._intPt[1] = new Coordinate();
		this._pa = this._intPt[0];
		this._pb = this._intPt[1];
		this._result = 0;
	};

	var staticAccessors$10 = { DONT_INTERSECT: { configurable: true }, DO_INTERSECT: { configurable: true }, COLLINEAR: { configurable: true }, NO_INTERSECTION: { configurable: true }, POINT_INTERSECTION: { configurable: true }, COLLINEAR_INTERSECTION: { configurable: true } };
	LineIntersector.prototype.getIndexAlongSegment = function getIndexAlongSegment(segmentIndex, intIndex) {
		this.computeIntLineIndex();
		return this._intLineIndex[segmentIndex][intIndex]
	};
	LineIntersector.prototype.getTopologySummary = function getTopologySummary() {
		var catBuf = new StringBuffer();
		if (this.isEndPoint()) { catBuf.append(' endpoint'); }
		if (this._isProper) { catBuf.append(' proper'); }
		if (this.isCollinear()) { catBuf.append(' collinear'); }
		return catBuf.toString()
	};
	LineIntersector.prototype.computeIntersection = function computeIntersection(p1, p2, p3, p4) {
		this._inputLines[0][0] = p1;
		this._inputLines[0][1] = p2;
		this._inputLines[1][0] = p3;
		this._inputLines[1][1] = p4;
		this._result = this.computeIntersect(p1, p2, p3, p4);
	};
	LineIntersector.prototype.getIntersectionNum = function getIntersectionNum() {
		return this._result
	};
	LineIntersector.prototype.computeIntLineIndex = function computeIntLineIndex() {
		if (arguments.length === 0) {
			if (this._intLineIndex === null) {
				this._intLineIndex = Array(2).fill().map(function () { return Array(2); });
				this.computeIntLineIndex(0);
				this.computeIntLineIndex(1);
			}
		} else if (arguments.length === 1) {
			var segmentIndex = arguments[0];
			var dist0 = this.getEdgeDistance(segmentIndex, 0);
			var dist1 = this.getEdgeDistance(segmentIndex, 1);
			if (dist0 > dist1) {
				this._intLineIndex[segmentIndex][0] = 0;
				this._intLineIndex[segmentIndex][1] = 1;
			} else {
				this._intLineIndex[segmentIndex][0] = 1;
				this._intLineIndex[segmentIndex][1] = 0;
			}
		}
	};
	LineIntersector.prototype.isProper = function isProper() {
		return this.hasIntersection() && this._isProper
	};
	LineIntersector.prototype.setPrecisionModel = function setPrecisionModel(precisionModel) {
		this._precisionModel = precisionModel;
	};
	LineIntersector.prototype.isInteriorIntersection = function isInteriorIntersection() {
		var this$1$1 = this;

		if (arguments.length === 0) {
			if (this.isInteriorIntersection(0)) { return true }
			if (this.isInteriorIntersection(1)) { return true }
			return false
		} else if (arguments.length === 1) {
			var inputLineIndex = arguments[0];
			for (var i = 0; i < this._result; i++) {
				if (!(this$1$1._intPt[i].equals2D(this$1$1._inputLines[inputLineIndex][0]) || this$1$1._intPt[i].equals2D(this$1$1._inputLines[inputLineIndex][1]))) {
					return true
				}
			}
			return false
		}
	};
	LineIntersector.prototype.getIntersection = function getIntersection(intIndex) {
		return this._intPt[intIndex]
	};
	LineIntersector.prototype.isEndPoint = function isEndPoint() {
		return this.hasIntersection() && !this._isProper
	};
	LineIntersector.prototype.hasIntersection = function hasIntersection() {
		return this._result !== LineIntersector.NO_INTERSECTION
	};
	LineIntersector.prototype.getEdgeDistance = function getEdgeDistance(segmentIndex, intIndex) {
		var dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1]);
		return dist
	};
	LineIntersector.prototype.isCollinear = function isCollinear() {
		return this._result === LineIntersector.COLLINEAR_INTERSECTION
	};
	LineIntersector.prototype.toString = function toString() {
		return WKTWriter.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + ' - ' + WKTWriter.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary()
	};
	LineIntersector.prototype.getEndpoint = function getEndpoint(segmentIndex, ptIndex) {
		return this._inputLines[segmentIndex][ptIndex]
	};
	LineIntersector.prototype.isIntersection = function isIntersection(pt) {
		var this$1$1 = this;

		for (var i = 0; i < this._result; i++) {
			if (this$1$1._intPt[i].equals2D(pt)) {
				return true
			}
		}
		return false
	};
	LineIntersector.prototype.getIntersectionAlongSegment = function getIntersectionAlongSegment(segmentIndex, intIndex) {
		this.computeIntLineIndex();
		return this._intPt[this._intLineIndex[segmentIndex][intIndex]]
	};
	LineIntersector.prototype.interfaces_ = function interfaces_() {
		return []
	};
	LineIntersector.prototype.getClass = function getClass() {
		return LineIntersector
	};
	LineIntersector.computeEdgeDistance = function computeEdgeDistance(p, p0, p1) {
		var dx = Math.abs(p1.x - p0.x);
		var dy = Math.abs(p1.y - p0.y);
		var dist = -1.0;
		if (p.equals(p0)) {
			dist = 0.0;
		} else if (p.equals(p1)) {
			if (dx > dy) { dist = dx; } else { dist = dy; }
		} else {
			var pdx = Math.abs(p.x - p0.x);
			var pdy = Math.abs(p.y - p0.y);
			if (dx > dy) { dist = pdx; } else { dist = pdy; }
			if (dist === 0.0 && !p.equals(p0)) {
				dist = Math.max(pdx, pdy);
			}
		}
		Assert.isTrue(!(dist === 0.0 && !p.equals(p0)), 'Bad distance calculation');
		return dist
	};
	LineIntersector.nonRobustComputeEdgeDistance = function nonRobustComputeEdgeDistance(p, p1, p2) {
		var dx = p.x - p1.x;
		var dy = p.y - p1.y;
		var dist = Math.sqrt(dx * dx + dy * dy);
		Assert.isTrue(!(dist === 0.0 && !p.equals(p1)), 'Invalid distance calculation');
		return dist
	};
	staticAccessors$10.DONT_INTERSECT.get = function () { return 0 };
	staticAccessors$10.DO_INTERSECT.get = function () { return 1 };
	staticAccessors$10.COLLINEAR.get = function () { return 2 };
	staticAccessors$10.NO_INTERSECTION.get = function () { return 0 };
	staticAccessors$10.POINT_INTERSECTION.get = function () { return 1 };
	staticAccessors$10.COLLINEAR_INTERSECTION.get = function () { return 2 };

	Object.defineProperties(LineIntersector, staticAccessors$10);

	var RobustLineIntersector = (function (LineIntersector$$1) {
		function RobustLineIntersector() {
			LineIntersector$$1.apply(this, arguments);
		}

		if (LineIntersector$$1) RobustLineIntersector.__proto__ = LineIntersector$$1;
		RobustLineIntersector.prototype = Object.create(LineIntersector$$1 && LineIntersector$$1.prototype);
		RobustLineIntersector.prototype.constructor = RobustLineIntersector;

		RobustLineIntersector.prototype.isInSegmentEnvelopes = function isInSegmentEnvelopes(intPt) {
			var env0 = new Envelope(this._inputLines[0][0], this._inputLines[0][1]);
			var env1 = new Envelope(this._inputLines[1][0], this._inputLines[1][1]);
			return env0.contains(intPt) && env1.contains(intPt)
		};
		RobustLineIntersector.prototype.computeIntersection = function computeIntersection() {
			if (arguments.length === 3) {
				var p = arguments[0];
				var p1 = arguments[1];
				var p2 = arguments[2];
				this._isProper = false;
				if (Envelope.intersects(p1, p2, p)) {
					if (CGAlgorithms.orientationIndex(p1, p2, p) === 0 && CGAlgorithms.orientationIndex(p2, p1, p) === 0) {
						this._isProper = true;
						if (p.equals(p1) || p.equals(p2)) {
							this._isProper = false;
						}
						this._result = LineIntersector$$1.POINT_INTERSECTION;
						return null
					}
				}
				this._result = LineIntersector$$1.NO_INTERSECTION;
			} else { return LineIntersector$$1.prototype.computeIntersection.apply(this, arguments) }
		};
		RobustLineIntersector.prototype.normalizeToMinimum = function normalizeToMinimum(n1, n2, n3, n4, normPt) {
			normPt.x = this.smallestInAbsValue(n1.x, n2.x, n3.x, n4.x);
			normPt.y = this.smallestInAbsValue(n1.y, n2.y, n3.y, n4.y);
			n1.x -= normPt.x;
			n1.y -= normPt.y;
			n2.x -= normPt.x;
			n2.y -= normPt.y;
			n3.x -= normPt.x;
			n3.y -= normPt.y;
			n4.x -= normPt.x;
			n4.y -= normPt.y;
		};
		RobustLineIntersector.prototype.safeHCoordinateIntersection = function safeHCoordinateIntersection(p1, p2, q1, q2) {
			var intPt = null;
			try {
				intPt = HCoordinate.intersection(p1, p2, q1, q2);
			} catch (e) {
				if (e instanceof NotRepresentableException) {
					intPt = RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2);
				} else { throw e }
			} finally { }
			return intPt
		};
		RobustLineIntersector.prototype.intersection = function intersection(p1, p2, q1, q2) {
			var intPt = this.intersectionWithNormalization(p1, p2, q1, q2);
			if (!this.isInSegmentEnvelopes(intPt)) {
				intPt = new Coordinate(RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2));
			}
			if (this._precisionModel !== null) {
				this._precisionModel.makePrecise(intPt);
			}
			return intPt
		};
		RobustLineIntersector.prototype.smallestInAbsValue = function smallestInAbsValue(x1, x2, x3, x4) {
			var x = x1;
			var xabs = Math.abs(x);
			if (Math.abs(x2) < xabs) {
				x = x2;
				xabs = Math.abs(x2);
			}
			if (Math.abs(x3) < xabs) {
				x = x3;
				xabs = Math.abs(x3);
			}
			if (Math.abs(x4) < xabs) {
				x = x4;
			}
			return x
		};
		RobustLineIntersector.prototype.checkDD = function checkDD(p1, p2, q1, q2, intPt) {
			var intPtDD = CGAlgorithmsDD.intersection(p1, p2, q1, q2);
			var isIn = this.isInSegmentEnvelopes(intPtDD);
			System.out.println('DD in env = ' + isIn + '  --------------------- ' + intPtDD);
			if (intPt.distance(intPtDD) > 0.0001) {
				System.out.println('Distance = ' + intPt.distance(intPtDD));
			}
		};
		RobustLineIntersector.prototype.intersectionWithNormalization = function intersectionWithNormalization(p1, p2, q1, q2) {
			var n1 = new Coordinate(p1);
			var n2 = new Coordinate(p2);
			var n3 = new Coordinate(q1);
			var n4 = new Coordinate(q2);
			var normPt = new Coordinate();
			this.normalizeToEnvCentre(n1, n2, n3, n4, normPt);
			var intPt = this.safeHCoordinateIntersection(n1, n2, n3, n4);
			intPt.x += normPt.x;
			intPt.y += normPt.y;
			return intPt
		};
		RobustLineIntersector.prototype.computeCollinearIntersection = function computeCollinearIntersection(p1, p2, q1, q2) {
			var p1q1p2 = Envelope.intersects(p1, p2, q1);
			var p1q2p2 = Envelope.intersects(p1, p2, q2);
			var q1p1q2 = Envelope.intersects(q1, q2, p1);
			var q1p2q2 = Envelope.intersects(q1, q2, p2);
			if (p1q1p2 && p1q2p2) {
				this._intPt[0] = q1;
				this._intPt[1] = q2;
				return LineIntersector$$1.COLLINEAR_INTERSECTION
			}
			if (q1p1q2 && q1p2q2) {
				this._intPt[0] = p1;
				this._intPt[1] = p2;
				return LineIntersector$$1.COLLINEAR_INTERSECTION
			}
			if (p1q1p2 && q1p1q2) {
				this._intPt[0] = q1;
				this._intPt[1] = p1;
				return q1.equals(p1) && !p1q2p2 && !q1p2q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION
			}
			if (p1q1p2 && q1p2q2) {
				this._intPt[0] = q1;
				this._intPt[1] = p2;
				return q1.equals(p2) && !p1q2p2 && !q1p1q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION
			}
			if (p1q2p2 && q1p1q2) {
				this._intPt[0] = q2;
				this._intPt[1] = p1;
				return q2.equals(p1) && !p1q1p2 && !q1p2q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION
			}
			if (p1q2p2 && q1p2q2) {
				this._intPt[0] = q2;
				this._intPt[1] = p2;
				return q2.equals(p2) && !p1q1p2 && !q1p1q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION
			}
			return LineIntersector$$1.NO_INTERSECTION
		};
		RobustLineIntersector.prototype.normalizeToEnvCentre = function normalizeToEnvCentre(n00, n01, n10, n11, normPt) {
			var minX0 = n00.x < n01.x ? n00.x : n01.x;
			var minY0 = n00.y < n01.y ? n00.y : n01.y;
			var maxX0 = n00.x > n01.x ? n00.x : n01.x;
			var maxY0 = n00.y > n01.y ? n00.y : n01.y;
			var minX1 = n10.x < n11.x ? n10.x : n11.x;
			var minY1 = n10.y < n11.y ? n10.y : n11.y;
			var maxX1 = n10.x > n11.x ? n10.x : n11.x;
			var maxY1 = n10.y > n11.y ? n10.y : n11.y;
			var intMinX = minX0 > minX1 ? minX0 : minX1;
			var intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;
			var intMinY = minY0 > minY1 ? minY0 : minY1;
			var intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;
			var intMidX = (intMinX + intMaxX) / 2.0;
			var intMidY = (intMinY + intMaxY) / 2.0;
			normPt.x = intMidX;
			normPt.y = intMidY;
			n00.x -= normPt.x;
			n00.y -= normPt.y;
			n01.x -= normPt.x;
			n01.y -= normPt.y;
			n10.x -= normPt.x;
			n10.y -= normPt.y;
			n11.x -= normPt.x;
			n11.y -= normPt.y;
		};
		RobustLineIntersector.prototype.computeIntersect = function computeIntersect(p1, p2, q1, q2) {
			this._isProper = false;
			if (!Envelope.intersects(p1, p2, q1, q2)) { return LineIntersector$$1.NO_INTERSECTION }
			var Pq1 = CGAlgorithms.orientationIndex(p1, p2, q1);
			var Pq2 = CGAlgorithms.orientationIndex(p1, p2, q2);
			if ((Pq1 > 0 && Pq2 > 0) || (Pq1 < 0 && Pq2 < 0)) {
				return LineIntersector$$1.NO_INTERSECTION
			}
			var Qp1 = CGAlgorithms.orientationIndex(q1, q2, p1);
			var Qp2 = CGAlgorithms.orientationIndex(q1, q2, p2);
			if ((Qp1 > 0 && Qp2 > 0) || (Qp1 < 0 && Qp2 < 0)) {
				return LineIntersector$$1.NO_INTERSECTION
			}
			var collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;
			if (collinear) {
				return this.computeCollinearIntersection(p1, p2, q1, q2)
			}
			if (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {
				this._isProper = false;
				if (p1.equals2D(q1) || p1.equals2D(q2)) {
					this._intPt[0] = p1;
				} else if (p2.equals2D(q1) || p2.equals2D(q2)) {
					this._intPt[0] = p2;
				} else if (Pq1 === 0) {
					this._intPt[0] = new Coordinate(q1);
				} else if (Pq2 === 0) {
					this._intPt[0] = new Coordinate(q2);
				} else if (Qp1 === 0) {
					this._intPt[0] = new Coordinate(p1);
				} else if (Qp2 === 0) {
					this._intPt[0] = new Coordinate(p2);
				}
			} else {
				this._isProper = true;
				this._intPt[0] = this.intersection(p1, p2, q1, q2);
			}
			return LineIntersector$$1.POINT_INTERSECTION
		};
		RobustLineIntersector.prototype.interfaces_ = function interfaces_() {
			return []
		};
		RobustLineIntersector.prototype.getClass = function getClass() {
			return RobustLineIntersector
		};
		RobustLineIntersector.nearestEndpoint = function nearestEndpoint(p1, p2, q1, q2) {
			var nearestPt = p1;
			var minDist = CGAlgorithms.distancePointLine(p1, q1, q2);
			var dist = CGAlgorithms.distancePointLine(p2, q1, q2);
			if (dist < minDist) {
				minDist = dist;
				nearestPt = p2;
			}
			dist = CGAlgorithms.distancePointLine(q1, p1, p2);
			if (dist < minDist) {
				minDist = dist;
				nearestPt = q1;
			}
			dist = CGAlgorithms.distancePointLine(q2, p1, p2);
			if (dist < minDist) {
				minDist = dist;
				nearestPt = q2;
			}
			return nearestPt
		};

		return RobustLineIntersector;
	}(LineIntersector));

	var RobustDeterminant = function RobustDeterminant() { };

	RobustDeterminant.prototype.interfaces_ = function interfaces_() {
		return []
	};
	RobustDeterminant.prototype.getClass = function getClass() {
		return RobustDeterminant
	};
	RobustDeterminant.orientationIndex = function orientationIndex(p1, p2, q) {
		var dx1 = p2.x - p1.x;
		var dy1 = p2.y - p1.y;
		var dx2 = q.x - p2.x;
		var dy2 = q.y - p2.y;
		return RobustDeterminant.signOfDet2x2(dx1, dy1, dx2, dy2)
	};
	RobustDeterminant.signOfDet2x2 = function signOfDet2x2(x1, y1, x2, y2) {
		var sign = null;
		var swap = null;
		var k = null;
		sign = 1;
		if (x1 === 0.0 || y2 === 0.0) {
			if (y1 === 0.0 || x2 === 0.0) {
				return 0
			} else if (y1 > 0) {
				if (x2 > 0) {
					return -sign
				} else {
					return sign
				}
			} else {
				if (x2 > 0) {
					return sign
				} else {
					return -sign
				}
			}
		}
		if (y1 === 0.0 || x2 === 0.0) {
			if (y2 > 0) {
				if (x1 > 0) {
					return sign
				} else {
					return -sign
				}
			} else {
				if (x1 > 0) {
					return -sign
				} else {
					return sign
				}
			}
		}
		if (y1 > 0.0) {
			if (y2 > 0.0) {
				if (y1 <= y2); else {
					sign = -sign;
					swap = x1;
					x1 = x2;
					x2 = swap;
					swap = y1;
					y1 = y2;
					y2 = swap;
				}
			} else {
				if (y1 <= -y2) {
					sign = -sign;
					x2 = -x2;
					y2 = -y2;
				} else {
					swap = x1;
					x1 = -x2;
					x2 = swap;
					swap = y1;
					y1 = -y2;
					y2 = swap;
				}
			}
		} else {
			if (y2 > 0.0) {
				if (-y1 <= y2) {
					sign = -sign;
					x1 = -x1;
					y1 = -y1;
				} else {
					swap = -x1;
					x1 = x2;
					x2 = swap;
					swap = -y1;
					y1 = y2;
					y2 = swap;
				}
			} else {
				if (y1 >= y2) {
					x1 = -x1;
					y1 = -y1;
					x2 = -x2;
					y2 = -y2;
				} else {
					sign = -sign;
					swap = -x1;
					x1 = -x2;
					x2 = swap;
					swap = -y1;
					y1 = -y2;
					y2 = swap;
				}
			}
		}
		if (x1 > 0.0) {
			if (x2 > 0.0) {
				if (x1 <= x2); else {
					return sign
				}
			} else {
				return sign
			}
		} else {
			if (x2 > 0.0) {
				return -sign
			} else {
				if (x1 >= x2) {
					sign = -sign;
					x1 = -x1;
					x2 = -x2;
				} else {
					return -sign
				}
			}
		}
		while (true) {
			k = Math.floor(x2 / x1);
			x2 = x2 - k * x1;
			y2 = y2 - k * y1;
			if (y2 < 0.0) {
				return -sign
			}
			if (y2 > y1) {
				return sign
			}
			if (x1 > x2 + x2) {
				if (y1 < y2 + y2) {
					return sign
				}
			} else {
				if (y1 > y2 + y2) {
					return -sign
				} else {
					x2 = x1 - x2;
					y2 = y1 - y2;
					sign = -sign;
				}
			}
			if (y2 === 0.0) {
				if (x2 === 0.0) {
					return 0
				} else {
					return -sign
				}
			}
			if (x2 === 0.0) {
				return sign
			}
			k = Math.floor(x1 / x2);
			x1 = x1 - k * x2;
			y1 = y1 - k * y2;
			if (y1 < 0.0) {
				return sign
			}
			if (y1 > y2) {
				return -sign
			}
			if (x2 > x1 + x1) {
				if (y2 < y1 + y1) {
					return -sign
				}
			} else {
				if (y2 > y1 + y1) {
					return sign
				} else {
					x1 = x2 - x1;
					y1 = y2 - y1;
					sign = -sign;
				}
			}
			if (y1 === 0.0) {
				if (x1 === 0.0) {
					return 0
				} else {
					return sign
				}
			}
			if (x1 === 0.0) {
				return -sign
			}
		}
	};

	var RayCrossingCounter = function RayCrossingCounter() {
		this._p = null;
		this._crossingCount = 0;
		this._isPointOnSegment = false;
		var p = arguments[0];
		this._p = p;
	};
	RayCrossingCounter.prototype.countSegment = function countSegment(p1, p2) {
		if (p1.x < this._p.x && p2.x < this._p.x) { return null }
		if (this._p.x === p2.x && this._p.y === p2.y) {
			this._isPointOnSegment = true;
			return null
		}
		if (p1.y === this._p.y && p2.y === this._p.y) {
			var minx = p1.x;
			var maxx = p2.x;
			if (minx > maxx) {
				minx = p2.x;
				maxx = p1.x;
			}
			if (this._p.x >= minx && this._p.x <= maxx) {
				this._isPointOnSegment = true;
			}
			return null
		}
		if ((p1.y > this._p.y && p2.y <= this._p.y) || (p2.y > this._p.y && p1.y <= this._p.y)) {
			var x1 = p1.x - this._p.x;
			var y1 = p1.y - this._p.y;
			var x2 = p2.x - this._p.x;
			var y2 = p2.y - this._p.y;
			var xIntSign = RobustDeterminant.signOfDet2x2(x1, y1, x2, y2);
			if (xIntSign === 0.0) {
				this._isPointOnSegment = true;
				return null
			}
			if (y2 < y1) { xIntSign = -xIntSign; }
			if (xIntSign > 0.0) {
				this._crossingCount++;
			}
		}
	};
	RayCrossingCounter.prototype.isPointInPolygon = function isPointInPolygon() {
		return this.getLocation() !== Location.EXTERIOR
	};
	RayCrossingCounter.prototype.getLocation = function getLocation() {
		if (this._isPointOnSegment) { return Location.BOUNDARY }
		if (this._crossingCount % 2 === 1) {
			return Location.INTERIOR
		}
		return Location.EXTERIOR
	};
	RayCrossingCounter.prototype.isOnSegment = function isOnSegment() {
		return this._isPointOnSegment
	};
	RayCrossingCounter.prototype.interfaces_ = function interfaces_() {
		return []
	};
	RayCrossingCounter.prototype.getClass = function getClass() {
		return RayCrossingCounter
	};
	RayCrossingCounter.locatePointInRing = function locatePointInRing() {
		if (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {
			var p = arguments[0];
			var ring = arguments[1];
			var counter = new RayCrossingCounter(p);
			var p1 = new Coordinate();
			var p2 = new Coordinate();
			for (var i = 1; i < ring.size(); i++) {
				ring.getCoordinate(i, p1);
				ring.getCoordinate(i - 1, p2);
				counter.countSegment(p1, p2);
				if (counter.isOnSegment()) { return counter.getLocation() }
			}
			return counter.getLocation()
		} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {
			var p$1 = arguments[0];
			var ring$1 = arguments[1];
			var counter$1 = new RayCrossingCounter(p$1);
			for (var i$1 = 1; i$1 < ring$1.length; i$1++) {
				var p1$1 = ring$1[i$1];
				var p2$1 = ring$1[i$1 - 1];
				counter$1.countSegment(p1$1, p2$1);
				if (counter$1.isOnSegment()) { return counter$1.getLocation() }
			}
			return counter$1.getLocation()
		}
	};

	var CGAlgorithms = function CGAlgorithms() { };

	var staticAccessors$3 = { CLOCKWISE: { configurable: true }, RIGHT: { configurable: true }, COUNTERCLOCKWISE: { configurable: true }, LEFT: { configurable: true }, COLLINEAR: { configurable: true }, STRAIGHT: { configurable: true } };

	CGAlgorithms.prototype.interfaces_ = function interfaces_() {
		return []
	};
	CGAlgorithms.prototype.getClass = function getClass() {
		return CGAlgorithms
	};
	CGAlgorithms.orientationIndex = function orientationIndex(p1, p2, q) {
		return CGAlgorithmsDD.orientationIndex(p1, p2, q)
	};
	CGAlgorithms.signedArea = function signedArea() {
		if (arguments[0] instanceof Array) {
			var ring = arguments[0];
			if (ring.length < 3) { return 0.0 }
			var sum = 0.0;
			var x0 = ring[0].x;
			for (var i = 1; i < ring.length - 1; i++) {
				var x = ring[i].x - x0;
				var y1 = ring[i + 1].y;
				var y2 = ring[i - 1].y;
				sum += x * (y2 - y1);
			}
			return sum / 2.0
		} else if (hasInterface(arguments[0], CoordinateSequence)) {
			var ring$1 = arguments[0];
			var n = ring$1.size();
			if (n < 3) { return 0.0 }
			var p0 = new Coordinate();
			var p1 = new Coordinate();
			var p2 = new Coordinate();
			ring$1.getCoordinate(0, p1);
			ring$1.getCoordinate(1, p2);
			var x0$1 = p1.x;
			p2.x -= x0$1;
			var sum$1 = 0.0;
			for (var i$1 = 1; i$1 < n - 1; i$1++) {
				p0.y = p1.y;
				p1.x = p2.x;
				p1.y = p2.y;
				ring$1.getCoordinate(i$1 + 1, p2);
				p2.x -= x0$1;
				sum$1 += p1.x * (p0.y - p2.y);
			}
			return sum$1 / 2.0
		}
	};
	CGAlgorithms.distanceLineLine = function distanceLineLine(A, B, C, D) {
		if (A.equals(B)) { return CGAlgorithms.distancePointLine(A, C, D) }
		if (C.equals(D)) { return CGAlgorithms.distancePointLine(D, A, B) }
		var noIntersection = false;
		if (!Envelope.intersects(A, B, C, D)) {
			noIntersection = true;
		} else {
			var denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);
			if (denom === 0) {
				noIntersection = true;
			} else {
				var rNumb = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);
				var sNum = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);
				var s = sNum / denom;
				var r = rNumb / denom;
				if (r < 0 || r > 1 || s < 0 || s > 1) {
					noIntersection = true;
				}
			}
		}
		if (noIntersection) {
			return MathUtil.min(CGAlgorithms.distancePointLine(A, C, D), CGAlgorithms.distancePointLine(B, C, D), CGAlgorithms.distancePointLine(C, A, B), CGAlgorithms.distancePointLine(D, A, B))
		}
		return 0.0
	};
	CGAlgorithms.isPointInRing = function isPointInRing(p, ring) {
		return CGAlgorithms.locatePointInRing(p, ring) !== Location.EXTERIOR
	};
	CGAlgorithms.computeLength = function computeLength(pts) {
		var n = pts.size();
		if (n <= 1) { return 0.0 }
		var len = 0.0;
		var p = new Coordinate();
		pts.getCoordinate(0, p);
		var x0 = p.x;
		var y0 = p.y;
		for (var i = 1; i < n; i++) {
			pts.getCoordinate(i, p);
			var x1 = p.x;
			var y1 = p.y;
			var dx = x1 - x0;
			var dy = y1 - y0;
			len += Math.sqrt(dx * dx + dy * dy);
			x0 = x1;
			y0 = y1;
		}
		return len
	};
	CGAlgorithms.isCCW = function isCCW(ring) {
		var nPts = ring.length - 1;
		if (nPts < 3) { throw new IllegalArgumentException('Ring has fewer than 4 points, so orientation cannot be determined') }
		var hiPt = ring[0];
		var hiIndex = 0;
		for (var i = 1; i <= nPts; i++) {
			var p = ring[i];
			if (p.y > hiPt.y) {
				hiPt = p;
				hiIndex = i;
			}
		}
		var iPrev = hiIndex;
		do {
			iPrev = iPrev - 1;
			if (iPrev < 0) { iPrev = nPts; }
		} while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex)
		var iNext = hiIndex;
		do {
			iNext = (iNext + 1) % nPts;
		} while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex)
		var prev = ring[iPrev];
		var next = ring[iNext];
		if (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) { return false }
		var disc = CGAlgorithms.computeOrientation(prev, hiPt, next);
		var isCCW = false;
		if (disc === 0) {
			isCCW = prev.x > next.x;
		} else {
			isCCW = disc > 0;
		}
		return isCCW
	};
	CGAlgorithms.locatePointInRing = function locatePointInRing(p, ring) {
		return RayCrossingCounter.locatePointInRing(p, ring)
	};
	CGAlgorithms.distancePointLinePerpendicular = function distancePointLinePerpendicular(p, A, B) {
		var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);
		var s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;
		return Math.abs(s) * Math.sqrt(len2)
	};
	CGAlgorithms.computeOrientation = function computeOrientation(p1, p2, q) {
		return CGAlgorithms.orientationIndex(p1, p2, q)
	};
	CGAlgorithms.distancePointLine = function distancePointLine() {
		if (arguments.length === 2) {
			var p = arguments[0];
			var line = arguments[1];
			if (line.length === 0) { throw new IllegalArgumentException('Line array must contain at least one vertex') }
			var minDistance = p.distance(line[0]);
			for (var i = 0; i < line.length - 1; i++) {
				var dist = CGAlgorithms.distancePointLine(p, line[i], line[i + 1]);
				if (dist < minDistance) {
					minDistance = dist;
				}
			}
			return minDistance
		} else if (arguments.length === 3) {
			var p$1 = arguments[0];
			var A = arguments[1];
			var B = arguments[2];
			if (A.x === B.x && A.y === B.y) { return p$1.distance(A) }
			var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);
			var r = ((p$1.x - A.x) * (B.x - A.x) + (p$1.y - A.y) * (B.y - A.y)) / len2;
			if (r <= 0.0) { return p$1.distance(A) }
			if (r >= 1.0) { return p$1.distance(B) }
			var s = ((A.y - p$1.y) * (B.x - A.x) - (A.x - p$1.x) * (B.y - A.y)) / len2;
			return Math.abs(s) * Math.sqrt(len2)
		}
	};
	CGAlgorithms.isOnLine = function isOnLine(p, pt) {
		var lineIntersector = new RobustLineIntersector();
		for (var i = 1; i < pt.length; i++) {
			var p0 = pt[i - 1];
			var p1 = pt[i];
			lineIntersector.computeIntersection(p, p0, p1);
			if (lineIntersector.hasIntersection()) {
				return true
			}
		}
		return false
	};
	staticAccessors$3.CLOCKWISE.get = function () { return -1 };
	staticAccessors$3.RIGHT.get = function () { return CGAlgorithms.CLOCKWISE };
	staticAccessors$3.COUNTERCLOCKWISE.get = function () { return 1 };
	staticAccessors$3.LEFT.get = function () { return CGAlgorithms.COUNTERCLOCKWISE };
	staticAccessors$3.COLLINEAR.get = function () { return 0 };
	staticAccessors$3.STRAIGHT.get = function () { return CGAlgorithms.COLLINEAR };

	Object.defineProperties(CGAlgorithms, staticAccessors$3);

	var GeometryComponentFilter = function GeometryComponentFilter() { };

	GeometryComponentFilter.prototype.filter = function filter(geom) { };
	GeometryComponentFilter.prototype.interfaces_ = function interfaces_() {
		return []
	};
	GeometryComponentFilter.prototype.getClass = function getClass() {
		return GeometryComponentFilter
	};

	var Geometry = function Geometry() {
		var factory = arguments[0];

		this._envelope = null;
		this._factory = null;
		this._SRID = null;
		this._userData = null;
		this._factory = factory;
		this._SRID = factory.getSRID();
	};

	var staticAccessors$11 = { serialVersionUID: { configurable: true }, SORTINDEX_POINT: { configurable: true }, SORTINDEX_MULTIPOINT: { configurable: true }, SORTINDEX_LINESTRING: { configurable: true }, SORTINDEX_LINEARRING: { configurable: true }, SORTINDEX_MULTILINESTRING: { configurable: true }, SORTINDEX_POLYGON: { configurable: true }, SORTINDEX_MULTIPOLYGON: { configurable: true }, SORTINDEX_GEOMETRYCOLLECTION: { configurable: true }, geometryChangedFilter: { configurable: true } };
	Geometry.prototype.isGeometryCollection = function isGeometryCollection() {
		return this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION
	};
	Geometry.prototype.getFactory = function getFactory() {
		return this._factory
	};
	Geometry.prototype.getGeometryN = function getGeometryN(n) {
		return this
	};
	Geometry.prototype.getArea = function getArea() {
		return 0.0
	};
	Geometry.prototype.isRectangle = function isRectangle() {
		return false
	};
	Geometry.prototype.equals = function equals() {
		if (arguments[0] instanceof Geometry) {
			var g$1 = arguments[0];
			if (g$1 === null) { return false }
			return this.equalsTopo(g$1)
		} else if (arguments[0] instanceof Object) {
			var o = arguments[0];
			if (!(o instanceof Geometry)) { return false }
			var g = o;
			return this.equalsExact(g)
		}
	};
	Geometry.prototype.equalsExact = function equalsExact(other) {
		return this === other || this.equalsExact(other, 0)
	};
	Geometry.prototype.geometryChanged = function geometryChanged() {
		this.apply(Geometry.geometryChangedFilter);
	};
	Geometry.prototype.geometryChangedAction = function geometryChangedAction() {
		this._envelope = null;
	};
	Geometry.prototype.equalsNorm = function equalsNorm(g) {
		if (g === null) { return false }
		return this.norm().equalsExact(g.norm())
	};
	Geometry.prototype.getLength = function getLength() {
		return 0.0
	};
	Geometry.prototype.getNumGeometries = function getNumGeometries() {
		return 1
	};
	Geometry.prototype.compareTo = function compareTo() {
		if (arguments.length === 1) {
			var o = arguments[0];
			var other = o;
			if (this.getSortIndex() !== other.getSortIndex()) {
				return this.getSortIndex() - other.getSortIndex()
			}
			if (this.isEmpty() && other.isEmpty()) {
				return 0
			}
			if (this.isEmpty()) {
				return -1
			}
			if (other.isEmpty()) {
				return 1
			}
			return this.compareToSameClass(o)
		} else if (arguments.length === 2) {
			var other$1 = arguments[0];
			var comp = arguments[1];
			if (this.getSortIndex() !== other$1.getSortIndex()) {
				return this.getSortIndex() - other$1.getSortIndex()
			}
			if (this.isEmpty() && other$1.isEmpty()) {
				return 0
			}
			if (this.isEmpty()) {
				return -1
			}
			if (other$1.isEmpty()) {
				return 1
			}
			return this.compareToSameClass(other$1, comp)
		}
	};
	Geometry.prototype.getUserData = function getUserData() {
		return this._userData
	};
	Geometry.prototype.getSRID = function getSRID() {
		return this._SRID
	};
	Geometry.prototype.getEnvelope = function getEnvelope() {
		return this.getFactory().toGeometry(this.getEnvelopeInternal())
	};
	Geometry.prototype.checkNotGeometryCollection = function checkNotGeometryCollection(g) {
		if (g.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION) {
			throw new IllegalArgumentException('This method does not support GeometryCollection arguments')
		}
	};
	Geometry.prototype.equal = function equal(a, b, tolerance) {
		if (tolerance === 0) {
			return a.equals(b)
		}
		return a.distance(b) <= tolerance
	};
	Geometry.prototype.norm = function norm() {
		var copy = this.copy();
		copy.normalize();
		return copy
	};
	Geometry.prototype.getPrecisionModel = function getPrecisionModel() {
		return this._factory.getPrecisionModel()
	};
	Geometry.prototype.getEnvelopeInternal = function getEnvelopeInternal() {
		if (this._envelope === null) {
			this._envelope = this.computeEnvelopeInternal();
		}
		return new Envelope(this._envelope)
	};
	Geometry.prototype.setSRID = function setSRID(SRID) {
		this._SRID = SRID;
	};
	Geometry.prototype.setUserData = function setUserData(userData) {
		this._userData = userData;
	};
	Geometry.prototype.compare = function compare(a, b) {
		var i = a.iterator();
		var j = b.iterator();
		while (i.hasNext() && j.hasNext()) {
			var aElement = i.next();
			var bElement = j.next();
			var comparison = aElement.compareTo(bElement);
			if (comparison !== 0) {
				return comparison
			}
		}
		if (i.hasNext()) {
			return 1
		}
		if (j.hasNext()) {
			return -1
		}
		return 0
	};
	Geometry.prototype.hashCode = function hashCode() {
		return this.getEnvelopeInternal().hashCode()
	};
	Geometry.prototype.isGeometryCollectionOrDerived = function isGeometryCollectionOrDerived() {
		if (this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOINT || this.getSortIndex() === Geometry.SORTINDEX_MULTILINESTRING || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOLYGON) {
			return true
		}
		return false
	};
	Geometry.prototype.interfaces_ = function interfaces_() {
		return [Clonable, Comparable, Serializable]
	};
	Geometry.prototype.getClass = function getClass() {
		return Geometry
	};
	Geometry.hasNonEmptyElements = function hasNonEmptyElements(geometries) {
		for (var i = 0; i < geometries.length; i++) {
			if (!geometries[i].isEmpty()) {
				return true
			}
		}
		return false
	};
	Geometry.hasNullElements = function hasNullElements(array) {
		for (var i = 0; i < array.length; i++) {
			if (array[i] === null) {
				return true
			}
		}
		return false
	};
	staticAccessors$11.serialVersionUID.get = function () { return 8763622679187376702 };
	staticAccessors$11.SORTINDEX_POINT.get = function () { return 0 };
	staticAccessors$11.SORTINDEX_MULTIPOINT.get = function () { return 1 };
	staticAccessors$11.SORTINDEX_LINESTRING.get = function () { return 2 };
	staticAccessors$11.SORTINDEX_LINEARRING.get = function () { return 3 };
	staticAccessors$11.SORTINDEX_MULTILINESTRING.get = function () { return 4 };
	staticAccessors$11.SORTINDEX_POLYGON.get = function () { return 5 };
	staticAccessors$11.SORTINDEX_MULTIPOLYGON.get = function () { return 6 };
	staticAccessors$11.SORTINDEX_GEOMETRYCOLLECTION.get = function () { return 7 };
	staticAccessors$11.geometryChangedFilter.get = function () { return geometryChangedFilter };

	Object.defineProperties(Geometry, staticAccessors$11);

	var geometryChangedFilter = function geometryChangedFilter() { };

	geometryChangedFilter.interfaces_ = function interfaces_() {
		return [GeometryComponentFilter]
	};
	geometryChangedFilter.filter = function filter(geom) {
		geom.geometryChangedAction();
	};

	var CoordinateFilter = function CoordinateFilter() { };

	CoordinateFilter.prototype.filter = function filter(coord) { };
	CoordinateFilter.prototype.interfaces_ = function interfaces_() {
		return []
	};
	CoordinateFilter.prototype.getClass = function getClass() {
		return CoordinateFilter
	};

	var BoundaryNodeRule = function BoundaryNodeRule() { };

	var staticAccessors$12 = { Mod2BoundaryNodeRule: { configurable: true }, EndPointBoundaryNodeRule: { configurable: true }, MultiValentEndPointBoundaryNodeRule: { configurable: true }, MonoValentEndPointBoundaryNodeRule: { configurable: true }, MOD2_BOUNDARY_RULE: { configurable: true }, ENDPOINT_BOUNDARY_RULE: { configurable: true }, MULTIVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true }, MONOVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true }, OGC_SFS_BOUNDARY_RULE: { configurable: true } };

	BoundaryNodeRule.prototype.isInBoundary = function isInBoundary(boundaryCount) { };
	BoundaryNodeRule.prototype.interfaces_ = function interfaces_() {
		return []
	};
	BoundaryNodeRule.prototype.getClass = function getClass() {
		return BoundaryNodeRule
	};
	staticAccessors$12.Mod2BoundaryNodeRule.get = function () { return Mod2BoundaryNodeRule };
	staticAccessors$12.EndPointBoundaryNodeRule.get = function () { return EndPointBoundaryNodeRule };
	staticAccessors$12.MultiValentEndPointBoundaryNodeRule.get = function () { return MultiValentEndPointBoundaryNodeRule };
	staticAccessors$12.MonoValentEndPointBoundaryNodeRule.get = function () { return MonoValentEndPointBoundaryNodeRule };
	staticAccessors$12.MOD2_BOUNDARY_RULE.get = function () { return new Mod2BoundaryNodeRule() };
	staticAccessors$12.ENDPOINT_BOUNDARY_RULE.get = function () { return new EndPointBoundaryNodeRule() };
	staticAccessors$12.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function () { return new MultiValentEndPointBoundaryNodeRule() };
	staticAccessors$12.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function () { return new MonoValentEndPointBoundaryNodeRule() };
	staticAccessors$12.OGC_SFS_BOUNDARY_RULE.get = function () { return BoundaryNodeRule.MOD2_BOUNDARY_RULE };

	Object.defineProperties(BoundaryNodeRule, staticAccessors$12);

	var Mod2BoundaryNodeRule = function Mod2BoundaryNodeRule() { };

	Mod2BoundaryNodeRule.prototype.isInBoundary = function isInBoundary(boundaryCount) {
		return boundaryCount % 2 === 1
	};
	Mod2BoundaryNodeRule.prototype.interfaces_ = function interfaces_() {
		return [BoundaryNodeRule]
	};
	Mod2BoundaryNodeRule.prototype.getClass = function getClass() {
		return Mod2BoundaryNodeRule
	};

	var EndPointBoundaryNodeRule = function EndPointBoundaryNodeRule() { };

	EndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary(boundaryCount) {
		return boundaryCount > 0
	};
	EndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_() {
		return [BoundaryNodeRule]
	};
	EndPointBoundaryNodeRule.prototype.getClass = function getClass() {
		return EndPointBoundaryNodeRule
	};

	var MultiValentEndPointBoundaryNodeRule = function MultiValentEndPointBoundaryNodeRule() { };

	MultiValentEndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary(boundaryCount) {
		return boundaryCount > 1
	};
	MultiValentEndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_() {
		return [BoundaryNodeRule]
	};
	MultiValentEndPointBoundaryNodeRule.prototype.getClass = function getClass() {
		return MultiValentEndPointBoundaryNodeRule
	};

	var MonoValentEndPointBoundaryNodeRule = function MonoValentEndPointBoundaryNodeRule() { };

	MonoValentEndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary(boundaryCount) {
		return boundaryCount === 1
	};
	MonoValentEndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_() {
		return [BoundaryNodeRule]
	};
	MonoValentEndPointBoundaryNodeRule.prototype.getClass = function getClass() {
		return MonoValentEndPointBoundaryNodeRule
	};

	// import Iterator from './Iterator'

	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/Collection.html
	 *
	 * @constructor
	 * @private
	 */
	var Collection = function Collection() { };

	Collection.prototype.add = function add() { };

	/**
	 * Appends all of the elements in the specified collection to the end of this
	 * list, in the order that they are returned by the specified collection's
	 * iterator (optional operation).
	 * @param {javascript.util.Collection} c
	 * @return {boolean}
	 */
	Collection.prototype.addAll = function addAll() { };

	/**
	 * Returns true if this collection contains no elements.
	 * @return {boolean}
	 */
	Collection.prototype.isEmpty = function isEmpty() { };

	/**
	 * Returns an iterator over the elements in this collection.
	 * @return {javascript.util.Iterator}
	 */
	Collection.prototype.iterator = function iterator() { };

	/**
	 * Returns an iterator over the elements in this collection.
	 * @return {number}
	 */
	Collection.prototype.size = function size() { };

	/**
	 * Returns an array containing all of the elements in this collection.
	 * @return {Array}
	 */
	Collection.prototype.toArray = function toArray() { };

	/**
	 * Removes a single instance of the specified element from this collection if it
	 * is present. (optional)
	 * @param {Object} e
	 * @return {boolean}
	 */
	Collection.prototype.remove = function remove() { };

	/**
	 * @param {string=} message Optional message
	 * @extends {Error}
	 * @constructor
	 * @private
	 */
	function IndexOutOfBoundsException(message) {
		this.message = message || '';
	}
	IndexOutOfBoundsException.prototype = new Error();

	/**
	 * @type {string}
	 */
	IndexOutOfBoundsException.prototype.name = 'IndexOutOfBoundsException';

	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html
	 * @constructor
	 * @private
	 */
	var Iterator = function Iterator() { };

	Iterator.prototype.hasNext = function hasNext() { };

	/**
	 * Returns the next element in the iteration.
	 * @return {Object}
	 */
	Iterator.prototype.next = function next() { };

	/**
	 * Removes from the underlying collection the last element returned by the
	 * iterator (optional operation).
	 */
	Iterator.prototype.remove = function remove() { };

	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/List.html
	 *
	 * @extends {javascript.util.Collection}
	 * @constructor
	 * @private
	 */
	var List = (function (Collection$$1) {
		function List() {
			Collection$$1.apply(this, arguments);
		}

		if (Collection$$1) List.__proto__ = Collection$$1;
		List.prototype = Object.create(Collection$$1 && Collection$$1.prototype);
		List.prototype.constructor = List;

		List.prototype.get = function get() { };

		/**
		 * Replaces the element at the specified position in this list with the
		 * specified element (optional operation).
		 * @param {number} index
		 * @param {Object} e
		 * @return {Object}
		 */
		List.prototype.set = function set() { };

		/**
		 * Returns true if this collection contains no elements.
		 * @return {boolean}
		 */
		List.prototype.isEmpty = function isEmpty() { };

		return List;
	}(Collection));

	/**
	 * @param {string=} message Optional message
	 * @extends {Error}
	 * @constructor
	 * @private
	 */
	function NoSuchElementException(message) {
		this.message = message || '';
	}
	NoSuchElementException.prototype = new Error();

	/**
	 * @type {string}
	 */
	NoSuchElementException.prototype.name = 'NoSuchElementException';

	// import OperationNotSupported from './OperationNotSupported'

	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/ArrayList.html
	 *
	 * @extends List
	 * @private
	 */
	var ArrayList = (function (List$$1) {
		function ArrayList() {
			List$$1.call(this);
			this.array_ = [];

			if (arguments[0] instanceof Collection) {
				this.addAll(arguments[0]);
			}
		}

		if (List$$1) ArrayList.__proto__ = List$$1;
		ArrayList.prototype = Object.create(List$$1 && List$$1.prototype);
		ArrayList.prototype.constructor = ArrayList;

		ArrayList.prototype.ensureCapacity = function ensureCapacity() { };
		ArrayList.prototype.interfaces_ = function interfaces_() { return [List$$1, Collection] };

		/**
		 * @override
		 */
		ArrayList.prototype.add = function add(e) {
			if (arguments.length === 1) {
				this.array_.push(e);
			} else {
				this.array_.splice(arguments[0], arguments[1]);
			}
			return true
		};

		ArrayList.prototype.clear = function clear() {
			this.array_ = [];
		};

		/**
		 * @override
		 */
		ArrayList.prototype.addAll = function addAll(c) {
			var this$1$1 = this;

			for (var i = c.iterator(); i.hasNext();) {
				this$1$1.add(i.next());
			}
			return true
		};

		/**
		 * @override
		 */
		ArrayList.prototype.set = function set(index, element) {
			var oldElement = this.array_[index];
			this.array_[index] = element;
			return oldElement
		};

		/**
		 * @override
		 */
		ArrayList.prototype.iterator = function iterator() {
			return new Iterator_(this)
		};

		/**
		 * @override
		 */
		ArrayList.prototype.get = function get(index) {
			if (index < 0 || index >= this.size()) {
				throw new IndexOutOfBoundsException()
			}

			return this.array_[index]
		};

		/**
		 * @override
		 */
		ArrayList.prototype.isEmpty = function isEmpty() {
			return this.array_.length === 0
		};

		/**
		 * @override
		 */
		ArrayList.prototype.size = function size() {
			return this.array_.length
		};

		/**
		 * @override
		 */
		ArrayList.prototype.toArray = function toArray() {
			var this$1$1 = this;

			var array = [];

			for (var i = 0, len = this.array_.length; i < len; i++) {
				array.push(this$1$1.array_[i]);
			}

			return array
		};

		/**
		 * @override
		 */
		ArrayList.prototype.remove = function remove(o) {
			var this$1$1 = this;

			var found = false;

			for (var i = 0, len = this.array_.length; i < len; i++) {
				if (this$1$1.array_[i] === o) {
					this$1$1.array_.splice(i, 1);
					found = true;
					break
				}
			}

			return found
		};

		return ArrayList;
	}(List));

	/**
	 * @extends {Iterator}
	 * @param {ArrayList} arrayList
	 * @constructor
	 * @private
	 */
	var Iterator_ = (function (Iterator$$1) {
		function Iterator_(arrayList) {
			Iterator$$1.call(this);
			/**
			 * @type {ArrayList}
			 * @private
			*/
			this.arrayList_ = arrayList;
			/**
			 * @type {number}
			 * @private
			*/
			this.position_ = 0;
		}

		if (Iterator$$1) Iterator_.__proto__ = Iterator$$1;
		Iterator_.prototype = Object.create(Iterator$$1 && Iterator$$1.prototype);
		Iterator_.prototype.constructor = Iterator_;

		/**
		 * @override
		 */
		Iterator_.prototype.next = function next() {
			if (this.position_ === this.arrayList_.size()) {
				throw new NoSuchElementException()
			}
			return this.arrayList_.get(this.position_++)
		};

		/**
		 * @override
		 */
		Iterator_.prototype.hasNext = function hasNext() {
			if (this.position_ < this.arrayList_.size()) {
				return true
			} else {
				return false
			}
		};

		/**
		 * TODO: should be in ListIterator
		 * @override
		 */
		Iterator_.prototype.set = function set(element) {
			return this.arrayList_.set(this.position_ - 1, element)
		};

		/**
		 * @override
		 */
		Iterator_.prototype.remove = function remove() {
			this.arrayList_.remove(this.arrayList_.get(this.position_));
		};

		return Iterator_;
	}(Iterator));

	var CoordinateList = (function (ArrayList$$1) {
		function CoordinateList() {
			ArrayList$$1.call(this);
			if (arguments.length === 0); else if (arguments.length === 1) {
				var coord = arguments[0];
				this.ensureCapacity(coord.length);
				this.add(coord, true);
			} else if (arguments.length === 2) {
				var coord$1 = arguments[0];
				var allowRepeated = arguments[1];
				this.ensureCapacity(coord$1.length);
				this.add(coord$1, allowRepeated);
			}
		}

		if (ArrayList$$1) CoordinateList.__proto__ = ArrayList$$1;
		CoordinateList.prototype = Object.create(ArrayList$$1 && ArrayList$$1.prototype);
		CoordinateList.prototype.constructor = CoordinateList;

		var staticAccessors = { coordArrayType: { configurable: true } };
		staticAccessors.coordArrayType.get = function () { return new Array(0).fill(null) };
		CoordinateList.prototype.getCoordinate = function getCoordinate(i) {
			return this.get(i)
		};
		CoordinateList.prototype.addAll = function addAll() {
			var this$1$1 = this;

			if (arguments.length === 2) {
				var coll = arguments[0];
				var allowRepeated = arguments[1];
				var isChanged = false;
				for (var i = coll.iterator(); i.hasNext();) {
					this$1$1.add(i.next(), allowRepeated);
					isChanged = true;
				}
				return isChanged
			} else { return ArrayList$$1.prototype.addAll.apply(this, arguments) }
		};
		CoordinateList.prototype.clone = function clone() {
			var this$1$1 = this;

			var clone = ArrayList$$1.prototype.clone.call(this);
			for (var i = 0; i < this.size(); i++) {
				clone.add(i, this$1$1.get(i).copy());
			}
			return clone
		};
		CoordinateList.prototype.toCoordinateArray = function toCoordinateArray() {
			return this.toArray(CoordinateList.coordArrayType)
		};
		CoordinateList.prototype.add = function add() {
			var this$1$1 = this;

			if (arguments.length === 1) {
				var coord = arguments[0];
				ArrayList$$1.prototype.add.call(this, coord);
			} else if (arguments.length === 2) {
				if (arguments[0] instanceof Array && typeof arguments[1] === 'boolean') {
					var coord$1 = arguments[0];
					var allowRepeated = arguments[1];
					this.add(coord$1, allowRepeated, true);
					return true
				} else if (arguments[0] instanceof Coordinate && typeof arguments[1] === 'boolean') {
					var coord$2 = arguments[0];
					var allowRepeated$1 = arguments[1];
					if (!allowRepeated$1) {
						if (this.size() >= 1) {
							var last = this.get(this.size() - 1);
							if (last.equals2D(coord$2)) { return null }
						}
					}
					ArrayList$$1.prototype.add.call(this, coord$2);
				} else if (arguments[0] instanceof Object && typeof arguments[1] === 'boolean') {
					var obj = arguments[0];
					var allowRepeated$2 = arguments[1];
					this.add(obj, allowRepeated$2);
					return true
				}
			} else if (arguments.length === 3) {
				if (typeof arguments[2] === 'boolean' && (arguments[0] instanceof Array && typeof arguments[1] === 'boolean')) {
					var coord$3 = arguments[0];
					var allowRepeated$3 = arguments[1];
					var direction = arguments[2];
					if (direction) {
						for (var i$1 = 0; i$1 < coord$3.length; i$1++) {
							this$1$1.add(coord$3[i$1], allowRepeated$3);
						}
					} else {
						for (var i$2 = coord$3.length - 1; i$2 >= 0; i$2--) {
							this$1$1.add(coord$3[i$2], allowRepeated$3);
						}
					}
					return true
				} else if (typeof arguments[2] === 'boolean' && (Number.isInteger(arguments[0]) && arguments[1] instanceof Coordinate)) {
					var i$3 = arguments[0];
					var coord$4 = arguments[1];
					var allowRepeated$4 = arguments[2];
					if (!allowRepeated$4) {
						var size = this.size();
						if (size > 0) {
							if (i$3 > 0) {
								var prev = this.get(i$3 - 1);
								if (prev.equals2D(coord$4)) { return null }
							}
							if (i$3 < size) {
								var next = this.get(i$3);
								if (next.equals2D(coord$4)) { return null }
							}
						}
					}
					ArrayList$$1.prototype.add.call(this, i$3, coord$4);
				}
			} else if (arguments.length === 4) {
				var coord$5 = arguments[0];
				var allowRepeated$5 = arguments[1];
				var start = arguments[2];
				var end = arguments[3];
				var inc = 1;
				if (start > end) { inc = -1; }
				for (var i = start; i !== end; i += inc) {
					this$1$1.add(coord$5[i], allowRepeated$5);
				}
				return true
			}
		};
		CoordinateList.prototype.closeRing = function closeRing() {
			if (this.size() > 0) { this.add(new Coordinate(this.get(0)), false); }
		};
		CoordinateList.prototype.interfaces_ = function interfaces_() {
			return []
		};
		CoordinateList.prototype.getClass = function getClass() {
			return CoordinateList
		};

		Object.defineProperties(CoordinateList, staticAccessors);

		return CoordinateList;
	}(ArrayList));

	var CoordinateArrays = function CoordinateArrays() { };

	var staticAccessors$13 = { ForwardComparator: { configurable: true }, BidirectionalComparator: { configurable: true }, coordArrayType: { configurable: true } };

	staticAccessors$13.ForwardComparator.get = function () { return ForwardComparator };
	staticAccessors$13.BidirectionalComparator.get = function () { return BidirectionalComparator };
	staticAccessors$13.coordArrayType.get = function () { return new Array(0).fill(null) };

	CoordinateArrays.prototype.interfaces_ = function interfaces_() {
		return []
	};
	CoordinateArrays.prototype.getClass = function getClass() {
		return CoordinateArrays
	};
	CoordinateArrays.isRing = function isRing(pts) {
		if (pts.length < 4) { return false }
		if (!pts[0].equals2D(pts[pts.length - 1])) { return false }
		return true
	};
	CoordinateArrays.ptNotInList = function ptNotInList(testPts, pts) {
		for (var i = 0; i < testPts.length; i++) {
			var testPt = testPts[i];
			if (CoordinateArrays.indexOf(testPt, pts) < 0) { return testPt }
		}
		return null
	};
	CoordinateArrays.scroll = function scroll(coordinates, firstCoordinate) {
		var i = CoordinateArrays.indexOf(firstCoordinate, coordinates);
		if (i < 0) { return null }
		var newCoordinates = new Array(coordinates.length).fill(null);
		System.arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);
		System.arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);
		System.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);
	};
	CoordinateArrays.equals = function equals() {
		if (arguments.length === 2) {
			var coord1 = arguments[0];
			var coord2 = arguments[1];
			if (coord1 === coord2) { return true }
			if (coord1 === null || coord2 === null) { return false }
			if (coord1.length !== coord2.length) { return false }
			for (var i = 0; i < coord1.length; i++) {
				if (!coord1[i].equals(coord2[i])) { return false }
			}
			return true
		} else if (arguments.length === 3) {
			var coord1$1 = arguments[0];
			var coord2$1 = arguments[1];
			var coordinateComparator = arguments[2];
			if (coord1$1 === coord2$1) { return true }
			if (coord1$1 === null || coord2$1 === null) { return false }
			if (coord1$1.length !== coord2$1.length) { return false }
			for (var i$1 = 0; i$1 < coord1$1.length; i$1++) {
				if (coordinateComparator.compare(coord1$1[i$1], coord2$1[i$1]) !== 0) { return false }
			}
			return true
		}
	};
	CoordinateArrays.intersection = function intersection(coordinates, env) {
		var coordList = new CoordinateList();
		for (var i = 0; i < coordinates.length; i++) {
			if (env.intersects(coordinates[i])) { coordList.add(coordinates[i], true); }
		}
		return coordList.toCoordinateArray()
	};
	CoordinateArrays.hasRepeatedPoints = function hasRepeatedPoints(coord) {
		for (var i = 1; i < coord.length; i++) {
			if (coord[i - 1].equals(coord[i])) {
				return true
			}
		}
		return false
	};
	CoordinateArrays.removeRepeatedPoints = function removeRepeatedPoints(coord) {
		if (!CoordinateArrays.hasRepeatedPoints(coord)) { return coord }
		var coordList = new CoordinateList(coord, false);
		return coordList.toCoordinateArray()
	};
	CoordinateArrays.reverse = function reverse(coord) {
		var last = coord.length - 1;
		var mid = Math.trunc(last / 2);
		for (var i = 0; i <= mid; i++) {
			var tmp = coord[i];
			coord[i] = coord[last - i];
			coord[last - i] = tmp;
		}
	};
	CoordinateArrays.removeNull = function removeNull(coord) {
		var nonNull = 0;
		for (var i = 0; i < coord.length; i++) {
			if (coord[i] !== null) { nonNull++; }
		}
		var newCoord = new Array(nonNull).fill(null);
		if (nonNull === 0) { return newCoord }
		var j = 0;
		for (var i$1 = 0; i$1 < coord.length; i$1++) {
			if (coord[i$1] !== null) { newCoord[j++] = coord[i$1]; }
		}
		return newCoord
	};
	CoordinateArrays.copyDeep = function copyDeep() {
		if (arguments.length === 1) {
			var coordinates = arguments[0];
			var copy = new Array(coordinates.length).fill(null);
			for (var i = 0; i < coordinates.length; i++) {
				copy[i] = new Coordinate(coordinates[i]);
			}
			return copy
		} else if (arguments.length === 5) {
			var src = arguments[0];
			var srcStart = arguments[1];
			var dest = arguments[2];
			var destStart = arguments[3];
			var length = arguments[4];
			for (var i$1 = 0; i$1 < length; i$1++) {
				dest[destStart + i$1] = new Coordinate(src[srcStart + i$1]);
			}
		}
	};
	CoordinateArrays.isEqualReversed = function isEqualReversed(pts1, pts2) {
		for (var i = 0; i < pts1.length; i++) {
			var p1 = pts1[i];
			var p2 = pts2[pts1.length - i - 1];
			if (p1.compareTo(p2) !== 0) { return false }
		}
		return true
	};
	CoordinateArrays.envelope = function envelope(coordinates) {
		var env = new Envelope();
		for (var i = 0; i < coordinates.length; i++) {
			env.expandToInclude(coordinates[i]);
		}
		return env
	};
	CoordinateArrays.toCoordinateArray = function toCoordinateArray(coordList) {
		return coordList.toArray(CoordinateArrays.coordArrayType)
	};
	CoordinateArrays.atLeastNCoordinatesOrNothing = function atLeastNCoordinatesOrNothing(n, c) {
		return c.length >= n ? c : []
	};
	CoordinateArrays.indexOf = function indexOf(coordinate, coordinates) {
		for (var i = 0; i < coordinates.length; i++) {
			if (coordinate.equals(coordinates[i])) {
				return i
			}
		}
		return -1
	};
	CoordinateArrays.increasingDirection = function increasingDirection(pts) {
		for (var i = 0; i < Math.trunc(pts.length / 2); i++) {
			var j = pts.length - 1 - i;
			var comp = pts[i].compareTo(pts[j]);
			if (comp !== 0) { return comp }
		}
		return 1
	};
	CoordinateArrays.compare = function compare(pts1, pts2) {
		var i = 0;
		while (i < pts1.length && i < pts2.length) {
			var compare = pts1[i].compareTo(pts2[i]);
			if (compare !== 0) { return compare }
			i++;
		}
		if (i < pts2.length) { return -1 }
		if (i < pts1.length) { return 1 }
		return 0
	};
	CoordinateArrays.minCoordinate = function minCoordinate(coordinates) {
		var minCoord = null;
		for (var i = 0; i < coordinates.length; i++) {
			if (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) {
				minCoord = coordinates[i];
			}
		}
		return minCoord
	};
	CoordinateArrays.extract = function extract(pts, start, end) {
		start = MathUtil.clamp(start, 0, pts.length);
		end = MathUtil.clamp(end, -1, pts.length);
		var npts = end - start + 1;
		if (end < 0) { npts = 0; }
		if (start >= pts.length) { npts = 0; }
		if (end < start) { npts = 0; }
		var extractPts = new Array(npts).fill(null);
		if (npts === 0) { return extractPts }
		var iPts = 0;
		for (var i = start; i <= end; i++) {
			extractPts[iPts++] = pts[i];
		}
		return extractPts
	};

	Object.defineProperties(CoordinateArrays, staticAccessors$13);

	var ForwardComparator = function ForwardComparator() { };

	ForwardComparator.prototype.compare = function compare(o1, o2) {
		var pts1 = o1;
		var pts2 = o2;
		return CoordinateArrays.compare(pts1, pts2)
	};
	ForwardComparator.prototype.interfaces_ = function interfaces_() {
		return [Comparator]
	};
	ForwardComparator.prototype.getClass = function getClass() {
		return ForwardComparator
	};

	var BidirectionalComparator = function BidirectionalComparator() { };

	BidirectionalComparator.prototype.compare = function compare(o1, o2) {
		var pts1 = o1;
		var pts2 = o2;
		if (pts1.length < pts2.length) { return -1 }
		if (pts1.length > pts2.length) { return 1 }
		if (pts1.length === 0) { return 0 }
		var forwardComp = CoordinateArrays.compare(pts1, pts2);
		var isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);
		if (isEqualRev) { return 0 }
		return forwardComp
	};
	BidirectionalComparator.prototype.OLDcompare = function OLDcompare(o1, o2) {
		var pts1 = o1;
		var pts2 = o2;
		if (pts1.length < pts2.length) { return -1 }
		if (pts1.length > pts2.length) { return 1 }
		if (pts1.length === 0) { return 0 }
		var dir1 = CoordinateArrays.increasingDirection(pts1);
		var dir2 = CoordinateArrays.increasingDirection(pts2);
		var i1 = dir1 > 0 ? 0 : pts1.length - 1;
		var i2 = dir2 > 0 ? 0 : pts1.length - 1;
		for (var i = 0; i < pts1.length; i++) {
			var comparePt = pts1[i1].compareTo(pts2[i2]);
			if (comparePt !== 0) { return comparePt }
			i1 += dir1;
			i2 += dir2;
		}
		return 0
	};
	BidirectionalComparator.prototype.interfaces_ = function interfaces_() {
		return [Comparator]
	};
	BidirectionalComparator.prototype.getClass = function getClass() {
		return BidirectionalComparator
	};

	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/Map.html
	 *
	 * @constructor
	 * @private
	 */
	var Map$1 = function Map() { };

	Map$1.prototype.get = function get() { };
	/**
	 * Associates the specified value with the specified key in this map (optional
	 * operation).
	 * @param {Object} key
	 * @param {Object} value
	 * @return {Object}
	 */
	Map$1.prototype.put = function put() { };

	/**
	 * Returns the number of key-value mappings in this map.
	 * @return {number}
	 */
	Map$1.prototype.size = function size() { };

	/**
	 * Returns a Collection view of the values contained in this map.
	 * @return {javascript.util.Collection}
	 */
	Map$1.prototype.values = function values() { };

	/**
	 * Returns a {@link Set} view of the mappings contained in this map.
	 * The set is backed by the map, so changes to the map are
	 * reflected in the set, and vice-versa.If the map is modified
	 * while an iteration over the set is in progress (except through
	 * the iterator's own <tt>remove</tt> operation, or through the
	 * <tt>setValue</tt> operation on a map entry returned by the
	 * iterator) the results of the iteration are undefined.The set
	 * supports element removal, which removes the corresponding
	 * mapping from the map, via the <tt>Iterator.remove</tt>,
	 * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and
	 * <tt>clear</tt> operations.It does not support the
	 * <tt>add</tt> or <tt>addAll</tt> operations.
	 *
	 * @return {Set} a set view of the mappings contained in this map
	 */
	Map$1.prototype.entrySet = function entrySet() { };

	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedMap.html
	 *
	 * @extends {Map}
	 * @constructor
	 * @private
	 */
	var SortedMap = (function (Map) {
		function SortedMap() {
			Map.apply(this, arguments);
		} if (Map) SortedMap.__proto__ = Map;
		SortedMap.prototype = Object.create(Map && Map.prototype);
		SortedMap.prototype.constructor = SortedMap;



		return SortedMap;
	}(Map$1));

	/**
	 * @param {string=} message Optional message
	 * @extends {Error}
	 * @constructor
	 * @private
	 */
	function OperationNotSupported(message) {
		this.message = message || '';
	}
	OperationNotSupported.prototype = new Error();

	/**
	 * @type {string}
	 */
	OperationNotSupported.prototype.name = 'OperationNotSupported';

	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/Set.html
	 *
	 * @extends {Collection}
	 * @constructor
	 * @private
	 */
	function Set() { }
	Set.prototype = new Collection();


	/**
	 * Returns true if this set contains the specified element. More formally,
	 * returns true if and only if this set contains an element e such that (o==null ?
	 * e==null : o.equals(e)).
	 * @param {Object} e
	 * @return {boolean}
	 */
	Set.prototype.contains = function () { };

	/**
	 * @see http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html
	 *
	 * @extends {javascript.util.Set}
	 * @constructor
	 * @private
	 */
	var HashSet = (function (Set$$1) {
		function HashSet() {
			Set$$1.call(this);
			this.array_ = [];

			if (arguments[0] instanceof Collection) {
				this.addAll(arguments[0]);
			}
		}

		if (Set$$1) HashSet.__proto__ = Set$$1;
		HashSet.prototype = Object.create(Set$$1 && Set$$1.prototype);
		HashSet.prototype.constructor = HashSet;

		/**
		 * @override
		 */
		HashSet.prototype.contains = function contains(o) {
			var this$1$1 = this;

			for (var i = 0, len = this.array_.length; i < len; i++) {
				var e = this$1$1.array_[i];
				if (e === o) {
					return true
				}
			}
			return false
		};

		/**
		 * @override
		 */
		HashSet.prototype.add = function add(o) {
			if (this.contains(o)) {
				return false
			}

			this.array_.push(o);

			return true
		};

		/**
		 * @override
		 */
		HashSet.prototype.addAll = function addAll(c) {
			var this$1$1 = this;

			for (var i = c.iterator(); i.hasNext();) {
				this$1$1.add(i.next());
			}
			return true
		};

		/**
		 * @override
		 */
		HashSet.prototype.remove = function remove(o) {
			// throw new javascript.util.OperationNotSupported()
			throw new Error()
		};

		/**
		 * @override
		 */
		HashSet.prototype.size = function size() {
			return this.array_.length
		};

		/**
		 * @override
		 */
		HashSet.prototype.isEmpty = function isEmpty() {
			return this.array_.length === 0
		};

		/**
		 * @override
		 */
		HashSet.prototype.toArray = function toArray() {
			var this$1$1 = this;

			var array = [];

			for (var i = 0, len = this.array_.length; i < len; i++) {
				array.push(this$1$1.array_[i]);
			}

			return array
		};

		/**
		 * @override
		 */
		HashSet.prototype.iterator = function iterator() {
			return new Iterator_$1(this)
		};

		return HashSet;
	}(Set));

	/**
	   * @extends {Iterator}
	   * @param {HashSet} hashSet
	   * @constructor
	   * @private
	   */
	var Iterator_$1 = (function (Iterator$$1) {
		function Iterator_(hashSet) {
			Iterator$$1.call(this);
			/**
			 * @type {HashSet}
			 * @private
			 */
			this.hashSet_ = hashSet;
			/**
			 * @type {number}
			 * @private
			 */
			this.position_ = 0;
		}

		if (Iterator$$1) Iterator_.__proto__ = Iterator$$1;
		Iterator_.prototype = Object.create(Iterator$$1 && Iterator$$1.prototype);
		Iterator_.prototype.constructor = Iterator_;

		/**
		 * @override
		 */
		Iterator_.prototype.next = function next() {
			if (this.position_ === this.hashSet_.size()) {
				throw new NoSuchElementException()
			}
			return this.hashSet_.array_[this.position_++]
		};

		/**
		 * @override
		 */
		Iterator_.prototype.hasNext = function hasNext() {
			if (this.position_ < this.hashSet_.size()) {
				return true
			} else {
				return false
			}
		};

		/**
		 * @override
		 */
		Iterator_.prototype.remove = function remove() {
			throw new OperationNotSupported()
		};

		return Iterator_;
	}(Iterator));

	var BLACK = 0;
	var RED = 1;
	function colorOf(p) { return (p === null ? BLACK : p.color) }
	function parentOf(p) { return (p === null ? null : p.parent) }
	function setColor(p, c) { if (p !== null) { p.color = c; } }
	function leftOf(p) { return (p === null ? null : p.left) }
	function rightOf(p) { return (p === null ? null : p.right) }

	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeMap.html
	 *
	 * @extends {SortedMap}
	 * @constructor
	 * @private
	 */
	function TreeMap() {
		/**
		 * @type {Object}
		 * @private
		 */
		this.root_ = null;
		/**
		 * @type {number}
		 * @private
		*/
		this.size_ = 0;
	}
	TreeMap.prototype = new SortedMap();

	/**
	 * @override
	 */
	TreeMap.prototype.get = function (key) {
		var p = this.root_;
		while (p !== null) {
			var cmp = key['compareTo'](p.key);
			if (cmp < 0) { p = p.left; }
			else if (cmp > 0) { p = p.right; }
			else { return p.value }
		}
		return null
	};

	/**
	 * @override
	 */
	TreeMap.prototype.put = function (key, value) {
		if (this.root_ === null) {
			this.root_ = {
				key: key,
				value: value,
				left: null,
				right: null,
				parent: null,
				color: BLACK,
				getValue: function getValue() { return this.value },
				getKey: function getKey() { return this.key }
			};
			this.size_ = 1;
			return null
		}
		var t = this.root_;
		var parent;
		var cmp;
		do {
			parent = t;
			cmp = key['compareTo'](t.key);
			if (cmp < 0) {
				t = t.left;
			} else if (cmp > 0) {
				t = t.right;
			} else {
				var oldValue = t.value;
				t.value = value;
				return oldValue
			}
		} while (t !== null)
		var e = {
			key: key,
			left: null,
			right: null,
			value: value,
			parent: parent,
			color: BLACK,
			getValue: function getValue() { return this.value },
			getKey: function getKey() { return this.key }
		};
		if (cmp < 0) {
			parent.left = e;
		} else {
			parent.right = e;
		}
		this.fixAfterInsertion(e);
		this.size_++;
		return null
	};

	/**
	 * @param {Object} x
	 */
	TreeMap.prototype.fixAfterInsertion = function (x) {
		var this$1$1 = this;

		x.color = RED;
		while (x != null && x !== this.root_ && x.parent.color === RED) {
			if (parentOf(x) === leftOf(parentOf(parentOf(x)))) {
				var y = rightOf(parentOf(parentOf(x)));
				if (colorOf(y) === RED) {
					setColor(parentOf(x), BLACK);
					setColor(y, BLACK);
					setColor(parentOf(parentOf(x)), RED);
					x = parentOf(parentOf(x));
				} else {
					if (x === rightOf(parentOf(x))) {
						x = parentOf(x);
						this$1$1.rotateLeft(x);
					}
					setColor(parentOf(x), BLACK);
					setColor(parentOf(parentOf(x)), RED);
					this$1$1.rotateRight(parentOf(parentOf(x)));
				}
			} else {
				var y$1 = leftOf(parentOf(parentOf(x)));
				if (colorOf(y$1) === RED) {
					setColor(parentOf(x), BLACK);
					setColor(y$1, BLACK);
					setColor(parentOf(parentOf(x)), RED);
					x = parentOf(parentOf(x));
				} else {
					if (x === leftOf(parentOf(x))) {
						x = parentOf(x);
						this$1$1.rotateRight(x);
					}
					setColor(parentOf(x), BLACK);
					setColor(parentOf(parentOf(x)), RED);
					this$1$1.rotateLeft(parentOf(parentOf(x)));
				}
			}
		}
		this.root_.color = BLACK;
	};

	/**
	 * @override
	 */
	TreeMap.prototype.values = function () {
		var arrayList = new ArrayList();
		var p = this.getFirstEntry();
		if (p !== null) {
			arrayList.add(p.value);
			while ((p = TreeMap.successor(p)) !== null) {
				arrayList.add(p.value);
			}
		}
		return arrayList
	};

	/**
	 * @override
	 */
	TreeMap.prototype.entrySet = function () {
		var hashSet = new HashSet();
		var p = this.getFirstEntry();
		if (p !== null) {
			hashSet.add(p);
			while ((p = TreeMap.successor(p)) !== null) {
				hashSet.add(p);
			}
		}
		return hashSet
	};

	/**
	 * @param {Object} p
	 */
	TreeMap.prototype.rotateLeft = function (p) {
		if (p != null) {
			var r = p.right;
			p.right = r.left;
			if (r.left != null) { r.left.parent = p; }
			r.parent = p.parent;
			if (p.parent === null) { this.root_ = r; } else if (p.parent.left === p) { p.parent.left = r; } else { p.parent.right = r; }
			r.left = p;
			p.parent = r;
		}
	};

	/**
	 * @param {Object} p
	 */
	TreeMap.prototype.rotateRight = function (p) {
		if (p != null) {
			var l = p.left;
			p.left = l.right;
			if (l.right != null) { l.right.parent = p; }
			l.parent = p.parent;
			if (p.parent === null) { this.root_ = l; } else if (p.parent.right === p) { p.parent.right = l; } else { p.parent.left = l; }
			l.right = p;
			p.parent = l;
		}
	};

	/**
	 * @return {Object}
	 */
	TreeMap.prototype.getFirstEntry = function () {
		var p = this.root_;
		if (p != null) {
			while (p.left != null) {
				p = p.left;
			}
		}
		return p
	};

	/**
	 * @param {Object} t
	 * @return {Object}
	 * @private
	 */
	TreeMap.successor = function (t) {
		if (t === null) { return null } else if (t.right !== null) {
			var p = t.right;
			while (p.left !== null) {
				p = p.left;
			}
			return p
		} else {
			var p$1 = t.parent;
			var ch = t;
			while (p$1 !== null && ch === p$1.right) {
				ch = p$1;
				p$1 = p$1.parent;
			}
			return p$1
		}
	};

	/**
	 * @override
	 */
	TreeMap.prototype.size = function () {
		return this.size_
	};

	var Lineal = function Lineal() { };

	Lineal.prototype.interfaces_ = function interfaces_() {
		return []
	};
	Lineal.prototype.getClass = function getClass() {
		return Lineal
	};

	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedSet.html
	 *
	 * @extends {Set}
	 * @constructor
	 * @private
	 */
	function SortedSet() { }
	SortedSet.prototype = new Set();

	// import Iterator from './Iterator'
	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeSet.html
	 *
	 * @extends {SortedSet}
	 * @constructor
	 * @private
	 */
	function TreeSet() {
		/**
		 * @type {Array}
		 * @private
		*/
		this.array_ = [];

		if (arguments[0] instanceof Collection) {
			this.addAll(arguments[0]);
		}
	}
	TreeSet.prototype = new SortedSet();

	/**
	 * @override
	 */
	TreeSet.prototype.contains = function (o) {
		var this$1$1 = this;

		for (var i = 0, len = this.array_.length; i < len; i++) {
			var e = this$1$1.array_[i];
			if (e['compareTo'](o) === 0) {
				return true
			}
		}
		return false
	};

	/**
	 * @override
	 */
	TreeSet.prototype.add = function (o) {
		var this$1$1 = this;

		if (this.contains(o)) {
			return false
		}

		for (var i = 0, len = this.array_.length; i < len; i++) {
			var e = this$1$1.array_[i];
			if (e['compareTo'](o) === 1) {
				this$1$1.array_.splice(i, 0, o);
				return true
			}
		}

		this.array_.push(o);

		return true
	};

	/**
	 * @override
	 */
	TreeSet.prototype.addAll = function (c) {
		var this$1$1 = this;

		for (var i = c.iterator(); i.hasNext();) {
			this$1$1.add(i.next());
		}
		return true
	};

	/**
	 * @override
	 */
	TreeSet.prototype.remove = function (e) {
		throw new OperationNotSupported()
	};

	/**
	 * @override
	 */
	TreeSet.prototype.size = function () {
		return this.array_.length
	};

	/**
	 * @override
	 */
	TreeSet.prototype.isEmpty = function () {
		return this.array_.length === 0
	};

	/**
	 * @override
	 */
	TreeSet.prototype.toArray = function () {
		var this$1$1 = this;

		var array = [];

		for (var i = 0, len = this.array_.length; i < len; i++) {
			array.push(this$1$1.array_[i]);
		}

		return array
	};

	/**
	 * @override
	 */
	TreeSet.prototype.iterator = function () {
		return new Iterator_$2(this)
	};

	/**
	 * @extends {javascript.util.Iterator}
	 * @param {javascript.util.TreeSet} treeSet
	 * @constructor
	 * @private
	 */
	var Iterator_$2 = function (treeSet) {
		/**
		 * @type {javascript.util.TreeSet}
		 * @private
		 */
		this.treeSet_ = treeSet;
		/**
		 * @type {number}
		 * @private
		 */
		this.position_ = 0;
	};

	/**
	 * @override
	 */
	Iterator_$2.prototype.next = function () {
		if (this.position_ === this.treeSet_.size()) {
			throw new NoSuchElementException()
		}
		return this.treeSet_.array_[this.position_++]
	};

	/**
	 * @override
	 */
	Iterator_$2.prototype.hasNext = function () {
		if (this.position_ < this.treeSet_.size()) {
			return true
		} else {
			return false
		}
	};

	/**
	 * @override
	 */
	Iterator_$2.prototype.remove = function () {
		throw new OperationNotSupported()
	};

	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/Arrays.html
	 *
	 * @constructor
	 * @private
	 */
	var Arrays = function Arrays() { };

	Arrays.sort = function sort() {
		var a = arguments[0];
		var i;
		var t;
		var comparator;
		var compare;
		if (arguments.length === 1) {
			compare = function (a, b) {
				return a.compareTo(b)
			};
			a.sort(compare);
		} else if (arguments.length === 2) {
			comparator = arguments[1];
			compare = function (a, b) {
				return comparator['compare'](a, b)
			};
			a.sort(compare);
		} else if (arguments.length === 3) {
			t = a.slice(arguments[1], arguments[2]);
			t.sort();
			var r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));
			a.splice(0, a.length);
			for (i = 0; i < r.length; i++) {
				a.push(r[i]);
			}
		} else if (arguments.length === 4) {
			t = a.slice(arguments[1], arguments[2]);
			comparator = arguments[3];
			compare = function (a, b) {
				return comparator['compare'](a, b)
			};
			t.sort(compare);
			r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));
			a.splice(0, a.length);
			for (i = 0; i < r.length; i++) {
				a.push(r[i]);
			}
		}
	};
	/**
	 * @param {Array} array
	 * @return {ArrayList}
	 */
	Arrays.asList = function asList(array) {
		var arrayList = new ArrayList();
		for (var i = 0, len = array.length; i < len; i++) {
			arrayList.add(array[i]);
		}
		return arrayList
	};

	var Dimension = function Dimension() { };

	var staticAccessors$14 = { P: { configurable: true }, L: { configurable: true }, A: { configurable: true }, FALSE: { configurable: true }, TRUE: { configurable: true }, DONTCARE: { configurable: true }, SYM_FALSE: { configurable: true }, SYM_TRUE: { configurable: true }, SYM_DONTCARE: { configurable: true }, SYM_P: { configurable: true }, SYM_L: { configurable: true }, SYM_A: { configurable: true } };

	staticAccessors$14.P.get = function () { return 0 };
	staticAccessors$14.L.get = function () { return 1 };
	staticAccessors$14.A.get = function () { return 2 };
	staticAccessors$14.FALSE.get = function () { return -1 };
	staticAccessors$14.TRUE.get = function () { return -2 };
	staticAccessors$14.DONTCARE.get = function () { return -3 };
	staticAccessors$14.SYM_FALSE.get = function () { return 'F' };
	staticAccessors$14.SYM_TRUE.get = function () { return 'T' };
	staticAccessors$14.SYM_DONTCARE.get = function () { return '*' };
	staticAccessors$14.SYM_P.get = function () { return '0' };
	staticAccessors$14.SYM_L.get = function () { return '1' };
	staticAccessors$14.SYM_A.get = function () { return '2' };

	Dimension.prototype.interfaces_ = function interfaces_() {
		return []
	};
	Dimension.prototype.getClass = function getClass() {
		return Dimension
	};
	Dimension.toDimensionSymbol = function toDimensionSymbol(dimensionValue) {
		switch (dimensionValue) {
			case Dimension.FALSE:
				return Dimension.SYM_FALSE
			case Dimension.TRUE:
				return Dimension.SYM_TRUE
			case Dimension.DONTCARE:
				return Dimension.SYM_DONTCARE
			case Dimension.P:
				return Dimension.SYM_P
			case Dimension.L:
				return Dimension.SYM_L
			case Dimension.A:
				return Dimension.SYM_A
		}
		throw new IllegalArgumentException('Unknown dimension value: ' + dimensionValue)
	};
	Dimension.toDimensionValue = function toDimensionValue(dimensionSymbol) {
		switch (Character.toUpperCase(dimensionSymbol)) {
			case Dimension.SYM_FALSE:
				return Dimension.FALSE
			case Dimension.SYM_TRUE:
				return Dimension.TRUE
			case Dimension.SYM_DONTCARE:
				return Dimension.DONTCARE
			case Dimension.SYM_P:
				return Dimension.P
			case Dimension.SYM_L:
				return Dimension.L
			case Dimension.SYM_A:
				return Dimension.A
		}
		throw new IllegalArgumentException('Unknown dimension symbol: ' + dimensionSymbol)
	};

	Object.defineProperties(Dimension, staticAccessors$14);

	var GeometryFilter = function GeometryFilter() { };

	GeometryFilter.prototype.filter = function filter(geom) { };
	GeometryFilter.prototype.interfaces_ = function interfaces_() {
		return []
	};
	GeometryFilter.prototype.getClass = function getClass() {
		return GeometryFilter
	};

	var CoordinateSequenceFilter = function CoordinateSequenceFilter() { };

	CoordinateSequenceFilter.prototype.filter = function filter(seq, i) { };
	CoordinateSequenceFilter.prototype.isDone = function isDone() { };
	CoordinateSequenceFilter.prototype.isGeometryChanged = function isGeometryChanged() { };
	CoordinateSequenceFilter.prototype.interfaces_ = function interfaces_() {
		return []
	};
	CoordinateSequenceFilter.prototype.getClass = function getClass() {
		return CoordinateSequenceFilter
	};

	var GeometryCollection = (function (Geometry$$1) {
		function GeometryCollection(geometries, factory) {
			Geometry$$1.call(this, factory);
			this._geometries = geometries || [];

			if (Geometry$$1.hasNullElements(this._geometries)) {
				throw new IllegalArgumentException('geometries must not contain null elements')
			}
		}

		if (Geometry$$1) GeometryCollection.__proto__ = Geometry$$1;
		GeometryCollection.prototype = Object.create(Geometry$$1 && Geometry$$1.prototype);
		GeometryCollection.prototype.constructor = GeometryCollection;

		var staticAccessors = { serialVersionUID: { configurable: true } };
		GeometryCollection.prototype.computeEnvelopeInternal = function computeEnvelopeInternal() {
			var this$1$1 = this;

			var envelope = new Envelope();
			for (var i = 0; i < this._geometries.length; i++) {
				envelope.expandToInclude(this$1$1._geometries[i].getEnvelopeInternal());
			}
			return envelope
		};
		GeometryCollection.prototype.getGeometryN = function getGeometryN(n) {
			return this._geometries[n]
		};
		GeometryCollection.prototype.getSortIndex = function getSortIndex() {
			return Geometry$$1.SORTINDEX_GEOMETRYCOLLECTION
		};
		GeometryCollection.prototype.getCoordinates = function getCoordinates() {
			var this$1$1 = this;

			var coordinates = new Array(this.getNumPoints()).fill(null);
			var k = -1;
			for (var i = 0; i < this._geometries.length; i++) {
				var childCoordinates = this$1$1._geometries[i].getCoordinates();
				for (var j = 0; j < childCoordinates.length; j++) {
					k++;
					coordinates[k] = childCoordinates[j];
				}
			}
			return coordinates
		};
		GeometryCollection.prototype.getArea = function getArea() {
			var this$1$1 = this;

			var area = 0.0;
			for (var i = 0; i < this._geometries.length; i++) {
				area += this$1$1._geometries[i].getArea();
			}
			return area
		};
		GeometryCollection.prototype.equalsExact = function equalsExact() {
			var this$1$1 = this;

			if (arguments.length === 2) {
				var other = arguments[0];
				var tolerance = arguments[1];
				if (!this.isEquivalentClass(other)) {
					return false
				}
				var otherCollection = other;
				if (this._geometries.length !== otherCollection._geometries.length) {
					return false
				}
				for (var i = 0; i < this._geometries.length; i++) {
					if (!this$1$1._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) {
						return false
					}
				}
				return true
			} else { return Geometry$$1.prototype.equalsExact.apply(this, arguments) }
		};
		GeometryCollection.prototype.normalize = function normalize() {
			var this$1$1 = this;

			for (var i = 0; i < this._geometries.length; i++) {
				this$1$1._geometries[i].normalize();
			}
			Arrays.sort(this._geometries);
		};
		GeometryCollection.prototype.getCoordinate = function getCoordinate() {
			if (this.isEmpty()) { return null }
			return this._geometries[0].getCoordinate()
		};
		GeometryCollection.prototype.getBoundaryDimension = function getBoundaryDimension() {
			var this$1$1 = this;

			var dimension = Dimension.FALSE;
			for (var i = 0; i < this._geometries.length; i++) {
				dimension = Math.max(dimension, this$1$1._geometries[i].getBoundaryDimension());
			}
			return dimension
		};
		GeometryCollection.prototype.getDimension = function getDimension() {
			var this$1$1 = this;

			var dimension = Dimension.FALSE;
			for (var i = 0; i < this._geometries.length; i++) {
				dimension = Math.max(dimension, this$1$1._geometries[i].getDimension());
			}
			return dimension
		};
		GeometryCollection.prototype.getLength = function getLength() {
			var this$1$1 = this;

			var sum = 0.0;
			for (var i = 0; i < this._geometries.length; i++) {
				sum += this$1$1._geometries[i].getLength();
			}
			return sum
		};
		GeometryCollection.prototype.getNumPoints = function getNumPoints() {
			var this$1$1 = this;

			var numPoints = 0;
			for (var i = 0; i < this._geometries.length; i++) {
				numPoints += this$1$1._geometries[i].getNumPoints();
			}
			return numPoints
		};
		GeometryCollection.prototype.getNumGeometries = function getNumGeometries() {
			return this._geometries.length
		};
		GeometryCollection.prototype.reverse = function reverse() {
			var this$1$1 = this;

			var n = this._geometries.length;
			var revGeoms = new Array(n).fill(null);
			for (var i = 0; i < this._geometries.length; i++) {
				revGeoms[i] = this$1$1._geometries[i].reverse();
			}
			return this.getFactory().createGeometryCollection(revGeoms)
		};
		GeometryCollection.prototype.compareToSameClass = function compareToSameClass() {
			var this$1$1 = this;

			if (arguments.length === 1) {
				var o = arguments[0];
				var theseElements = new TreeSet(Arrays.asList(this._geometries));
				var otherElements = new TreeSet(Arrays.asList(o._geometries));
				return this.compare(theseElements, otherElements)
			} else if (arguments.length === 2) {
				var o$1 = arguments[0];
				var comp = arguments[1];
				var gc = o$1;
				var n1 = this.getNumGeometries();
				var n2 = gc.getNumGeometries();
				var i = 0;
				while (i < n1 && i < n2) {
					var thisGeom = this$1$1.getGeometryN(i);
					var otherGeom = gc.getGeometryN(i);
					var holeComp = thisGeom.compareToSameClass(otherGeom, comp);
					if (holeComp !== 0) { return holeComp }
					i++;
				}
				if (i < n1) { return 1 }
				if (i < n2) { return -1 }
				return 0
			}
		};
		GeometryCollection.prototype.apply = function apply() {
			var this$1$1 = this;

			if (hasInterface(arguments[0], CoordinateFilter)) {
				var filter = arguments[0];
				for (var i = 0; i < this._geometries.length; i++) {
					this$1$1._geometries[i].apply(filter);
				}
			} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
				var filter$1 = arguments[0];
				if (this._geometries.length === 0) { return null }
				for (var i$1 = 0; i$1 < this._geometries.length; i$1++) {
					this$1$1._geometries[i$1].apply(filter$1);
					if (filter$1.isDone()) {
						break
					}
				}
				if (filter$1.isGeometryChanged()) { this.geometryChanged(); }
			} else if (hasInterface(arguments[0], GeometryFilter)) {
				var filter$2 = arguments[0];
				filter$2.filter(this);
				for (var i$2 = 0; i$2 < this._geometries.length; i$2++) {
					this$1$1._geometries[i$2].apply(filter$2);
				}
			} else if (hasInterface(arguments[0], GeometryComponentFilter)) {
				var filter$3 = arguments[0];
				filter$3.filter(this);
				for (var i$3 = 0; i$3 < this._geometries.length; i$3++) {
					this$1$1._geometries[i$3].apply(filter$3);
				}
			}
		};
		GeometryCollection.prototype.getBoundary = function getBoundary() {
			this.checkNotGeometryCollection(this);
			Assert.shouldNeverReachHere();
			return null
		};
		GeometryCollection.prototype.clone = function clone() {
			var this$1$1 = this;

			var gc = Geometry$$1.prototype.clone.call(this);
			gc._geometries = new Array(this._geometries.length).fill(null);
			for (var i = 0; i < this._geometries.length; i++) {
				gc._geometries[i] = this$1$1._geometries[i].clone();
			}
			return gc
		};
		GeometryCollection.prototype.getGeometryType = function getGeometryType() {
			return 'GeometryCollection'
		};
		GeometryCollection.prototype.copy = function copy() {
			var this$1$1 = this;

			var geometries = new Array(this._geometries.length).fill(null);
			for (var i = 0; i < geometries.length; i++) {
				geometries[i] = this$1$1._geometries[i].copy();
			}
			return new GeometryCollection(geometries, this._factory)
		};
		GeometryCollection.prototype.isEmpty = function isEmpty() {
			var this$1$1 = this;

			for (var i = 0; i < this._geometries.length; i++) {
				if (!this$1$1._geometries[i].isEmpty()) {
					return false
				}
			}
			return true
		};
		GeometryCollection.prototype.interfaces_ = function interfaces_() {
			return []
		};
		GeometryCollection.prototype.getClass = function getClass() {
			return GeometryCollection
		};
		staticAccessors.serialVersionUID.get = function () { return -5694727726395021467 };

		Object.defineProperties(GeometryCollection, staticAccessors);

		return GeometryCollection;
	}(Geometry));

	var MultiLineString = (function (GeometryCollection$$1) {
		function MultiLineString() {
			GeometryCollection$$1.apply(this, arguments);
		}

		if (GeometryCollection$$1) MultiLineString.__proto__ = GeometryCollection$$1;
		MultiLineString.prototype = Object.create(GeometryCollection$$1 && GeometryCollection$$1.prototype);
		MultiLineString.prototype.constructor = MultiLineString;

		var staticAccessors = { serialVersionUID: { configurable: true } };

		MultiLineString.prototype.getSortIndex = function getSortIndex() {
			return Geometry.SORTINDEX_MULTILINESTRING
		};
		MultiLineString.prototype.equalsExact = function equalsExact() {
			if (arguments.length === 2) {
				var other = arguments[0];
				var tolerance = arguments[1];
				if (!this.isEquivalentClass(other)) {
					return false
				}
				return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance)
			} else { return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments) }
		};
		MultiLineString.prototype.getBoundaryDimension = function getBoundaryDimension() {
			if (this.isClosed()) {
				return Dimension.FALSE
			}
			return 0
		};
		MultiLineString.prototype.isClosed = function isClosed() {
			var this$1$1 = this;

			if (this.isEmpty()) {
				return false
			}
			for (var i = 0; i < this._geometries.length; i++) {
				if (!this$1$1._geometries[i].isClosed()) {
					return false
				}
			}
			return true
		};
		MultiLineString.prototype.getDimension = function getDimension() {
			return 1
		};
		MultiLineString.prototype.reverse = function reverse() {
			var this$1$1 = this;

			var nLines = this._geometries.length;
			var revLines = new Array(nLines).fill(null);
			for (var i = 0; i < this._geometries.length; i++) {
				revLines[nLines - 1 - i] = this$1$1._geometries[i].reverse();
			}
			return this.getFactory().createMultiLineString(revLines)
		};
		MultiLineString.prototype.getBoundary = function getBoundary() {
			return new BoundaryOp(this).getBoundary()
		};
		MultiLineString.prototype.getGeometryType = function getGeometryType() {
			return 'MultiLineString'
		};
		MultiLineString.prototype.copy = function copy() {
			var this$1$1 = this;

			var lineStrings = new Array(this._geometries.length).fill(null);
			for (var i = 0; i < lineStrings.length; i++) {
				lineStrings[i] = this$1$1._geometries[i].copy();
			}
			return new MultiLineString(lineStrings, this._factory)
		};
		MultiLineString.prototype.interfaces_ = function interfaces_() {
			return [Lineal]
		};
		MultiLineString.prototype.getClass = function getClass() {
			return MultiLineString
		};
		staticAccessors.serialVersionUID.get = function () { return 8166665132445433741 };

		Object.defineProperties(MultiLineString, staticAccessors);

		return MultiLineString;
	}(GeometryCollection));

	var BoundaryOp = function BoundaryOp() {
		this._geom = null;
		this._geomFact = null;
		this._bnRule = null;
		this._endpointMap = null;
		if (arguments.length === 1) {
			var geom = arguments[0];
			var bnRule = BoundaryNodeRule.MOD2_BOUNDARY_RULE;
			this._geom = geom;
			this._geomFact = geom.getFactory();
			this._bnRule = bnRule;
		} else if (arguments.length === 2) {
			var geom$1 = arguments[0];
			var bnRule$1 = arguments[1];
			this._geom = geom$1;
			this._geomFact = geom$1.getFactory();
			this._bnRule = bnRule$1;
		}
	};
	BoundaryOp.prototype.boundaryMultiLineString = function boundaryMultiLineString(mLine) {
		if (this._geom.isEmpty()) {
			return this.getEmptyMultiPoint()
		}
		var bdyPts = this.computeBoundaryCoordinates(mLine);
		if (bdyPts.length === 1) {
			return this._geomFact.createPoint(bdyPts[0])
		}
		return this._geomFact.createMultiPointFromCoords(bdyPts)
	};
	BoundaryOp.prototype.getBoundary = function getBoundary() {
		if (this._geom instanceof LineString) { return this.boundaryLineString(this._geom) }
		if (this._geom instanceof MultiLineString) { return this.boundaryMultiLineString(this._geom) }
		return this._geom.getBoundary()
	};
	BoundaryOp.prototype.boundaryLineString = function boundaryLineString(line) {
		if (this._geom.isEmpty()) {
			return this.getEmptyMultiPoint()
		}
		if (line.isClosed()) {
			var closedEndpointOnBoundary = this._bnRule.isInBoundary(2);
			if (closedEndpointOnBoundary) {
				return line.getStartPoint()
			} else {
				return this._geomFact.createMultiPoint()
			}
		}
		return this._geomFact.createMultiPoint([line.getStartPoint(), line.getEndPoint()])
	};
	BoundaryOp.prototype.getEmptyMultiPoint = function getEmptyMultiPoint() {
		return this._geomFact.createMultiPoint()
	};
	BoundaryOp.prototype.computeBoundaryCoordinates = function computeBoundaryCoordinates(mLine) {
		var this$1$1 = this;

		var bdyPts = new ArrayList();
		this._endpointMap = new TreeMap();
		for (var i = 0; i < mLine.getNumGeometries(); i++) {
			var line = mLine.getGeometryN(i);
			if (line.getNumPoints() === 0) { continue }
			this$1$1.addEndpoint(line.getCoordinateN(0));
			this$1$1.addEndpoint(line.getCoordinateN(line.getNumPoints() - 1));
		}
		for (var it = this._endpointMap.entrySet().iterator(); it.hasNext();) {
			var entry = it.next();
			var counter = entry.getValue();
			var valence = counter.count;
			if (this$1$1._bnRule.isInBoundary(valence)) {
				bdyPts.add(entry.getKey());
			}
		}
		return CoordinateArrays.toCoordinateArray(bdyPts)
	};
	BoundaryOp.prototype.addEndpoint = function addEndpoint(pt) {
		var counter = this._endpointMap.get(pt);
		if (counter === null) {
			counter = new Counter();
			this._endpointMap.put(pt, counter);
		}
		counter.count++;
	};
	BoundaryOp.prototype.interfaces_ = function interfaces_() {
		return []
	};
	BoundaryOp.prototype.getClass = function getClass() {
		return BoundaryOp
	};
	BoundaryOp.getBoundary = function getBoundary() {
		if (arguments.length === 1) {
			var g = arguments[0];
			var bop = new BoundaryOp(g);
			return bop.getBoundary()
		} else if (arguments.length === 2) {
			var g$1 = arguments[0];
			var bnRule = arguments[1];
			var bop$1 = new BoundaryOp(g$1, bnRule);
			return bop$1.getBoundary()
		}
	};

	var Counter = function Counter() {
		this.count = null;
	};
	Counter.prototype.interfaces_ = function interfaces_() {
		return []
	};
	Counter.prototype.getClass = function getClass() {
		return Counter
	};

	// boundary

	function PrintStream() { }

	function StringReader() { }

	var DecimalFormat = function DecimalFormat() { };

	function ByteArrayOutputStream() { }

	function IOException() { }

	function LineNumberReader() { }

	var StringUtil = function StringUtil() { };

	var staticAccessors$15 = { NEWLINE: { configurable: true }, SIMPLE_ORDINATE_FORMAT: { configurable: true } };

	StringUtil.prototype.interfaces_ = function interfaces_() {
		return []
	};
	StringUtil.prototype.getClass = function getClass() {
		return StringUtil
	};
	StringUtil.chars = function chars(c, n) {
		var ch = new Array(n).fill(null);
		for (var i = 0; i < n; i++) {
			ch[i] = c;
		}
		return String(ch)
	};
	StringUtil.getStackTrace = function getStackTrace() {
		if (arguments.length === 1) {
			var t = arguments[0];
			var os = new ByteArrayOutputStream();
			var ps = new PrintStream();
			t.printStackTrace(ps);
			return os.toString()
		} else if (arguments.length === 2) {
			var t$1 = arguments[0];
			var depth = arguments[1];
			var stackTrace = '';
			new StringReader(StringUtil.getStackTrace(t$1));
			var lineNumberReader = new LineNumberReader();
			for (var i = 0; i < depth; i++) {
				try {
					stackTrace += lineNumberReader.readLine() + StringUtil.NEWLINE;
				} catch (e) {
					if (e instanceof IOException) {
						Assert.shouldNeverReachHere();
					} else { throw e }
				} finally { }
			}
			return stackTrace
		}
	};
	StringUtil.split = function split(s, separator) {
		var separatorlen = separator.length;
		var tokenList = new ArrayList();
		var tmpString = '' + s;
		var pos = tmpString.indexOf(separator);
		while (pos >= 0) {
			var token = tmpString.substring(0, pos);
			tokenList.add(token);
			tmpString = tmpString.substring(pos + separatorlen);
			pos = tmpString.indexOf(separator);
		}
		if (tmpString.length > 0) { tokenList.add(tmpString); }
		var res = new Array(tokenList.size()).fill(null);
		for (var i = 0; i < res.length; i++) {
			res[i] = tokenList.get(i);
		}
		return res
	};
	StringUtil.toString = function toString() {
		if (arguments.length === 1) {
			var d = arguments[0];
			return StringUtil.SIMPLE_ORDINATE_FORMAT.format(d)
		}
	};
	StringUtil.spaces = function spaces(n) {
		return StringUtil.chars(' ', n)
	};
	staticAccessors$15.NEWLINE.get = function () { return System.getProperty('line.separator') };
	staticAccessors$15.SIMPLE_ORDINATE_FORMAT.get = function () { return new DecimalFormat() };

	Object.defineProperties(StringUtil, staticAccessors$15);

	var CoordinateSequences = function CoordinateSequences() { };

	CoordinateSequences.prototype.interfaces_ = function interfaces_() {
		return []
	};
	CoordinateSequences.prototype.getClass = function getClass() {
		return CoordinateSequences
	};
	CoordinateSequences.copyCoord = function copyCoord(src, srcPos, dest, destPos) {
		var minDim = Math.min(src.getDimension(), dest.getDimension());
		for (var dim = 0; dim < minDim; dim++) {
			dest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim));
		}
	};
	CoordinateSequences.isRing = function isRing(seq) {
		var n = seq.size();
		if (n === 0) { return true }
		if (n <= 3) { return false }
		return seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y)
	};
	CoordinateSequences.isEqual = function isEqual(cs1, cs2) {
		var cs1Size = cs1.size();
		var cs2Size = cs2.size();
		if (cs1Size !== cs2Size) { return false }
		var dim = Math.min(cs1.getDimension(), cs2.getDimension());
		for (var i = 0; i < cs1Size; i++) {
			for (var d = 0; d < dim; d++) {
				var v1 = cs1.getOrdinate(i, d);
				var v2 = cs2.getOrdinate(i, d);
				if (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) { continue }
				if (Double.isNaN(v1) && Double.isNaN(v2)) { continue }
				return false
			}
		}
		return true
	};
	CoordinateSequences.extend = function extend(fact, seq, size) {
		var newseq = fact.create(size, seq.getDimension());
		var n = seq.size();
		CoordinateSequences.copy(seq, 0, newseq, 0, n);
		if (n > 0) {
			for (var i = n; i < size; i++) { CoordinateSequences.copy(seq, n - 1, newseq, i, 1); }
		}
		return newseq
	};
	CoordinateSequences.reverse = function reverse(seq) {
		var last = seq.size() - 1;
		var mid = Math.trunc(last / 2);
		for (var i = 0; i <= mid; i++) {
			CoordinateSequences.swap(seq, i, last - i);
		}
	};
	CoordinateSequences.swap = function swap(seq, i, j) {
		if (i === j) { return null }
		for (var dim = 0; dim < seq.getDimension(); dim++) {
			var tmp = seq.getOrdinate(i, dim);
			seq.setOrdinate(i, dim, seq.getOrdinate(j, dim));
			seq.setOrdinate(j, dim, tmp);
		}
	};
	CoordinateSequences.copy = function copy(src, srcPos, dest, destPos, length) {
		for (var i = 0; i < length; i++) {
			CoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i);
		}
	};
	CoordinateSequences.toString = function toString() {
		if (arguments.length === 1) {
			var cs = arguments[0];
			var size = cs.size();
			if (size === 0) { return '()' }
			var dim = cs.getDimension();
			var buf = new StringBuffer();
			buf.append('(');
			for (var i = 0; i < size; i++) {
				if (i > 0) { buf.append(' '); }
				for (var d = 0; d < dim; d++) {
					if (d > 0) { buf.append(','); }
					buf.append(StringUtil.toString(cs.getOrdinate(i, d)));
				}
			}
			buf.append(')');
			return buf.toString()
		}
	};
	CoordinateSequences.ensureValidRing = function ensureValidRing(fact, seq) {
		var n = seq.size();
		if (n === 0) { return seq }
		if (n <= 3) { return CoordinateSequences.createClosedRing(fact, seq, 4) }
		var isClosed = seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);
		if (isClosed) { return seq }
		return CoordinateSequences.createClosedRing(fact, seq, n + 1)
	};
	CoordinateSequences.createClosedRing = function createClosedRing(fact, seq, size) {
		var newseq = fact.create(size, seq.getDimension());
		var n = seq.size();
		CoordinateSequences.copy(seq, 0, newseq, 0, n);
		for (var i = n; i < size; i++) { CoordinateSequences.copy(seq, 0, newseq, i, 1); }
		return newseq
	};

	var LineString = (function (Geometry$$1) {
		function LineString(points, factory) {
			Geometry$$1.call(this, factory);
			this._points = null;
			this.init(points);
		}

		if (Geometry$$1) LineString.__proto__ = Geometry$$1;
		LineString.prototype = Object.create(Geometry$$1 && Geometry$$1.prototype);
		LineString.prototype.constructor = LineString;

		var staticAccessors = { serialVersionUID: { configurable: true } };
		LineString.prototype.computeEnvelopeInternal = function computeEnvelopeInternal() {
			if (this.isEmpty()) {
				return new Envelope()
			}
			return this._points.expandEnvelope(new Envelope())
		};
		LineString.prototype.isRing = function isRing() {
			return this.isClosed() && this.isSimple()
		};
		LineString.prototype.getSortIndex = function getSortIndex() {
			return Geometry$$1.SORTINDEX_LINESTRING
		};
		LineString.prototype.getCoordinates = function getCoordinates() {
			return this._points.toCoordinateArray()
		};
		LineString.prototype.equalsExact = function equalsExact() {
			var this$1$1 = this;

			if (arguments.length === 2) {
				var other = arguments[0];
				var tolerance = arguments[1];
				if (!this.isEquivalentClass(other)) {
					return false
				}
				var otherLineString = other;
				if (this._points.size() !== otherLineString._points.size()) {
					return false
				}
				for (var i = 0; i < this._points.size(); i++) {
					if (!this$1$1.equal(this$1$1._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) {
						return false
					}
				}
				return true
			} else { return Geometry$$1.prototype.equalsExact.apply(this, arguments) }
		};
		LineString.prototype.normalize = function normalize() {
			var this$1$1 = this;

			for (var i = 0; i < Math.trunc(this._points.size() / 2); i++) {
				var j = this$1$1._points.size() - 1 - i;
				if (!this$1$1._points.getCoordinate(i).equals(this$1$1._points.getCoordinate(j))) {
					if (this$1$1._points.getCoordinate(i).compareTo(this$1$1._points.getCoordinate(j)) > 0) {
						CoordinateSequences.reverse(this$1$1._points);
					}
					return null
				}
			}
		};
		LineString.prototype.getCoordinate = function getCoordinate() {
			if (this.isEmpty()) { return null }
			return this._points.getCoordinate(0)
		};
		LineString.prototype.getBoundaryDimension = function getBoundaryDimension() {
			if (this.isClosed()) {
				return Dimension.FALSE
			}
			return 0
		};
		LineString.prototype.isClosed = function isClosed() {
			if (this.isEmpty()) {
				return false
			}
			return this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1))
		};
		LineString.prototype.getEndPoint = function getEndPoint() {
			if (this.isEmpty()) {
				return null
			}
			return this.getPointN(this.getNumPoints() - 1)
		};
		LineString.prototype.getDimension = function getDimension() {
			return 1
		};
		LineString.prototype.getLength = function getLength() {
			return CGAlgorithms.computeLength(this._points)
		};
		LineString.prototype.getNumPoints = function getNumPoints() {
			return this._points.size()
		};
		LineString.prototype.reverse = function reverse() {
			var seq = this._points.copy();
			CoordinateSequences.reverse(seq);
			var revLine = this.getFactory().createLineString(seq);
			return revLine
		};
		LineString.prototype.compareToSameClass = function compareToSameClass() {
			var this$1$1 = this;

			if (arguments.length === 1) {
				var o = arguments[0];
				var line = o;
				var i = 0;
				var j = 0;
				while (i < this._points.size() && j < line._points.size()) {
					var comparison = this$1$1._points.getCoordinate(i).compareTo(line._points.getCoordinate(j));
					if (comparison !== 0) {
						return comparison
					}
					i++;
					j++;
				}
				if (i < this._points.size()) {
					return 1
				}
				if (j < line._points.size()) {
					return -1
				}
				return 0
			} else if (arguments.length === 2) {
				var o$1 = arguments[0];
				var comp = arguments[1];
				var line$1 = o$1;
				return comp.compare(this._points, line$1._points)
			}
		};
		LineString.prototype.apply = function apply() {
			var this$1$1 = this;

			if (hasInterface(arguments[0], CoordinateFilter)) {
				var filter = arguments[0];
				for (var i = 0; i < this._points.size(); i++) {
					filter.filter(this$1$1._points.getCoordinate(i));
				}
			} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
				var filter$1 = arguments[0];
				if (this._points.size() === 0) { return null }
				for (var i$1 = 0; i$1 < this._points.size(); i$1++) {
					filter$1.filter(this$1$1._points, i$1);
					if (filter$1.isDone()) { break }
				}
				if (filter$1.isGeometryChanged()) { this.geometryChanged(); }
			} else if (hasInterface(arguments[0], GeometryFilter)) {
				var filter$2 = arguments[0];
				filter$2.filter(this);
			} else if (hasInterface(arguments[0], GeometryComponentFilter)) {
				var filter$3 = arguments[0];
				filter$3.filter(this);
			}
		};
		LineString.prototype.getBoundary = function getBoundary() {
			return new BoundaryOp(this).getBoundary()
		};
		LineString.prototype.isEquivalentClass = function isEquivalentClass(other) {
			return other instanceof LineString
		};
		LineString.prototype.clone = function clone() {
			var ls = Geometry$$1.prototype.clone.call(this);
			ls._points = this._points.clone();
			return ls
		};
		LineString.prototype.getCoordinateN = function getCoordinateN(n) {
			return this._points.getCoordinate(n)
		};
		LineString.prototype.getGeometryType = function getGeometryType() {
			return 'LineString'
		};
		LineString.prototype.copy = function copy() {
			return new LineString(this._points.copy(), this._factory)
		};
		LineString.prototype.getCoordinateSequence = function getCoordinateSequence() {
			return this._points
		};
		LineString.prototype.isEmpty = function isEmpty() {
			return this._points.size() === 0
		};
		LineString.prototype.init = function init(points) {
			if (points === null) {
				points = this.getFactory().getCoordinateSequenceFactory().create([]);
			}
			if (points.size() === 1) {
				throw new IllegalArgumentException('Invalid number of points in LineString (found ' + points.size() + ' - must be 0 or >= 2)')
			}
			this._points = points;
		};
		LineString.prototype.isCoordinate = function isCoordinate(pt) {
			var this$1$1 = this;

			for (var i = 0; i < this._points.size(); i++) {
				if (this$1$1._points.getCoordinate(i).equals(pt)) {
					return true
				}
			}
			return false
		};
		LineString.prototype.getStartPoint = function getStartPoint() {
			if (this.isEmpty()) {
				return null
			}
			return this.getPointN(0)
		};
		LineString.prototype.getPointN = function getPointN(n) {
			return this.getFactory().createPoint(this._points.getCoordinate(n))
		};
		LineString.prototype.interfaces_ = function interfaces_() {
			return [Lineal]
		};
		LineString.prototype.getClass = function getClass() {
			return LineString
		};
		staticAccessors.serialVersionUID.get = function () { return 3110669828065365560 };

		Object.defineProperties(LineString, staticAccessors);

		return LineString;
	}(Geometry));

	var Puntal = function Puntal() { };

	Puntal.prototype.interfaces_ = function interfaces_() {
		return []
	};
	Puntal.prototype.getClass = function getClass() {
		return Puntal
	};

	var Point = (function (Geometry$$1) {
		function Point(coordinates, factory) {
			Geometry$$1.call(this, factory);
			this._coordinates = coordinates || null;
			this.init(this._coordinates);
		}

		if (Geometry$$1) Point.__proto__ = Geometry$$1;
		Point.prototype = Object.create(Geometry$$1 && Geometry$$1.prototype);
		Point.prototype.constructor = Point;

		var staticAccessors = { serialVersionUID: { configurable: true } };
		Point.prototype.computeEnvelopeInternal = function computeEnvelopeInternal() {
			if (this.isEmpty()) {
				return new Envelope()
			}
			var env = new Envelope();
			env.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0));
			return env
		};
		Point.prototype.getSortIndex = function getSortIndex() {
			return Geometry$$1.SORTINDEX_POINT
		};
		Point.prototype.getCoordinates = function getCoordinates() {
			return this.isEmpty() ? [] : [this.getCoordinate()]
		};
		Point.prototype.equalsExact = function equalsExact() {
			if (arguments.length === 2) {
				var other = arguments[0];
				var tolerance = arguments[1];
				if (!this.isEquivalentClass(other)) {
					return false
				}
				if (this.isEmpty() && other.isEmpty()) {
					return true
				}
				if (this.isEmpty() !== other.isEmpty()) {
					return false
				}
				return this.equal(other.getCoordinate(), this.getCoordinate(), tolerance)
			} else { return Geometry$$1.prototype.equalsExact.apply(this, arguments) }
		};
		Point.prototype.normalize = function normalize() { };
		Point.prototype.getCoordinate = function getCoordinate() {
			return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null
		};
		Point.prototype.getBoundaryDimension = function getBoundaryDimension() {
			return Dimension.FALSE
		};
		Point.prototype.getDimension = function getDimension() {
			return 0
		};
		Point.prototype.getNumPoints = function getNumPoints() {
			return this.isEmpty() ? 0 : 1
		};
		Point.prototype.reverse = function reverse() {
			return this.copy()
		};
		Point.prototype.getX = function getX() {
			if (this.getCoordinate() === null) {
				throw new Error('getX called on empty Point')
			}
			return this.getCoordinate().x
		};
		Point.prototype.compareToSameClass = function compareToSameClass() {
			if (arguments.length === 1) {
				var other = arguments[0];
				var point$1 = other;
				return this.getCoordinate().compareTo(point$1.getCoordinate())
			} else if (arguments.length === 2) {
				var other$1 = arguments[0];
				var comp = arguments[1];
				var point = other$1;
				return comp.compare(this._coordinates, point._coordinates)
			}
		};
		Point.prototype.apply = function apply() {
			if (hasInterface(arguments[0], CoordinateFilter)) {
				var filter = arguments[0];
				if (this.isEmpty()) {
					return null
				}
				filter.filter(this.getCoordinate());
			} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
				var filter$1 = arguments[0];
				if (this.isEmpty()) { return null }
				filter$1.filter(this._coordinates, 0);
				if (filter$1.isGeometryChanged()) { this.geometryChanged(); }
			} else if (hasInterface(arguments[0], GeometryFilter)) {
				var filter$2 = arguments[0];
				filter$2.filter(this);
			} else if (hasInterface(arguments[0], GeometryComponentFilter)) {
				var filter$3 = arguments[0];
				filter$3.filter(this);
			}
		};
		Point.prototype.getBoundary = function getBoundary() {
			return this.getFactory().createGeometryCollection(null)
		};
		Point.prototype.clone = function clone() {
			var p = Geometry$$1.prototype.clone.call(this);
			p._coordinates = this._coordinates.clone();
			return p
		};
		Point.prototype.getGeometryType = function getGeometryType() {
			return 'Point'
		};
		Point.prototype.copy = function copy() {
			return new Point(this._coordinates.copy(), this._factory)
		};
		Point.prototype.getCoordinateSequence = function getCoordinateSequence() {
			return this._coordinates
		};
		Point.prototype.getY = function getY() {
			if (this.getCoordinate() === null) {
				throw new Error('getY called on empty Point')
			}
			return this.getCoordinate().y
		};
		Point.prototype.isEmpty = function isEmpty() {
			return this._coordinates.size() === 0
		};
		Point.prototype.init = function init(coordinates) {
			if (coordinates === null) {
				coordinates = this.getFactory().getCoordinateSequenceFactory().create([]);
			}
			Assert.isTrue(coordinates.size() <= 1);
			this._coordinates = coordinates;
		};
		Point.prototype.isSimple = function isSimple() {
			return true
		};
		Point.prototype.interfaces_ = function interfaces_() {
			return [Puntal]
		};
		Point.prototype.getClass = function getClass() {
			return Point
		};
		staticAccessors.serialVersionUID.get = function () { return 4902022702746614570 };

		Object.defineProperties(Point, staticAccessors);

		return Point;
	}(Geometry));

	var Polygonal = function Polygonal() { };

	Polygonal.prototype.interfaces_ = function interfaces_() {
		return []
	};
	Polygonal.prototype.getClass = function getClass() {
		return Polygonal
	};

	var Polygon = (function (Geometry$$1) {
		function Polygon(shell, holes, factory) {
			Geometry$$1.call(this, factory);
			this._shell = null;
			this._holes = null;
			if (shell === null) {
				shell = this.getFactory().createLinearRing();
			}
			if (holes === null) {
				holes = [];
			}
			if (Geometry$$1.hasNullElements(holes)) {
				throw new IllegalArgumentException('holes must not contain null elements')
			}
			if (shell.isEmpty() && Geometry$$1.hasNonEmptyElements(holes)) {
				throw new IllegalArgumentException('shell is empty but holes are not')
			}
			this._shell = shell;
			this._holes = holes;
		}

		if (Geometry$$1) Polygon.__proto__ = Geometry$$1;
		Polygon.prototype = Object.create(Geometry$$1 && Geometry$$1.prototype);
		Polygon.prototype.constructor = Polygon;

		var staticAccessors = { serialVersionUID: { configurable: true } };
		Polygon.prototype.computeEnvelopeInternal = function computeEnvelopeInternal() {
			return this._shell.getEnvelopeInternal()
		};
		Polygon.prototype.getSortIndex = function getSortIndex() {
			return Geometry$$1.SORTINDEX_POLYGON
		};
		Polygon.prototype.getCoordinates = function getCoordinates() {
			var this$1$1 = this;

			if (this.isEmpty()) {
				return []
			}
			var coordinates = new Array(this.getNumPoints()).fill(null);
			var k = -1;
			var shellCoordinates = this._shell.getCoordinates();
			for (var x = 0; x < shellCoordinates.length; x++) {
				k++;
				coordinates[k] = shellCoordinates[x];
			}
			for (var i = 0; i < this._holes.length; i++) {
				var childCoordinates = this$1$1._holes[i].getCoordinates();
				for (var j = 0; j < childCoordinates.length; j++) {
					k++;
					coordinates[k] = childCoordinates[j];
				}
			}
			return coordinates
		};
		Polygon.prototype.getArea = function getArea() {
			var this$1$1 = this;

			var area = 0.0;
			area += Math.abs(CGAlgorithms.signedArea(this._shell.getCoordinateSequence()));
			for (var i = 0; i < this._holes.length; i++) {
				area -= Math.abs(CGAlgorithms.signedArea(this$1$1._holes[i].getCoordinateSequence()));
			}
			return area
		};
		Polygon.prototype.isRectangle = function isRectangle() {
			if (this.getNumInteriorRing() !== 0) { return false }
			if (this._shell === null) { return false }
			if (this._shell.getNumPoints() !== 5) { return false }
			var seq = this._shell.getCoordinateSequence();
			var env = this.getEnvelopeInternal();
			for (var i = 0; i < 5; i++) {
				var x = seq.getX(i);
				if (!(x === env.getMinX() || x === env.getMaxX())) { return false }
				var y = seq.getY(i);
				if (!(y === env.getMinY() || y === env.getMaxY())) { return false }
			}
			var prevX = seq.getX(0);
			var prevY = seq.getY(0);
			for (var i$1 = 1; i$1 <= 4; i$1++) {
				var x$1 = seq.getX(i$1);
				var y$1 = seq.getY(i$1);
				var xChanged = x$1 !== prevX;
				var yChanged = y$1 !== prevY;
				if (xChanged === yChanged) { return false }
				prevX = x$1;
				prevY = y$1;
			}
			return true
		};
		Polygon.prototype.equalsExact = function equalsExact() {
			var this$1$1 = this;

			if (arguments.length === 2) {
				var other = arguments[0];
				var tolerance = arguments[1];
				if (!this.isEquivalentClass(other)) {
					return false
				}
				var otherPolygon = other;
				var thisShell = this._shell;
				var otherPolygonShell = otherPolygon._shell;
				if (!thisShell.equalsExact(otherPolygonShell, tolerance)) {
					return false
				}
				if (this._holes.length !== otherPolygon._holes.length) {
					return false
				}
				for (var i = 0; i < this._holes.length; i++) {
					if (!this$1$1._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) {
						return false
					}
				}
				return true
			} else { return Geometry$$1.prototype.equalsExact.apply(this, arguments) }
		};
		Polygon.prototype.normalize = function normalize() {
			var this$1$1 = this;

			if (arguments.length === 0) {
				this.normalize(this._shell, true);
				for (var i = 0; i < this._holes.length; i++) {
					this$1$1.normalize(this$1$1._holes[i], false);
				}
				Arrays.sort(this._holes);
			} else if (arguments.length === 2) {
				var ring = arguments[0];
				var clockwise = arguments[1];
				if (ring.isEmpty()) {
					return null
				}
				var uniqueCoordinates = new Array(ring.getCoordinates().length - 1).fill(null);
				System.arraycopy(ring.getCoordinates(), 0, uniqueCoordinates, 0, uniqueCoordinates.length);
				var minCoordinate = CoordinateArrays.minCoordinate(ring.getCoordinates());
				CoordinateArrays.scroll(uniqueCoordinates, minCoordinate);
				System.arraycopy(uniqueCoordinates, 0, ring.getCoordinates(), 0, uniqueCoordinates.length);
				ring.getCoordinates()[uniqueCoordinates.length] = uniqueCoordinates[0];
				if (CGAlgorithms.isCCW(ring.getCoordinates()) === clockwise) {
					CoordinateArrays.reverse(ring.getCoordinates());
				}
			}
		};
		Polygon.prototype.getCoordinate = function getCoordinate() {
			return this._shell.getCoordinate()
		};
		Polygon.prototype.getNumInteriorRing = function getNumInteriorRing() {
			return this._holes.length
		};
		Polygon.prototype.getBoundaryDimension = function getBoundaryDimension() {
			return 1
		};
		Polygon.prototype.getDimension = function getDimension() {
			return 2
		};
		Polygon.prototype.getLength = function getLength() {
			var this$1$1 = this;

			var len = 0.0;
			len += this._shell.getLength();
			for (var i = 0; i < this._holes.length; i++) {
				len += this$1$1._holes[i].getLength();
			}
			return len
		};
		Polygon.prototype.getNumPoints = function getNumPoints() {
			var this$1$1 = this;

			var numPoints = this._shell.getNumPoints();
			for (var i = 0; i < this._holes.length; i++) {
				numPoints += this$1$1._holes[i].getNumPoints();
			}
			return numPoints
		};
		Polygon.prototype.reverse = function reverse() {
			var this$1$1 = this;

			var poly = this.copy();
			poly._shell = this._shell.copy().reverse();
			poly._holes = new Array(this._holes.length).fill(null);
			for (var i = 0; i < this._holes.length; i++) {
				poly._holes[i] = this$1$1._holes[i].copy().reverse();
			}
			return poly
		};
		Polygon.prototype.convexHull = function convexHull() {
			return this.getExteriorRing().convexHull()
		};
		Polygon.prototype.compareToSameClass = function compareToSameClass() {
			var this$1$1 = this;

			if (arguments.length === 1) {
				var o = arguments[0];
				var thisShell = this._shell;
				var otherShell = o._shell;
				return thisShell.compareToSameClass(otherShell)
			} else if (arguments.length === 2) {
				var o$1 = arguments[0];
				var comp = arguments[1];
				var poly = o$1;
				var thisShell$1 = this._shell;
				var otherShell$1 = poly._shell;
				var shellComp = thisShell$1.compareToSameClass(otherShell$1, comp);
				if (shellComp !== 0) { return shellComp }
				var nHole1 = this.getNumInteriorRing();
				var nHole2 = poly.getNumInteriorRing();
				var i = 0;
				while (i < nHole1 && i < nHole2) {
					var thisHole = this$1$1.getInteriorRingN(i);
					var otherHole = poly.getInteriorRingN(i);
					var holeComp = thisHole.compareToSameClass(otherHole, comp);
					if (holeComp !== 0) { return holeComp }
					i++;
				}
				if (i < nHole1) { return 1 }
				if (i < nHole2) { return -1 }
				return 0
			}
		};
		Polygon.prototype.apply = function apply(filter) {
			var this$1$1 = this;

			if (hasInterface(filter, CoordinateFilter)) {
				this._shell.apply(filter);
				for (var i$1 = 0; i$1 < this._holes.length; i$1++) {
					this$1$1._holes[i$1].apply(filter);
				}
			} else if (hasInterface(filter, CoordinateSequenceFilter)) {
				this._shell.apply(filter);
				if (!filter.isDone()) {
					for (var i$2 = 0; i$2 < this._holes.length; i$2++) {
						this$1$1._holes[i$2].apply(filter);
						if (filter.isDone()) { break }
					}
				}
				if (filter.isGeometryChanged()) { this.geometryChanged(); }
			} else if (hasInterface(filter, GeometryFilter)) {
				filter.filter(this);
			} else if (hasInterface(filter, GeometryComponentFilter)) {
				filter.filter(this);
				this._shell.apply(filter);
				for (var i = 0; i < this._holes.length; i++) {
					this$1$1._holes[i].apply(filter);
				}
			}
		};
		Polygon.prototype.getBoundary = function getBoundary() {
			var this$1$1 = this;

			if (this.isEmpty()) {
				return this.getFactory().createMultiLineString()
			}
			var rings = new Array(this._holes.length + 1).fill(null);
			rings[0] = this._shell;
			for (var i = 0; i < this._holes.length; i++) {
				rings[i + 1] = this$1$1._holes[i];
			}
			if (rings.length <= 1) { return this.getFactory().createLinearRing(rings[0].getCoordinateSequence()) }
			return this.getFactory().createMultiLineString(rings)
		};
		Polygon.prototype.clone = function clone() {
			var this$1$1 = this;

			var poly = Geometry$$1.prototype.clone.call(this);
			poly._shell = this._shell.clone();
			poly._holes = new Array(this._holes.length).fill(null);
			for (var i = 0; i < this._holes.length; i++) {
				poly._holes[i] = this$1$1._holes[i].clone();
			}
			return poly
		};
		Polygon.prototype.getGeometryType = function getGeometryType() {
			return 'Polygon'
		};
		Polygon.prototype.copy = function copy() {
			var this$1$1 = this;

			var shell = this._shell.copy();
			var holes = new Array(this._holes.length).fill(null);
			for (var i = 0; i < holes.length; i++) {
				holes[i] = this$1$1._holes[i].copy();
			}
			return new Polygon(shell, holes, this._factory)
		};
		Polygon.prototype.getExteriorRing = function getExteriorRing() {
			return this._shell
		};
		Polygon.prototype.isEmpty = function isEmpty() {
			return this._shell.isEmpty()
		};
		Polygon.prototype.getInteriorRingN = function getInteriorRingN(n) {
			return this._holes[n]
		};
		Polygon.prototype.interfaces_ = function interfaces_() {
			return [Polygonal]
		};
		Polygon.prototype.getClass = function getClass() {
			return Polygon
		};
		staticAccessors.serialVersionUID.get = function () { return -3494792200821764533 };

		Object.defineProperties(Polygon, staticAccessors);

		return Polygon;
	}(Geometry));

	var MultiPoint = (function (GeometryCollection$$1) {
		function MultiPoint() {
			GeometryCollection$$1.apply(this, arguments);
		}

		if (GeometryCollection$$1) MultiPoint.__proto__ = GeometryCollection$$1;
		MultiPoint.prototype = Object.create(GeometryCollection$$1 && GeometryCollection$$1.prototype);
		MultiPoint.prototype.constructor = MultiPoint;

		var staticAccessors = { serialVersionUID: { configurable: true } };

		MultiPoint.prototype.getSortIndex = function getSortIndex() {
			return Geometry.SORTINDEX_MULTIPOINT
		};
		MultiPoint.prototype.isValid = function isValid() {
			return true
		};
		MultiPoint.prototype.equalsExact = function equalsExact() {
			if (arguments.length === 2) {
				var other = arguments[0];
				var tolerance = arguments[1];
				if (!this.isEquivalentClass(other)) {
					return false
				}
				return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance)
			} else { return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments) }
		};
		MultiPoint.prototype.getCoordinate = function getCoordinate() {
			if (arguments.length === 1) {
				var n = arguments[0];
				return this._geometries[n].getCoordinate()
			} else { return GeometryCollection$$1.prototype.getCoordinate.apply(this, arguments) }
		};
		MultiPoint.prototype.getBoundaryDimension = function getBoundaryDimension() {
			return Dimension.FALSE
		};
		MultiPoint.prototype.getDimension = function getDimension() {
			return 0
		};
		MultiPoint.prototype.getBoundary = function getBoundary() {
			return this.getFactory().createGeometryCollection(null)
		};
		MultiPoint.prototype.getGeometryType = function getGeometryType() {
			return 'MultiPoint'
		};
		MultiPoint.prototype.copy = function copy() {
			var this$1$1 = this;

			var points = new Array(this._geometries.length).fill(null);
			for (var i = 0; i < points.length; i++) {
				points[i] = this$1$1._geometries[i].copy();
			}
			return new MultiPoint(points, this._factory)
		};
		MultiPoint.prototype.interfaces_ = function interfaces_() {
			return [Puntal]
		};
		MultiPoint.prototype.getClass = function getClass() {
			return MultiPoint
		};
		staticAccessors.serialVersionUID.get = function () { return -8048474874175355449 };

		Object.defineProperties(MultiPoint, staticAccessors);

		return MultiPoint;
	}(GeometryCollection));

	var LinearRing = (function (LineString$$1) {
		function LinearRing(points, factory) {
			if (points instanceof Coordinate && factory instanceof GeometryFactory) {
				points = factory.getCoordinateSequenceFactory().create(points);
			}
			LineString$$1.call(this, points, factory);
			this.validateConstruction();
		}

		if (LineString$$1) LinearRing.__proto__ = LineString$$1;
		LinearRing.prototype = Object.create(LineString$$1 && LineString$$1.prototype);
		LinearRing.prototype.constructor = LinearRing;

		var staticAccessors = { MINIMUM_VALID_SIZE: { configurable: true }, serialVersionUID: { configurable: true } };
		LinearRing.prototype.getSortIndex = function getSortIndex() {
			return Geometry.SORTINDEX_LINEARRING
		};
		LinearRing.prototype.getBoundaryDimension = function getBoundaryDimension() {
			return Dimension.FALSE
		};
		LinearRing.prototype.isClosed = function isClosed() {
			if (this.isEmpty()) {
				return true
			}
			return LineString$$1.prototype.isClosed.call(this)
		};
		LinearRing.prototype.reverse = function reverse() {
			var seq = this._points.copy();
			CoordinateSequences.reverse(seq);
			var rev = this.getFactory().createLinearRing(seq);
			return rev
		};
		LinearRing.prototype.validateConstruction = function validateConstruction() {
			if (!this.isEmpty() && !LineString$$1.prototype.isClosed.call(this)) {
				throw new IllegalArgumentException('Points of LinearRing do not form a closed linestring')
			}
			if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing.MINIMUM_VALID_SIZE) {
				throw new IllegalArgumentException('Invalid number of points in LinearRing (found ' + this.getCoordinateSequence().size() + ' - must be 0 or >= 4)')
			}
		};
		LinearRing.prototype.getGeometryType = function getGeometryType() {
			return 'LinearRing'
		};
		LinearRing.prototype.copy = function copy() {
			return new LinearRing(this._points.copy(), this._factory)
		};
		LinearRing.prototype.interfaces_ = function interfaces_() {
			return []
		};
		LinearRing.prototype.getClass = function getClass() {
			return LinearRing
		};
		staticAccessors.MINIMUM_VALID_SIZE.get = function () { return 4 };
		staticAccessors.serialVersionUID.get = function () { return -4261142084085851829 };

		Object.defineProperties(LinearRing, staticAccessors);

		return LinearRing;
	}(LineString));

	var MultiPolygon = (function (GeometryCollection$$1) {
		function MultiPolygon() {
			GeometryCollection$$1.apply(this, arguments);
		}

		if (GeometryCollection$$1) MultiPolygon.__proto__ = GeometryCollection$$1;
		MultiPolygon.prototype = Object.create(GeometryCollection$$1 && GeometryCollection$$1.prototype);
		MultiPolygon.prototype.constructor = MultiPolygon;

		var staticAccessors = { serialVersionUID: { configurable: true } };

		MultiPolygon.prototype.getSortIndex = function getSortIndex() {
			return Geometry.SORTINDEX_MULTIPOLYGON
		};
		MultiPolygon.prototype.equalsExact = function equalsExact() {
			if (arguments.length === 2) {
				var other = arguments[0];
				var tolerance = arguments[1];
				if (!this.isEquivalentClass(other)) {
					return false
				}
				return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance)
			} else { return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments) }
		};
		MultiPolygon.prototype.getBoundaryDimension = function getBoundaryDimension() {
			return 1
		};
		MultiPolygon.prototype.getDimension = function getDimension() {
			return 2
		};
		MultiPolygon.prototype.reverse = function reverse() {
			var this$1$1 = this;

			var n = this._geometries.length;
			var revGeoms = new Array(n).fill(null);
			for (var i = 0; i < this._geometries.length; i++) {
				revGeoms[i] = this$1$1._geometries[i].reverse();
			}
			return this.getFactory().createMultiPolygon(revGeoms)
		};
		MultiPolygon.prototype.getBoundary = function getBoundary() {
			var this$1$1 = this;

			if (this.isEmpty()) {
				return this.getFactory().createMultiLineString()
			}
			var allRings = new ArrayList();
			for (var i = 0; i < this._geometries.length; i++) {
				var polygon = this$1$1._geometries[i];
				var rings = polygon.getBoundary();
				for (var j = 0; j < rings.getNumGeometries(); j++) {
					allRings.add(rings.getGeometryN(j));
				}
			}
			var allRingsArray = new Array(allRings.size()).fill(null);
			return this.getFactory().createMultiLineString(allRings.toArray(allRingsArray))
		};
		MultiPolygon.prototype.getGeometryType = function getGeometryType() {
			return 'MultiPolygon'
		};
		MultiPolygon.prototype.copy = function copy() {
			var this$1$1 = this;

			var polygons = new Array(this._geometries.length).fill(null);
			for (var i = 0; i < polygons.length; i++) {
				polygons[i] = this$1$1._geometries[i].copy();
			}
			return new MultiPolygon(polygons, this._factory)
		};
		MultiPolygon.prototype.interfaces_ = function interfaces_() {
			return [Polygonal]
		};
		MultiPolygon.prototype.getClass = function getClass() {
			return MultiPolygon
		};
		staticAccessors.serialVersionUID.get = function () { return -551033529766975875 };

		Object.defineProperties(MultiPolygon, staticAccessors);

		return MultiPolygon;
	}(GeometryCollection));

	var GeometryEditor = function GeometryEditor(factory) {
		this._factory = factory || null;
		this._isUserDataCopied = false;
	};

	var staticAccessors$16 = { NoOpGeometryOperation: { configurable: true }, CoordinateOperation: { configurable: true }, CoordinateSequenceOperation: { configurable: true } };
	GeometryEditor.prototype.setCopyUserData = function setCopyUserData(isUserDataCopied) {
		this._isUserDataCopied = isUserDataCopied;
	};
	GeometryEditor.prototype.edit = function edit(geometry, operation) {
		if (geometry === null) { return null }
		var result = this.editInternal(geometry, operation);
		if (this._isUserDataCopied) {
			result.setUserData(geometry.getUserData());
		}
		return result
	};
	GeometryEditor.prototype.editInternal = function editInternal(geometry, operation) {
		if (this._factory === null) { this._factory = geometry.getFactory(); }
		if (geometry instanceof GeometryCollection) {
			return this.editGeometryCollection(geometry, operation)
		}
		if (geometry instanceof Polygon) {
			return this.editPolygon(geometry, operation)
		}
		if (geometry instanceof Point) {
			return operation.edit(geometry, this._factory)
		}
		if (geometry instanceof LineString) {
			return operation.edit(geometry, this._factory)
		}
		Assert.shouldNeverReachHere('Unsupported Geometry class: ' + geometry.getClass().getName());
		return null
	};
	GeometryEditor.prototype.editGeometryCollection = function editGeometryCollection(collection, operation) {
		var this$1$1 = this;

		var collectionForType = operation.edit(collection, this._factory);
		var geometries = new ArrayList();
		for (var i = 0; i < collectionForType.getNumGeometries(); i++) {
			var geometry = this$1$1.edit(collectionForType.getGeometryN(i), operation);
			if (geometry === null || geometry.isEmpty()) {
				continue
			}
			geometries.add(geometry);
		}
		if (collectionForType.getClass() === MultiPoint) {
			return this._factory.createMultiPoint(geometries.toArray([]))
		}
		if (collectionForType.getClass() === MultiLineString) {
			return this._factory.createMultiLineString(geometries.toArray([]))
		}
		if (collectionForType.getClass() === MultiPolygon) {
			return this._factory.createMultiPolygon(geometries.toArray([]))
		}
		return this._factory.createGeometryCollection(geometries.toArray([]))
	};
	GeometryEditor.prototype.editPolygon = function editPolygon(polygon, operation) {
		var this$1$1 = this;

		var newPolygon = operation.edit(polygon, this._factory);
		if (newPolygon === null) { newPolygon = this._factory.createPolygon(null); }
		if (newPolygon.isEmpty()) {
			return newPolygon
		}
		var shell = this.edit(newPolygon.getExteriorRing(), operation);
		if (shell === null || shell.isEmpty()) {
			return this._factory.createPolygon()
		}
		var holes = new ArrayList();
		for (var i = 0; i < newPolygon.getNumInteriorRing(); i++) {
			var hole = this$1$1.edit(newPolygon.getInteriorRingN(i), operation);
			if (hole === null || hole.isEmpty()) {
				continue
			}
			holes.add(hole);
		}
		return this._factory.createPolygon(shell, holes.toArray([]))
	};
	GeometryEditor.prototype.interfaces_ = function interfaces_() {
		return []
	};
	GeometryEditor.prototype.getClass = function getClass() {
		return GeometryEditor
	};
	GeometryEditor.GeometryEditorOperation = function GeometryEditorOperation() { };
	staticAccessors$16.NoOpGeometryOperation.get = function () { return NoOpGeometryOperation };
	staticAccessors$16.CoordinateOperation.get = function () { return CoordinateOperation };
	staticAccessors$16.CoordinateSequenceOperation.get = function () { return CoordinateSequenceOperation };

	Object.defineProperties(GeometryEditor, staticAccessors$16);

	var NoOpGeometryOperation = function NoOpGeometryOperation() { };

	NoOpGeometryOperation.prototype.edit = function edit(geometry, factory) {
		return geometry
	};
	NoOpGeometryOperation.prototype.interfaces_ = function interfaces_() {
		return [GeometryEditor.GeometryEditorOperation]
	};
	NoOpGeometryOperation.prototype.getClass = function getClass() {
		return NoOpGeometryOperation
	};

	var CoordinateOperation = function CoordinateOperation() { };

	CoordinateOperation.prototype.edit = function edit(geometry, factory) {
		var coords = this.editCoordinates(geometry.getCoordinates(), geometry);
		if (coords === null) { return geometry }
		if (geometry instanceof LinearRing) {
			return factory.createLinearRing(coords)
		}
		if (geometry instanceof LineString) {
			return factory.createLineString(coords)
		}
		if (geometry instanceof Point) {
			if (coords.length > 0) {
				return factory.createPoint(coords[0])
			} else {
				return factory.createPoint()
			}
		}
		return geometry
	};
	CoordinateOperation.prototype.interfaces_ = function interfaces_() {
		return [GeometryEditor.GeometryEditorOperation]
	};
	CoordinateOperation.prototype.getClass = function getClass() {
		return CoordinateOperation
	};

	var CoordinateSequenceOperation = function CoordinateSequenceOperation() { };

	CoordinateSequenceOperation.prototype.edit = function edit(geometry, factory) {
		if (geometry instanceof LinearRing) {
			return factory.createLinearRing(this.edit(geometry.getCoordinateSequence(), geometry))
		}
		if (geometry instanceof LineString) {
			return factory.createLineString(this.edit(geometry.getCoordinateSequence(), geometry))
		}
		if (geometry instanceof Point) {
			return factory.createPoint(this.edit(geometry.getCoordinateSequence(), geometry))
		}
		return geometry
	};
	CoordinateSequenceOperation.prototype.interfaces_ = function interfaces_() {
		return [GeometryEditor.GeometryEditorOperation]
	};
	CoordinateSequenceOperation.prototype.getClass = function getClass() {
		return CoordinateSequenceOperation
	};

	var CoordinateArraySequence = function CoordinateArraySequence() {
		var this$1$1 = this;

		this._dimension = 3;
		this._coordinates = null;
		if (arguments.length === 1) {
			if (arguments[0] instanceof Array) {
				this._coordinates = arguments[0];
				this._dimension = 3;
			} else if (Number.isInteger(arguments[0])) {
				var size = arguments[0];
				this._coordinates = new Array(size).fill(null);
				for (var i = 0; i < size; i++) {
					this$1$1._coordinates[i] = new Coordinate();
				}
			} else if (hasInterface(arguments[0], CoordinateSequence)) {
				var coordSeq = arguments[0];
				if (coordSeq === null) {
					this._coordinates = new Array(0).fill(null);
					return null
				}
				this._dimension = coordSeq.getDimension();
				this._coordinates = new Array(coordSeq.size()).fill(null);
				for (var i$1 = 0; i$1 < this._coordinates.length; i$1++) {
					this$1$1._coordinates[i$1] = coordSeq.getCoordinateCopy(i$1);
				}
			}
		} else if (arguments.length === 2) {
			if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
				var coordinates = arguments[0];
				var dimension = arguments[1];
				this._coordinates = coordinates;
				this._dimension = dimension;
				if (coordinates === null) { this._coordinates = new Array(0).fill(null); }
			} else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
				var size$1 = arguments[0];
				var dimension$1 = arguments[1];
				this._coordinates = new Array(size$1).fill(null);
				this._dimension = dimension$1;
				for (var i$2 = 0; i$2 < size$1; i$2++) {
					this$1$1._coordinates[i$2] = new Coordinate();
				}
			}
		}
	};

	var staticAccessors$18 = { serialVersionUID: { configurable: true } };
	CoordinateArraySequence.prototype.setOrdinate = function setOrdinate(index, ordinateIndex, value) {
		switch (ordinateIndex) {
			case CoordinateSequence.X:
				this._coordinates[index].x = value;
				break
			case CoordinateSequence.Y:
				this._coordinates[index].y = value;
				break
			case CoordinateSequence.Z:
				this._coordinates[index].z = value;
				break
			default:
				throw new IllegalArgumentException('invalid ordinateIndex')
		}
	};
	CoordinateArraySequence.prototype.size = function size() {
		return this._coordinates.length
	};
	CoordinateArraySequence.prototype.getOrdinate = function getOrdinate(index, ordinateIndex) {
		switch (ordinateIndex) {
			case CoordinateSequence.X:
				return this._coordinates[index].x
			case CoordinateSequence.Y:
				return this._coordinates[index].y
			case CoordinateSequence.Z:
				return this._coordinates[index].z
		}
		return Double.NaN
	};
	CoordinateArraySequence.prototype.getCoordinate = function getCoordinate() {
		if (arguments.length === 1) {
			var i = arguments[0];
			return this._coordinates[i]
		} else if (arguments.length === 2) {
			var index = arguments[0];
			var coord = arguments[1];
			coord.x = this._coordinates[index].x;
			coord.y = this._coordinates[index].y;
			coord.z = this._coordinates[index].z;
		}
	};
	CoordinateArraySequence.prototype.getCoordinateCopy = function getCoordinateCopy(i) {
		return new Coordinate(this._coordinates[i])
	};
	CoordinateArraySequence.prototype.getDimension = function getDimension() {
		return this._dimension
	};
	CoordinateArraySequence.prototype.getX = function getX(index) {
		return this._coordinates[index].x
	};
	CoordinateArraySequence.prototype.clone = function clone() {
		var this$1$1 = this;

		var cloneCoordinates = new Array(this.size()).fill(null);
		for (var i = 0; i < this._coordinates.length; i++) {
			cloneCoordinates[i] = this$1$1._coordinates[i].clone();
		}
		return new CoordinateArraySequence(cloneCoordinates, this._dimension)
	};
	CoordinateArraySequence.prototype.expandEnvelope = function expandEnvelope(env) {
		var this$1$1 = this;

		for (var i = 0; i < this._coordinates.length; i++) {
			env.expandToInclude(this$1$1._coordinates[i]);
		}
		return env
	};
	CoordinateArraySequence.prototype.copy = function copy() {
		var this$1$1 = this;

		var cloneCoordinates = new Array(this.size()).fill(null);
		for (var i = 0; i < this._coordinates.length; i++) {
			cloneCoordinates[i] = this$1$1._coordinates[i].copy();
		}
		return new CoordinateArraySequence(cloneCoordinates, this._dimension)
	};
	CoordinateArraySequence.prototype.toString = function toString() {
		var this$1$1 = this;

		if (this._coordinates.length > 0) {
			var strBuf = new StringBuffer(17 * this._coordinates.length);
			strBuf.append('(');
			strBuf.append(this._coordinates[0]);
			for (var i = 1; i < this._coordinates.length; i++) {
				strBuf.append(', ');
				strBuf.append(this$1$1._coordinates[i]);
			}
			strBuf.append(')');
			return strBuf.toString()
		} else {
			return '()'
		}
	};
	CoordinateArraySequence.prototype.getY = function getY(index) {
		return this._coordinates[index].y
	};
	CoordinateArraySequence.prototype.toCoordinateArray = function toCoordinateArray() {
		return this._coordinates
	};
	CoordinateArraySequence.prototype.interfaces_ = function interfaces_() {
		return [CoordinateSequence, Serializable]
	};
	CoordinateArraySequence.prototype.getClass = function getClass() {
		return CoordinateArraySequence
	};
	staticAccessors$18.serialVersionUID.get = function () { return -915438501601840650 };

	Object.defineProperties(CoordinateArraySequence, staticAccessors$18);

	var CoordinateArraySequenceFactory = function CoordinateArraySequenceFactory() { };

	var staticAccessors$17 = { serialVersionUID: { configurable: true }, instanceObject: { configurable: true } };

	CoordinateArraySequenceFactory.prototype.readResolve = function readResolve() {
		return CoordinateArraySequenceFactory.instance()
	};
	CoordinateArraySequenceFactory.prototype.create = function create() {
		if (arguments.length === 1) {
			if (arguments[0] instanceof Array) {
				var coordinates = arguments[0];
				return new CoordinateArraySequence(coordinates)
			} else if (hasInterface(arguments[0], CoordinateSequence)) {
				var coordSeq = arguments[0];
				return new CoordinateArraySequence(coordSeq)
			}
		} else if (arguments.length === 2) {
			var size = arguments[0];
			var dimension = arguments[1];
			if (dimension > 3) { dimension = 3; }
			if (dimension < 2) { return new CoordinateArraySequence(size) }
			return new CoordinateArraySequence(size, dimension)
		}
	};
	CoordinateArraySequenceFactory.prototype.interfaces_ = function interfaces_() {
		return [CoordinateSequenceFactory, Serializable]
	};
	CoordinateArraySequenceFactory.prototype.getClass = function getClass() {
		return CoordinateArraySequenceFactory
	};
	CoordinateArraySequenceFactory.instance = function instance() {
		return CoordinateArraySequenceFactory.instanceObject
	};

	staticAccessors$17.serialVersionUID.get = function () { return -4099577099607551657 };
	staticAccessors$17.instanceObject.get = function () { return new CoordinateArraySequenceFactory() };

	Object.defineProperties(CoordinateArraySequenceFactory, staticAccessors$17);

	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/HashMap.html
	 *
	 * @extends {javascript.util.Map}
	 * @constructor
	 * @private
	 */
	var HashMap = (function (MapInterface) {
		function HashMap() {
			MapInterface.call(this);
			this.map_ = new Map();
		}

		if (MapInterface) HashMap.__proto__ = MapInterface;
		HashMap.prototype = Object.create(MapInterface && MapInterface.prototype);
		HashMap.prototype.constructor = HashMap;
		/**
		 * @override
		 */
		HashMap.prototype.get = function get(key) {
			return this.map_.get(key) || null
		};

		/**
		 * @override
		 */
		HashMap.prototype.put = function put(key, value) {
			this.map_.set(key, value);
			return value
		};

		/**
		 * @override
		 */
		HashMap.prototype.values = function values() {
			var arrayList = new ArrayList();
			var it = this.map_.values();
			var o = it.next();
			while (!o.done) {
				arrayList.add(o.value);
				o = it.next();
			}
			return arrayList
		};

		/**
		 * @override
		 */
		HashMap.prototype.entrySet = function entrySet() {
			var hashSet = new HashSet();
			this.map_.entries().forEach(function (entry) { return hashSet.add(entry); });
			return hashSet
		};

		/**
		 * @override
		 */
		HashMap.prototype.size = function size() {
			return this.map_.size()
		};

		return HashMap;
	}(Map$1));

	var PrecisionModel = function PrecisionModel() {
		this._modelType = null;
		this._scale = null;
		if (arguments.length === 0) {
			this._modelType = PrecisionModel.FLOATING;
		} else if (arguments.length === 1) {
			if (arguments[0] instanceof Type) {
				var modelType = arguments[0];
				this._modelType = modelType;
				if (modelType === PrecisionModel.FIXED) {
					this.setScale(1.0);
				}
			} else if (typeof arguments[0] === 'number') {
				var scale = arguments[0];
				this._modelType = PrecisionModel.FIXED;
				this.setScale(scale);
			} else if (arguments[0] instanceof PrecisionModel) {
				var pm = arguments[0];
				this._modelType = pm._modelType;
				this._scale = pm._scale;
			}
		}
	};

	var staticAccessors$19 = { serialVersionUID: { configurable: true }, maximumPreciseValue: { configurable: true } };
	PrecisionModel.prototype.equals = function equals(other) {
		if (!(other instanceof PrecisionModel)) {
			return false
		}
		var otherPrecisionModel = other;
		return this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale
	};
	PrecisionModel.prototype.compareTo = function compareTo(o) {
		var other = o;
		var sigDigits = this.getMaximumSignificantDigits();
		var otherSigDigits = other.getMaximumSignificantDigits();
		return new Integer(sigDigits).compareTo(new Integer(otherSigDigits))
	};
	PrecisionModel.prototype.getScale = function getScale() {
		return this._scale
	};
	PrecisionModel.prototype.isFloating = function isFloating() {
		return this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE
	};
	PrecisionModel.prototype.getType = function getType() {
		return this._modelType
	};
	PrecisionModel.prototype.toString = function toString() {
		var description = 'UNKNOWN';
		if (this._modelType === PrecisionModel.FLOATING) {
			description = 'Floating';
		} else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
			description = 'Floating-Single';
		} else if (this._modelType === PrecisionModel.FIXED) {
			description = 'Fixed (Scale=' + this.getScale() + ')';
		}
		return description
	};
	PrecisionModel.prototype.makePrecise = function makePrecise() {
		if (typeof arguments[0] === 'number') {
			var val = arguments[0];
			if (Double.isNaN(val)) { return val }
			if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
				var floatSingleVal = val;
				return floatSingleVal
			}
			if (this._modelType === PrecisionModel.FIXED) {
				return Math.round(val * this._scale) / this._scale
			}
			return val
		} else if (arguments[0] instanceof Coordinate) {
			var coord = arguments[0];
			if (this._modelType === PrecisionModel.FLOATING) { return null }
			coord.x = this.makePrecise(coord.x);
			coord.y = this.makePrecise(coord.y);
		}
	};
	PrecisionModel.prototype.getMaximumSignificantDigits = function getMaximumSignificantDigits() {
		var maxSigDigits = 16;
		if (this._modelType === PrecisionModel.FLOATING) {
			maxSigDigits = 16;
		} else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
			maxSigDigits = 6;
		} else if (this._modelType === PrecisionModel.FIXED) {
			maxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));
		}
		return maxSigDigits
	};
	PrecisionModel.prototype.setScale = function setScale(scale) {
		this._scale = Math.abs(scale);
	};
	PrecisionModel.prototype.interfaces_ = function interfaces_() {
		return [Serializable, Comparable]
	};
	PrecisionModel.prototype.getClass = function getClass() {
		return PrecisionModel
	};
	PrecisionModel.mostPrecise = function mostPrecise(pm1, pm2) {
		if (pm1.compareTo(pm2) >= 0) { return pm1 }
		return pm2
	};
	staticAccessors$19.serialVersionUID.get = function () { return 7777263578777803835 };
	staticAccessors$19.maximumPreciseValue.get = function () { return 9007199254740992.0 };

	Object.defineProperties(PrecisionModel, staticAccessors$19);

	var Type = function Type(name) {
		this._name = name || null;
		Type.nameToTypeMap.put(name, this);
	};

	var staticAccessors$1$1 = { serialVersionUID: { configurable: true }, nameToTypeMap: { configurable: true } };
	Type.prototype.readResolve = function readResolve() {
		return Type.nameToTypeMap.get(this._name)
	};
	Type.prototype.toString = function toString() {
		return this._name
	};
	Type.prototype.interfaces_ = function interfaces_() {
		return [Serializable]
	};
	Type.prototype.getClass = function getClass() {
		return Type
	};
	staticAccessors$1$1.serialVersionUID.get = function () { return -5528602631731589822 };
	staticAccessors$1$1.nameToTypeMap.get = function () { return new HashMap() };

	Object.defineProperties(Type, staticAccessors$1$1);

	PrecisionModel.Type = Type;
	PrecisionModel.FIXED = new Type('FIXED');
	PrecisionModel.FLOATING = new Type('FLOATING');
	PrecisionModel.FLOATING_SINGLE = new Type('FLOATING SINGLE');

	var GeometryFactory = function GeometryFactory() {
		this._precisionModel = new PrecisionModel();
		this._SRID = 0;
		this._coordinateSequenceFactory = GeometryFactory.getDefaultCoordinateSequenceFactory();

		if (arguments.length === 0); else if (arguments.length === 1) {
			if (hasInterface(arguments[0], CoordinateSequenceFactory)) {
				this._coordinateSequenceFactory = arguments[0];
			} else if (arguments[0] instanceof PrecisionModel) {
				this._precisionModel = arguments[0];
			}
		} else if (arguments.length === 2) {
			this._precisionModel = arguments[0];
			this._SRID = arguments[1];
		} else if (arguments.length === 3) {
			this._precisionModel = arguments[0];
			this._SRID = arguments[1];
			this._coordinateSequenceFactory = arguments[2];
		}
	};

	var staticAccessors$2 = { serialVersionUID: { configurable: true } };
	GeometryFactory.prototype.toGeometry = function toGeometry(envelope) {
		if (envelope.isNull()) {
			return this.createPoint(null)
		}
		if (envelope.getMinX() === envelope.getMaxX() && envelope.getMinY() === envelope.getMaxY()) {
			return this.createPoint(new Coordinate(envelope.getMinX(), envelope.getMinY()))
		}
		if (envelope.getMinX() === envelope.getMaxX() || envelope.getMinY() === envelope.getMaxY()) {
			return this.createLineString([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY())])
		}
		return this.createPolygon(this.createLinearRing([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMinY())]), null)
	};
	GeometryFactory.prototype.createLineString = function createLineString(coordinates) {
		if (!coordinates) { return new LineString(this.getCoordinateSequenceFactory().create([]), this) }
		else if (coordinates instanceof Array) { return new LineString(this.getCoordinateSequenceFactory().create(coordinates), this) }
		else if (hasInterface(coordinates, CoordinateSequence)) { return new LineString(coordinates, this) }
	};
	GeometryFactory.prototype.createMultiLineString = function createMultiLineString() {
		if (arguments.length === 0) {
			return new MultiLineString(null, this)
		} else if (arguments.length === 1) {
			var lineStrings = arguments[0];
			return new MultiLineString(lineStrings, this)
		}
	};
	GeometryFactory.prototype.buildGeometry = function buildGeometry(geomList) {
		var geomClass = null;
		var isHeterogeneous = false;
		var hasGeometryCollection = false;
		for (var i = geomList.iterator(); i.hasNext();) {
			var geom = i.next();
			var partClass = geom.getClass();
			if (geomClass === null) {
				geomClass = partClass;
			}
			if (partClass !== geomClass) {
				isHeterogeneous = true;
			}
			if (geom.isGeometryCollectionOrDerived()) { hasGeometryCollection = true; }
		}
		if (geomClass === null) {
			return this.createGeometryCollection()
		}
		if (isHeterogeneous || hasGeometryCollection) {
			return this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList))
		}
		var geom0 = geomList.iterator().next();
		var isCollection = geomList.size() > 1;
		if (isCollection) {
			if (geom0 instanceof Polygon) {
				return this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList))
			} else if (geom0 instanceof LineString) {
				return this.createMultiLineString(GeometryFactory.toLineStringArray(geomList))
			} else if (geom0 instanceof Point) {
				return this.createMultiPoint(GeometryFactory.toPointArray(geomList))
			}
			Assert.shouldNeverReachHere('Unhandled class: ' + geom0.getClass().getName());
		}
		return geom0
	};
	GeometryFactory.prototype.createMultiPointFromCoords = function createMultiPointFromCoords(coordinates) {
		return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null)
	};
	GeometryFactory.prototype.createPoint = function createPoint() {
		if (arguments.length === 0) {
			return this.createPoint(this.getCoordinateSequenceFactory().create([]))
		} else if (arguments.length === 1) {
			if (arguments[0] instanceof Coordinate) {
				var coordinate = arguments[0];
				return this.createPoint(coordinate !== null ? this.getCoordinateSequenceFactory().create([coordinate]) : null)
			} else if (hasInterface(arguments[0], CoordinateSequence)) {
				var coordinates = arguments[0];
				return new Point(coordinates, this)
			}
		}
	};
	GeometryFactory.prototype.getCoordinateSequenceFactory = function getCoordinateSequenceFactory() {
		return this._coordinateSequenceFactory
	};
	GeometryFactory.prototype.createPolygon = function createPolygon() {
		if (arguments.length === 0) {
			return new Polygon(null, null, this)
		} else if (arguments.length === 1) {
			if (hasInterface(arguments[0], CoordinateSequence)) {
				var coordinates = arguments[0];
				return this.createPolygon(this.createLinearRing(coordinates))
			} else if (arguments[0] instanceof Array) {
				var coordinates$1 = arguments[0];
				return this.createPolygon(this.createLinearRing(coordinates$1))
			} else if (arguments[0] instanceof LinearRing) {
				var shell = arguments[0];
				return this.createPolygon(shell, null)
			}
		} else if (arguments.length === 2) {
			var shell$1 = arguments[0];
			var holes = arguments[1];
			return new Polygon(shell$1, holes, this)
		}
	};
	GeometryFactory.prototype.getSRID = function getSRID() {
		return this._SRID
	};
	GeometryFactory.prototype.createGeometryCollection = function createGeometryCollection() {
		if (arguments.length === 0) {
			return new GeometryCollection(null, this)
		} else if (arguments.length === 1) {
			var geometries = arguments[0];
			return new GeometryCollection(geometries, this)
		}
	};
	GeometryFactory.prototype.createGeometry = function createGeometry(g) {
		var editor = new GeometryEditor(this);
		return editor.edit(g, {
			edit: function () {
				if (arguments.length === 2) {
					var coordSeq = arguments[0];
					// const geometry = arguments[1]
					return this._coordinateSequenceFactory.create(coordSeq)
				}
			}
		})
	};
	GeometryFactory.prototype.getPrecisionModel = function getPrecisionModel() {
		return this._precisionModel
	};
	GeometryFactory.prototype.createLinearRing = function createLinearRing() {
		if (arguments.length === 0) {
			return this.createLinearRing(this.getCoordinateSequenceFactory().create([]))
		} else if (arguments.length === 1) {
			if (arguments[0] instanceof Array) {
				var coordinates = arguments[0];
				return this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null)
			} else if (hasInterface(arguments[0], CoordinateSequence)) {
				var coordinates$1 = arguments[0];
				return new LinearRing(coordinates$1, this)
			}
		}
	};
	GeometryFactory.prototype.createMultiPolygon = function createMultiPolygon() {
		if (arguments.length === 0) {
			return new MultiPolygon(null, this)
		} else if (arguments.length === 1) {
			var polygons = arguments[0];
			return new MultiPolygon(polygons, this)
		}
	};
	GeometryFactory.prototype.createMultiPoint = function createMultiPoint() {
		var this$1$1 = this;

		if (arguments.length === 0) {
			return new MultiPoint(null, this)
		} else if (arguments.length === 1) {
			if (arguments[0] instanceof Array) {
				var point = arguments[0];
				return new MultiPoint(point, this)
			} else if (arguments[0] instanceof Array) {
				var coordinates = arguments[0];
				return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null)
			} else if (hasInterface(arguments[0], CoordinateSequence)) {
				var coordinates$1 = arguments[0];
				if (coordinates$1 === null) {
					return this.createMultiPoint(new Array(0).fill(null))
				}
				var points = new Array(coordinates$1.size()).fill(null);
				for (var i = 0; i < coordinates$1.size(); i++) {
					var ptSeq = this$1$1.getCoordinateSequenceFactory().create(1, coordinates$1.getDimension());
					CoordinateSequences.copy(coordinates$1, i, ptSeq, 0, 1);
					points[i] = this$1$1.createPoint(ptSeq);
				}
				return this.createMultiPoint(points)
			}
		}
	};
	GeometryFactory.prototype.interfaces_ = function interfaces_() {
		return [Serializable]
	};
	GeometryFactory.prototype.getClass = function getClass() {
		return GeometryFactory
	};
	GeometryFactory.toMultiPolygonArray = function toMultiPolygonArray(multiPolygons) {
		var multiPolygonArray = new Array(multiPolygons.size()).fill(null);
		return multiPolygons.toArray(multiPolygonArray)
	};
	GeometryFactory.toGeometryArray = function toGeometryArray(geometries) {
		if (geometries === null) { return null }
		var geometryArray = new Array(geometries.size()).fill(null);
		return geometries.toArray(geometryArray)
	};
	GeometryFactory.getDefaultCoordinateSequenceFactory = function getDefaultCoordinateSequenceFactory() {
		return CoordinateArraySequenceFactory.instance()
	};
	GeometryFactory.toMultiLineStringArray = function toMultiLineStringArray(multiLineStrings) {
		var multiLineStringArray = new Array(multiLineStrings.size()).fill(null);
		return multiLineStrings.toArray(multiLineStringArray)
	};
	GeometryFactory.toLineStringArray = function toLineStringArray(lineStrings) {
		var lineStringArray = new Array(lineStrings.size()).fill(null);
		return lineStrings.toArray(lineStringArray)
	};
	GeometryFactory.toMultiPointArray = function toMultiPointArray(multiPoints) {
		var multiPointArray = new Array(multiPoints.size()).fill(null);
		return multiPoints.toArray(multiPointArray)
	};
	GeometryFactory.toLinearRingArray = function toLinearRingArray(linearRings) {
		var linearRingArray = new Array(linearRings.size()).fill(null);
		return linearRings.toArray(linearRingArray)
	};
	GeometryFactory.toPointArray = function toPointArray(points) {
		var pointArray = new Array(points.size()).fill(null);
		return points.toArray(pointArray)
	};
	GeometryFactory.toPolygonArray = function toPolygonArray(polygons) {
		var polygonArray = new Array(polygons.size()).fill(null);
		return polygons.toArray(polygonArray)
	};
	GeometryFactory.createPointFromInternalCoord = function createPointFromInternalCoord(coord, exemplar) {
		exemplar.getPrecisionModel().makePrecise(coord);
		return exemplar.getFactory().createPoint(coord)
	};
	staticAccessors$2.serialVersionUID.get = function () { return -6820524753094095635 };

	Object.defineProperties(GeometryFactory, staticAccessors$2);

	var geometryTypes = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon'];

	/**
	 * Class for reading and writing Well-Known Text.Create a new parser for GeoJSON
	 * NOTE: Adapted from OpenLayers 2.11 implementation.
	 */

	/**
	 * Create a new parser for GeoJSON
	 *
	 * @param {GeometryFactory} geometryFactory
	 * @return An instance of GeoJsonParser.
	 * @constructor
	 * @private
	 */
	var GeoJSONParser = function GeoJSONParser(geometryFactory) {
		this.geometryFactory = geometryFactory || new GeometryFactory();
	};
	/**
	 * Deserialize a GeoJSON object and return the Geometry or Feature(Collection) with JSTS Geometries
	 *
	 * @param {}
	 *        A GeoJSON object.
	 * @return {} A Geometry instance or object representing a Feature(Collection) with Geometry instances.
	 * @private
	 */
	GeoJSONParser.prototype.read = function read(json) {
		var obj;
		if (typeof json === 'string') {
			obj = JSON.parse(json);
		} else {
			obj = json;
		}

		var type = obj.type;

		if (!parse[type]) {
			throw new Error('Unknown GeoJSON type: ' + obj.type)
		}

		if (geometryTypes.indexOf(type) !== -1) {
			return parse[type].apply(this, [obj.coordinates])
		} else if (type === 'GeometryCollection') {
			return parse[type].apply(this, [obj.geometries])
		}

		// feature or feature collection
		return parse[type].apply(this, [obj])
	};

	/**
	 * Serialize a Geometry object into GeoJSON
	 *
	 * @param {Geometry}
	 *        geometry A Geometry or array of Geometries.
	 * @return {Object} A GeoJSON object represting the input Geometry/Geometries.
	 * @private
	 */
	GeoJSONParser.prototype.write = function write(geometry) {
		var type = geometry.getGeometryType();

		if (!extract[type]) {
			throw new Error('Geometry is not supported')
		}

		return extract[type].apply(this, [geometry])
	};

	var parse = {
		/**
		 * Parse a GeoJSON Feature object
		 *
		 * @param {Object}
		 *          obj Object to parse.
		 *
		 * @return {Object} Feature with geometry/bbox converted to JSTS Geometries.
		 */
		Feature: function (obj) {
			var feature = {};

			// copy features
			for (var key in obj) {
				feature[key] = obj[key];
			}

			// parse geometry
			if (obj.geometry) {
				var type = obj.geometry.type;
				if (!parse[type]) {
					throw new Error('Unknown GeoJSON type: ' + obj.type)
				}
				feature.geometry = this.read(obj.geometry);
			}

			// bbox
			if (obj.bbox) {
				feature.bbox = parse.bbox.apply(this, [obj.bbox]);
			}

			return feature
		},

		/**
		 * Parse a GeoJSON FeatureCollection object
		 *
		 * @param {Object}
		 *          obj Object to parse.
		 *
		 * @return {Object} FeatureCollection with geometry/bbox converted to JSTS Geometries.
		 */
		FeatureCollection: function (obj) {
			var this$1$1 = this;

			var featureCollection = {};

			if (obj.features) {
				featureCollection.features = [];

				for (var i = 0; i < obj.features.length; ++i) {
					featureCollection.features.push(this$1$1.read(obj.features[i]));
				}
			}

			if (obj.bbox) {
				featureCollection.bbox = this.parse.bbox.apply(this, [obj.bbox]);
			}

			return featureCollection
		},

		/**
		 * Convert the ordinates in an array to an array of Coordinates
		 *
		 * @param {Array}
		 *          array Array with {Number}s.
		 *
		 * @return {Array} Array with Coordinates.
		 */
		coordinates: function (array) {
			var coordinates = [];
			for (var i = 0; i < array.length; ++i) {
				var sub = array[i];
				coordinates.push(new Coordinate(sub[0], sub[1]));
			}
			return coordinates
		},

		/**
		 * Convert the bbox to a LinearRing
		 *
		 * @param {Array}
		 *          array Array with [xMin, yMin, xMax, yMax].
		 *
		 * @return {Array} Array with Coordinates.
		 */
		bbox: function (array) {
			return this.geometryFactory.createLinearRing([
				new Coordinate(array[0], array[1]),
				new Coordinate(array[2], array[1]),
				new Coordinate(array[2], array[3]),
				new Coordinate(array[0], array[3]),
				new Coordinate(array[0], array[1])
			])
		},

		/**
		 * Convert an Array with ordinates to a Point
		 *
		 * @param {Array}
		 *          array Array with ordinates.
		 *
		 * @return {Point} Point.
		 */
		Point: function (array) {
			var coordinate = new Coordinate(array[0], array[1]);
			return this.geometryFactory.createPoint(coordinate)
		},

		/**
		 * Convert an Array with coordinates to a MultiPoint
		 *
		 * @param {Array}
		 *          array Array with coordinates.
		 *
		 * @return {MultiPoint} MultiPoint.
		 */
		MultiPoint: function (array) {
			var this$1$1 = this;

			var points = [];
			for (var i = 0; i < array.length; ++i) {
				points.push(parse.Point.apply(this$1$1, [array[i]]));
			}
			return this.geometryFactory.createMultiPoint(points)
		},

		/**
		 * Convert an Array with coordinates to a LineString
		 *
		 * @param {Array}
		 *          array Array with coordinates.
		 *
		 * @return {LineString} LineString.
		 */
		LineString: function (array) {
			var coordinates = parse.coordinates.apply(this, [array]);
			return this.geometryFactory.createLineString(coordinates)
		},

		/**
		 * Convert an Array with coordinates to a MultiLineString
		 *
		 * @param {Array}
		 *          array Array with coordinates.
		 *
		 * @return {MultiLineString} MultiLineString.
		 */
		MultiLineString: function (array) {
			var this$1$1 = this;

			var lineStrings = [];
			for (var i = 0; i < array.length; ++i) {
				lineStrings.push(parse.LineString.apply(this$1$1, [array[i]]));
			}
			return this.geometryFactory.createMultiLineString(lineStrings)
		},

		/**
		 * Convert an Array to a Polygon
		 *
		 * @param {Array}
		 *          array Array with shell and holes.
		 *
		 * @return {Polygon} Polygon.
		 */
		Polygon: function (array) {
			var this$1$1 = this;

			var shellCoordinates = parse.coordinates.apply(this, [array[0]]);
			var shell = this.geometryFactory.createLinearRing(shellCoordinates);
			var holes = [];
			for (var i = 1; i < array.length; ++i) {
				var hole = array[i];
				var coordinates = parse.coordinates.apply(this$1$1, [hole]);
				var linearRing = this$1$1.geometryFactory.createLinearRing(coordinates);
				holes.push(linearRing);
			}
			return this.geometryFactory.createPolygon(shell, holes)
		},

		/**
		 * Convert an Array to a MultiPolygon
		 *
		 * @param {Array}
		 *          array Array of arrays with shell and rings.
		 *
		 * @return {MultiPolygon} MultiPolygon.
		 */
		MultiPolygon: function (array) {
			var this$1$1 = this;

			var polygons = [];
			for (var i = 0; i < array.length; ++i) {
				var polygon = array[i];
				polygons.push(parse.Polygon.apply(this$1$1, [polygon]));
			}
			return this.geometryFactory.createMultiPolygon(polygons)
		},

		/**
		 * Convert an Array to a GeometryCollection
		 *
		 * @param {Array}
		 *          array Array of GeoJSON geometries.
		 *
		 * @return {GeometryCollection} GeometryCollection.
		 */
		GeometryCollection: function (array) {
			var this$1$1 = this;

			var geometries = [];
			for (var i = 0; i < array.length; ++i) {
				var geometry = array[i];
				geometries.push(this$1$1.read(geometry));
			}
			return this.geometryFactory.createGeometryCollection(geometries)
		}
	};

	var extract = {
		/**
		 * Convert a Coordinate to an Array
		 *
		 * @param {Coordinate}
		 *          coordinate Coordinate to convert.
		 *
		 * @return {Array} Array of ordinates.
		 */
		coordinate: function (coordinate) {
			return [coordinate.x, coordinate.y]
		},

		/**
		 * Convert a Point to a GeoJSON object
		 *
		 * @param {Point}
		 *          point Point to convert.
		 *
		 * @return {Array} Array of 2 ordinates (paired to a coordinate).
		 */
		Point: function (point) {
			var array = extract.coordinate.apply(this, [point.getCoordinate()]);
			return {
				type: 'Point',
				coordinates: array
			}
		},

		/**
		 * Convert a MultiPoint to a GeoJSON object
		 *
		 * @param {MultiPoint}
		 *          multipoint MultiPoint to convert.
		 *
		 * @return {Array} Array of coordinates.
		 */
		MultiPoint: function (multipoint) {
			var this$1$1 = this;

			var array = [];
			for (var i = 0; i < multipoint._geometries.length; ++i) {
				var point = multipoint._geometries[i];
				var geoJson = extract.Point.apply(this$1$1, [point]);
				array.push(geoJson.coordinates);
			}
			return {
				type: 'MultiPoint',
				coordinates: array
			}
		},

		/**
		 * Convert a LineString to a GeoJSON object
		 *
		 * @param {LineString}
		 *          linestring LineString to convert.
		 *
		 * @return {Array} Array of coordinates.
		 */
		LineString: function (linestring) {
			var this$1$1 = this;

			var array = [];
			var coordinates = linestring.getCoordinates();
			for (var i = 0; i < coordinates.length; ++i) {
				var coordinate = coordinates[i];
				array.push(extract.coordinate.apply(this$1$1, [coordinate]));
			}
			return {
				type: 'LineString',
				coordinates: array
			}
		},

		/**
		 * Convert a MultiLineString to a GeoJSON object
		 *
		 * @param {MultiLineString}
		 *          multilinestring MultiLineString to convert.
		 *
		 * @return {Array} Array of Array of coordinates.
		 */
		MultiLineString: function (multilinestring) {
			var this$1$1 = this;

			var array = [];
			for (var i = 0; i < multilinestring._geometries.length; ++i) {
				var linestring = multilinestring._geometries[i];
				var geoJson = extract.LineString.apply(this$1$1, [linestring]);
				array.push(geoJson.coordinates);
			}
			return {
				type: 'MultiLineString',
				coordinates: array
			}
		},

		/**
		 * Convert a Polygon to a GeoJSON object
		 *
		 * @param {Polygon}
		 *          polygon Polygon to convert.
		 *
		 * @return {Array} Array with shell, holes.
		 */
		Polygon: function (polygon) {
			var this$1$1 = this;

			var array = [];
			var shellGeoJson = extract.LineString.apply(this, [polygon._shell]);
			array.push(shellGeoJson.coordinates);
			for (var i = 0; i < polygon._holes.length; ++i) {
				var hole = polygon._holes[i];
				var holeGeoJson = extract.LineString.apply(this$1$1, [hole]);
				array.push(holeGeoJson.coordinates);
			}
			return {
				type: 'Polygon',
				coordinates: array
			}
		},

		/**
		 * Convert a MultiPolygon to a GeoJSON object
		 *
		 * @param {MultiPolygon}
		 *          multipolygon MultiPolygon to convert.
		 *
		 * @return {Array} Array of polygons.
		 */
		MultiPolygon: function (multipolygon) {
			var this$1$1 = this;

			var array = [];
			for (var i = 0; i < multipolygon._geometries.length; ++i) {
				var polygon = multipolygon._geometries[i];
				var geoJson = extract.Polygon.apply(this$1$1, [polygon]);
				array.push(geoJson.coordinates);
			}
			return {
				type: 'MultiPolygon',
				coordinates: array
			}
		},

		/**
		 * Convert a GeometryCollection to a GeoJSON object
		 *
		 * @param {GeometryCollection}
		 *          collection GeometryCollection to convert.
		 *
		 * @return {Array} Array of geometries.
		 */
		GeometryCollection: function (collection) {
			var this$1$1 = this;

			var array = [];
			for (var i = 0; i < collection._geometries.length; ++i) {
				var geometry = collection._geometries[i];
				var type = geometry.getGeometryType();
				array.push(extract[type].apply(this$1$1, [geometry]));
			}
			return {
				type: 'GeometryCollection',
				geometries: array
			}
		}
	};

	/**
	 * Converts a geometry in GeoJSON to a {@link Geometry}.
	 */

	/**
	 * A <code>GeoJSONReader</code> is parameterized by a <code>GeometryFactory</code>,
	 * to allow it to create <code>Geometry</code> objects of the appropriate
	 * implementation. In particular, the <code>GeometryFactory</code> determines
	 * the <code>PrecisionModel</code> and <code>SRID</code> that is used.
	 *
	 * @param {GeometryFactory} geometryFactory
	 * @constructor
	 */
	var GeoJSONReader = function GeoJSONReader(geometryFactory) {
		this.geometryFactory = geometryFactory || new GeometryFactory();
		this.precisionModel = this.geometryFactory.getPrecisionModel();
		this.parser = new GeoJSONParser(this.geometryFactory);
	};
	/**
	 * Reads a GeoJSON representation of a {@link Geometry}
	 *
	 * Will also parse GeoJSON Features/FeatureCollections as custom objects.
	 *
	 * @param {Object|String} geoJson a GeoJSON Object or String.
	 * @return {Geometry|Object} a <code>Geometry or Feature/FeatureCollection representation.</code>
	 * @memberof GeoJSONReader
	 */
	GeoJSONReader.prototype.read = function read(geoJson) {
		var geometry = this.parser.read(geoJson);

		if (this.precisionModel.getType() === PrecisionModel.FIXED) {
			this.reducePrecision(geometry);
		}

		return geometry
	};

	// NOTE: this is a hack
	GeoJSONReader.prototype.reducePrecision = function reducePrecision(geometry) {
		var this$1$1 = this;

		var i, len;

		if (geometry.coordinate) {
			this.precisionModel.makePrecise(geometry.coordinate);
		} else if (geometry.points) {
			for (i = 0, len = geometry.points.length; i < len; i++) {
				this$1$1.precisionModel.makePrecise(geometry.points[i]);
			}
		} else if (geometry.geometries) {
			for (i = 0, len = geometry.geometries.length; i < len; i++) {
				this$1$1.reducePrecision(geometry.geometries[i]);
			}
		}
	};

	/**
	 * @module GeoJSONWriter
	 */

	/**
	 * Writes the GeoJSON representation of a {@link Geometry}. The
	 * The GeoJSON format is defined <A
	 * HREF="http://geojson.org/geojson-spec.html">here</A>.
	 */

	/**
	 * The <code>GeoJSONWriter</code> outputs coordinates rounded to the precision
	 * model. Only the maximum number of decimal places necessary to represent the
	 * ordinates to the required precision will be output.
	 *
	 * @param {GeometryFactory} geometryFactory
	 * @constructor
	 */
	var GeoJSONWriter = function GeoJSONWriter() {
		this.parser = new GeoJSONParser(this.geometryFactory);
	};
	/**
	 * Converts a <code>Geometry</code> to its GeoJSON representation.
	 *
	 * @param {Geometry}
	 *        geometry a <code>Geometry</code> to process.
	 * @return {Object} The GeoJSON representation of the Geometry.
	 * @memberof GeoJSONWriter
	 */
	GeoJSONWriter.prototype.write = function write(geometry) {
		return this.parser.write(geometry)
	};

	/* eslint-disable no-undef */

	// io

	var Position = function Position() { };

	var staticAccessors$20 = { ON: { configurable: true }, LEFT: { configurable: true }, RIGHT: { configurable: true } };

	Position.prototype.interfaces_ = function interfaces_() {
		return []
	};
	Position.prototype.getClass = function getClass() {
		return Position
	};
	Position.opposite = function opposite(position) {
		if (position === Position.LEFT) { return Position.RIGHT }
		if (position === Position.RIGHT) { return Position.LEFT }
		return position
	};
	staticAccessors$20.ON.get = function () { return 0 };
	staticAccessors$20.LEFT.get = function () { return 1 };
	staticAccessors$20.RIGHT.get = function () { return 2 };

	Object.defineProperties(Position, staticAccessors$20);

	/**
	 * @param {string=} message Optional message
	 * @extends {Error}
	 * @constructor
	 * @private
	 */
	function EmptyStackException(message) {
		this.message = message || '';
	}
	EmptyStackException.prototype = new Error();

	/**
	 * @type {string}
	 */
	EmptyStackException.prototype.name = 'EmptyStackException';

	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/Stack.html
	 *
	 * @extends {List}
	 * @constructor
	 * @private
	 */
	function Stack() {
		/**
		 * @type {Array}
		 * @private
		 */
		this.array_ = [];
	}
	Stack.prototype = new List();

	/**
	 * @override
	 */
	Stack.prototype.add = function (e) {
		this.array_.push(e);
		return true
	};

	/**
	 * @override
	 */
	Stack.prototype.get = function (index) {
		if (index < 0 || index >= this.size()) {
			throw new Error()
		}

		return this.array_[index]
	};

	/**
	 * Pushes an item onto the top of this stack.
	 * @param {Object} e
	 * @return {Object}
	 */
	Stack.prototype.push = function (e) {
		this.array_.push(e);
		return e
	};

	/**
	 * Pushes an item onto the top of this stack.
	 * @param {Object} e
	 * @return {Object}
	 */
	Stack.prototype.pop = function (e) {
		if (this.array_.length === 0) {
			throw new EmptyStackException()
		}

		return this.array_.pop()
	};

	/**
	 * Looks at the object at the top of this stack without removing it from the
	 * stack.
	 * @return {Object}
	 */
	Stack.prototype.peek = function () {
		if (this.array_.length === 0) {
			throw new EmptyStackException()
		}

		return this.array_[this.array_.length - 1]
	};

	/**
	 * Tests if this stack is empty.
	 * @return {boolean} true if and only if this stack contains no items; false
	 *         otherwise.
	 */
	Stack.prototype.empty = function () {
		if (this.array_.length === 0) {
			return true
		} else {
			return false
		}
	};

	/**
	 * @return {boolean}
	 */
	Stack.prototype.isEmpty = function () {
		return this.empty()
	};

	/**
	 * Returns the 1-based position where an object is on this stack. If the object
	 * o occurs as an item in this stack, this method returns the distance from the
	 * top of the stack of the occurrence nearest the top of the stack; the topmost
	 * item on the stack is considered to be at distance 1. The equals method is
	 * used to compare o to the items in this stack.
	 *
	 * NOTE: does not currently actually use equals. (=== is used)
	 *
	 * @param {Object} o
	 * @return {number} the 1-based position from the top of the stack where the
	 *         object is located; the return value -1 indicates that the object is
	 *         not on the stack.
	 */
	Stack.prototype.search = function (o) {
		return this.array_.indexOf(o)
	};

	/**
	 * @return {number}
	 * @export
	 */
	Stack.prototype.size = function () {
		return this.array_.length
	};

	/**
	 * @return {Array}
	 */
	Stack.prototype.toArray = function () {
		var this$1$1 = this;

		var array = [];

		for (var i = 0, len = this.array_.length; i < len; i++) {
			array.push(this$1$1.array_[i]);
		}

		return array
	};

	var RightmostEdgeFinder = function RightmostEdgeFinder() {
		this._minIndex = -1;
		this._minCoord = null;
		this._minDe = null;
		this._orientedDe = null;
	};
	RightmostEdgeFinder.prototype.getCoordinate = function getCoordinate() {
		return this._minCoord
	};
	RightmostEdgeFinder.prototype.getRightmostSide = function getRightmostSide(de, index) {
		var side = this.getRightmostSideOfSegment(de, index);
		if (side < 0) { side = this.getRightmostSideOfSegment(de, index - 1); }
		if (side < 0) {
			this._minCoord = null;
			this.checkForRightmostCoordinate(de);
		}
		return side
	};
	RightmostEdgeFinder.prototype.findRightmostEdgeAtVertex = function findRightmostEdgeAtVertex() {
		var pts = this._minDe.getEdge().getCoordinates();
		Assert.isTrue(this._minIndex > 0 && this._minIndex < pts.length, 'rightmost point expected to be interior vertex of edge');
		var pPrev = pts[this._minIndex - 1];
		var pNext = pts[this._minIndex + 1];
		var orientation = CGAlgorithms.computeOrientation(this._minCoord, pNext, pPrev);
		var usePrev = false;
		if (pPrev.y < this._minCoord.y && pNext.y < this._minCoord.y && orientation === CGAlgorithms.COUNTERCLOCKWISE) {
			usePrev = true;
		} else if (pPrev.y > this._minCoord.y && pNext.y > this._minCoord.y && orientation === CGAlgorithms.CLOCKWISE) {
			usePrev = true;
		}
		if (usePrev) {
			this._minIndex = this._minIndex - 1;
		}
	};
	RightmostEdgeFinder.prototype.getRightmostSideOfSegment = function getRightmostSideOfSegment(de, i) {
		var e = de.getEdge();
		var coord = e.getCoordinates();
		if (i < 0 || i + 1 >= coord.length) { return -1 }
		if (coord[i].y === coord[i + 1].y) { return -1 }
		var pos = Position.LEFT;
		if (coord[i].y < coord[i + 1].y) { pos = Position.RIGHT; }
		return pos
	};
	RightmostEdgeFinder.prototype.getEdge = function getEdge() {
		return this._orientedDe
	};
	RightmostEdgeFinder.prototype.checkForRightmostCoordinate = function checkForRightmostCoordinate(de) {
		var this$1$1 = this;

		var coord = de.getEdge().getCoordinates();
		for (var i = 0; i < coord.length - 1; i++) {
			if (this$1$1._minCoord === null || coord[i].x > this$1$1._minCoord.x) {
				this$1$1._minDe = de;
				this$1$1._minIndex = i;
				this$1$1._minCoord = coord[i];
			}
		}
	};
	RightmostEdgeFinder.prototype.findRightmostEdgeAtNode = function findRightmostEdgeAtNode() {
		var node = this._minDe.getNode();
		var star = node.getEdges();
		this._minDe = star.getRightmostEdge();
		if (!this._minDe.isForward()) {
			this._minDe = this._minDe.getSym();
			this._minIndex = this._minDe.getEdge().getCoordinates().length - 1;
		}
	};
	RightmostEdgeFinder.prototype.findEdge = function findEdge(dirEdgeList) {
		var this$1$1 = this;

		for (var i = dirEdgeList.iterator(); i.hasNext();) {
			var de = i.next();
			if (!de.isForward()) { continue }
			this$1$1.checkForRightmostCoordinate(de);
		}
		Assert.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), 'inconsistency in rightmost processing');
		if (this._minIndex === 0) {
			this.findRightmostEdgeAtNode();
		} else {
			this.findRightmostEdgeAtVertex();
		}
		this._orientedDe = this._minDe;
		var rightmostSide = this.getRightmostSide(this._minDe, this._minIndex);
		if (rightmostSide === Position.LEFT) {
			this._orientedDe = this._minDe.getSym();
		}
	};
	RightmostEdgeFinder.prototype.interfaces_ = function interfaces_() {
		return []
	};
	RightmostEdgeFinder.prototype.getClass = function getClass() {
		return RightmostEdgeFinder
	};

	var TopologyException = (function (RuntimeException$$1) {
		function TopologyException(msg, pt) {
			RuntimeException$$1.call(this, TopologyException.msgWithCoord(msg, pt));
			this.pt = pt ? new Coordinate(pt) : null;
			this.name = 'TopologyException';
		}

		if (RuntimeException$$1) TopologyException.__proto__ = RuntimeException$$1;
		TopologyException.prototype = Object.create(RuntimeException$$1 && RuntimeException$$1.prototype);
		TopologyException.prototype.constructor = TopologyException;
		TopologyException.prototype.getCoordinate = function getCoordinate() {
			return this.pt
		};
		TopologyException.prototype.interfaces_ = function interfaces_() {
			return []
		};
		TopologyException.prototype.getClass = function getClass() {
			return TopologyException
		};
		TopologyException.msgWithCoord = function msgWithCoord(msg, pt) {
			if (!pt) { return msg + ' [ ' + pt + ' ]' }
			return msg
		};

		return TopologyException;
	}(RuntimeException));

	var LinkedList = function LinkedList() {
		this.array_ = [];
	};
	LinkedList.prototype.addLast = function addLast(e) {
		this.array_.push(e);
	};
	LinkedList.prototype.removeFirst = function removeFirst() {
		return this.array_.shift()
	};
	LinkedList.prototype.isEmpty = function isEmpty() {
		return this.array_.length === 0
	};

	var BufferSubgraph = function BufferSubgraph() {
		this._finder = null;
		this._dirEdgeList = new ArrayList();
		this._nodes = new ArrayList();
		this._rightMostCoord = null;
		this._env = null;
		this._finder = new RightmostEdgeFinder();
	};
	BufferSubgraph.prototype.clearVisitedEdges = function clearVisitedEdges() {
		for (var it = this._dirEdgeList.iterator(); it.hasNext();) {
			var de = it.next();
			de.setVisited(false);
		}
	};
	BufferSubgraph.prototype.getRightmostCoordinate = function getRightmostCoordinate() {
		return this._rightMostCoord
	};
	BufferSubgraph.prototype.computeNodeDepth = function computeNodeDepth(n) {
		var this$1$1 = this;

		var startEdge = null;
		for (var i = n.getEdges().iterator(); i.hasNext();) {
			var de = i.next();
			if (de.isVisited() || de.getSym().isVisited()) {
				startEdge = de;
				break
			}
		}
		if (startEdge === null) { throw new TopologyException('unable to find edge to compute depths at ' + n.getCoordinate()) }
		n.getEdges().computeDepths(startEdge);
		for (var i$1 = n.getEdges().iterator(); i$1.hasNext();) {
			var de$1 = i$1.next();
			de$1.setVisited(true);
			this$1$1.copySymDepths(de$1);
		}
	};
	BufferSubgraph.prototype.computeDepth = function computeDepth(outsideDepth) {
		this.clearVisitedEdges();
		var de = this._finder.getEdge();
		// const n = de.getNode()
		// const label = de.getLabel()
		de.setEdgeDepths(Position.RIGHT, outsideDepth);
		this.copySymDepths(de);
		this.computeDepths(de);
	};
	BufferSubgraph.prototype.create = function create(node) {
		this.addReachable(node);
		this._finder.findEdge(this._dirEdgeList);
		this._rightMostCoord = this._finder.getCoordinate();
	};
	BufferSubgraph.prototype.findResultEdges = function findResultEdges() {
		for (var it = this._dirEdgeList.iterator(); it.hasNext();) {
			var de = it.next();
			if (de.getDepth(Position.RIGHT) >= 1 && de.getDepth(Position.LEFT) <= 0 && !de.isInteriorAreaEdge()) {
				de.setInResult(true);
			}
		}
	};
	BufferSubgraph.prototype.computeDepths = function computeDepths(startEdge) {
		var this$1$1 = this;

		var nodesVisited = new HashSet();
		var nodeQueue = new LinkedList();
		var startNode = startEdge.getNode();
		nodeQueue.addLast(startNode);
		nodesVisited.add(startNode);
		startEdge.setVisited(true);
		while (!nodeQueue.isEmpty()) {
			var n = nodeQueue.removeFirst();
			nodesVisited.add(n);
			this$1$1.computeNodeDepth(n);
			for (var i = n.getEdges().iterator(); i.hasNext();) {
				var de = i.next();
				var sym = de.getSym();
				if (sym.isVisited()) { continue }
				var adjNode = sym.getNode();
				if (!nodesVisited.contains(adjNode)) {
					nodeQueue.addLast(adjNode);
					nodesVisited.add(adjNode);
				}
			}
		}
	};
	BufferSubgraph.prototype.compareTo = function compareTo(o) {
		var graph = o;
		if (this._rightMostCoord.x < graph._rightMostCoord.x) {
			return -1
		}
		if (this._rightMostCoord.x > graph._rightMostCoord.x) {
			return 1
		}
		return 0
	};
	BufferSubgraph.prototype.getEnvelope = function getEnvelope() {
		if (this._env === null) {
			var edgeEnv = new Envelope();
			for (var it = this._dirEdgeList.iterator(); it.hasNext();) {
				var dirEdge = it.next();
				var pts = dirEdge.getEdge().getCoordinates();
				for (var i = 0; i < pts.length - 1; i++) {
					edgeEnv.expandToInclude(pts[i]);
				}
			}
			this._env = edgeEnv;
		}
		return this._env
	};
	BufferSubgraph.prototype.addReachable = function addReachable(startNode) {
		var this$1$1 = this;

		var nodeStack = new Stack();
		nodeStack.add(startNode);
		while (!nodeStack.empty()) {
			var node = nodeStack.pop();
			this$1$1.add(node, nodeStack);
		}
	};
	BufferSubgraph.prototype.copySymDepths = function copySymDepths(de) {
		var sym = de.getSym();
		sym.setDepth(Position.LEFT, de.getDepth(Position.RIGHT));
		sym.setDepth(Position.RIGHT, de.getDepth(Position.LEFT));
	};
	BufferSubgraph.prototype.add = function add(node, nodeStack) {
		var this$1$1 = this;

		node.setVisited(true);
		this._nodes.add(node);
		for (var i = node.getEdges().iterator(); i.hasNext();) {
			var de = i.next();
			this$1$1._dirEdgeList.add(de);
			var sym = de.getSym();
			var symNode = sym.getNode();
			if (!symNode.isVisited()) { nodeStack.push(symNode); }
		}
	};
	BufferSubgraph.prototype.getNodes = function getNodes() {
		return this._nodes
	};
	BufferSubgraph.prototype.getDirectedEdges = function getDirectedEdges() {
		return this._dirEdgeList
	};
	BufferSubgraph.prototype.interfaces_ = function interfaces_() {
		return [Comparable]
	};
	BufferSubgraph.prototype.getClass = function getClass() {
		return BufferSubgraph
	};

	var TopologyLocation = function TopologyLocation() {
		var this$1$1 = this;

		this.location = null;
		if (arguments.length === 1) {
			if (arguments[0] instanceof Array) {
				var location = arguments[0];
				this.init(location.length);
			} else if (Number.isInteger(arguments[0])) {
				var on = arguments[0];
				this.init(1);
				this.location[Position.ON] = on;
			} else if (arguments[0] instanceof TopologyLocation) {
				var gl = arguments[0];
				this.init(gl.location.length);
				if (gl !== null) {
					for (var i = 0; i < this.location.length; i++) {
						this$1$1.location[i] = gl.location[i];
					}
				}
			}
		} else if (arguments.length === 3) {
			var on$1 = arguments[0];
			var left = arguments[1];
			var right = arguments[2];
			this.init(3);
			this.location[Position.ON] = on$1;
			this.location[Position.LEFT] = left;
			this.location[Position.RIGHT] = right;
		}
	};
	TopologyLocation.prototype.setAllLocations = function setAllLocations(locValue) {
		var this$1$1 = this;

		for (var i = 0; i < this.location.length; i++) {
			this$1$1.location[i] = locValue;
		}
	};
	TopologyLocation.prototype.isNull = function isNull() {
		var this$1$1 = this;

		for (var i = 0; i < this.location.length; i++) {
			if (this$1$1.location[i] !== Location.NONE) { return false }
		}
		return true
	};
	TopologyLocation.prototype.setAllLocationsIfNull = function setAllLocationsIfNull(locValue) {
		var this$1$1 = this;

		for (var i = 0; i < this.location.length; i++) {
			if (this$1$1.location[i] === Location.NONE) { this$1$1.location[i] = locValue; }
		}
	};
	TopologyLocation.prototype.isLine = function isLine() {
		return this.location.length === 1
	};
	TopologyLocation.prototype.merge = function merge(gl) {
		var this$1$1 = this;

		if (gl.location.length > this.location.length) {
			var newLoc = new Array(3).fill(null);
			newLoc[Position.ON] = this.location[Position.ON];
			newLoc[Position.LEFT] = Location.NONE;
			newLoc[Position.RIGHT] = Location.NONE;
			this.location = newLoc;
		}
		for (var i = 0; i < this.location.length; i++) {
			if (this$1$1.location[i] === Location.NONE && i < gl.location.length) { this$1$1.location[i] = gl.location[i]; }
		}
	};
	TopologyLocation.prototype.getLocations = function getLocations() {
		return this.location
	};
	TopologyLocation.prototype.flip = function flip() {
		if (this.location.length <= 1) { return null }
		var temp = this.location[Position.LEFT];
		this.location[Position.LEFT] = this.location[Position.RIGHT];
		this.location[Position.RIGHT] = temp;
	};
	TopologyLocation.prototype.toString = function toString() {
		var buf = new StringBuffer();
		if (this.location.length > 1) { buf.append(Location.toLocationSymbol(this.location[Position.LEFT])); }
		buf.append(Location.toLocationSymbol(this.location[Position.ON]));
		if (this.location.length > 1) { buf.append(Location.toLocationSymbol(this.location[Position.RIGHT])); }
		return buf.toString()
	};
	TopologyLocation.prototype.setLocations = function setLocations(on, left, right) {
		this.location[Position.ON] = on;
		this.location[Position.LEFT] = left;
		this.location[Position.RIGHT] = right;
	};
	TopologyLocation.prototype.get = function get(posIndex) {
		if (posIndex < this.location.length) { return this.location[posIndex] }
		return Location.NONE
	};
	TopologyLocation.prototype.isArea = function isArea() {
		return this.location.length > 1
	};
	TopologyLocation.prototype.isAnyNull = function isAnyNull() {
		var this$1$1 = this;

		for (var i = 0; i < this.location.length; i++) {
			if (this$1$1.location[i] === Location.NONE) { return true }
		}
		return false
	};
	TopologyLocation.prototype.setLocation = function setLocation() {
		if (arguments.length === 1) {
			var locValue = arguments[0];
			this.setLocation(Position.ON, locValue);
		} else if (arguments.length === 2) {
			var locIndex = arguments[0];
			var locValue$1 = arguments[1];
			this.location[locIndex] = locValue$1;
		}
	};
	TopologyLocation.prototype.init = function init(size) {
		this.location = new Array(size).fill(null);
		this.setAllLocations(Location.NONE);
	};
	TopologyLocation.prototype.isEqualOnSide = function isEqualOnSide(le, locIndex) {
		return this.location[locIndex] === le.location[locIndex]
	};
	TopologyLocation.prototype.allPositionsEqual = function allPositionsEqual(loc) {
		var this$1$1 = this;

		for (var i = 0; i < this.location.length; i++) {
			if (this$1$1.location[i] !== loc) { return false }
		}
		return true
	};
	TopologyLocation.prototype.interfaces_ = function interfaces_() {
		return []
	};
	TopologyLocation.prototype.getClass = function getClass() {
		return TopologyLocation
	};

	var Label = function Label() {
		this.elt = new Array(2).fill(null);
		if (arguments.length === 1) {
			if (Number.isInteger(arguments[0])) {
				var onLoc = arguments[0];
				this.elt[0] = new TopologyLocation(onLoc);
				this.elt[1] = new TopologyLocation(onLoc);
			} else if (arguments[0] instanceof Label) {
				var lbl = arguments[0];
				this.elt[0] = new TopologyLocation(lbl.elt[0]);
				this.elt[1] = new TopologyLocation(lbl.elt[1]);
			}
		} else if (arguments.length === 2) {
			var geomIndex = arguments[0];
			var onLoc$1 = arguments[1];
			this.elt[0] = new TopologyLocation(Location.NONE);
			this.elt[1] = new TopologyLocation(Location.NONE);
			this.elt[geomIndex].setLocation(onLoc$1);
		} else if (arguments.length === 3) {
			var onLoc$2 = arguments[0];
			var leftLoc = arguments[1];
			var rightLoc = arguments[2];
			this.elt[0] = new TopologyLocation(onLoc$2, leftLoc, rightLoc);
			this.elt[1] = new TopologyLocation(onLoc$2, leftLoc, rightLoc);
		} else if (arguments.length === 4) {
			var geomIndex$1 = arguments[0];
			var onLoc$3 = arguments[1];
			var leftLoc$1 = arguments[2];
			var rightLoc$1 = arguments[3];
			this.elt[0] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);
			this.elt[1] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);
			this.elt[geomIndex$1].setLocations(onLoc$3, leftLoc$1, rightLoc$1);
		}
	};
	Label.prototype.getGeometryCount = function getGeometryCount() {
		var count = 0;
		if (!this.elt[0].isNull()) { count++; }
		if (!this.elt[1].isNull()) { count++; }
		return count
	};
	Label.prototype.setAllLocations = function setAllLocations(geomIndex, location) {
		this.elt[geomIndex].setAllLocations(location);
	};
	Label.prototype.isNull = function isNull(geomIndex) {
		return this.elt[geomIndex].isNull()
	};
	Label.prototype.setAllLocationsIfNull = function setAllLocationsIfNull() {
		if (arguments.length === 1) {
			var location = arguments[0];
			this.setAllLocationsIfNull(0, location);
			this.setAllLocationsIfNull(1, location);
		} else if (arguments.length === 2) {
			var geomIndex = arguments[0];
			var location$1 = arguments[1];
			this.elt[geomIndex].setAllLocationsIfNull(location$1);
		}
	};
	Label.prototype.isLine = function isLine(geomIndex) {
		return this.elt[geomIndex].isLine()
	};
	Label.prototype.merge = function merge(lbl) {
		var this$1$1 = this;

		for (var i = 0; i < 2; i++) {
			if (this$1$1.elt[i] === null && lbl.elt[i] !== null) {
				this$1$1.elt[i] = new TopologyLocation(lbl.elt[i]);
			} else {
				this$1$1.elt[i].merge(lbl.elt[i]);
			}
		}
	};
	Label.prototype.flip = function flip() {
		this.elt[0].flip();
		this.elt[1].flip();
	};
	Label.prototype.getLocation = function getLocation() {
		if (arguments.length === 1) {
			var geomIndex = arguments[0];
			return this.elt[geomIndex].get(Position.ON)
		} else if (arguments.length === 2) {
			var geomIndex$1 = arguments[0];
			var posIndex = arguments[1];
			return this.elt[geomIndex$1].get(posIndex)
		}
	};
	Label.prototype.toString = function toString() {
		var buf = new StringBuffer();
		if (this.elt[0] !== null) {
			buf.append('A:');
			buf.append(this.elt[0].toString());
		}
		if (this.elt[1] !== null) {
			buf.append(' B:');
			buf.append(this.elt[1].toString());
		}
		return buf.toString()
	};
	Label.prototype.isArea = function isArea() {
		if (arguments.length === 0) {
			return this.elt[0].isArea() || this.elt[1].isArea()
		} else if (arguments.length === 1) {
			var geomIndex = arguments[0];
			return this.elt[geomIndex].isArea()
		}
	};
	Label.prototype.isAnyNull = function isAnyNull(geomIndex) {
		return this.elt[geomIndex].isAnyNull()
	};
	Label.prototype.setLocation = function setLocation() {
		if (arguments.length === 2) {
			var geomIndex = arguments[0];
			var location = arguments[1];
			this.elt[geomIndex].setLocation(Position.ON, location);
		} else if (arguments.length === 3) {
			var geomIndex$1 = arguments[0];
			var posIndex = arguments[1];
			var location$1 = arguments[2];
			this.elt[geomIndex$1].setLocation(posIndex, location$1);
		}
	};
	Label.prototype.isEqualOnSide = function isEqualOnSide(lbl, side) {
		return this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side)
	};
	Label.prototype.allPositionsEqual = function allPositionsEqual(geomIndex, loc) {
		return this.elt[geomIndex].allPositionsEqual(loc)
	};
	Label.prototype.toLine = function toLine(geomIndex) {
		if (this.elt[geomIndex].isArea()) { this.elt[geomIndex] = new TopologyLocation(this.elt[geomIndex].location[0]); }
	};
	Label.prototype.interfaces_ = function interfaces_() {
		return []
	};
	Label.prototype.getClass = function getClass() {
		return Label
	};
	Label.toLineLabel = function toLineLabel(label) {
		var lineLabel = new Label(Location.NONE);
		for (var i = 0; i < 2; i++) {
			lineLabel.setLocation(i, label.getLocation(i));
		}
		return lineLabel
	};

	var EdgeRing = function EdgeRing() {
		this._startDe = null;
		this._maxNodeDegree = -1;
		this._edges = new ArrayList();
		this._pts = new ArrayList();
		this._label = new Label(Location.NONE);
		this._ring = null;
		this._isHole = null;
		this._shell = null;
		this._holes = new ArrayList();
		this._geometryFactory = null;
		var start = arguments[0];
		var geometryFactory = arguments[1];
		this._geometryFactory = geometryFactory;
		this.computePoints(start);
		this.computeRing();
	};
	EdgeRing.prototype.computeRing = function computeRing() {
		var this$1$1 = this;

		if (this._ring !== null) { return null }
		var coord = new Array(this._pts.size()).fill(null);
		for (var i = 0; i < this._pts.size(); i++) {
			coord[i] = this$1$1._pts.get(i);
		}
		this._ring = this._geometryFactory.createLinearRing(coord);
		this._isHole = CGAlgorithms.isCCW(this._ring.getCoordinates());
	};
	EdgeRing.prototype.isIsolated = function isIsolated() {
		return this._label.getGeometryCount() === 1
	};
	EdgeRing.prototype.computePoints = function computePoints(start) {
		var this$1$1 = this;

		this._startDe = start;
		var de = start;
		var isFirstEdge = true;
		do {
			if (de === null) { throw new TopologyException('Found null DirectedEdge') }
			if (de.getEdgeRing() === this$1$1) { throw new TopologyException('Directed Edge visited twice during ring-building at ' + de.getCoordinate()) }
			this$1$1._edges.add(de);
			var label = de.getLabel();
			Assert.isTrue(label.isArea());
			this$1$1.mergeLabel(label);
			this$1$1.addPoints(de.getEdge(), de.isForward(), isFirstEdge);
			isFirstEdge = false;
			this$1$1.setEdgeRing(de, this$1$1);
			de = this$1$1.getNext(de);
		} while (de !== this._startDe)
	};
	EdgeRing.prototype.getLinearRing = function getLinearRing() {
		return this._ring
	};
	EdgeRing.prototype.getCoordinate = function getCoordinate(i) {
		return this._pts.get(i)
	};
	EdgeRing.prototype.computeMaxNodeDegree = function computeMaxNodeDegree() {
		var this$1$1 = this;

		this._maxNodeDegree = 0;
		var de = this._startDe;
		do {
			var node = de.getNode();
			var degree = node.getEdges().getOutgoingDegree(this$1$1);
			if (degree > this$1$1._maxNodeDegree) { this$1$1._maxNodeDegree = degree; }
			de = this$1$1.getNext(de);
		} while (de !== this._startDe)
		this._maxNodeDegree *= 2;
	};
	EdgeRing.prototype.addPoints = function addPoints(edge, isForward, isFirstEdge) {
		var this$1$1 = this;

		var edgePts = edge.getCoordinates();
		if (isForward) {
			var startIndex = 1;
			if (isFirstEdge) { startIndex = 0; }
			for (var i = startIndex; i < edgePts.length; i++) {
				this$1$1._pts.add(edgePts[i]);
			}
		} else {
			var startIndex$1 = edgePts.length - 2;
			if (isFirstEdge) { startIndex$1 = edgePts.length - 1; }
			for (var i$1 = startIndex$1; i$1 >= 0; i$1--) {
				this$1$1._pts.add(edgePts[i$1]);
			}
		}
	};
	EdgeRing.prototype.isHole = function isHole() {
		return this._isHole
	};
	EdgeRing.prototype.setInResult = function setInResult() {
		var de = this._startDe;
		do {
			de.getEdge().setInResult(true);
			de = de.getNext();
		} while (de !== this._startDe)
	};
	EdgeRing.prototype.containsPoint = function containsPoint(p) {
		var shell = this.getLinearRing();
		var env = shell.getEnvelopeInternal();
		if (!env.contains(p)) { return false }
		if (!CGAlgorithms.isPointInRing(p, shell.getCoordinates())) { return false }
		for (var i = this._holes.iterator(); i.hasNext();) {
			var hole = i.next();
			if (hole.containsPoint(p)) { return false }
		}
		return true
	};
	EdgeRing.prototype.addHole = function addHole(ring) {
		this._holes.add(ring);
	};
	EdgeRing.prototype.isShell = function isShell() {
		return this._shell === null
	};
	EdgeRing.prototype.getLabel = function getLabel() {
		return this._label
	};
	EdgeRing.prototype.getEdges = function getEdges() {
		return this._edges
	};
	EdgeRing.prototype.getMaxNodeDegree = function getMaxNodeDegree() {
		if (this._maxNodeDegree < 0) { this.computeMaxNodeDegree(); }
		return this._maxNodeDegree
	};
	EdgeRing.prototype.getShell = function getShell() {
		return this._shell
	};
	EdgeRing.prototype.mergeLabel = function mergeLabel() {
		if (arguments.length === 1) {
			var deLabel = arguments[0];
			this.mergeLabel(deLabel, 0);
			this.mergeLabel(deLabel, 1);
		} else if (arguments.length === 2) {
			var deLabel$1 = arguments[0];
			var geomIndex = arguments[1];
			var loc = deLabel$1.getLocation(geomIndex, Position.RIGHT);
			if (loc === Location.NONE) { return null }
			if (this._label.getLocation(geomIndex) === Location.NONE) {
				this._label.setLocation(geomIndex, loc);
				return null
			}
		}
	};
	EdgeRing.prototype.setShell = function setShell(shell) {
		this._shell = shell;
		if (shell !== null) { shell.addHole(this); }
	};
	EdgeRing.prototype.toPolygon = function toPolygon(geometryFactory) {
		var this$1$1 = this;

		var holeLR = new Array(this._holes.size()).fill(null);
		for (var i = 0; i < this._holes.size(); i++) {
			holeLR[i] = this$1$1._holes.get(i).getLinearRing();
		}
		var poly = geometryFactory.createPolygon(this.getLinearRing(), holeLR);
		return poly
	};
	EdgeRing.prototype.interfaces_ = function interfaces_() {
		return []
	};
	EdgeRing.prototype.getClass = function getClass() {
		return EdgeRing
	};

	var MinimalEdgeRing = (function (EdgeRing$$1) {
		function MinimalEdgeRing() {
			var start = arguments[0];
			var geometryFactory = arguments[1];
			EdgeRing$$1.call(this, start, geometryFactory);
		}

		if (EdgeRing$$1) MinimalEdgeRing.__proto__ = EdgeRing$$1;
		MinimalEdgeRing.prototype = Object.create(EdgeRing$$1 && EdgeRing$$1.prototype);
		MinimalEdgeRing.prototype.constructor = MinimalEdgeRing;
		MinimalEdgeRing.prototype.setEdgeRing = function setEdgeRing(de, er) {
			de.setMinEdgeRing(er);
		};
		MinimalEdgeRing.prototype.getNext = function getNext(de) {
			return de.getNextMin()
		};
		MinimalEdgeRing.prototype.interfaces_ = function interfaces_() {
			return []
		};
		MinimalEdgeRing.prototype.getClass = function getClass() {
			return MinimalEdgeRing
		};

		return MinimalEdgeRing;
	}(EdgeRing));

	var MaximalEdgeRing = (function (EdgeRing$$1) {
		function MaximalEdgeRing() {
			var start = arguments[0];
			var geometryFactory = arguments[1];
			EdgeRing$$1.call(this, start, geometryFactory);
		}

		if (EdgeRing$$1) MaximalEdgeRing.__proto__ = EdgeRing$$1;
		MaximalEdgeRing.prototype = Object.create(EdgeRing$$1 && EdgeRing$$1.prototype);
		MaximalEdgeRing.prototype.constructor = MaximalEdgeRing;
		MaximalEdgeRing.prototype.buildMinimalRings = function buildMinimalRings() {
			var this$1$1 = this;

			var minEdgeRings = new ArrayList();
			var de = this._startDe;
			do {
				if (de.getMinEdgeRing() === null) {
					var minEr = new MinimalEdgeRing(de, this$1$1._geometryFactory);
					minEdgeRings.add(minEr);
				}
				de = de.getNext();
			} while (de !== this._startDe)
			return minEdgeRings
		};
		MaximalEdgeRing.prototype.setEdgeRing = function setEdgeRing(de, er) {
			de.setEdgeRing(er);
		};
		MaximalEdgeRing.prototype.linkDirectedEdgesForMinimalEdgeRings = function linkDirectedEdgesForMinimalEdgeRings() {
			var this$1$1 = this;

			var de = this._startDe;
			do {
				var node = de.getNode();
				node.getEdges().linkMinimalDirectedEdges(this$1$1);
				de = de.getNext();
			} while (de !== this._startDe)
		};
		MaximalEdgeRing.prototype.getNext = function getNext(de) {
			return de.getNext()
		};
		MaximalEdgeRing.prototype.interfaces_ = function interfaces_() {
			return []
		};
		MaximalEdgeRing.prototype.getClass = function getClass() {
			return MaximalEdgeRing
		};

		return MaximalEdgeRing;
	}(EdgeRing));

	var GraphComponent = function GraphComponent() {
		this._label = null;
		this._isInResult = false;
		this._isCovered = false;
		this._isCoveredSet = false;
		this._isVisited = false;
		if (arguments.length === 0); else if (arguments.length === 1) {
			var label = arguments[0];
			this._label = label;
		}
	};
	GraphComponent.prototype.setVisited = function setVisited(isVisited) {
		this._isVisited = isVisited;
	};
	GraphComponent.prototype.setInResult = function setInResult(isInResult) {
		this._isInResult = isInResult;
	};
	GraphComponent.prototype.isCovered = function isCovered() {
		return this._isCovered
	};
	GraphComponent.prototype.isCoveredSet = function isCoveredSet() {
		return this._isCoveredSet
	};
	GraphComponent.prototype.setLabel = function setLabel(label) {
		this._label = label;
	};
	GraphComponent.prototype.getLabel = function getLabel() {
		return this._label
	};
	GraphComponent.prototype.setCovered = function setCovered(isCovered) {
		this._isCovered = isCovered;
		this._isCoveredSet = true;
	};
	GraphComponent.prototype.updateIM = function updateIM(im) {
		Assert.isTrue(this._label.getGeometryCount() >= 2, 'found partial label');
		this.computeIM(im);
	};
	GraphComponent.prototype.isInResult = function isInResult() {
		return this._isInResult
	};
	GraphComponent.prototype.isVisited = function isVisited() {
		return this._isVisited
	};
	GraphComponent.prototype.interfaces_ = function interfaces_() {
		return []
	};
	GraphComponent.prototype.getClass = function getClass() {
		return GraphComponent
	};

	var Node = (function (GraphComponent$$1) {
		function Node() {
			GraphComponent$$1.call(this);
			this._coord = null;
			this._edges = null;
			var coord = arguments[0];
			var edges = arguments[1];
			this._coord = coord;
			this._edges = edges;
			this._label = new Label(0, Location.NONE);
		}

		if (GraphComponent$$1) Node.__proto__ = GraphComponent$$1;
		Node.prototype = Object.create(GraphComponent$$1 && GraphComponent$$1.prototype);
		Node.prototype.constructor = Node;
		Node.prototype.isIncidentEdgeInResult = function isIncidentEdgeInResult() {
			for (var it = this.getEdges().getEdges().iterator(); it.hasNext();) {
				var de = it.next();
				if (de.getEdge().isInResult()) { return true }
			}
			return false
		};
		Node.prototype.isIsolated = function isIsolated() {
			return this._label.getGeometryCount() === 1
		};
		Node.prototype.getCoordinate = function getCoordinate() {
			return this._coord
		};
		Node.prototype.print = function print(out) {
			out.println('node ' + this._coord + ' lbl: ' + this._label);
		};
		Node.prototype.computeIM = function computeIM(im) { };
		Node.prototype.computeMergedLocation = function computeMergedLocation(label2, eltIndex) {
			var loc = Location.NONE;
			loc = this._label.getLocation(eltIndex);
			if (!label2.isNull(eltIndex)) {
				var nLoc = label2.getLocation(eltIndex);
				if (loc !== Location.BOUNDARY) { loc = nLoc; }
			}
			return loc
		};
		Node.prototype.setLabel = function setLabel() {
			if (arguments.length === 2) {
				var argIndex = arguments[0];
				var onLocation = arguments[1];
				if (this._label === null) {
					this._label = new Label(argIndex, onLocation);
				} else { this._label.setLocation(argIndex, onLocation); }
			} else { return GraphComponent$$1.prototype.setLabel.apply(this, arguments) }
		};
		Node.prototype.getEdges = function getEdges() {
			return this._edges
		};
		Node.prototype.mergeLabel = function mergeLabel() {
			var this$1$1 = this;

			if (arguments[0] instanceof Node) {
				var n = arguments[0];
				this.mergeLabel(n._label);
			} else if (arguments[0] instanceof Label) {
				var label2 = arguments[0];
				for (var i = 0; i < 2; i++) {
					var loc = this$1$1.computeMergedLocation(label2, i);
					var thisLoc = this$1$1._label.getLocation(i);
					if (thisLoc === Location.NONE) { this$1$1._label.setLocation(i, loc); }
				}
			}
		};
		Node.prototype.add = function add(e) {
			this._edges.insert(e);
			e.setNode(this);
		};
		Node.prototype.setLabelBoundary = function setLabelBoundary(argIndex) {
			if (this._label === null) { return null }
			var loc = Location.NONE;
			if (this._label !== null) { loc = this._label.getLocation(argIndex); }
			var newLoc = null;
			switch (loc) {
				case Location.BOUNDARY:
					newLoc = Location.INTERIOR;
					break
				case Location.INTERIOR:
					newLoc = Location.BOUNDARY;
					break
				default:
					newLoc = Location.BOUNDARY;
					break
			}
			this._label.setLocation(argIndex, newLoc);
		};
		Node.prototype.interfaces_ = function interfaces_() {
			return []
		};
		Node.prototype.getClass = function getClass() {
			return Node
		};

		return Node;
	}(GraphComponent));

	var NodeMap = function NodeMap() {
		this.nodeMap = new TreeMap();
		this.nodeFact = null;
		var nodeFact = arguments[0];
		this.nodeFact = nodeFact;
	};
	NodeMap.prototype.find = function find(coord) {
		return this.nodeMap.get(coord)
	};
	NodeMap.prototype.addNode = function addNode() {
		if (arguments[0] instanceof Coordinate) {
			var coord = arguments[0];
			var node = this.nodeMap.get(coord);
			if (node === null) {
				node = this.nodeFact.createNode(coord);
				this.nodeMap.put(coord, node);
			}
			return node
		} else if (arguments[0] instanceof Node) {
			var n = arguments[0];
			var node$1 = this.nodeMap.get(n.getCoordinate());
			if (node$1 === null) {
				this.nodeMap.put(n.getCoordinate(), n);
				return n
			}
			node$1.mergeLabel(n);
			return node$1
		}
	};
	NodeMap.prototype.print = function print(out) {
		for (var it = this.iterator(); it.hasNext();) {
			var n = it.next();
			n.print(out);
		}
	};
	NodeMap.prototype.iterator = function iterator() {
		return this.nodeMap.values().iterator()
	};
	NodeMap.prototype.values = function values() {
		return this.nodeMap.values()
	};
	NodeMap.prototype.getBoundaryNodes = function getBoundaryNodes(geomIndex) {
		var bdyNodes = new ArrayList();
		for (var i = this.iterator(); i.hasNext();) {
			var node = i.next();
			if (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) { bdyNodes.add(node); }
		}
		return bdyNodes
	};
	NodeMap.prototype.add = function add(e) {
		var p = e.getCoordinate();
		var n = this.addNode(p);
		n.add(e);
	};
	NodeMap.prototype.interfaces_ = function interfaces_() {
		return []
	};
	NodeMap.prototype.getClass = function getClass() {
		return NodeMap
	};

	var Quadrant = function Quadrant() { };

	var staticAccessors$21 = { NE: { configurable: true }, NW: { configurable: true }, SW: { configurable: true }, SE: { configurable: true } };

	Quadrant.prototype.interfaces_ = function interfaces_() {
		return []
	};
	Quadrant.prototype.getClass = function getClass() {
		return Quadrant
	};
	Quadrant.isNorthern = function isNorthern(quad) {
		return quad === Quadrant.NE || quad === Quadrant.NW
	};
	Quadrant.isOpposite = function isOpposite(quad1, quad2) {
		if (quad1 === quad2) { return false }
		var diff = (quad1 - quad2 + 4) % 4;
		if (diff === 2) { return true }
		return false
	};
	Quadrant.commonHalfPlane = function commonHalfPlane(quad1, quad2) {
		if (quad1 === quad2) { return quad1 }
		var diff = (quad1 - quad2 + 4) % 4;
		if (diff === 2) { return -1 }
		var min = quad1 < quad2 ? quad1 : quad2;
		var max = quad1 > quad2 ? quad1 : quad2;
		if (min === 0 && max === 3) { return 3 }
		return min
	};
	Quadrant.isInHalfPlane = function isInHalfPlane(quad, halfPlane) {
		if (halfPlane === Quadrant.SE) {
			return quad === Quadrant.SE || quad === Quadrant.SW
		}
		return quad === halfPlane || quad === halfPlane + 1
	};
	Quadrant.quadrant = function quadrant() {
		if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
			var dx = arguments[0];
			var dy = arguments[1];
			if (dx === 0.0 && dy === 0.0) { throw new IllegalArgumentException('Cannot compute the quadrant for point ( ' + dx + ', ' + dy + ' )') }
			if (dx >= 0.0) {
				if (dy >= 0.0) { return Quadrant.NE; } else { return Quadrant.SE }
			} else {
				if (dy >= 0.0) { return Quadrant.NW; } else { return Quadrant.SW }
			}
		} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
			var p0 = arguments[0];
			var p1 = arguments[1];
			if (p1.x === p0.x && p1.y === p0.y) { throw new IllegalArgumentException('Cannot compute the quadrant for two identical points ' + p0) }
			if (p1.x >= p0.x) {
				if (p1.y >= p0.y) { return Quadrant.NE; } else { return Quadrant.SE }
			} else {
				if (p1.y >= p0.y) { return Quadrant.NW; } else { return Quadrant.SW }
			}
		}
	};
	staticAccessors$21.NE.get = function () { return 0 };
	staticAccessors$21.NW.get = function () { return 1 };
	staticAccessors$21.SW.get = function () { return 2 };
	staticAccessors$21.SE.get = function () { return 3 };

	Object.defineProperties(Quadrant, staticAccessors$21);

	var EdgeEnd = function EdgeEnd() {
		this._edge = null;
		this._label = null;
		this._node = null;
		this._p0 = null;
		this._p1 = null;
		this._dx = null;
		this._dy = null;
		this._quadrant = null;
		if (arguments.length === 1) {
			var edge = arguments[0];
			this._edge = edge;
		} else if (arguments.length === 3) {
			var edge$1 = arguments[0];
			var p0 = arguments[1];
			var p1 = arguments[2];
			var label = null;
			this._edge = edge$1;
			this.init(p0, p1);
			this._label = label;
		} else if (arguments.length === 4) {
			var edge$2 = arguments[0];
			var p0$1 = arguments[1];
			var p1$1 = arguments[2];
			var label$1 = arguments[3];
			this._edge = edge$2;
			this.init(p0$1, p1$1);
			this._label = label$1;
		}
	};
	EdgeEnd.prototype.compareDirection = function compareDirection(e) {
		if (this._dx === e._dx && this._dy === e._dy) { return 0 }
		if (this._quadrant > e._quadrant) { return 1 }
		if (this._quadrant < e._quadrant) { return -1 }
		return CGAlgorithms.computeOrientation(e._p0, e._p1, this._p1)
	};
	EdgeEnd.prototype.getDy = function getDy() {
		return this._dy
	};
	EdgeEnd.prototype.getCoordinate = function getCoordinate() {
		return this._p0
	};
	EdgeEnd.prototype.setNode = function setNode(node) {
		this._node = node;
	};
	EdgeEnd.prototype.print = function print(out) {
		var angle = Math.atan2(this._dy, this._dx);
		var className = this.getClass().getName();
		var lastDotPos = className.lastIndexOf('.');
		var name = className.substring(lastDotPos + 1);
		out.print('  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label);
	};
	EdgeEnd.prototype.compareTo = function compareTo(obj) {
		var e = obj;
		return this.compareDirection(e)
	};
	EdgeEnd.prototype.getDirectedCoordinate = function getDirectedCoordinate() {
		return this._p1
	};
	EdgeEnd.prototype.getDx = function getDx() {
		return this._dx
	};
	EdgeEnd.prototype.getLabel = function getLabel() {
		return this._label
	};
	EdgeEnd.prototype.getEdge = function getEdge() {
		return this._edge
	};
	EdgeEnd.prototype.getQuadrant = function getQuadrant() {
		return this._quadrant
	};
	EdgeEnd.prototype.getNode = function getNode() {
		return this._node
	};
	EdgeEnd.prototype.toString = function toString() {
		var angle = Math.atan2(this._dy, this._dx);
		var className = this.getClass().getName();
		var lastDotPos = className.lastIndexOf('.');
		var name = className.substring(lastDotPos + 1);
		return '  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label
	};
	EdgeEnd.prototype.computeLabel = function computeLabel(boundaryNodeRule) { };
	EdgeEnd.prototype.init = function init(p0, p1) {
		this._p0 = p0;
		this._p1 = p1;
		this._dx = p1.x - p0.x;
		this._dy = p1.y - p0.y;
		this._quadrant = Quadrant.quadrant(this._dx, this._dy);
		Assert.isTrue(!(this._dx === 0 && this._dy === 0), 'EdgeEnd with identical endpoints found');
	};
	EdgeEnd.prototype.interfaces_ = function interfaces_() {
		return [Comparable]
	};
	EdgeEnd.prototype.getClass = function getClass() {
		return EdgeEnd
	};

	var DirectedEdge = (function (EdgeEnd$$1) {
		function DirectedEdge() {
			var edge = arguments[0];
			var isForward = arguments[1];
			EdgeEnd$$1.call(this, edge);
			this._isForward = null;
			this._isInResult = false;
			this._isVisited = false;
			this._sym = null;
			this._next = null;
			this._nextMin = null;
			this._edgeRing = null;
			this._minEdgeRing = null;
			this._depth = [0, -999, -999];
			this._isForward = isForward;
			if (isForward) {
				this.init(edge.getCoordinate(0), edge.getCoordinate(1));
			} else {
				var n = edge.getNumPoints() - 1;
				this.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));
			}
			this.computeDirectedLabel();
		}

		if (EdgeEnd$$1) DirectedEdge.__proto__ = EdgeEnd$$1;
		DirectedEdge.prototype = Object.create(EdgeEnd$$1 && EdgeEnd$$1.prototype);
		DirectedEdge.prototype.constructor = DirectedEdge;
		DirectedEdge.prototype.getNextMin = function getNextMin() {
			return this._nextMin
		};
		DirectedEdge.prototype.getDepth = function getDepth(position) {
			return this._depth[position]
		};
		DirectedEdge.prototype.setVisited = function setVisited(isVisited) {
			this._isVisited = isVisited;
		};
		DirectedEdge.prototype.computeDirectedLabel = function computeDirectedLabel() {
			this._label = new Label(this._edge.getLabel());
			if (!this._isForward) { this._label.flip(); }
		};
		DirectedEdge.prototype.getNext = function getNext() {
			return this._next
		};
		DirectedEdge.prototype.setDepth = function setDepth(position, depthVal) {
			if (this._depth[position] !== -999) {
				if (this._depth[position] !== depthVal) { throw new TopologyException('assigned depths do not match', this.getCoordinate()) }
			}
			this._depth[position] = depthVal;
		};
		DirectedEdge.prototype.isInteriorAreaEdge = function isInteriorAreaEdge() {
			var this$1$1 = this;

			var isInteriorAreaEdge = true;
			for (var i = 0; i < 2; i++) {
				if (!(this$1$1._label.isArea(i) && this$1$1._label.getLocation(i, Position.LEFT) === Location.INTERIOR && this$1$1._label.getLocation(i, Position.RIGHT) === Location.INTERIOR)) {
					isInteriorAreaEdge = false;
				}
			}
			return isInteriorAreaEdge
		};
		DirectedEdge.prototype.setNextMin = function setNextMin(nextMin) {
			this._nextMin = nextMin;
		};
		DirectedEdge.prototype.print = function print(out) {
			EdgeEnd$$1.prototype.print.call(this, out);
			out.print(' ' + this._depth[Position.LEFT] + '/' + this._depth[Position.RIGHT]);
			out.print(' (' + this.getDepthDelta() + ')');
			if (this._isInResult) { out.print(' inResult'); }
		};
		DirectedEdge.prototype.setMinEdgeRing = function setMinEdgeRing(minEdgeRing) {
			this._minEdgeRing = minEdgeRing;
		};
		DirectedEdge.prototype.isLineEdge = function isLineEdge() {
			var isLine = this._label.isLine(0) || this._label.isLine(1);
			var isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, Location.EXTERIOR);
			var isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, Location.EXTERIOR);
			return isLine && isExteriorIfArea0 && isExteriorIfArea1
		};
		DirectedEdge.prototype.setEdgeRing = function setEdgeRing(edgeRing) {
			this._edgeRing = edgeRing;
		};
		DirectedEdge.prototype.getMinEdgeRing = function getMinEdgeRing() {
			return this._minEdgeRing
		};
		DirectedEdge.prototype.getDepthDelta = function getDepthDelta() {
			var depthDelta = this._edge.getDepthDelta();
			if (!this._isForward) { depthDelta = -depthDelta; }
			return depthDelta
		};
		DirectedEdge.prototype.setInResult = function setInResult(isInResult) {
			this._isInResult = isInResult;
		};
		DirectedEdge.prototype.getSym = function getSym() {
			return this._sym
		};
		DirectedEdge.prototype.isForward = function isForward() {
			return this._isForward
		};
		DirectedEdge.prototype.getEdge = function getEdge() {
			return this._edge
		};
		DirectedEdge.prototype.printEdge = function printEdge(out) {
			this.print(out);
			out.print(' ');
			if (this._isForward) { this._edge.print(out); } else { this._edge.printReverse(out); }
		};
		DirectedEdge.prototype.setSym = function setSym(de) {
			this._sym = de;
		};
		DirectedEdge.prototype.setVisitedEdge = function setVisitedEdge(isVisited) {
			this.setVisited(isVisited);
			this._sym.setVisited(isVisited);
		};
		DirectedEdge.prototype.setEdgeDepths = function setEdgeDepths(position, depth) {
			var depthDelta = this.getEdge().getDepthDelta();
			if (!this._isForward) { depthDelta = -depthDelta; }
			var directionFactor = 1;
			if (position === Position.LEFT) { directionFactor = -1; }
			var oppositePos = Position.opposite(position);
			var delta = depthDelta * directionFactor;
			var oppositeDepth = depth + delta;
			this.setDepth(position, depth);
			this.setDepth(oppositePos, oppositeDepth);
		};
		DirectedEdge.prototype.getEdgeRing = function getEdgeRing() {
			return this._edgeRing
		};
		DirectedEdge.prototype.isInResult = function isInResult() {
			return this._isInResult
		};
		DirectedEdge.prototype.setNext = function setNext(next) {
			this._next = next;
		};
		DirectedEdge.prototype.isVisited = function isVisited() {
			return this._isVisited
		};
		DirectedEdge.prototype.interfaces_ = function interfaces_() {
			return []
		};
		DirectedEdge.prototype.getClass = function getClass() {
			return DirectedEdge
		};
		DirectedEdge.depthFactor = function depthFactor(currLocation, nextLocation) {
			if (currLocation === Location.EXTERIOR && nextLocation === Location.INTERIOR) { return 1; } else if (currLocation === Location.INTERIOR && nextLocation === Location.EXTERIOR) { return -1 }
			return 0
		};

		return DirectedEdge;
	}(EdgeEnd));

	var NodeFactory = function NodeFactory() { };

	NodeFactory.prototype.createNode = function createNode(coord) {
		return new Node(coord, null)
	};
	NodeFactory.prototype.interfaces_ = function interfaces_() {
		return []
	};
	NodeFactory.prototype.getClass = function getClass() {
		return NodeFactory
	};

	var PlanarGraph = function PlanarGraph() {
		this._edges = new ArrayList();
		this._nodes = null;
		this._edgeEndList = new ArrayList();
		if (arguments.length === 0) {
			this._nodes = new NodeMap(new NodeFactory());
		} else if (arguments.length === 1) {
			var nodeFact = arguments[0];
			this._nodes = new NodeMap(nodeFact);
		}
	};
	PlanarGraph.prototype.printEdges = function printEdges(out) {
		var this$1$1 = this;

		out.println('Edges:');
		for (var i = 0; i < this._edges.size(); i++) {
			out.println('edge ' + i + ':');
			var e = this$1$1._edges.get(i);
			e.print(out);
			e.eiList.print(out);
		}
	};
	PlanarGraph.prototype.find = function find(coord) {
		return this._nodes.find(coord)
	};
	PlanarGraph.prototype.addNode = function addNode() {
		if (arguments[0] instanceof Node) {
			var node = arguments[0];
			return this._nodes.addNode(node)
		} else if (arguments[0] instanceof Coordinate) {
			var coord = arguments[0];
			return this._nodes.addNode(coord)
		}
	};
	PlanarGraph.prototype.getNodeIterator = function getNodeIterator() {
		return this._nodes.iterator()
	};
	PlanarGraph.prototype.linkResultDirectedEdges = function linkResultDirectedEdges() {
		for (var nodeit = this._nodes.iterator(); nodeit.hasNext();) {
			var node = nodeit.next();
			node.getEdges().linkResultDirectedEdges();
		}
	};
	PlanarGraph.prototype.debugPrintln = function debugPrintln(o) {
		System.out.println(o);
	};
	PlanarGraph.prototype.isBoundaryNode = function isBoundaryNode(geomIndex, coord) {
		var node = this._nodes.find(coord);
		if (node === null) { return false }
		var label = node.getLabel();
		if (label !== null && label.getLocation(geomIndex) === Location.BOUNDARY) { return true }
		return false
	};
	PlanarGraph.prototype.linkAllDirectedEdges = function linkAllDirectedEdges() {
		for (var nodeit = this._nodes.iterator(); nodeit.hasNext();) {
			var node = nodeit.next();
			node.getEdges().linkAllDirectedEdges();
		}
	};
	PlanarGraph.prototype.matchInSameDirection = function matchInSameDirection(p0, p1, ep0, ep1) {
		if (!p0.equals(ep0)) { return false }
		if (CGAlgorithms.computeOrientation(p0, p1, ep1) === CGAlgorithms.COLLINEAR && Quadrant.quadrant(p0, p1) === Quadrant.quadrant(ep0, ep1)) { return true }
		return false
	};
	PlanarGraph.prototype.getEdgeEnds = function getEdgeEnds() {
		return this._edgeEndList
	};
	PlanarGraph.prototype.debugPrint = function debugPrint(o) {
		System.out.print(o);
	};
	PlanarGraph.prototype.getEdgeIterator = function getEdgeIterator() {
		return this._edges.iterator()
	};
	PlanarGraph.prototype.findEdgeInSameDirection = function findEdgeInSameDirection(p0, p1) {
		var this$1$1 = this;

		for (var i = 0; i < this._edges.size(); i++) {
			var e = this$1$1._edges.get(i);
			var eCoord = e.getCoordinates();
			if (this$1$1.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) { return e }
			if (this$1$1.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) { return e }
		}
		return null
	};
	PlanarGraph.prototype.insertEdge = function insertEdge(e) {
		this._edges.add(e);
	};
	PlanarGraph.prototype.findEdgeEnd = function findEdgeEnd(e) {
		for (var i = this.getEdgeEnds().iterator(); i.hasNext();) {
			var ee = i.next();
			if (ee.getEdge() === e) { return ee }
		}
		return null
	};
	PlanarGraph.prototype.addEdges = function addEdges(edgesToAdd) {
		var this$1$1 = this;

		for (var it = edgesToAdd.iterator(); it.hasNext();) {
			var e = it.next();
			this$1$1._edges.add(e);
			var de1 = new DirectedEdge(e, true);
			var de2 = new DirectedEdge(e, false);
			de1.setSym(de2);
			de2.setSym(de1);
			this$1$1.add(de1);
			this$1$1.add(de2);
		}
	};
	PlanarGraph.prototype.add = function add(e) {
		this._nodes.add(e);
		this._edgeEndList.add(e);
	};
	PlanarGraph.prototype.getNodes = function getNodes() {
		return this._nodes.values()
	};
	PlanarGraph.prototype.findEdge = function findEdge(p0, p1) {
		var this$1$1 = this;

		for (var i = 0; i < this._edges.size(); i++) {
			var e = this$1$1._edges.get(i);
			var eCoord = e.getCoordinates();
			if (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) { return e }
		}
		return null
	};
	PlanarGraph.prototype.interfaces_ = function interfaces_() {
		return []
	};
	PlanarGraph.prototype.getClass = function getClass() {
		return PlanarGraph
	};
	PlanarGraph.linkResultDirectedEdges = function linkResultDirectedEdges(nodes) {
		for (var nodeit = nodes.iterator(); nodeit.hasNext();) {
			var node = nodeit.next();
			node.getEdges().linkResultDirectedEdges();
		}
	};

	var PolygonBuilder = function PolygonBuilder() {
		this._geometryFactory = null;
		this._shellList = new ArrayList();
		var geometryFactory = arguments[0];
		this._geometryFactory = geometryFactory;
	};
	PolygonBuilder.prototype.sortShellsAndHoles = function sortShellsAndHoles(edgeRings, shellList, freeHoleList) {
		for (var it = edgeRings.iterator(); it.hasNext();) {
			var er = it.next();
			if (er.isHole()) {
				freeHoleList.add(er);
			} else {
				shellList.add(er);
			}
		}
	};
	PolygonBuilder.prototype.computePolygons = function computePolygons(shellList) {
		var this$1$1 = this;

		var resultPolyList = new ArrayList();
		for (var it = shellList.iterator(); it.hasNext();) {
			var er = it.next();
			var poly = er.toPolygon(this$1$1._geometryFactory);
			resultPolyList.add(poly);
		}
		return resultPolyList
	};
	PolygonBuilder.prototype.placeFreeHoles = function placeFreeHoles(shellList, freeHoleList) {
		var this$1$1 = this;

		for (var it = freeHoleList.iterator(); it.hasNext();) {
			var hole = it.next();
			if (hole.getShell() === null) {
				var shell = this$1$1.findEdgeRingContaining(hole, shellList);
				if (shell === null) { throw new TopologyException('unable to assign hole to a shell', hole.getCoordinate(0)) }
				hole.setShell(shell);
			}
		}
	};
	PolygonBuilder.prototype.buildMinimalEdgeRings = function buildMinimalEdgeRings(maxEdgeRings, shellList, freeHoleList) {
		var this$1$1 = this;

		var edgeRings = new ArrayList();
		for (var it = maxEdgeRings.iterator(); it.hasNext();) {
			var er = it.next();
			if (er.getMaxNodeDegree() > 2) {
				er.linkDirectedEdgesForMinimalEdgeRings();
				var minEdgeRings = er.buildMinimalRings();
				var shell = this$1$1.findShell(minEdgeRings);
				if (shell !== null) {
					this$1$1.placePolygonHoles(shell, minEdgeRings);
					shellList.add(shell);
				} else {
					freeHoleList.addAll(minEdgeRings);
				}
			} else {
				edgeRings.add(er);
			}
		}
		return edgeRings
	};
	PolygonBuilder.prototype.containsPoint = function containsPoint(p) {
		for (var it = this._shellList.iterator(); it.hasNext();) {
			var er = it.next();
			if (er.containsPoint(p)) { return true }
		}
		return false
	};
	PolygonBuilder.prototype.buildMaximalEdgeRings = function buildMaximalEdgeRings(dirEdges) {
		var this$1$1 = this;

		var maxEdgeRings = new ArrayList();
		for (var it = dirEdges.iterator(); it.hasNext();) {
			var de = it.next();
			if (de.isInResult() && de.getLabel().isArea()) {
				if (de.getEdgeRing() === null) {
					var er = new MaximalEdgeRing(de, this$1$1._geometryFactory);
					maxEdgeRings.add(er);
					er.setInResult();
				}
			}
		}
		return maxEdgeRings
	};
	PolygonBuilder.prototype.placePolygonHoles = function placePolygonHoles(shell, minEdgeRings) {
		for (var it = minEdgeRings.iterator(); it.hasNext();) {
			var er = it.next();
			if (er.isHole()) {
				er.setShell(shell);
			}
		}
	};
	PolygonBuilder.prototype.getPolygons = function getPolygons() {
		var resultPolyList = this.computePolygons(this._shellList);
		return resultPolyList
	};
	PolygonBuilder.prototype.findEdgeRingContaining = function findEdgeRingContaining(testEr, shellList) {
		var testRing = testEr.getLinearRing();
		var testEnv = testRing.getEnvelopeInternal();
		var testPt = testRing.getCoordinateN(0);
		var minShell = null;
		var minEnv = null;
		for (var it = shellList.iterator(); it.hasNext();) {
			var tryShell = it.next();
			var tryRing = tryShell.getLinearRing();
			var tryEnv = tryRing.getEnvelopeInternal();
			if (minShell !== null) { minEnv = minShell.getLinearRing().getEnvelopeInternal(); }
			var isContained = false;
			if (tryEnv.contains(testEnv) && CGAlgorithms.isPointInRing(testPt, tryRing.getCoordinates())) { isContained = true; }
			if (isContained) {
				if (minShell === null || minEnv.contains(tryEnv)) {
					minShell = tryShell;
				}
			}
		}
		return minShell
	};
	PolygonBuilder.prototype.findShell = function findShell(minEdgeRings) {
		var shellCount = 0;
		var shell = null;
		for (var it = minEdgeRings.iterator(); it.hasNext();) {
			var er = it.next();
			if (!er.isHole()) {
				shell = er;
				shellCount++;
			}
		}
		Assert.isTrue(shellCount <= 1, 'found two shells in MinimalEdgeRing list');
		return shell
	};
	PolygonBuilder.prototype.add = function add() {
		if (arguments.length === 1) {
			var graph = arguments[0];
			this.add(graph.getEdgeEnds(), graph.getNodes());
		} else if (arguments.length === 2) {
			var dirEdges = arguments[0];
			var nodes = arguments[1];
			PlanarGraph.linkResultDirectedEdges(nodes);
			var maxEdgeRings = this.buildMaximalEdgeRings(dirEdges);
			var freeHoleList = new ArrayList();
			var edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this._shellList, freeHoleList);
			this.sortShellsAndHoles(edgeRings, this._shellList, freeHoleList);
			this.placeFreeHoles(this._shellList, freeHoleList);
		}
	};
	PolygonBuilder.prototype.interfaces_ = function interfaces_() {
		return []
	};
	PolygonBuilder.prototype.getClass = function getClass() {
		return PolygonBuilder
	};

	var Boundable = function Boundable() { };

	Boundable.prototype.getBounds = function getBounds() { };
	Boundable.prototype.interfaces_ = function interfaces_() {
		return []
	};
	Boundable.prototype.getClass = function getClass() {
		return Boundable
	};

	var ItemBoundable = function ItemBoundable() {
		this._bounds = null;
		this._item = null;
		var bounds = arguments[0];
		var item = arguments[1];
		this._bounds = bounds;
		this._item = item;
	};
	ItemBoundable.prototype.getItem = function getItem() {
		return this._item
	};
	ItemBoundable.prototype.getBounds = function getBounds() {
		return this._bounds
	};
	ItemBoundable.prototype.interfaces_ = function interfaces_() {
		return [Boundable, Serializable]
	};
	ItemBoundable.prototype.getClass = function getClass() {
		return ItemBoundable
	};

	var PriorityQueue = function PriorityQueue() {
		this._size = null;
		this._items = null;
		this._size = 0;
		this._items = new ArrayList();
		this._items.add(null);
	};
	PriorityQueue.prototype.poll = function poll() {
		if (this.isEmpty()) { return null }
		var minItem = this._items.get(1);
		this._items.set(1, this._items.get(this._size));
		this._size -= 1;
		this.reorder(1);
		return minItem
	};
	PriorityQueue.prototype.size = function size() {
		return this._size
	};
	PriorityQueue.prototype.reorder = function reorder(hole) {
		var this$1$1 = this;

		var child = null;
		var tmp = this._items.get(hole);
		for (; hole * 2 <= this._size; hole = child) {
			child = hole * 2;
			if (child !== this$1$1._size && this$1$1._items.get(child + 1).compareTo(this$1$1._items.get(child)) < 0) { child++; }
			if (this$1$1._items.get(child).compareTo(tmp) < 0) { this$1$1._items.set(hole, this$1$1._items.get(child)); } else { break }
		}
		this._items.set(hole, tmp);
	};
	PriorityQueue.prototype.clear = function clear() {
		this._size = 0;
		this._items.clear();
	};
	PriorityQueue.prototype.isEmpty = function isEmpty() {
		return this._size === 0
	};
	PriorityQueue.prototype.add = function add(x) {
		var this$1$1 = this;

		this._items.add(null);
		this._size += 1;
		var hole = this._size;
		this._items.set(0, x);
		for (; x.compareTo(this._items.get(Math.trunc(hole / 2))) < 0; hole /= 2) {
			this$1$1._items.set(hole, this$1$1._items.get(Math.trunc(hole / 2)));
		}
		this._items.set(hole, x);
	};
	PriorityQueue.prototype.interfaces_ = function interfaces_() {
		return []
	};
	PriorityQueue.prototype.getClass = function getClass() {
		return PriorityQueue
	};

	var ItemVisitor = function ItemVisitor() { };

	ItemVisitor.prototype.visitItem = function visitItem(item) { };
	ItemVisitor.prototype.interfaces_ = function interfaces_() {
		return []
	};
	ItemVisitor.prototype.getClass = function getClass() {
		return ItemVisitor
	};

	var SpatialIndex = function SpatialIndex() { };

	SpatialIndex.prototype.insert = function insert(itemEnv, item) { };
	SpatialIndex.prototype.remove = function remove(itemEnv, item) { };
	SpatialIndex.prototype.query = function query() {
		// if (arguments.length === 1) {
		// const searchEnv = arguments[0]
		// } else if (arguments.length === 2) {
		// const searchEnv = arguments[0]
		// const visitor = arguments[1]
		// }
	};
	SpatialIndex.prototype.interfaces_ = function interfaces_() {
		return []
	};
	SpatialIndex.prototype.getClass = function getClass() {
		return SpatialIndex
	};

	var AbstractNode = function AbstractNode() {
		this._childBoundables = new ArrayList();
		this._bounds = null;
		this._level = null;
		if (arguments.length === 0); else if (arguments.length === 1) {
			var level = arguments[0];
			this._level = level;
		}
	};

	var staticAccessors$22 = { serialVersionUID: { configurable: true } };
	AbstractNode.prototype.getLevel = function getLevel() {
		return this._level
	};
	AbstractNode.prototype.size = function size() {
		return this._childBoundables.size()
	};
	AbstractNode.prototype.getChildBoundables = function getChildBoundables() {
		return this._childBoundables
	};
	AbstractNode.prototype.addChildBoundable = function addChildBoundable(childBoundable) {
		Assert.isTrue(this._bounds === null);
		this._childBoundables.add(childBoundable);
	};
	AbstractNode.prototype.isEmpty = function isEmpty() {
		return this._childBoundables.isEmpty()
	};
	AbstractNode.prototype.getBounds = function getBounds() {
		if (this._bounds === null) {
			this._bounds = this.computeBounds();
		}
		return this._bounds
	};
	AbstractNode.prototype.interfaces_ = function interfaces_() {
		return [Boundable, Serializable]
	};
	AbstractNode.prototype.getClass = function getClass() {
		return AbstractNode
	};
	staticAccessors$22.serialVersionUID.get = function () { return 6493722185909573708 };

	Object.defineProperties(AbstractNode, staticAccessors$22);

	var Collections = function Collections() { };

	Collections.reverseOrder = function reverseOrder() {
		return {
			compare: function compare(a, b) {
				return b.compareTo(a)
			}
		}
	};
	Collections.min = function min(l) {
		Collections.sort(l);
		return l.get(0)
	};
	Collections.sort = function sort(l, c) {
		var a = l.toArray();
		if (c) {
			Arrays.sort(a, c);
		} else {
			Arrays.sort(a);
		}
		var i = l.iterator();
		for (var pos = 0, alen = a.length; pos < alen; pos++) {
			i.next();
			i.set(a[pos]);
		}
	};
	Collections.singletonList = function singletonList(o) {
		var arrayList = new ArrayList();
		arrayList.add(o);
		return arrayList
	};

	var BoundablePair = function BoundablePair() {
		this._boundable1 = null;
		this._boundable2 = null;
		this._distance = null;
		this._itemDistance = null;
		var boundable1 = arguments[0];
		var boundable2 = arguments[1];
		var itemDistance = arguments[2];
		this._boundable1 = boundable1;
		this._boundable2 = boundable2;
		this._itemDistance = itemDistance;
		this._distance = this.distance();
	};
	BoundablePair.prototype.expandToQueue = function expandToQueue(priQ, minDistance) {
		var isComp1 = BoundablePair.isComposite(this._boundable1);
		var isComp2 = BoundablePair.isComposite(this._boundable2);
		if (isComp1 && isComp2) {
			if (BoundablePair.area(this._boundable1) > BoundablePair.area(this._boundable2)) {
				this.expand(this._boundable1, this._boundable2, priQ, minDistance);
				return null
			} else {
				this.expand(this._boundable2, this._boundable1, priQ, minDistance);
				return null
			}
		} else if (isComp1) {
			this.expand(this._boundable1, this._boundable2, priQ, minDistance);
			return null
		} else if (isComp2) {
			this.expand(this._boundable2, this._boundable1, priQ, minDistance);
			return null
		}
		throw new IllegalArgumentException('neither boundable is composite')
	};
	BoundablePair.prototype.isLeaves = function isLeaves() {
		return !(BoundablePair.isComposite(this._boundable1) || BoundablePair.isComposite(this._boundable2))
	};
	BoundablePair.prototype.compareTo = function compareTo(o) {
		var nd = o;
		if (this._distance < nd._distance) { return -1 }
		if (this._distance > nd._distance) { return 1 }
		return 0
	};
	BoundablePair.prototype.expand = function expand(bndComposite, bndOther, priQ, minDistance) {
		var this$1$1 = this;

		var children = bndComposite.getChildBoundables();
		for (var i = children.iterator(); i.hasNext();) {
			var child = i.next();
			var bp = new BoundablePair(child, bndOther, this$1$1._itemDistance);
			if (bp.getDistance() < minDistance) {
				priQ.add(bp);
			}
		}
	};
	BoundablePair.prototype.getBoundable = function getBoundable(i) {
		if (i === 0) { return this._boundable1 }
		return this._boundable2
	};
	BoundablePair.prototype.getDistance = function getDistance() {
		return this._distance
	};
	BoundablePair.prototype.distance = function distance() {
		if (this.isLeaves()) {
			return this._itemDistance.distance(this._boundable1, this._boundable2)
		}
		return this._boundable1.getBounds().distance(this._boundable2.getBounds())
	};
	BoundablePair.prototype.interfaces_ = function interfaces_() {
		return [Comparable]
	};
	BoundablePair.prototype.getClass = function getClass() {
		return BoundablePair
	};
	BoundablePair.area = function area(b) {
		return b.getBounds().getArea()
	};
	BoundablePair.isComposite = function isComposite(item) {
		return item instanceof AbstractNode
	};

	var AbstractSTRtree = function AbstractSTRtree() {
		this._root = null;
		this._built = false;
		this._itemBoundables = new ArrayList();
		this._nodeCapacity = null;
		if (arguments.length === 0) {
			var nodeCapacity = AbstractSTRtree.DEFAULT_NODE_CAPACITY;
			this._nodeCapacity = nodeCapacity;
		} else if (arguments.length === 1) {
			var nodeCapacity$1 = arguments[0];
			Assert.isTrue(nodeCapacity$1 > 1, 'Node capacity must be greater than 1');
			this._nodeCapacity = nodeCapacity$1;
		}
	};

	var staticAccessors$23 = { IntersectsOp: { configurable: true }, serialVersionUID: { configurable: true }, DEFAULT_NODE_CAPACITY: { configurable: true } };
	AbstractSTRtree.prototype.getNodeCapacity = function getNodeCapacity() {
		return this._nodeCapacity
	};
	AbstractSTRtree.prototype.lastNode = function lastNode(nodes) {
		return nodes.get(nodes.size() - 1)
	};
	AbstractSTRtree.prototype.size = function size() {
		var this$1$1 = this;

		if (arguments.length === 0) {
			if (this.isEmpty()) {
				return 0
			}
			this.build();
			return this.size(this._root)
		} else if (arguments.length === 1) {
			var node = arguments[0];
			var size = 0;
			for (var i = node.getChildBoundables().iterator(); i.hasNext();) {
				var childBoundable = i.next();
				if (childBoundable instanceof AbstractNode) {
					size += this$1$1.size(childBoundable);
				} else if (childBoundable instanceof ItemBoundable) {
					size += 1;
				}
			}
			return size
		}
	};
	AbstractSTRtree.prototype.removeItem = function removeItem(node, item) {
		var childToRemove = null;
		for (var i = node.getChildBoundables().iterator(); i.hasNext();) {
			var childBoundable = i.next();
			if (childBoundable instanceof ItemBoundable) {
				if (childBoundable.getItem() === item) { childToRemove = childBoundable; }
			}
		}
		if (childToRemove !== null) {
			node.getChildBoundables().remove(childToRemove);
			return true
		}
		return false
	};
	AbstractSTRtree.prototype.itemsTree = function itemsTree() {
		var this$1$1 = this;

		if (arguments.length === 0) {
			this.build();
			var valuesTree = this.itemsTree(this._root);
			if (valuesTree === null) { return new ArrayList() }
			return valuesTree
		} else if (arguments.length === 1) {
			var node = arguments[0];
			var valuesTreeForNode = new ArrayList();
			for (var i = node.getChildBoundables().iterator(); i.hasNext();) {
				var childBoundable = i.next();
				if (childBoundable instanceof AbstractNode) {
					var valuesTreeForChild = this$1$1.itemsTree(childBoundable);
					if (valuesTreeForChild !== null) { valuesTreeForNode.add(valuesTreeForChild); }
				} else if (childBoundable instanceof ItemBoundable) {
					valuesTreeForNode.add(childBoundable.getItem());
				} else {
					Assert.shouldNeverReachHere();
				}
			}
			if (valuesTreeForNode.size() <= 0) { return null }
			return valuesTreeForNode
		}
	};
	AbstractSTRtree.prototype.insert = function insert(bounds, item) {
		Assert.isTrue(!this._built, 'Cannot insert items into an STR packed R-tree after it has been built.');
		this._itemBoundables.add(new ItemBoundable(bounds, item));
	};
	AbstractSTRtree.prototype.boundablesAtLevel = function boundablesAtLevel() {
		var this$1$1 = this;

		if (arguments.length === 1) {
			var level = arguments[0];
			var boundables = new ArrayList();
			this.boundablesAtLevel(level, this._root, boundables);
			return boundables
		} else if (arguments.length === 3) {
			var level$1 = arguments[0];
			var top = arguments[1];
			var boundables$1 = arguments[2];
			Assert.isTrue(level$1 > -2);
			if (top.getLevel() === level$1) {
				boundables$1.add(top);
				return null
			}
			for (var i = top.getChildBoundables().iterator(); i.hasNext();) {
				var boundable = i.next();
				if (boundable instanceof AbstractNode) {
					this$1$1.boundablesAtLevel(level$1, boundable, boundables$1);
				} else {
					Assert.isTrue(boundable instanceof ItemBoundable);
					if (level$1 === -1) {
						boundables$1.add(boundable);
					}
				}
			}
			return null
		}
	};
	AbstractSTRtree.prototype.query = function query() {
		var this$1$1 = this;

		if (arguments.length === 1) {
			var searchBounds = arguments[0];
			this.build();
			var matches = new ArrayList();
			if (this.isEmpty()) {
				return matches
			}
			if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {
				this.query(searchBounds, this._root, matches);
			}
			return matches
		} else if (arguments.length === 2) {
			var searchBounds$1 = arguments[0];
			var visitor = arguments[1];
			this.build();
			if (this.isEmpty()) {
				return null
			}
			if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds$1)) {
				this.query(searchBounds$1, this._root, visitor);
			}
		} else if (arguments.length === 3) {
			if (hasInterface(arguments[2], ItemVisitor) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
				var searchBounds$2 = arguments[0];
				var node = arguments[1];
				var visitor$1 = arguments[2];
				var childBoundables = node.getChildBoundables();
				for (var i = 0; i < childBoundables.size(); i++) {
					var childBoundable = childBoundables.get(i);
					if (!this$1$1.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds$2)) {
						continue
					}
					if (childBoundable instanceof AbstractNode) {
						this$1$1.query(searchBounds$2, childBoundable, visitor$1);
					} else if (childBoundable instanceof ItemBoundable) {
						visitor$1.visitItem(childBoundable.getItem());
					} else {
						Assert.shouldNeverReachHere();
					}
				}
			} else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
				var searchBounds$3 = arguments[0];
				var node$1 = arguments[1];
				var matches$1 = arguments[2];
				var childBoundables$1 = node$1.getChildBoundables();
				for (var i$1 = 0; i$1 < childBoundables$1.size(); i$1++) {
					var childBoundable$1 = childBoundables$1.get(i$1);
					if (!this$1$1.getIntersectsOp().intersects(childBoundable$1.getBounds(), searchBounds$3)) {
						continue
					}
					if (childBoundable$1 instanceof AbstractNode) {
						this$1$1.query(searchBounds$3, childBoundable$1, matches$1);
					} else if (childBoundable$1 instanceof ItemBoundable) {
						matches$1.add(childBoundable$1.getItem());
					} else {
						Assert.shouldNeverReachHere();
					}
				}
			}
		}
	};
	AbstractSTRtree.prototype.build = function build() {
		if (this._built) { return null }
		this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1);
		this._itemBoundables = null;
		this._built = true;
	};
	AbstractSTRtree.prototype.getRoot = function getRoot() {
		this.build();
		return this._root
	};
	AbstractSTRtree.prototype.remove = function remove() {
		var this$1$1 = this;

		if (arguments.length === 2) {
			var searchBounds = arguments[0];
			var item = arguments[1];
			this.build();
			if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {
				return this.remove(searchBounds, this._root, item)
			}
			return false
		} else if (arguments.length === 3) {
			var searchBounds$1 = arguments[0];
			var node = arguments[1];
			var item$1 = arguments[2];
			var found = this.removeItem(node, item$1);
			if (found) { return true }
			var childToPrune = null;
			for (var i = node.getChildBoundables().iterator(); i.hasNext();) {
				var childBoundable = i.next();
				if (!this$1$1.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds$1)) {
					continue
				}
				if (childBoundable instanceof AbstractNode) {
					found = this$1$1.remove(searchBounds$1, childBoundable, item$1);
					if (found) {
						childToPrune = childBoundable;
						break
					}
				}
			}
			if (childToPrune !== null) {
				if (childToPrune.getChildBoundables().isEmpty()) {
					node.getChildBoundables().remove(childToPrune);
				}
			}
			return found
		}
	};
	AbstractSTRtree.prototype.createHigherLevels = function createHigherLevels(boundablesOfALevel, level) {
		Assert.isTrue(!boundablesOfALevel.isEmpty());
		var parentBoundables = this.createParentBoundables(boundablesOfALevel, level + 1);
		if (parentBoundables.size() === 1) {
			return parentBoundables.get(0)
		}
		return this.createHigherLevels(parentBoundables, level + 1)
	};
	AbstractSTRtree.prototype.depth = function depth() {
		var this$1$1 = this;

		if (arguments.length === 0) {
			if (this.isEmpty()) {
				return 0
			}
			this.build();
			return this.depth(this._root)
		} else if (arguments.length === 1) {
			var node = arguments[0];
			var maxChildDepth = 0;
			for (var i = node.getChildBoundables().iterator(); i.hasNext();) {
				var childBoundable = i.next();
				if (childBoundable instanceof AbstractNode) {
					var childDepth = this$1$1.depth(childBoundable);
					if (childDepth > maxChildDepth) { maxChildDepth = childDepth; }
				}
			}
			return maxChildDepth + 1
		}
	};
	AbstractSTRtree.prototype.createParentBoundables = function createParentBoundables(childBoundables, newLevel) {
		var this$1$1 = this;

		Assert.isTrue(!childBoundables.isEmpty());
		var parentBoundables = new ArrayList();
		parentBoundables.add(this.createNode(newLevel));
		var sortedChildBoundables = new ArrayList(childBoundables);
		Collections.sort(sortedChildBoundables, this.getComparator());
		for (var i = sortedChildBoundables.iterator(); i.hasNext();) {
			var childBoundable = i.next();
			if (this$1$1.lastNode(parentBoundables).getChildBoundables().size() === this$1$1.getNodeCapacity()) {
				parentBoundables.add(this$1$1.createNode(newLevel));
			}
			this$1$1.lastNode(parentBoundables).addChildBoundable(childBoundable);
		}
		return parentBoundables
	};
	AbstractSTRtree.prototype.isEmpty = function isEmpty() {
		if (!this._built) { return this._itemBoundables.isEmpty() }
		return this._root.isEmpty()
	};
	AbstractSTRtree.prototype.interfaces_ = function interfaces_() {
		return [Serializable]
	};
	AbstractSTRtree.prototype.getClass = function getClass() {
		return AbstractSTRtree
	};
	AbstractSTRtree.compareDoubles = function compareDoubles(a, b) {
		return a > b ? 1 : a < b ? -1 : 0
	};
	staticAccessors$23.IntersectsOp.get = function () { return IntersectsOp };
	staticAccessors$23.serialVersionUID.get = function () { return -3886435814360241337 };
	staticAccessors$23.DEFAULT_NODE_CAPACITY.get = function () { return 10 };

	Object.defineProperties(AbstractSTRtree, staticAccessors$23);

	var IntersectsOp = function IntersectsOp() { };

	var ItemDistance = function ItemDistance() { };

	ItemDistance.prototype.distance = function distance(item1, item2) { };
	ItemDistance.prototype.interfaces_ = function interfaces_() {
		return []
	};
	ItemDistance.prototype.getClass = function getClass() {
		return ItemDistance
	};

	var STRtree = (function (AbstractSTRtree$$1) {
		function STRtree(nodeCapacity) {
			nodeCapacity = nodeCapacity || STRtree.DEFAULT_NODE_CAPACITY;
			AbstractSTRtree$$1.call(this, nodeCapacity);
		}

		if (AbstractSTRtree$$1) STRtree.__proto__ = AbstractSTRtree$$1;
		STRtree.prototype = Object.create(AbstractSTRtree$$1 && AbstractSTRtree$$1.prototype);
		STRtree.prototype.constructor = STRtree;

		var staticAccessors = { STRtreeNode: { configurable: true }, serialVersionUID: { configurable: true }, xComparator: { configurable: true }, yComparator: { configurable: true }, intersectsOp: { configurable: true }, DEFAULT_NODE_CAPACITY: { configurable: true } };
		STRtree.prototype.createParentBoundablesFromVerticalSlices = function createParentBoundablesFromVerticalSlices(verticalSlices, newLevel) {
			var this$1$1 = this;

			Assert.isTrue(verticalSlices.length > 0);
			var parentBoundables = new ArrayList();
			for (var i = 0; i < verticalSlices.length; i++) {
				parentBoundables.addAll(this$1$1.createParentBoundablesFromVerticalSlice(verticalSlices[i], newLevel));
			}
			return parentBoundables
		};
		STRtree.prototype.createNode = function createNode(level) {
			return new STRtreeNode(level)
		};
		STRtree.prototype.size = function size() {
			if (arguments.length === 0) {
				return AbstractSTRtree$$1.prototype.size.call(this)
			} else { return AbstractSTRtree$$1.prototype.size.apply(this, arguments) }
		};
		STRtree.prototype.insert = function insert() {
			if (arguments.length === 2) {
				var itemEnv = arguments[0];
				var item = arguments[1];
				if (itemEnv.isNull()) {
					return null
				}
				AbstractSTRtree$$1.prototype.insert.call(this, itemEnv, item);
			} else { return AbstractSTRtree$$1.prototype.insert.apply(this, arguments) }
		};
		STRtree.prototype.getIntersectsOp = function getIntersectsOp() {
			return STRtree.intersectsOp
		};
		STRtree.prototype.verticalSlices = function verticalSlices(childBoundables, sliceCount) {
			var sliceCapacity = Math.trunc(Math.ceil(childBoundables.size() / sliceCount));
			var slices = new Array(sliceCount).fill(null);
			var i = childBoundables.iterator();
			for (var j = 0; j < sliceCount; j++) {
				slices[j] = new ArrayList();
				var boundablesAddedToSlice = 0;
				while (i.hasNext() && boundablesAddedToSlice < sliceCapacity) {
					var childBoundable = i.next();
					slices[j].add(childBoundable);
					boundablesAddedToSlice++;
				}
			}
			return slices
		};
		STRtree.prototype.query = function query() {
			if (arguments.length === 1) {
				var searchEnv = arguments[0];
				return AbstractSTRtree$$1.prototype.query.call(this, searchEnv)
			} else if (arguments.length === 2) {
				var searchEnv$1 = arguments[0];
				var visitor = arguments[1];
				AbstractSTRtree$$1.prototype.query.call(this, searchEnv$1, visitor);
			} else if (arguments.length === 3) {
				if (hasInterface(arguments[2], ItemVisitor) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
					var searchBounds = arguments[0];
					var node = arguments[1];
					var visitor$1 = arguments[2];
					AbstractSTRtree$$1.prototype.query.call(this, searchBounds, node, visitor$1);
				} else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
					var searchBounds$1 = arguments[0];
					var node$1 = arguments[1];
					var matches = arguments[2];
					AbstractSTRtree$$1.prototype.query.call(this, searchBounds$1, node$1, matches);
				}
			}
		};
		STRtree.prototype.getComparator = function getComparator() {
			return STRtree.yComparator
		};
		STRtree.prototype.createParentBoundablesFromVerticalSlice = function createParentBoundablesFromVerticalSlice(childBoundables, newLevel) {
			return AbstractSTRtree$$1.prototype.createParentBoundables.call(this, childBoundables, newLevel)
		};
		STRtree.prototype.remove = function remove() {
			if (arguments.length === 2) {
				var itemEnv = arguments[0];
				var item = arguments[1];
				return AbstractSTRtree$$1.prototype.remove.call(this, itemEnv, item)
			} else { return AbstractSTRtree$$1.prototype.remove.apply(this, arguments) }
		};
		STRtree.prototype.depth = function depth() {
			if (arguments.length === 0) {
				return AbstractSTRtree$$1.prototype.depth.call(this)
			} else { return AbstractSTRtree$$1.prototype.depth.apply(this, arguments) }
		};
		STRtree.prototype.createParentBoundables = function createParentBoundables(childBoundables, newLevel) {
			Assert.isTrue(!childBoundables.isEmpty());
			var minLeafCount = Math.trunc(Math.ceil(childBoundables.size() / this.getNodeCapacity()));
			var sortedChildBoundables = new ArrayList(childBoundables);
			Collections.sort(sortedChildBoundables, STRtree.xComparator);
			var verticalSlices = this.verticalSlices(sortedChildBoundables, Math.trunc(Math.ceil(Math.sqrt(minLeafCount))));
			return this.createParentBoundablesFromVerticalSlices(verticalSlices, newLevel)
		};
		STRtree.prototype.nearestNeighbour = function nearestNeighbour() {
			if (arguments.length === 1) {
				if (hasInterface(arguments[0], ItemDistance)) {
					var itemDist = arguments[0];
					var bp = new BoundablePair(this.getRoot(), this.getRoot(), itemDist);
					return this.nearestNeighbour(bp)
				} else if (arguments[0] instanceof BoundablePair) {
					var initBndPair = arguments[0];
					return this.nearestNeighbour(initBndPair, Double.POSITIVE_INFINITY)
				}
			} else if (arguments.length === 2) {
				if (arguments[0] instanceof STRtree && hasInterface(arguments[1], ItemDistance)) {
					var tree = arguments[0];
					var itemDist$1 = arguments[1];
					var bp$1 = new BoundablePair(this.getRoot(), tree.getRoot(), itemDist$1);
					return this.nearestNeighbour(bp$1)
				} else if (arguments[0] instanceof BoundablePair && typeof arguments[1] === 'number') {
					var initBndPair$1 = arguments[0];
					var maxDistance = arguments[1];
					var distanceLowerBound = maxDistance;
					var minPair = null;
					var priQ = new PriorityQueue();
					priQ.add(initBndPair$1);
					while (!priQ.isEmpty() && distanceLowerBound > 0.0) {
						var bndPair = priQ.poll();
						var currentDistance = bndPair.getDistance();
						if (currentDistance >= distanceLowerBound) { break }
						if (bndPair.isLeaves()) {
							distanceLowerBound = currentDistance;
							minPair = bndPair;
						} else {
							bndPair.expandToQueue(priQ, distanceLowerBound);
						}
					}
					return [minPair.getBoundable(0).getItem(), minPair.getBoundable(1).getItem()]
				}
			} else if (arguments.length === 3) {
				var env = arguments[0];
				var item = arguments[1];
				var itemDist$2 = arguments[2];
				var bnd = new ItemBoundable(env, item);
				var bp$2 = new BoundablePair(this.getRoot(), bnd, itemDist$2);
				return this.nearestNeighbour(bp$2)[0]
			}
		};
		STRtree.prototype.interfaces_ = function interfaces_() {
			return [SpatialIndex, Serializable]
		};
		STRtree.prototype.getClass = function getClass() {
			return STRtree
		};
		STRtree.centreX = function centreX(e) {
			return STRtree.avg(e.getMinX(), e.getMaxX())
		};
		STRtree.avg = function avg(a, b) {
			return (a + b) / 2
		};
		STRtree.centreY = function centreY(e) {
			return STRtree.avg(e.getMinY(), e.getMaxY())
		};
		staticAccessors.STRtreeNode.get = function () { return STRtreeNode };
		staticAccessors.serialVersionUID.get = function () { return 259274702368956900 };
		staticAccessors.xComparator.get = function () {
			return {
				interfaces_: function () {
					return [Comparator]
				},
				compare: function (o1, o2) {
					return AbstractSTRtree$$1.compareDoubles(STRtree.centreX(o1.getBounds()), STRtree.centreX(o2.getBounds()))
				}
			}
		};
		staticAccessors.yComparator.get = function () {
			return {
				interfaces_: function () {
					return [Comparator]
				},
				compare: function (o1, o2) {
					return AbstractSTRtree$$1.compareDoubles(STRtree.centreY(o1.getBounds()), STRtree.centreY(o2.getBounds()))
				}
			}
		};
		staticAccessors.intersectsOp.get = function () {
			return {
				interfaces_: function () {
					return [AbstractSTRtree$$1.IntersectsOp]
				},
				intersects: function (aBounds, bBounds) {
					return aBounds.intersects(bBounds)
				}
			}
		};
		staticAccessors.DEFAULT_NODE_CAPACITY.get = function () { return 10 };

		Object.defineProperties(STRtree, staticAccessors);

		return STRtree;
	}(AbstractSTRtree));

	var STRtreeNode = (function (AbstractNode$$1) {
		function STRtreeNode() {
			var level = arguments[0];
			AbstractNode$$1.call(this, level);
		}

		if (AbstractNode$$1) STRtreeNode.__proto__ = AbstractNode$$1;
		STRtreeNode.prototype = Object.create(AbstractNode$$1 && AbstractNode$$1.prototype);
		STRtreeNode.prototype.constructor = STRtreeNode;
		STRtreeNode.prototype.computeBounds = function computeBounds() {
			var bounds = null;
			for (var i = this.getChildBoundables().iterator(); i.hasNext();) {
				var childBoundable = i.next();
				if (bounds === null) {
					bounds = new Envelope(childBoundable.getBounds());
				} else {
					bounds.expandToInclude(childBoundable.getBounds());
				}
			}
			return bounds
		};
		STRtreeNode.prototype.interfaces_ = function interfaces_() {
			return []
		};
		STRtreeNode.prototype.getClass = function getClass() {
			return STRtreeNode
		};

		return STRtreeNode;
	}(AbstractNode));

	var SegmentPointComparator = function SegmentPointComparator() { };

	SegmentPointComparator.prototype.interfaces_ = function interfaces_() {
		return []
	};
	SegmentPointComparator.prototype.getClass = function getClass() {
		return SegmentPointComparator
	};
	SegmentPointComparator.relativeSign = function relativeSign(x0, x1) {
		if (x0 < x1) { return -1 }
		if (x0 > x1) { return 1 }
		return 0
	};
	SegmentPointComparator.compare = function compare(octant, p0, p1) {
		if (p0.equals2D(p1)) { return 0 }
		var xSign = SegmentPointComparator.relativeSign(p0.x, p1.x);
		var ySign = SegmentPointComparator.relativeSign(p0.y, p1.y);
		switch (octant) {
			case 0:
				return SegmentPointComparator.compareValue(xSign, ySign)
			case 1:
				return SegmentPointComparator.compareValue(ySign, xSign)
			case 2:
				return SegmentPointComparator.compareValue(ySign, -xSign)
			case 3:
				return SegmentPointComparator.compareValue(-xSign, ySign)
			case 4:
				return SegmentPointComparator.compareValue(-xSign, -ySign)
			case 5:
				return SegmentPointComparator.compareValue(-ySign, -xSign)
			case 6:
				return SegmentPointComparator.compareValue(-ySign, xSign)
			case 7:
				return SegmentPointComparator.compareValue(xSign, -ySign)
		}
		Assert.shouldNeverReachHere('invalid octant value');
		return 0
	};
	SegmentPointComparator.compareValue = function compareValue(compareSign0, compareSign1) {
		if (compareSign0 < 0) { return -1 }
		if (compareSign0 > 0) { return 1 }
		if (compareSign1 < 0) { return -1 }
		if (compareSign1 > 0) { return 1 }
		return 0
	};

	var SegmentNode = function SegmentNode() {
		this._segString = null;
		this.coord = null;
		this.segmentIndex = null;
		this._segmentOctant = null;
		this._isInterior = null;
		var segString = arguments[0];
		var coord = arguments[1];
		var segmentIndex = arguments[2];
		var segmentOctant = arguments[3];
		this._segString = segString;
		this.coord = new Coordinate(coord);
		this.segmentIndex = segmentIndex;
		this._segmentOctant = segmentOctant;
		this._isInterior = !coord.equals2D(segString.getCoordinate(segmentIndex));
	};
	SegmentNode.prototype.getCoordinate = function getCoordinate() {
		return this.coord
	};
	SegmentNode.prototype.print = function print(out) {
		out.print(this.coord);
		out.print(' seg # = ' + this.segmentIndex);
	};
	SegmentNode.prototype.compareTo = function compareTo(obj) {
		var other = obj;
		if (this.segmentIndex < other.segmentIndex) { return -1 }
		if (this.segmentIndex > other.segmentIndex) { return 1 }
		if (this.coord.equals2D(other.coord)) { return 0 }
		return SegmentPointComparator.compare(this._segmentOctant, this.coord, other.coord)
	};
	SegmentNode.prototype.isEndPoint = function isEndPoint(maxSegmentIndex) {
		if (this.segmentIndex === 0 && !this._isInterior) { return true }
		if (this.segmentIndex === maxSegmentIndex) { return true }
		return false
	};
	SegmentNode.prototype.isInterior = function isInterior() {
		return this._isInterior
	};
	SegmentNode.prototype.interfaces_ = function interfaces_() {
		return [Comparable]
	};
	SegmentNode.prototype.getClass = function getClass() {
		return SegmentNode
	};

	// import Iterator from '../../../../java/util/Iterator'
	var SegmentNodeList = function SegmentNodeList() {
		this._nodeMap = new TreeMap();
		this._edge = null;
		var edge = arguments[0];
		this._edge = edge;
	};
	SegmentNodeList.prototype.getSplitCoordinates = function getSplitCoordinates() {
		var this$1$1 = this;

		var coordList = new CoordinateList();
		this.addEndpoints();
		var it = this.iterator();
		var eiPrev = it.next();
		while (it.hasNext()) {
			var ei = it.next();
			this$1$1.addEdgeCoordinates(eiPrev, ei, coordList);
			eiPrev = ei;
		}
		return coordList.toCoordinateArray()
	};
	SegmentNodeList.prototype.addCollapsedNodes = function addCollapsedNodes() {
		var this$1$1 = this;

		var collapsedVertexIndexes = new ArrayList();
		this.findCollapsesFromInsertedNodes(collapsedVertexIndexes);
		this.findCollapsesFromExistingVertices(collapsedVertexIndexes);
		for (var it = collapsedVertexIndexes.iterator(); it.hasNext();) {
			var vertexIndex = it.next().intValue();
			this$1$1.add(this$1$1._edge.getCoordinate(vertexIndex), vertexIndex);
		}
	};
	SegmentNodeList.prototype.print = function print(out) {
		out.println('Intersections:');
		for (var it = this.iterator(); it.hasNext();) {
			var ei = it.next();
			ei.print(out);
		}
	};
	SegmentNodeList.prototype.findCollapsesFromExistingVertices = function findCollapsesFromExistingVertices(collapsedVertexIndexes) {
		var this$1$1 = this;

		for (var i = 0; i < this._edge.size() - 2; i++) {
			var p0 = this$1$1._edge.getCoordinate(i);
			// const p1 = this._edge.getCoordinate(i + 1)
			var p2 = this$1$1._edge.getCoordinate(i + 2);
			if (p0.equals2D(p2)) {
				collapsedVertexIndexes.add(new Integer(i + 1));
			}
		}
	};
	SegmentNodeList.prototype.addEdgeCoordinates = function addEdgeCoordinates(ei0, ei1, coordList) {
		var this$1$1 = this;

		// let npts = ei1.segmentIndex - ei0.segmentIndex + 2
		var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);
		var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);
		// if (!useIntPt1) {
		// npts--
		// }
		// const ipt = 0
		coordList.add(new Coordinate(ei0.coord), false);
		for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
			coordList.add(this$1$1._edge.getCoordinate(i));
		}
		if (useIntPt1) {
			coordList.add(new Coordinate(ei1.coord));
		}
	};
	SegmentNodeList.prototype.iterator = function iterator() {
		return this._nodeMap.values().iterator()
	};
	SegmentNodeList.prototype.addSplitEdges = function addSplitEdges(edgeList) {
		var this$1$1 = this;

		this.addEndpoints();
		this.addCollapsedNodes();
		var it = this.iterator();
		var eiPrev = it.next();
		while (it.hasNext()) {
			var ei = it.next();
			var newEdge = this$1$1.createSplitEdge(eiPrev, ei);
			edgeList.add(newEdge);
			eiPrev = ei;
		}
	};
	SegmentNodeList.prototype.findCollapseIndex = function findCollapseIndex(ei0, ei1, collapsedVertexIndex) {
		if (!ei0.coord.equals2D(ei1.coord)) { return false }
		var numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex;
		if (!ei1.isInterior()) {
			numVerticesBetween--;
		}
		if (numVerticesBetween === 1) {
			collapsedVertexIndex[0] = ei0.segmentIndex + 1;
			return true
		}
		return false
	};
	SegmentNodeList.prototype.findCollapsesFromInsertedNodes = function findCollapsesFromInsertedNodes(collapsedVertexIndexes) {
		var this$1$1 = this;

		var collapsedVertexIndex = new Array(1).fill(null);
		var it = this.iterator();
		var eiPrev = it.next();
		while (it.hasNext()) {
			var ei = it.next();
			var isCollapsed = this$1$1.findCollapseIndex(eiPrev, ei, collapsedVertexIndex);
			if (isCollapsed) { collapsedVertexIndexes.add(new Integer(collapsedVertexIndex[0])); }
			eiPrev = ei;
		}
	};
	SegmentNodeList.prototype.getEdge = function getEdge() {
		return this._edge
	};
	SegmentNodeList.prototype.addEndpoints = function addEndpoints() {
		var maxSegIndex = this._edge.size() - 1;
		this.add(this._edge.getCoordinate(0), 0);
		this.add(this._edge.getCoordinate(maxSegIndex), maxSegIndex);
	};
	SegmentNodeList.prototype.createSplitEdge = function createSplitEdge(ei0, ei1) {
		var this$1$1 = this;

		var npts = ei1.segmentIndex - ei0.segmentIndex + 2;
		var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);
		var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);
		if (!useIntPt1) {
			npts--;
		}
		var pts = new Array(npts).fill(null);
		var ipt = 0;
		pts[ipt++] = new Coordinate(ei0.coord);
		for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
			pts[ipt++] = this$1$1._edge.getCoordinate(i);
		}
		if (useIntPt1) { pts[ipt] = new Coordinate(ei1.coord); }
		return new NodedSegmentString(pts, this._edge.getData())
	};
	SegmentNodeList.prototype.add = function add(intPt, segmentIndex) {
		var eiNew = new SegmentNode(this._edge, intPt, segmentIndex, this._edge.getSegmentOctant(segmentIndex));
		var ei = this._nodeMap.get(eiNew);
		if (ei !== null) {
			Assert.isTrue(ei.coord.equals2D(intPt), 'Found equal nodes with different coordinates');
			return ei
		}
		this._nodeMap.put(eiNew, eiNew);
		return eiNew
	};
	SegmentNodeList.prototype.checkSplitEdgesCorrectness = function checkSplitEdgesCorrectness(splitEdges) {
		var edgePts = this._edge.getCoordinates();
		var split0 = splitEdges.get(0);
		var pt0 = split0.getCoordinate(0);
		if (!pt0.equals2D(edgePts[0])) { throw new RuntimeException('bad split edge start point at ' + pt0) }
		var splitn = splitEdges.get(splitEdges.size() - 1);
		var splitnPts = splitn.getCoordinates();
		var ptn = splitnPts[splitnPts.length - 1];
		if (!ptn.equals2D(edgePts[edgePts.length - 1])) { throw new RuntimeException('bad split edge end point at ' + ptn) }
	};
	SegmentNodeList.prototype.interfaces_ = function interfaces_() {
		return []
	};
	SegmentNodeList.prototype.getClass = function getClass() {
		return SegmentNodeList
	};



	// class NodeVertexIterator {
	//   constructor () {
	//     this._nodeList = null
	//     this._edge = null
	//     this._nodeIt = null
	//     this._currNode = null
	//     this._nextNode = null
	//     this._currSegIndex = 0
	//     let nodeList = arguments[0]
	//     this._nodeList = nodeList
	//     this._edge = nodeList.getEdge()
	//     this._nodeIt = nodeList.iterator()
	//     this.readNextNode()
	//   }
	//   next () {
	//     if (this._currNode === null) {
	//       this._currNode = this._nextNode
	//       this._currSegIndex = this._currNode.segmentIndex
	//       this.readNextNode()
	//       return this._currNode
	//     }
	//     if (this._nextNode === null) return null
	//     if (this._nextNode.segmentIndex === this._currNode.segmentIndex) {
	//       this._currNode = this._nextNode
	//       this._currSegIndex = this._currNode.segmentIndex
	//       this.readNextNode()
	//       return this._currNode
	//     }
	//     if (this._nextNode.segmentIndex > this._currNode.segmentIndex) {}
	//     return null
	//   }
	//   remove () {
	//     // throw new UnsupportedOperationException(this.getClass().getName())
	//   }
	//   hasNext () {
	//     if (this._nextNode === null) return false
	//     return true
	//   }
	//   readNextNode () {
	//     if (this._nodeIt.hasNext()) this._nextNode = this._nodeIt.next(); else this._nextNode = null
	//   }
	//   interfaces_ () {
	//     return [Iterator]
	//   }
	//   getClass () {
	//     return NodeVertexIterator
	//   }
	// }

	var Octant = function Octant() { };

	Octant.prototype.interfaces_ = function interfaces_() {
		return []
	};
	Octant.prototype.getClass = function getClass() {
		return Octant
	};
	Octant.octant = function octant() {
		if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
			var dx = arguments[0];
			var dy = arguments[1];
			if (dx === 0.0 && dy === 0.0) { throw new IllegalArgumentException('Cannot compute the octant for point ( ' + dx + ', ' + dy + ' )') }
			var adx = Math.abs(dx);
			var ady = Math.abs(dy);
			if (dx >= 0) {
				if (dy >= 0) {
					if (adx >= ady) { return 0; } else { return 1 }
				} else {
					if (adx >= ady) { return 7; } else { return 6 }
				}
			} else {
				if (dy >= 0) {
					if (adx >= ady) { return 3; } else { return 2 }
				} else {
					if (adx >= ady) { return 4; } else { return 5 }
				}
			}
		} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
			var p0 = arguments[0];
			var p1 = arguments[1];
			var dx$1 = p1.x - p0.x;
			var dy$1 = p1.y - p0.y;
			if (dx$1 === 0.0 && dy$1 === 0.0) { throw new IllegalArgumentException('Cannot compute the octant for two identical points ' + p0) }
			return Octant.octant(dx$1, dy$1)
		}
	};

	var SegmentString = function SegmentString() { };

	SegmentString.prototype.getCoordinates = function getCoordinates() { };
	SegmentString.prototype.size = function size() { };
	SegmentString.prototype.getCoordinate = function getCoordinate(i) { };
	SegmentString.prototype.isClosed = function isClosed() { };
	SegmentString.prototype.setData = function setData(data) { };
	SegmentString.prototype.getData = function getData() { };
	SegmentString.prototype.interfaces_ = function interfaces_() {
		return []
	};
	SegmentString.prototype.getClass = function getClass() {
		return SegmentString
	};

	var NodableSegmentString = function NodableSegmentString() { };

	NodableSegmentString.prototype.addIntersection = function addIntersection(intPt, segmentIndex) { };
	NodableSegmentString.prototype.interfaces_ = function interfaces_() {
		return [SegmentString]
	};
	NodableSegmentString.prototype.getClass = function getClass() {
		return NodableSegmentString
	};

	var NodedSegmentString = function NodedSegmentString() {
		this._nodeList = new SegmentNodeList(this);
		this._pts = null;
		this._data = null;
		var pts = arguments[0];
		var data = arguments[1];
		this._pts = pts;
		this._data = data;
	};
	NodedSegmentString.prototype.getCoordinates = function getCoordinates() {
		return this._pts
	};
	NodedSegmentString.prototype.size = function size() {
		return this._pts.length
	};
	NodedSegmentString.prototype.getCoordinate = function getCoordinate(i) {
		return this._pts[i]
	};
	NodedSegmentString.prototype.isClosed = function isClosed() {
		return this._pts[0].equals(this._pts[this._pts.length - 1])
	};
	NodedSegmentString.prototype.getSegmentOctant = function getSegmentOctant(index) {
		if (index === this._pts.length - 1) { return -1 }
		return this.safeOctant(this.getCoordinate(index), this.getCoordinate(index + 1))
	};
	NodedSegmentString.prototype.setData = function setData(data) {
		this._data = data;
	};
	NodedSegmentString.prototype.safeOctant = function safeOctant(p0, p1) {
		if (p0.equals2D(p1)) { return 0 }
		return Octant.octant(p0, p1)
	};
	NodedSegmentString.prototype.getData = function getData() {
		return this._data
	};
	NodedSegmentString.prototype.addIntersection = function addIntersection() {
		if (arguments.length === 2) {
			var intPt$1 = arguments[0];
			var segmentIndex = arguments[1];
			this.addIntersectionNode(intPt$1, segmentIndex);
		} else if (arguments.length === 4) {
			var li = arguments[0];
			var segmentIndex$1 = arguments[1];
			// const geomIndex = arguments[2]
			var intIndex = arguments[3];
			var intPt = new Coordinate(li.getIntersection(intIndex));
			this.addIntersection(intPt, segmentIndex$1);
		}
	};
	NodedSegmentString.prototype.toString = function toString() {
		return WKTWriter.toLineString(new CoordinateArraySequence(this._pts))
	};
	NodedSegmentString.prototype.getNodeList = function getNodeList() {
		return this._nodeList
	};
	NodedSegmentString.prototype.addIntersectionNode = function addIntersectionNode(intPt, segmentIndex) {
		var normalizedSegmentIndex = segmentIndex;
		var nextSegIndex = normalizedSegmentIndex + 1;
		if (nextSegIndex < this._pts.length) {
			var nextPt = this._pts[nextSegIndex];
			if (intPt.equals2D(nextPt)) {
				normalizedSegmentIndex = nextSegIndex;
			}
		}
		var ei = this._nodeList.add(intPt, normalizedSegmentIndex);
		return ei
	};
	NodedSegmentString.prototype.addIntersections = function addIntersections(li, segmentIndex, geomIndex) {
		var this$1$1 = this;

		for (var i = 0; i < li.getIntersectionNum(); i++) {
			this$1$1.addIntersection(li, segmentIndex, geomIndex, i);
		}
	};
	NodedSegmentString.prototype.interfaces_ = function interfaces_() {
		return [NodableSegmentString]
	};
	NodedSegmentString.prototype.getClass = function getClass() {
		return NodedSegmentString
	};
	NodedSegmentString.getNodedSubstrings = function getNodedSubstrings() {
		if (arguments.length === 1) {
			var segStrings = arguments[0];
			var resultEdgelist = new ArrayList();
			NodedSegmentString.getNodedSubstrings(segStrings, resultEdgelist);
			return resultEdgelist
		} else if (arguments.length === 2) {
			var segStrings$1 = arguments[0];
			var resultEdgelist$1 = arguments[1];
			for (var i = segStrings$1.iterator(); i.hasNext();) {
				var ss = i.next();
				ss.getNodeList().addSplitEdges(resultEdgelist$1);
			}
		}
	};

	var LineSegment = function LineSegment() {
		this.p0 = null;
		this.p1 = null;
		if (arguments.length === 0) {
			this.p0 = new Coordinate();
			this.p1 = new Coordinate();
		} else if (arguments.length === 1) {
			var ls = arguments[0];
			this.p0 = new Coordinate(ls.p0);
			this.p1 = new Coordinate(ls.p1);
		} else if (arguments.length === 2) {
			this.p0 = arguments[0];
			this.p1 = arguments[1];
		} else if (arguments.length === 4) {
			var x0 = arguments[0];
			var y0 = arguments[1];
			var x1 = arguments[2];
			var y1 = arguments[3];
			this.p0 = new Coordinate(x0, y0);
			this.p1 = new Coordinate(x1, y1);
		}
	};

	var staticAccessors$24 = { serialVersionUID: { configurable: true } };
	LineSegment.prototype.minX = function minX() {
		return Math.min(this.p0.x, this.p1.x)
	};
	LineSegment.prototype.orientationIndex = function orientationIndex() {
		if (arguments[0] instanceof LineSegment) {
			var seg = arguments[0];
			var orient0 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p0);
			var orient1 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p1);
			if (orient0 >= 0 && orient1 >= 0) { return Math.max(orient0, orient1) }
			if (orient0 <= 0 && orient1 <= 0) { return Math.max(orient0, orient1) }
			return 0
		} else if (arguments[0] instanceof Coordinate) {
			var p = arguments[0];
			return CGAlgorithms.orientationIndex(this.p0, this.p1, p)
		}
	};
	LineSegment.prototype.toGeometry = function toGeometry(geomFactory) {
		return geomFactory.createLineString([this.p0, this.p1])
	};
	LineSegment.prototype.isVertical = function isVertical() {
		return this.p0.x === this.p1.x
	};
	LineSegment.prototype.equals = function equals(o) {
		if (!(o instanceof LineSegment)) {
			return false
		}
		var other = o;
		return this.p0.equals(other.p0) && this.p1.equals(other.p1)
	};
	LineSegment.prototype.intersection = function intersection(line) {
		var li = new RobustLineIntersector();
		li.computeIntersection(this.p0, this.p1, line.p0, line.p1);
		if (li.hasIntersection()) { return li.getIntersection(0) }
		return null
	};
	LineSegment.prototype.project = function project() {
		if (arguments[0] instanceof Coordinate) {
			var p = arguments[0];
			if (p.equals(this.p0) || p.equals(this.p1)) { return new Coordinate(p) }
			var r = this.projectionFactor(p);
			var coord = new Coordinate();
			coord.x = this.p0.x + r * (this.p1.x - this.p0.x);
			coord.y = this.p0.y + r * (this.p1.y - this.p0.y);
			return coord
		} else if (arguments[0] instanceof LineSegment) {
			var seg = arguments[0];
			var pf0 = this.projectionFactor(seg.p0);
			var pf1 = this.projectionFactor(seg.p1);
			if (pf0 >= 1.0 && pf1 >= 1.0) { return null }
			if (pf0 <= 0.0 && pf1 <= 0.0) { return null }
			var newp0 = this.project(seg.p0);
			if (pf0 < 0.0) { newp0 = this.p0; }
			if (pf0 > 1.0) { newp0 = this.p1; }
			var newp1 = this.project(seg.p1);
			if (pf1 < 0.0) { newp1 = this.p0; }
			if (pf1 > 1.0) { newp1 = this.p1; }
			return new LineSegment(newp0, newp1)
		}
	};
	LineSegment.prototype.normalize = function normalize() {
		if (this.p1.compareTo(this.p0) < 0) { this.reverse(); }
	};
	LineSegment.prototype.angle = function angle() {
		return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)
	};
	LineSegment.prototype.getCoordinate = function getCoordinate(i) {
		if (i === 0) { return this.p0 }
		return this.p1
	};
	LineSegment.prototype.distancePerpendicular = function distancePerpendicular(p) {
		return CGAlgorithms.distancePointLinePerpendicular(p, this.p0, this.p1)
	};
	LineSegment.prototype.minY = function minY() {
		return Math.min(this.p0.y, this.p1.y)
	};
	LineSegment.prototype.midPoint = function midPoint() {
		return LineSegment.midPoint(this.p0, this.p1)
	};
	LineSegment.prototype.projectionFactor = function projectionFactor(p) {
		if (p.equals(this.p0)) { return 0.0 }
		if (p.equals(this.p1)) { return 1.0 }
		var dx = this.p1.x - this.p0.x;
		var dy = this.p1.y - this.p0.y;
		var len = dx * dx + dy * dy;
		if (len <= 0.0) { return Double.NaN }
		var r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len;
		return r
	};
	LineSegment.prototype.closestPoints = function closestPoints(line) {
		var intPt = this.intersection(line);
		if (intPt !== null) {
			return [intPt, intPt]
		}
		var closestPt = new Array(2).fill(null);
		var minDistance = Double.MAX_VALUE;
		var dist = null;
		var close00 = this.closestPoint(line.p0);
		minDistance = close00.distance(line.p0);
		closestPt[0] = close00;
		closestPt[1] = line.p0;
		var close01 = this.closestPoint(line.p1);
		dist = close01.distance(line.p1);
		if (dist < minDistance) {
			minDistance = dist;
			closestPt[0] = close01;
			closestPt[1] = line.p1;
		}
		var close10 = line.closestPoint(this.p0);
		dist = close10.distance(this.p0);
		if (dist < minDistance) {
			minDistance = dist;
			closestPt[0] = this.p0;
			closestPt[1] = close10;
		}
		var close11 = line.closestPoint(this.p1);
		dist = close11.distance(this.p1);
		if (dist < minDistance) {
			minDistance = dist;
			closestPt[0] = this.p1;
			closestPt[1] = close11;
		}
		return closestPt
	};
	LineSegment.prototype.closestPoint = function closestPoint(p) {
		var factor = this.projectionFactor(p);
		if (factor > 0 && factor < 1) {
			return this.project(p)
		}
		var dist0 = this.p0.distance(p);
		var dist1 = this.p1.distance(p);
		if (dist0 < dist1) { return this.p0 }
		return this.p1
	};
	LineSegment.prototype.maxX = function maxX() {
		return Math.max(this.p0.x, this.p1.x)
	};
	LineSegment.prototype.getLength = function getLength() {
		return this.p0.distance(this.p1)
	};
	LineSegment.prototype.compareTo = function compareTo(o) {
		var other = o;
		var comp0 = this.p0.compareTo(other.p0);
		if (comp0 !== 0) { return comp0 }
		return this.p1.compareTo(other.p1)
	};
	LineSegment.prototype.reverse = function reverse() {
		var temp = this.p0;
		this.p0 = this.p1;
		this.p1 = temp;
	};
	LineSegment.prototype.equalsTopo = function equalsTopo(other) {
		return this.p0.equals(other.p0) &&
			(this.p1.equals(other.p1) || this.p0.equals(other.p1)) &&
			this.p1.equals(other.p0)
	};
	LineSegment.prototype.lineIntersection = function lineIntersection(line) {
		try {
			var intPt = HCoordinate.intersection(this.p0, this.p1, line.p0, line.p1);
			return intPt
		} catch (ex) {
			if (ex instanceof NotRepresentableException); else { throw ex }
		} finally { }
		return null
	};
	LineSegment.prototype.maxY = function maxY() {
		return Math.max(this.p0.y, this.p1.y)
	};
	LineSegment.prototype.pointAlongOffset = function pointAlongOffset(segmentLengthFraction, offsetDistance) {
		var segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
		var segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);
		var dx = this.p1.x - this.p0.x;
		var dy = this.p1.y - this.p0.y;
		var len = Math.sqrt(dx * dx + dy * dy);
		var ux = 0.0;
		var uy = 0.0;
		if (offsetDistance !== 0.0) {
			if (len <= 0.0) { throw new Error('Cannot compute offset from zero-length line segment') }
			ux = offsetDistance * dx / len;
			uy = offsetDistance * dy / len;
		}
		var offsetx = segx - uy;
		var offsety = segy + ux;
		var coord = new Coordinate(offsetx, offsety);
		return coord
	};
	LineSegment.prototype.setCoordinates = function setCoordinates() {
		if (arguments.length === 1) {
			var ls = arguments[0];
			this.setCoordinates(ls.p0, ls.p1);
		} else if (arguments.length === 2) {
			var p0 = arguments[0];
			var p1 = arguments[1];
			this.p0.x = p0.x;
			this.p0.y = p0.y;
			this.p1.x = p1.x;
			this.p1.y = p1.y;
		}
	};
	LineSegment.prototype.segmentFraction = function segmentFraction(inputPt) {
		var segFrac = this.projectionFactor(inputPt);
		if (segFrac < 0.0) { segFrac = 0.0; } else if (segFrac > 1.0 || Double.isNaN(segFrac)) { segFrac = 1.0; }
		return segFrac
	};
	LineSegment.prototype.toString = function toString() {
		return 'LINESTRING( ' + this.p0.x + ' ' + this.p0.y + ', ' + this.p1.x + ' ' + this.p1.y + ')'
	};
	LineSegment.prototype.isHorizontal = function isHorizontal() {
		return this.p0.y === this.p1.y
	};
	LineSegment.prototype.distance = function distance() {
		if (arguments[0] instanceof LineSegment) {
			var ls = arguments[0];
			return CGAlgorithms.distanceLineLine(this.p0, this.p1, ls.p0, ls.p1)
		} else if (arguments[0] instanceof Coordinate) {
			var p = arguments[0];
			return CGAlgorithms.distancePointLine(p, this.p0, this.p1)
		}
	};
	LineSegment.prototype.pointAlong = function pointAlong(segmentLengthFraction) {
		var coord = new Coordinate();
		coord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
		coord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);
		return coord
	};
	LineSegment.prototype.hashCode = function hashCode() {
		var bits0 = Double.doubleToLongBits(this.p0.x);
		bits0 ^= Double.doubleToLongBits(this.p0.y) * 31;
		var hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);
		var bits1 = Double.doubleToLongBits(this.p1.x);
		bits1 ^= Double.doubleToLongBits(this.p1.y) * 31;
		var hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);
		return hash0 ^ hash1
	};
	LineSegment.prototype.interfaces_ = function interfaces_() {
		return [Comparable, Serializable]
	};
	LineSegment.prototype.getClass = function getClass() {
		return LineSegment
	};
	LineSegment.midPoint = function midPoint(p0, p1) {
		return new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2)
	};
	staticAccessors$24.serialVersionUID.get = function () { return 3252005833466256227 };

	Object.defineProperties(LineSegment, staticAccessors$24);

	var MonotoneChainOverlapAction = function MonotoneChainOverlapAction() {
		this.tempEnv1 = new Envelope();
		this.tempEnv2 = new Envelope();
		this._overlapSeg1 = new LineSegment();
		this._overlapSeg2 = new LineSegment();
	};
	MonotoneChainOverlapAction.prototype.overlap = function overlap() {
		if (arguments.length === 2); else if (arguments.length === 4) {
			var mc1 = arguments[0];
			var start1 = arguments[1];
			var mc2 = arguments[2];
			var start2 = arguments[3];
			mc1.getLineSegment(start1, this._overlapSeg1);
			mc2.getLineSegment(start2, this._overlapSeg2);
			this.overlap(this._overlapSeg1, this._overlapSeg2);
		}
	};
	MonotoneChainOverlapAction.prototype.interfaces_ = function interfaces_() {
		return []
	};
	MonotoneChainOverlapAction.prototype.getClass = function getClass() {
		return MonotoneChainOverlapAction
	};

	var MonotoneChain = function MonotoneChain() {
		this._pts = null;
		this._start = null;
		this._end = null;
		this._env = null;
		this._context = null;
		this._id = null;
		var pts = arguments[0];
		var start = arguments[1];
		var end = arguments[2];
		var context = arguments[3];
		this._pts = pts;
		this._start = start;
		this._end = end;
		this._context = context;
	};
	MonotoneChain.prototype.getLineSegment = function getLineSegment(index, ls) {
		ls.p0 = this._pts[index];
		ls.p1 = this._pts[index + 1];
	};
	MonotoneChain.prototype.computeSelect = function computeSelect(searchEnv, start0, end0, mcs) {
		var p0 = this._pts[start0];
		var p1 = this._pts[end0];
		mcs.tempEnv1.init(p0, p1);
		if (end0 - start0 === 1) {
			mcs.select(this, start0);
			return null
		}
		if (!searchEnv.intersects(mcs.tempEnv1)) { return null }
		var mid = Math.trunc((start0 + end0) / 2);
		if (start0 < mid) {
			this.computeSelect(searchEnv, start0, mid, mcs);
		}
		if (mid < end0) {
			this.computeSelect(searchEnv, mid, end0, mcs);
		}
	};
	MonotoneChain.prototype.getCoordinates = function getCoordinates() {
		var this$1$1 = this;

		var coord = new Array(this._end - this._start + 1).fill(null);
		var index = 0;
		for (var i = this._start; i <= this._end; i++) {
			coord[index++] = this$1$1._pts[i];
		}
		return coord
	};
	MonotoneChain.prototype.computeOverlaps = function computeOverlaps(mc, mco) {
		this.computeOverlapsInternal(this._start, this._end, mc, mc._start, mc._end, mco);
	};
	MonotoneChain.prototype.setId = function setId(id) {
		this._id = id;
	};
	MonotoneChain.prototype.select = function select(searchEnv, mcs) {
		this.computeSelect(searchEnv, this._start, this._end, mcs);
	};
	MonotoneChain.prototype.getEnvelope = function getEnvelope() {
		if (this._env === null) {
			var p0 = this._pts[this._start];
			var p1 = this._pts[this._end];
			this._env = new Envelope(p0, p1);
		}
		return this._env
	};
	MonotoneChain.prototype.getEndIndex = function getEndIndex() {
		return this._end
	};
	MonotoneChain.prototype.getStartIndex = function getStartIndex() {
		return this._start
	};
	MonotoneChain.prototype.getContext = function getContext() {
		return this._context
	};
	MonotoneChain.prototype.getId = function getId() {
		return this._id
	};
	MonotoneChain.prototype.computeOverlapsInternal = function computeOverlapsInternal(start0, end0, mc, start1, end1, mco) {
		var p00 = this._pts[start0];
		var p01 = this._pts[end0];
		var p10 = mc._pts[start1];
		var p11 = mc._pts[end1];
		if (end0 - start0 === 1 && end1 - start1 === 1) {
			mco.overlap(this, start0, mc, start1);
			return null
		}
		mco.tempEnv1.init(p00, p01);
		mco.tempEnv2.init(p10, p11);
		if (!mco.tempEnv1.intersects(mco.tempEnv2)) { return null }
		var mid0 = Math.trunc((start0 + end0) / 2);
		var mid1 = Math.trunc((start1 + end1) / 2);
		if (start0 < mid0) {
			if (start1 < mid1) { this.computeOverlapsInternal(start0, mid0, mc, start1, mid1, mco); }
			if (mid1 < end1) { this.computeOverlapsInternal(start0, mid0, mc, mid1, end1, mco); }
		}
		if (mid0 < end0) {
			if (start1 < mid1) { this.computeOverlapsInternal(mid0, end0, mc, start1, mid1, mco); }
			if (mid1 < end1) { this.computeOverlapsInternal(mid0, end0, mc, mid1, end1, mco); }
		}
	};
	MonotoneChain.prototype.interfaces_ = function interfaces_() {
		return []
	};
	MonotoneChain.prototype.getClass = function getClass() {
		return MonotoneChain
	};

	var MonotoneChainBuilder = function MonotoneChainBuilder() { };

	MonotoneChainBuilder.prototype.interfaces_ = function interfaces_() {
		return []
	};
	MonotoneChainBuilder.prototype.getClass = function getClass() {
		return MonotoneChainBuilder
	};
	MonotoneChainBuilder.getChainStartIndices = function getChainStartIndices(pts) {
		var start = 0;
		var startIndexList = new ArrayList();
		startIndexList.add(new Integer(start));
		do {
			var last = MonotoneChainBuilder.findChainEnd(pts, start);
			startIndexList.add(new Integer(last));
			start = last;
		} while (start < pts.length - 1)
		var startIndex = MonotoneChainBuilder.toIntArray(startIndexList);
		return startIndex
	};
	MonotoneChainBuilder.findChainEnd = function findChainEnd(pts, start) {
		var safeStart = start;
		while (safeStart < pts.length - 1 && pts[safeStart].equals2D(pts[safeStart + 1])) {
			safeStart++;
		}
		if (safeStart >= pts.length - 1) {
			return pts.length - 1
		}
		var chainQuad = Quadrant.quadrant(pts[safeStart], pts[safeStart + 1]);
		var last = start + 1;
		while (last < pts.length) {
			if (!pts[last - 1].equals2D(pts[last])) {
				var quad = Quadrant.quadrant(pts[last - 1], pts[last]);
				if (quad !== chainQuad) { break }
			}
			last++;
		}
		return last - 1
	};
	MonotoneChainBuilder.getChains = function getChains() {
		if (arguments.length === 1) {
			var pts = arguments[0];
			return MonotoneChainBuilder.getChains(pts, null)
		} else if (arguments.length === 2) {
			var pts$1 = arguments[0];
			var context = arguments[1];
			var mcList = new ArrayList();
			var startIndex = MonotoneChainBuilder.getChainStartIndices(pts$1);
			for (var i = 0; i < startIndex.length - 1; i++) {
				var mc = new MonotoneChain(pts$1, startIndex[i], startIndex[i + 1], context);
				mcList.add(mc);
			}
			return mcList
		}
	};
	MonotoneChainBuilder.toIntArray = function toIntArray(list) {
		var array = new Array(list.size()).fill(null);
		for (var i = 0; i < array.length; i++) {
			array[i] = list.get(i).intValue();
		}
		return array
	};

	var Noder = function Noder() { };

	Noder.prototype.computeNodes = function computeNodes(segStrings) { };
	Noder.prototype.getNodedSubstrings = function getNodedSubstrings() { };
	Noder.prototype.interfaces_ = function interfaces_() {
		return []
	};
	Noder.prototype.getClass = function getClass() {
		return Noder
	};

	var SinglePassNoder = function SinglePassNoder() {
		this._segInt = null;
		if (arguments.length === 0); else if (arguments.length === 1) {
			var segInt = arguments[0];
			this.setSegmentIntersector(segInt);
		}
	};
	SinglePassNoder.prototype.setSegmentIntersector = function setSegmentIntersector(segInt) {
		this._segInt = segInt;
	};
	SinglePassNoder.prototype.interfaces_ = function interfaces_() {
		return [Noder]
	};
	SinglePassNoder.prototype.getClass = function getClass() {
		return SinglePassNoder
	};

	var MCIndexNoder = (function (SinglePassNoder$$1) {
		function MCIndexNoder(si) {
			if (si) { SinglePassNoder$$1.call(this, si); }
			else { SinglePassNoder$$1.call(this); }
			this._monoChains = new ArrayList();
			this._index = new STRtree();
			this._idCounter = 0;
			this._nodedSegStrings = null;
			this._nOverlaps = 0;
		}

		if (SinglePassNoder$$1) MCIndexNoder.__proto__ = SinglePassNoder$$1;
		MCIndexNoder.prototype = Object.create(SinglePassNoder$$1 && SinglePassNoder$$1.prototype);
		MCIndexNoder.prototype.constructor = MCIndexNoder;

		var staticAccessors = { SegmentOverlapAction: { configurable: true } };
		MCIndexNoder.prototype.getMonotoneChains = function getMonotoneChains() {
			return this._monoChains
		};
		MCIndexNoder.prototype.getNodedSubstrings = function getNodedSubstrings() {
			return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings)
		};
		MCIndexNoder.prototype.getIndex = function getIndex() {
			return this._index
		};
		MCIndexNoder.prototype.add = function add(segStr) {
			var this$1$1 = this;

			var segChains = MonotoneChainBuilder.getChains(segStr.getCoordinates(), segStr);
			for (var i = segChains.iterator(); i.hasNext();) {
				var mc = i.next();
				mc.setId(this$1$1._idCounter++);
				this$1$1._index.insert(mc.getEnvelope(), mc);
				this$1$1._monoChains.add(mc);
			}
		};
		MCIndexNoder.prototype.computeNodes = function computeNodes(inputSegStrings) {
			var this$1$1 = this;

			this._nodedSegStrings = inputSegStrings;
			for (var i = inputSegStrings.iterator(); i.hasNext();) {
				this$1$1.add(i.next());
			}
			this.intersectChains();
		};
		MCIndexNoder.prototype.intersectChains = function intersectChains() {
			var this$1$1 = this;

			var overlapAction = new SegmentOverlapAction(this._segInt);
			for (var i = this._monoChains.iterator(); i.hasNext();) {
				var queryChain = i.next();
				var overlapChains = this$1$1._index.query(queryChain.getEnvelope());
				for (var j = overlapChains.iterator(); j.hasNext();) {
					var testChain = j.next();
					if (testChain.getId() > queryChain.getId()) {
						queryChain.computeOverlaps(testChain, overlapAction);
						this$1$1._nOverlaps++;
					}
					if (this$1$1._segInt.isDone()) { return null }
				}
			}
		};
		MCIndexNoder.prototype.interfaces_ = function interfaces_() {
			return []
		};
		MCIndexNoder.prototype.getClass = function getClass() {
			return MCIndexNoder
		};
		staticAccessors.SegmentOverlapAction.get = function () { return SegmentOverlapAction };

		Object.defineProperties(MCIndexNoder, staticAccessors);

		return MCIndexNoder;
	}(SinglePassNoder));

	var SegmentOverlapAction = (function (MonotoneChainOverlapAction$$1) {
		function SegmentOverlapAction() {
			MonotoneChainOverlapAction$$1.call(this);
			this._si = null;
			var si = arguments[0];
			this._si = si;
		}

		if (MonotoneChainOverlapAction$$1) SegmentOverlapAction.__proto__ = MonotoneChainOverlapAction$$1;
		SegmentOverlapAction.prototype = Object.create(MonotoneChainOverlapAction$$1 && MonotoneChainOverlapAction$$1.prototype);
		SegmentOverlapAction.prototype.constructor = SegmentOverlapAction;
		SegmentOverlapAction.prototype.overlap = function overlap() {
			if (arguments.length === 4) {
				var mc1 = arguments[0];
				var start1 = arguments[1];
				var mc2 = arguments[2];
				var start2 = arguments[3];
				var ss1 = mc1.getContext();
				var ss2 = mc2.getContext();
				this._si.processIntersections(ss1, start1, ss2, start2);
			} else { return MonotoneChainOverlapAction$$1.prototype.overlap.apply(this, arguments) }
		};
		SegmentOverlapAction.prototype.interfaces_ = function interfaces_() {
			return []
		};
		SegmentOverlapAction.prototype.getClass = function getClass() {
			return SegmentOverlapAction
		};

		return SegmentOverlapAction;
	}(MonotoneChainOverlapAction));

	var BufferParameters = function BufferParameters() {
		this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;
		this._endCapStyle = BufferParameters.CAP_ROUND;
		this._joinStyle = BufferParameters.JOIN_ROUND;
		this._mitreLimit = BufferParameters.DEFAULT_MITRE_LIMIT;
		this._isSingleSided = false;
		this._simplifyFactor = BufferParameters.DEFAULT_SIMPLIFY_FACTOR;

		if (arguments.length === 0); else if (arguments.length === 1) {
			var quadrantSegments = arguments[0];
			this.setQuadrantSegments(quadrantSegments);
		} else if (arguments.length === 2) {
			var quadrantSegments$1 = arguments[0];
			var endCapStyle = arguments[1];
			this.setQuadrantSegments(quadrantSegments$1);
			this.setEndCapStyle(endCapStyle);
		} else if (arguments.length === 4) {
			var quadrantSegments$2 = arguments[0];
			var endCapStyle$1 = arguments[1];
			var joinStyle = arguments[2];
			var mitreLimit = arguments[3];
			this.setQuadrantSegments(quadrantSegments$2);
			this.setEndCapStyle(endCapStyle$1);
			this.setJoinStyle(joinStyle);
			this.setMitreLimit(mitreLimit);
		}
	};

	var staticAccessors$25 = { CAP_ROUND: { configurable: true }, CAP_FLAT: { configurable: true }, CAP_SQUARE: { configurable: true }, JOIN_ROUND: { configurable: true }, JOIN_MITRE: { configurable: true }, JOIN_BEVEL: { configurable: true }, DEFAULT_QUADRANT_SEGMENTS: { configurable: true }, DEFAULT_MITRE_LIMIT: { configurable: true }, DEFAULT_SIMPLIFY_FACTOR: { configurable: true } };
	BufferParameters.prototype.getEndCapStyle = function getEndCapStyle() {
		return this._endCapStyle
	};
	BufferParameters.prototype.isSingleSided = function isSingleSided() {
		return this._isSingleSided
	};
	BufferParameters.prototype.setQuadrantSegments = function setQuadrantSegments(quadSegs) {
		this._quadrantSegments = quadSegs;
		if (this._quadrantSegments === 0) { this._joinStyle = BufferParameters.JOIN_BEVEL; }
		if (this._quadrantSegments < 0) {
			this._joinStyle = BufferParameters.JOIN_MITRE;
			this._mitreLimit = Math.abs(this._quadrantSegments);
		}
		if (quadSegs <= 0) {
			this._quadrantSegments = 1;
		}
		if (this._joinStyle !== BufferParameters.JOIN_ROUND) {
			this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;
		}
	};
	BufferParameters.prototype.getJoinStyle = function getJoinStyle() {
		return this._joinStyle
	};
	BufferParameters.prototype.setJoinStyle = function setJoinStyle(joinStyle) {
		this._joinStyle = joinStyle;
	};
	BufferParameters.prototype.setSimplifyFactor = function setSimplifyFactor(simplifyFactor) {
		this._simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor;
	};
	BufferParameters.prototype.getSimplifyFactor = function getSimplifyFactor() {
		return this._simplifyFactor
	};
	BufferParameters.prototype.getQuadrantSegments = function getQuadrantSegments() {
		return this._quadrantSegments
	};
	BufferParameters.prototype.setEndCapStyle = function setEndCapStyle(endCapStyle) {
		this._endCapStyle = endCapStyle;
	};
	BufferParameters.prototype.getMitreLimit = function getMitreLimit() {
		return this._mitreLimit
	};
	BufferParameters.prototype.setMitreLimit = function setMitreLimit(mitreLimit) {
		this._mitreLimit = mitreLimit;
	};
	BufferParameters.prototype.setSingleSided = function setSingleSided(isSingleSided) {
		this._isSingleSided = isSingleSided;
	};
	BufferParameters.prototype.interfaces_ = function interfaces_() {
		return []
	};
	BufferParameters.prototype.getClass = function getClass() {
		return BufferParameters
	};
	BufferParameters.bufferDistanceError = function bufferDistanceError(quadSegs) {
		var alpha = Math.PI / 2.0 / quadSegs;
		return 1 - Math.cos(alpha / 2.0)
	};
	staticAccessors$25.CAP_ROUND.get = function () { return 1 };
	staticAccessors$25.CAP_FLAT.get = function () { return 2 };
	staticAccessors$25.CAP_SQUARE.get = function () { return 3 };
	staticAccessors$25.JOIN_ROUND.get = function () { return 1 };
	staticAccessors$25.JOIN_MITRE.get = function () { return 2 };
	staticAccessors$25.JOIN_BEVEL.get = function () { return 3 };
	staticAccessors$25.DEFAULT_QUADRANT_SEGMENTS.get = function () { return 8 };
	staticAccessors$25.DEFAULT_MITRE_LIMIT.get = function () { return 5.0 };
	staticAccessors$25.DEFAULT_SIMPLIFY_FACTOR.get = function () { return 0.01 };

	Object.defineProperties(BufferParameters, staticAccessors$25);

	var BufferInputLineSimplifier = function BufferInputLineSimplifier(inputLine) {
		this._distanceTol = null;
		this._isDeleted = null;
		this._angleOrientation = CGAlgorithms.COUNTERCLOCKWISE;
		this._inputLine = inputLine || null;
	};

	var staticAccessors$26 = { INIT: { configurable: true }, DELETE: { configurable: true }, KEEP: { configurable: true }, NUM_PTS_TO_CHECK: { configurable: true } };
	BufferInputLineSimplifier.prototype.isDeletable = function isDeletable(i0, i1, i2, distanceTol) {
		var p0 = this._inputLine[i0];
		var p1 = this._inputLine[i1];
		var p2 = this._inputLine[i2];
		if (!this.isConcave(p0, p1, p2)) { return false }
		if (!this.isShallow(p0, p1, p2, distanceTol)) { return false }
		return this.isShallowSampled(p0, p1, i0, i2, distanceTol)
	};
	BufferInputLineSimplifier.prototype.deleteShallowConcavities = function deleteShallowConcavities() {
		var this$1$1 = this;

		var index = 1;
		// const maxIndex = this._inputLine.length - 1
		var midIndex = this.findNextNonDeletedIndex(index);
		var lastIndex = this.findNextNonDeletedIndex(midIndex);
		var isChanged = false;
		while (lastIndex < this._inputLine.length) {
			var isMiddleVertexDeleted = false;
			if (this$1$1.isDeletable(index, midIndex, lastIndex, this$1$1._distanceTol)) {
				this$1$1._isDeleted[midIndex] = BufferInputLineSimplifier.DELETE;
				isMiddleVertexDeleted = true;
				isChanged = true;
			}
			if (isMiddleVertexDeleted) { index = lastIndex; } else { index = midIndex; }
			midIndex = this$1$1.findNextNonDeletedIndex(index);
			lastIndex = this$1$1.findNextNonDeletedIndex(midIndex);
		}
		return isChanged
	};
	BufferInputLineSimplifier.prototype.isShallowConcavity = function isShallowConcavity(p0, p1, p2, distanceTol) {
		var orientation = CGAlgorithms.computeOrientation(p0, p1, p2);
		var isAngleToSimplify = orientation === this._angleOrientation;
		if (!isAngleToSimplify) { return false }
		var dist = CGAlgorithms.distancePointLine(p1, p0, p2);
		return dist < distanceTol
	};
	BufferInputLineSimplifier.prototype.isShallowSampled = function isShallowSampled(p0, p2, i0, i2, distanceTol) {
		var this$1$1 = this;

		var inc = Math.trunc((i2 - i0) / BufferInputLineSimplifier.NUM_PTS_TO_CHECK);
		if (inc <= 0) { inc = 1; }
		for (var i = i0; i < i2; i += inc) {
			if (!this$1$1.isShallow(p0, p2, this$1$1._inputLine[i], distanceTol)) { return false }
		}
		return true
	};
	BufferInputLineSimplifier.prototype.isConcave = function isConcave(p0, p1, p2) {
		var orientation = CGAlgorithms.computeOrientation(p0, p1, p2);
		var isConcave = orientation === this._angleOrientation;
		return isConcave
	};
	BufferInputLineSimplifier.prototype.simplify = function simplify(distanceTol) {
		var this$1$1 = this;

		this._distanceTol = Math.abs(distanceTol);
		if (distanceTol < 0) { this._angleOrientation = CGAlgorithms.CLOCKWISE; }
		this._isDeleted = new Array(this._inputLine.length).fill(null);
		var isChanged = false;
		do {
			isChanged = this$1$1.deleteShallowConcavities();
		} while (isChanged)
		return this.collapseLine()
	};
	BufferInputLineSimplifier.prototype.findNextNonDeletedIndex = function findNextNonDeletedIndex(index) {
		var next = index + 1;
		while (next < this._inputLine.length && this._isDeleted[next] === BufferInputLineSimplifier.DELETE) { next++; }
		return next
	};
	BufferInputLineSimplifier.prototype.isShallow = function isShallow(p0, p1, p2, distanceTol) {
		var dist = CGAlgorithms.distancePointLine(p1, p0, p2);
		return dist < distanceTol
	};
	BufferInputLineSimplifier.prototype.collapseLine = function collapseLine() {
		var this$1$1 = this;

		var coordList = new CoordinateList();
		for (var i = 0; i < this._inputLine.length; i++) {
			if (this$1$1._isDeleted[i] !== BufferInputLineSimplifier.DELETE) { coordList.add(this$1$1._inputLine[i]); }
		}
		return coordList.toCoordinateArray()
	};
	BufferInputLineSimplifier.prototype.interfaces_ = function interfaces_() {
		return []
	};
	BufferInputLineSimplifier.prototype.getClass = function getClass() {
		return BufferInputLineSimplifier
	};
	BufferInputLineSimplifier.simplify = function simplify(inputLine, distanceTol) {
		var simp = new BufferInputLineSimplifier(inputLine);
		return simp.simplify(distanceTol)
	};
	staticAccessors$26.INIT.get = function () { return 0 };
	staticAccessors$26.DELETE.get = function () { return 1 };
	staticAccessors$26.KEEP.get = function () { return 1 };
	staticAccessors$26.NUM_PTS_TO_CHECK.get = function () { return 10 };

	Object.defineProperties(BufferInputLineSimplifier, staticAccessors$26);

	var OffsetSegmentString = function OffsetSegmentString() {
		this._ptList = null;
		this._precisionModel = null;
		this._minimimVertexDistance = 0.0;
		this._ptList = new ArrayList();
	};

	var staticAccessors$28 = { COORDINATE_ARRAY_TYPE: { configurable: true } };
	OffsetSegmentString.prototype.getCoordinates = function getCoordinates() {
		var coord = this._ptList.toArray(OffsetSegmentString.COORDINATE_ARRAY_TYPE);
		return coord
	};
	OffsetSegmentString.prototype.setPrecisionModel = function setPrecisionModel(precisionModel) {
		this._precisionModel = precisionModel;
	};
	OffsetSegmentString.prototype.addPt = function addPt(pt) {
		var bufPt = new Coordinate(pt);
		this._precisionModel.makePrecise(bufPt);
		if (this.isRedundant(bufPt)) { return null }
		this._ptList.add(bufPt);
	};
	OffsetSegmentString.prototype.revere = function revere() { };
	OffsetSegmentString.prototype.addPts = function addPts(pt, isForward) {
		var this$1$1 = this;

		if (isForward) {
			for (var i = 0; i < pt.length; i++) {
				this$1$1.addPt(pt[i]);
			}
		} else {
			for (var i$1 = pt.length - 1; i$1 >= 0; i$1--) {
				this$1$1.addPt(pt[i$1]);
			}
		}
	};
	OffsetSegmentString.prototype.isRedundant = function isRedundant(pt) {
		if (this._ptList.size() < 1) { return false }
		var lastPt = this._ptList.get(this._ptList.size() - 1);
		var ptDist = pt.distance(lastPt);
		if (ptDist < this._minimimVertexDistance) { return true }
		return false
	};
	OffsetSegmentString.prototype.toString = function toString() {
		var fact = new GeometryFactory();
		var line = fact.createLineString(this.getCoordinates());
		return line.toString()
	};
	OffsetSegmentString.prototype.closeRing = function closeRing() {
		if (this._ptList.size() < 1) { return null }
		var startPt = new Coordinate(this._ptList.get(0));
		var lastPt = this._ptList.get(this._ptList.size() - 1);
		// const last2Pt = null
		// if (this._ptList.size() >= 2) last2Pt = this._ptList.get(this._ptList.size() - 2)
		if (startPt.equals(lastPt)) { return null }
		this._ptList.add(startPt);
	};
	OffsetSegmentString.prototype.setMinimumVertexDistance = function setMinimumVertexDistance(minimimVertexDistance) {
		this._minimimVertexDistance = minimimVertexDistance;
	};
	OffsetSegmentString.prototype.interfaces_ = function interfaces_() {
		return []
	};
	OffsetSegmentString.prototype.getClass = function getClass() {
		return OffsetSegmentString
	};
	staticAccessors$28.COORDINATE_ARRAY_TYPE.get = function () { return new Array(0).fill(null) };

	Object.defineProperties(OffsetSegmentString, staticAccessors$28);

	var Angle = function Angle() { };

	var staticAccessors$29 = { PI_TIMES_2: { configurable: true }, PI_OVER_2: { configurable: true }, PI_OVER_4: { configurable: true }, COUNTERCLOCKWISE: { configurable: true }, CLOCKWISE: { configurable: true }, NONE: { configurable: true } };

	Angle.prototype.interfaces_ = function interfaces_() {
		return []
	};
	Angle.prototype.getClass = function getClass() {
		return Angle
	};
	Angle.toDegrees = function toDegrees(radians) {
		return radians * 180 / Math.PI
	};
	Angle.normalize = function normalize(angle) {
		while (angle > Math.PI) { angle -= Angle.PI_TIMES_2; }
		while (angle <= -Math.PI) { angle += Angle.PI_TIMES_2; }
		return angle
	};
	Angle.angle = function angle() {
		if (arguments.length === 1) {
			var p = arguments[0];
			return Math.atan2(p.y, p.x)
		} else if (arguments.length === 2) {
			var p0 = arguments[0];
			var p1 = arguments[1];
			var dx = p1.x - p0.x;
			var dy = p1.y - p0.y;
			return Math.atan2(dy, dx)
		}
	};
	Angle.isAcute = function isAcute(p0, p1, p2) {
		var dx0 = p0.x - p1.x;
		var dy0 = p0.y - p1.y;
		var dx1 = p2.x - p1.x;
		var dy1 = p2.y - p1.y;
		var dotprod = dx0 * dx1 + dy0 * dy1;
		return dotprod > 0
	};
	Angle.isObtuse = function isObtuse(p0, p1, p2) {
		var dx0 = p0.x - p1.x;
		var dy0 = p0.y - p1.y;
		var dx1 = p2.x - p1.x;
		var dy1 = p2.y - p1.y;
		var dotprod = dx0 * dx1 + dy0 * dy1;
		return dotprod < 0
	};
	Angle.interiorAngle = function interiorAngle(p0, p1, p2) {
		var anglePrev = Angle.angle(p1, p0);
		var angleNext = Angle.angle(p1, p2);
		return Math.abs(angleNext - anglePrev)
	};
	Angle.normalizePositive = function normalizePositive(angle) {
		if (angle < 0.0) {
			while (angle < 0.0) { angle += Angle.PI_TIMES_2; }
			if (angle >= Angle.PI_TIMES_2) { angle = 0.0; }
		} else {
			while (angle >= Angle.PI_TIMES_2) { angle -= Angle.PI_TIMES_2; }
			if (angle < 0.0) { angle = 0.0; }
		}
		return angle
	};
	Angle.angleBetween = function angleBetween(tip1, tail, tip2) {
		var a1 = Angle.angle(tail, tip1);
		var a2 = Angle.angle(tail, tip2);
		return Angle.diff(a1, a2)
	};
	Angle.diff = function diff(ang1, ang2) {
		var delAngle = null;
		if (ang1 < ang2) {
			delAngle = ang2 - ang1;
		} else {
			delAngle = ang1 - ang2;
		}
		if (delAngle > Math.PI) {
			delAngle = 2 * Math.PI - delAngle;
		}
		return delAngle
	};
	Angle.toRadians = function toRadians(angleDegrees) {
		return angleDegrees * Math.PI / 180.0
	};
	Angle.getTurn = function getTurn(ang1, ang2) {
		var crossproduct = Math.sin(ang2 - ang1);
		if (crossproduct > 0) {
			return Angle.COUNTERCLOCKWISE
		}
		if (crossproduct < 0) {
			return Angle.CLOCKWISE
		}
		return Angle.NONE
	};
	Angle.angleBetweenOriented = function angleBetweenOriented(tip1, tail, tip2) {
		var a1 = Angle.angle(tail, tip1);
		var a2 = Angle.angle(tail, tip2);
		var angDel = a2 - a1;
		if (angDel <= -Math.PI) { return angDel + Angle.PI_TIMES_2 }
		if (angDel > Math.PI) { return angDel - Angle.PI_TIMES_2 }
		return angDel
	};
	staticAccessors$29.PI_TIMES_2.get = function () { return 2.0 * Math.PI };
	staticAccessors$29.PI_OVER_2.get = function () { return Math.PI / 2.0 };
	staticAccessors$29.PI_OVER_4.get = function () { return Math.PI / 4.0 };
	staticAccessors$29.COUNTERCLOCKWISE.get = function () { return CGAlgorithms.COUNTERCLOCKWISE };
	staticAccessors$29.CLOCKWISE.get = function () { return CGAlgorithms.CLOCKWISE };
	staticAccessors$29.NONE.get = function () { return CGAlgorithms.COLLINEAR };

	Object.defineProperties(Angle, staticAccessors$29);

	var OffsetSegmentGenerator = function OffsetSegmentGenerator() {
		this._maxCurveSegmentError = 0.0;
		this._filletAngleQuantum = null;
		this._closingSegLengthFactor = 1;
		this._segList = null;
		this._distance = 0.0;
		this._precisionModel = null;
		this._bufParams = null;
		this._li = null;
		this._s0 = null;
		this._s1 = null;
		this._s2 = null;
		this._seg0 = new LineSegment();
		this._seg1 = new LineSegment();
		this._offset0 = new LineSegment();
		this._offset1 = new LineSegment();
		this._side = 0;
		this._hasNarrowConcaveAngle = false;
		var precisionModel = arguments[0];
		var bufParams = arguments[1];
		var distance = arguments[2];
		this._precisionModel = precisionModel;
		this._bufParams = bufParams;
		this._li = new RobustLineIntersector();
		this._filletAngleQuantum = Math.PI / 2.0 / bufParams.getQuadrantSegments();
		if (bufParams.getQuadrantSegments() >= 8 && bufParams.getJoinStyle() === BufferParameters.JOIN_ROUND) { this._closingSegLengthFactor = OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR; }
		this.init(distance);
	};

	var staticAccessors$27 = { OFFSET_SEGMENT_SEPARATION_FACTOR: { configurable: true }, INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true }, CURVE_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true }, MAX_CLOSING_SEG_LEN_FACTOR: { configurable: true } };
	OffsetSegmentGenerator.prototype.addNextSegment = function addNextSegment(p, addStartPoint) {
		this._s0 = this._s1;
		this._s1 = this._s2;
		this._s2 = p;
		this._seg0.setCoordinates(this._s0, this._s1);
		this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0);
		this._seg1.setCoordinates(this._s1, this._s2);
		this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1);
		if (this._s1.equals(this._s2)) { return null }
		var orientation = CGAlgorithms.computeOrientation(this._s0, this._s1, this._s2);
		var outsideTurn = (orientation === CGAlgorithms.CLOCKWISE && this._side === Position.LEFT) || (orientation === CGAlgorithms.COUNTERCLOCKWISE && this._side === Position.RIGHT);
		if (orientation === 0) {
			this.addCollinear(addStartPoint);
		} else if (outsideTurn) {
			this.addOutsideTurn(orientation, addStartPoint);
		} else {
			this.addInsideTurn(orientation, addStartPoint);
		}
	};
	OffsetSegmentGenerator.prototype.addLineEndCap = function addLineEndCap(p0, p1) {
		var seg = new LineSegment(p0, p1);
		var offsetL = new LineSegment();
		this.computeOffsetSegment(seg, Position.LEFT, this._distance, offsetL);
		var offsetR = new LineSegment();
		this.computeOffsetSegment(seg, Position.RIGHT, this._distance, offsetR);
		var dx = p1.x - p0.x;
		var dy = p1.y - p0.y;
		var angle = Math.atan2(dy, dx);
		switch (this._bufParams.getEndCapStyle()) {
			case BufferParameters.CAP_ROUND:
				this._segList.addPt(offsetL.p1);
				this.addFilletArc(p1, angle + Math.PI / 2, angle - Math.PI / 2, CGAlgorithms.CLOCKWISE, this._distance);
				this._segList.addPt(offsetR.p1);
				break
			case BufferParameters.CAP_FLAT:
				this._segList.addPt(offsetL.p1);
				this._segList.addPt(offsetR.p1);
				break
			case BufferParameters.CAP_SQUARE:
				var squareCapSideOffset = new Coordinate();
				squareCapSideOffset.x = Math.abs(this._distance) * Math.cos(angle);
				squareCapSideOffset.y = Math.abs(this._distance) * Math.sin(angle);
				var squareCapLOffset = new Coordinate(offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y);
				var squareCapROffset = new Coordinate(offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y);
				this._segList.addPt(squareCapLOffset);
				this._segList.addPt(squareCapROffset);
				break
		}
	};
	OffsetSegmentGenerator.prototype.getCoordinates = function getCoordinates() {
		var pts = this._segList.getCoordinates();
		return pts
	};
	OffsetSegmentGenerator.prototype.addMitreJoin = function addMitreJoin(p, offset0, offset1, distance) {
		var isMitreWithinLimit = true;
		var intPt = null;
		try {
			intPt = HCoordinate.intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1);
			var mitreRatio = distance <= 0.0 ? 1.0 : intPt.distance(p) / Math.abs(distance);
			if (mitreRatio > this._bufParams.getMitreLimit()) { isMitreWithinLimit = false; }
		} catch (ex) {
			if (ex instanceof NotRepresentableException) {
				intPt = new Coordinate(0, 0);
				isMitreWithinLimit = false;
			} else { throw ex }
		} finally { }
		if (isMitreWithinLimit) {
			this._segList.addPt(intPt);
		} else {
			this.addLimitedMitreJoin(offset0, offset1, distance, this._bufParams.getMitreLimit());
		}
	};
	OffsetSegmentGenerator.prototype.addFilletCorner = function addFilletCorner(p, p0, p1, direction, radius) {
		var dx0 = p0.x - p.x;
		var dy0 = p0.y - p.y;
		var startAngle = Math.atan2(dy0, dx0);
		var dx1 = p1.x - p.x;
		var dy1 = p1.y - p.y;
		var endAngle = Math.atan2(dy1, dx1);
		if (direction === CGAlgorithms.CLOCKWISE) {
			if (startAngle <= endAngle) { startAngle += 2.0 * Math.PI; }
		} else {
			if (startAngle >= endAngle) { startAngle -= 2.0 * Math.PI; }
		}
		this._segList.addPt(p0);
		this.addFilletArc(p, startAngle, endAngle, direction, radius);
		this._segList.addPt(p1);
	};
	OffsetSegmentGenerator.prototype.addOutsideTurn = function addOutsideTurn(orientation, addStartPoint) {
		if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {
			this._segList.addPt(this._offset0.p1);
			return null
		}
		if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {
			this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance);
		} else if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL) {
			this.addBevelJoin(this._offset0, this._offset1);
		} else {
			if (addStartPoint) { this._segList.addPt(this._offset0.p1); }
			this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, orientation, this._distance);
			this._segList.addPt(this._offset1.p0);
		}
	};
	OffsetSegmentGenerator.prototype.createSquare = function createSquare(p) {
		this._segList.addPt(new Coordinate(p.x + this._distance, p.y + this._distance));
		this._segList.addPt(new Coordinate(p.x + this._distance, p.y - this._distance));
		this._segList.addPt(new Coordinate(p.x - this._distance, p.y - this._distance));
		this._segList.addPt(new Coordinate(p.x - this._distance, p.y + this._distance));
		this._segList.closeRing();
	};
	OffsetSegmentGenerator.prototype.addSegments = function addSegments(pt, isForward) {
		this._segList.addPts(pt, isForward);
	};
	OffsetSegmentGenerator.prototype.addFirstSegment = function addFirstSegment() {
		this._segList.addPt(this._offset1.p0);
	};
	OffsetSegmentGenerator.prototype.addLastSegment = function addLastSegment() {
		this._segList.addPt(this._offset1.p1);
	};
	OffsetSegmentGenerator.prototype.initSideSegments = function initSideSegments(s1, s2, side) {
		this._s1 = s1;
		this._s2 = s2;
		this._side = side;
		this._seg1.setCoordinates(s1, s2);
		this.computeOffsetSegment(this._seg1, side, this._distance, this._offset1);
	};
	OffsetSegmentGenerator.prototype.addLimitedMitreJoin = function addLimitedMitreJoin(offset0, offset1, distance, mitreLimit) {
		var basePt = this._seg0.p1;
		var ang0 = Angle.angle(basePt, this._seg0.p0);
		// const ang1 = Angle.angle(basePt, this._seg1.p1)
		var angDiff = Angle.angleBetweenOriented(this._seg0.p0, basePt, this._seg1.p1);
		var angDiffHalf = angDiff / 2;
		var midAng = Angle.normalize(ang0 + angDiffHalf);
		var mitreMidAng = Angle.normalize(midAng + Math.PI);
		var mitreDist = mitreLimit * distance;
		var bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf));
		var bevelHalfLen = distance - bevelDelta;
		var bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng);
		var bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng);
		var bevelMidPt = new Coordinate(bevelMidX, bevelMidY);
		var mitreMidLine = new LineSegment(basePt, bevelMidPt);
		var bevelEndLeft = mitreMidLine.pointAlongOffset(1.0, bevelHalfLen);
		var bevelEndRight = mitreMidLine.pointAlongOffset(1.0, -bevelHalfLen);
		if (this._side === Position.LEFT) {
			this._segList.addPt(bevelEndLeft);
			this._segList.addPt(bevelEndRight);
		} else {
			this._segList.addPt(bevelEndRight);
			this._segList.addPt(bevelEndLeft);
		}
	};
	OffsetSegmentGenerator.prototype.computeOffsetSegment = function computeOffsetSegment(seg, side, distance, offset) {
		var sideSign = side === Position.LEFT ? 1 : -1;
		var dx = seg.p1.x - seg.p0.x;
		var dy = seg.p1.y - seg.p0.y;
		var len = Math.sqrt(dx * dx + dy * dy);
		var ux = sideSign * distance * dx / len;
		var uy = sideSign * distance * dy / len;
		offset.p0.x = seg.p0.x - uy;
		offset.p0.y = seg.p0.y + ux;
		offset.p1.x = seg.p1.x - uy;
		offset.p1.y = seg.p1.y + ux;
	};
	OffsetSegmentGenerator.prototype.addFilletArc = function addFilletArc(p, startAngle, endAngle, direction, radius) {
		var this$1$1 = this;

		var directionFactor = direction === CGAlgorithms.CLOCKWISE ? -1 : 1;
		var totalAngle = Math.abs(startAngle - endAngle);
		var nSegs = Math.trunc(totalAngle / this._filletAngleQuantum + 0.5);
		if (nSegs < 1) { return null }
		var initAngle = 0.0;
		var currAngleInc = totalAngle / nSegs;
		var currAngle = initAngle;
		var pt = new Coordinate();
		while (currAngle < totalAngle) {
			var angle = startAngle + directionFactor * currAngle;
			pt.x = p.x + radius * Math.cos(angle);
			pt.y = p.y + radius * Math.sin(angle);
			this$1$1._segList.addPt(pt);
			currAngle += currAngleInc;
		}
	};
	OffsetSegmentGenerator.prototype.addInsideTurn = function addInsideTurn(orientation, addStartPoint) {
		this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1);
		if (this._li.hasIntersection()) {
			this._segList.addPt(this._li.getIntersection(0));
		} else {
			this._hasNarrowConcaveAngle = true;
			if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) {
				this._segList.addPt(this._offset0.p1);
			} else {
				this._segList.addPt(this._offset0.p1);
				if (this._closingSegLengthFactor > 0) {
					var mid0 = new Coordinate((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
					this._segList.addPt(mid0);
					var mid1 = new Coordinate((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
					this._segList.addPt(mid1);
				} else {
					this._segList.addPt(this._s1);
				}
				this._segList.addPt(this._offset1.p0);
			}
		}
	};
	OffsetSegmentGenerator.prototype.createCircle = function createCircle(p) {
		var pt = new Coordinate(p.x + this._distance, p.y);
		this._segList.addPt(pt);
		this.addFilletArc(p, 0.0, 2.0 * Math.PI, -1, this._distance);
		this._segList.closeRing();
	};
	OffsetSegmentGenerator.prototype.addBevelJoin = function addBevelJoin(offset0, offset1) {
		this._segList.addPt(offset0.p1);
		this._segList.addPt(offset1.p0);
	};
	OffsetSegmentGenerator.prototype.init = function init(distance) {
		this._distance = distance;
		this._maxCurveSegmentError = distance * (1 - Math.cos(this._filletAngleQuantum / 2.0));
		this._segList = new OffsetSegmentString();
		this._segList.setPrecisionModel(this._precisionModel);
		this._segList.setMinimumVertexDistance(distance * OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
	};
	OffsetSegmentGenerator.prototype.addCollinear = function addCollinear(addStartPoint) {
		this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);
		var numInt = this._li.getIntersectionNum();
		if (numInt >= 2) {
			if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL || this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {
				if (addStartPoint) { this._segList.addPt(this._offset0.p1); }
				this._segList.addPt(this._offset1.p0);
			} else {
				this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, CGAlgorithms.CLOCKWISE, this._distance);
			}
		}
	};
	OffsetSegmentGenerator.prototype.closeRing = function closeRing() {
		this._segList.closeRing();
	};
	OffsetSegmentGenerator.prototype.hasNarrowConcaveAngle = function hasNarrowConcaveAngle() {
		return this._hasNarrowConcaveAngle
	};
	OffsetSegmentGenerator.prototype.interfaces_ = function interfaces_() {
		return []
	};
	OffsetSegmentGenerator.prototype.getClass = function getClass() {
		return OffsetSegmentGenerator
	};
	staticAccessors$27.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function () { return 1.0E-3 };
	staticAccessors$27.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function () { return 1.0E-3 };
	staticAccessors$27.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function () { return 1.0E-6 };
	staticAccessors$27.MAX_CLOSING_SEG_LEN_FACTOR.get = function () { return 80 };

	Object.defineProperties(OffsetSegmentGenerator, staticAccessors$27);

	var OffsetCurveBuilder = function OffsetCurveBuilder() {
		this._distance = 0.0;
		this._precisionModel = null;
		this._bufParams = null;
		var precisionModel = arguments[0];
		var bufParams = arguments[1];
		this._precisionModel = precisionModel;
		this._bufParams = bufParams;
	};
	OffsetCurveBuilder.prototype.getOffsetCurve = function getOffsetCurve(inputPts, distance) {
		this._distance = distance;
		if (distance === 0.0) { return null }
		var isRightSide = distance < 0.0;
		var posDistance = Math.abs(distance);
		var segGen = this.getSegGen(posDistance);
		if (inputPts.length <= 1) {
			this.computePointCurve(inputPts[0], segGen);
		} else {
			this.computeOffsetCurve(inputPts, isRightSide, segGen);
		}
		var curvePts = segGen.getCoordinates();
		if (isRightSide) { CoordinateArrays.reverse(curvePts); }
		return curvePts
	};
	OffsetCurveBuilder.prototype.computeSingleSidedBufferCurve = function computeSingleSidedBufferCurve(inputPts, isRightSide, segGen) {
		var distTol = this.simplifyTolerance(this._distance);
		if (isRightSide) {
			segGen.addSegments(inputPts, true);
			var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
			var n2 = simp2.length - 1;
			segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);
			segGen.addFirstSegment();
			for (var i = n2 - 2; i >= 0; i--) {
				segGen.addNextSegment(simp2[i], true);
			}
		} else {
			segGen.addSegments(inputPts, false);
			var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
			var n1 = simp1.length - 1;
			segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);
			segGen.addFirstSegment();
			for (var i$1 = 2; i$1 <= n1; i$1++) {
				segGen.addNextSegment(simp1[i$1], true);
			}
		}
		segGen.addLastSegment();
		segGen.closeRing();
	};
	OffsetCurveBuilder.prototype.computeRingBufferCurve = function computeRingBufferCurve(inputPts, side, segGen) {
		var distTol = this.simplifyTolerance(this._distance);
		if (side === Position.RIGHT) { distTol = -distTol; }
		var simp = BufferInputLineSimplifier.simplify(inputPts, distTol);
		var n = simp.length - 1;
		segGen.initSideSegments(simp[n - 1], simp[0], side);
		for (var i = 1; i <= n; i++) {
			var addStartPoint = i !== 1;
			segGen.addNextSegment(simp[i], addStartPoint);
		}
		segGen.closeRing();
	};
	OffsetCurveBuilder.prototype.computeLineBufferCurve = function computeLineBufferCurve(inputPts, segGen) {
		var distTol = this.simplifyTolerance(this._distance);
		var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
		var n1 = simp1.length - 1;
		segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);
		for (var i = 2; i <= n1; i++) {
			segGen.addNextSegment(simp1[i], true);
		}
		segGen.addLastSegment();
		segGen.addLineEndCap(simp1[n1 - 1], simp1[n1]);
		var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
		var n2 = simp2.length - 1;
		segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);
		for (var i$1 = n2 - 2; i$1 >= 0; i$1--) {
			segGen.addNextSegment(simp2[i$1], true);
		}
		segGen.addLastSegment();
		segGen.addLineEndCap(simp2[1], simp2[0]);
		segGen.closeRing();
	};
	OffsetCurveBuilder.prototype.computePointCurve = function computePointCurve(pt, segGen) {
		switch (this._bufParams.getEndCapStyle()) {
			case BufferParameters.CAP_ROUND:
				segGen.createCircle(pt);
				break
			case BufferParameters.CAP_SQUARE:
				segGen.createSquare(pt);
				break
		}
	};
	OffsetCurveBuilder.prototype.getLineCurve = function getLineCurve(inputPts, distance) {
		this._distance = distance;
		if (distance < 0.0 && !this._bufParams.isSingleSided()) { return null }
		if (distance === 0.0) { return null }
		var posDistance = Math.abs(distance);
		var segGen = this.getSegGen(posDistance);
		if (inputPts.length <= 1) {
			this.computePointCurve(inputPts[0], segGen);
		} else {
			if (this._bufParams.isSingleSided()) {
				var isRightSide = distance < 0.0;
				this.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen);
			} else { this.computeLineBufferCurve(inputPts, segGen); }
		}
		var lineCoord = segGen.getCoordinates();
		return lineCoord
	};
	OffsetCurveBuilder.prototype.getBufferParameters = function getBufferParameters() {
		return this._bufParams
	};
	OffsetCurveBuilder.prototype.simplifyTolerance = function simplifyTolerance(bufDistance) {
		return bufDistance * this._bufParams.getSimplifyFactor()
	};
	OffsetCurveBuilder.prototype.getRingCurve = function getRingCurve(inputPts, side, distance) {
		this._distance = distance;
		if (inputPts.length <= 2) { return this.getLineCurve(inputPts, distance) }
		if (distance === 0.0) {
			return OffsetCurveBuilder.copyCoordinates(inputPts)
		}
		var segGen = this.getSegGen(distance);
		this.computeRingBufferCurve(inputPts, side, segGen);
		return segGen.getCoordinates()
	};
	OffsetCurveBuilder.prototype.computeOffsetCurve = function computeOffsetCurve(inputPts, isRightSide, segGen) {
		var distTol = this.simplifyTolerance(this._distance);
		if (isRightSide) {
			var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
			var n2 = simp2.length - 1;
			segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);
			segGen.addFirstSegment();
			for (var i = n2 - 2; i >= 0; i--) {
				segGen.addNextSegment(simp2[i], true);
			}
		} else {
			var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
			var n1 = simp1.length - 1;
			segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);
			segGen.addFirstSegment();
			for (var i$1 = 2; i$1 <= n1; i$1++) {
				segGen.addNextSegment(simp1[i$1], true);
			}
		}
		segGen.addLastSegment();
	};
	OffsetCurveBuilder.prototype.getSegGen = function getSegGen(distance) {
		return new OffsetSegmentGenerator(this._precisionModel, this._bufParams, distance)
	};
	OffsetCurveBuilder.prototype.interfaces_ = function interfaces_() {
		return []
	};
	OffsetCurveBuilder.prototype.getClass = function getClass() {
		return OffsetCurveBuilder
	};
	OffsetCurveBuilder.copyCoordinates = function copyCoordinates(pts) {
		var copy = new Array(pts.length).fill(null);
		for (var i = 0; i < copy.length; i++) {
			copy[i] = new Coordinate(pts[i]);
		}
		return copy
	};

	var SubgraphDepthLocater = function SubgraphDepthLocater() {
		this._subgraphs = null;
		this._seg = new LineSegment();
		this._cga = new CGAlgorithms();
		var subgraphs = arguments[0];
		this._subgraphs = subgraphs;
	};

	var staticAccessors$30 = { DepthSegment: { configurable: true } };
	SubgraphDepthLocater.prototype.findStabbedSegments = function findStabbedSegments() {
		var this$1$1 = this;

		if (arguments.length === 1) {
			var stabbingRayLeftPt = arguments[0];
			var stabbedSegments = new ArrayList();
			for (var i = this._subgraphs.iterator(); i.hasNext();) {
				var bsg = i.next();
				var env = bsg.getEnvelope();
				if (stabbingRayLeftPt.y < env.getMinY() || stabbingRayLeftPt.y > env.getMaxY()) { continue }
				this$1$1.findStabbedSegments(stabbingRayLeftPt, bsg.getDirectedEdges(), stabbedSegments);
			}
			return stabbedSegments
		} else if (arguments.length === 3) {
			if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && arguments[1] instanceof DirectedEdge)) {
				var stabbingRayLeftPt$1 = arguments[0];
				var dirEdge = arguments[1];
				var stabbedSegments$1 = arguments[2];
				var pts = dirEdge.getEdge().getCoordinates();
				for (var i$1 = 0; i$1 < pts.length - 1; i$1++) {
					this$1$1._seg.p0 = pts[i$1];
					this$1$1._seg.p1 = pts[i$1 + 1];
					if (this$1$1._seg.p0.y > this$1$1._seg.p1.y) { this$1$1._seg.reverse(); }
					var maxx = Math.max(this$1$1._seg.p0.x, this$1$1._seg.p1.x);
					if (maxx < stabbingRayLeftPt$1.x) { continue }
					if (this$1$1._seg.isHorizontal()) { continue }
					if (stabbingRayLeftPt$1.y < this$1$1._seg.p0.y || stabbingRayLeftPt$1.y > this$1$1._seg.p1.y) { continue }
					if (CGAlgorithms.computeOrientation(this$1$1._seg.p0, this$1$1._seg.p1, stabbingRayLeftPt$1) === CGAlgorithms.RIGHT) { continue }
					var depth = dirEdge.getDepth(Position.LEFT);
					if (!this$1$1._seg.p0.equals(pts[i$1])) { depth = dirEdge.getDepth(Position.RIGHT); }
					var ds = new DepthSegment(this$1$1._seg, depth);
					stabbedSegments$1.add(ds);
				}
			} else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && hasInterface(arguments[1], List))) {
				var stabbingRayLeftPt$2 = arguments[0];
				var dirEdges = arguments[1];
				var stabbedSegments$2 = arguments[2];
				for (var i$2 = dirEdges.iterator(); i$2.hasNext();) {
					var de = i$2.next();
					if (!de.isForward()) { continue }
					this$1$1.findStabbedSegments(stabbingRayLeftPt$2, de, stabbedSegments$2);
				}
			}
		}
	};
	SubgraphDepthLocater.prototype.getDepth = function getDepth(p) {
		var stabbedSegments = this.findStabbedSegments(p);
		if (stabbedSegments.size() === 0) { return 0 }
		var ds = Collections.min(stabbedSegments);
		return ds._leftDepth
	};
	SubgraphDepthLocater.prototype.interfaces_ = function interfaces_() {
		return []
	};
	SubgraphDepthLocater.prototype.getClass = function getClass() {
		return SubgraphDepthLocater
	};
	staticAccessors$30.DepthSegment.get = function () { return DepthSegment };

	Object.defineProperties(SubgraphDepthLocater, staticAccessors$30);

	var DepthSegment = function DepthSegment() {
		this._upwardSeg = null;
		this._leftDepth = null;
		var seg = arguments[0];
		var depth = arguments[1];
		this._upwardSeg = new LineSegment(seg);
		this._leftDepth = depth;
	};
	DepthSegment.prototype.compareTo = function compareTo(obj) {
		var other = obj;
		if (this._upwardSeg.minX() >= other._upwardSeg.maxX()) { return 1 }
		if (this._upwardSeg.maxX() <= other._upwardSeg.minX()) { return -1 }
		var orientIndex = this._upwardSeg.orientationIndex(other._upwardSeg);
		if (orientIndex !== 0) { return orientIndex }
		orientIndex = -1 * other._upwardSeg.orientationIndex(this._upwardSeg);
		if (orientIndex !== 0) { return orientIndex }
		return this._upwardSeg.compareTo(other._upwardSeg)
	};
	DepthSegment.prototype.compareX = function compareX(seg0, seg1) {
		var compare0 = seg0.p0.compareTo(seg1.p0);
		if (compare0 !== 0) { return compare0 }
		return seg0.p1.compareTo(seg1.p1)
	};
	DepthSegment.prototype.toString = function toString() {
		return this._upwardSeg.toString()
	};
	DepthSegment.prototype.interfaces_ = function interfaces_() {
		return [Comparable]
	};
	DepthSegment.prototype.getClass = function getClass() {
		return DepthSegment
	};

	var Triangle = function Triangle(p0, p1, p2) {
		this.p0 = p0 || null;
		this.p1 = p1 || null;
		this.p2 = p2 || null;
	};
	Triangle.prototype.area = function area() {
		return Triangle.area(this.p0, this.p1, this.p2)
	};
	Triangle.prototype.signedArea = function signedArea() {
		return Triangle.signedArea(this.p0, this.p1, this.p2)
	};
	Triangle.prototype.interpolateZ = function interpolateZ(p) {
		if (p === null) { throw new IllegalArgumentException('Supplied point is null.') }
		return Triangle.interpolateZ(p, this.p0, this.p1, this.p2)
	};
	Triangle.prototype.longestSideLength = function longestSideLength() {
		return Triangle.longestSideLength(this.p0, this.p1, this.p2)
	};
	Triangle.prototype.isAcute = function isAcute() {
		return Triangle.isAcute(this.p0, this.p1, this.p2)
	};
	Triangle.prototype.circumcentre = function circumcentre() {
		return Triangle.circumcentre(this.p0, this.p1, this.p2)
	};
	Triangle.prototype.area3D = function area3D() {
		return Triangle.area3D(this.p0, this.p1, this.p2)
	};
	Triangle.prototype.centroid = function centroid() {
		return Triangle.centroid(this.p0, this.p1, this.p2)
	};
	Triangle.prototype.inCentre = function inCentre() {
		return Triangle.inCentre(this.p0, this.p1, this.p2)
	};
	Triangle.prototype.interfaces_ = function interfaces_() {
		return []
	};
	Triangle.prototype.getClass = function getClass() {
		return Triangle
	};
	Triangle.area = function area(a, b, c) {
		return Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2)
	};
	Triangle.signedArea = function signedArea(a, b, c) {
		return ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2
	};
	Triangle.det = function det(m00, m01, m10, m11) {
		return m00 * m11 - m01 * m10
	};
	Triangle.interpolateZ = function interpolateZ(p, v0, v1, v2) {
		var x0 = v0.x;
		var y0 = v0.y;
		var a = v1.x - x0;
		var b = v2.x - x0;
		var c = v1.y - y0;
		var d = v2.y - y0;
		var det = a * d - b * c;
		var dx = p.x - x0;
		var dy = p.y - y0;
		var t = (d * dx - b * dy) / det;
		var u = (-c * dx + a * dy) / det;
		var z = v0.z + t * (v1.z - v0.z) + u * (v2.z - v0.z);
		return z
	};
	Triangle.longestSideLength = function longestSideLength(a, b, c) {
		var lenAB = a.distance(b);
		var lenBC = b.distance(c);
		var lenCA = c.distance(a);
		var maxLen = lenAB;
		if (lenBC > maxLen) { maxLen = lenBC; }
		if (lenCA > maxLen) { maxLen = lenCA; }
		return maxLen
	};
	Triangle.isAcute = function isAcute(a, b, c) {
		if (!Angle.isAcute(a, b, c)) { return false }
		if (!Angle.isAcute(b, c, a)) { return false }
		if (!Angle.isAcute(c, a, b)) { return false }
		return true
	};
	Triangle.circumcentre = function circumcentre(a, b, c) {
		var cx = c.x;
		var cy = c.y;
		var ax = a.x - cx;
		var ay = a.y - cy;
		var bx = b.x - cx;
		var by = b.y - cy;
		var denom = 2 * Triangle.det(ax, ay, bx, by);
		var numx = Triangle.det(ay, ax * ax + ay * ay, by, bx * bx + by * by);
		var numy = Triangle.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);
		var ccx = cx - numx / denom;
		var ccy = cy + numy / denom;
		return new Coordinate(ccx, ccy)
	};
	Triangle.perpendicularBisector = function perpendicularBisector(a, b) {
		var dx = b.x - a.x;
		var dy = b.y - a.y;
		var l1 = new HCoordinate(a.x + dx / 2.0, a.y + dy / 2.0, 1.0);
		var l2 = new HCoordinate(a.x - dy + dx / 2.0, a.y + dx + dy / 2.0, 1.0);
		return new HCoordinate(l1, l2)
	};
	Triangle.angleBisector = function angleBisector(a, b, c) {
		var len0 = b.distance(a);
		var len2 = b.distance(c);
		var frac = len0 / (len0 + len2);
		var dx = c.x - a.x;
		var dy = c.y - a.y;
		var splitPt = new Coordinate(a.x + frac * dx, a.y + frac * dy);
		return splitPt
	};
	Triangle.area3D = function area3D(a, b, c) {
		var ux = b.x - a.x;
		var uy = b.y - a.y;
		var uz = b.z - a.z;
		var vx = c.x - a.x;
		var vy = c.y - a.y;
		var vz = c.z - a.z;
		var crossx = uy * vz - uz * vy;
		var crossy = uz * vx - ux * vz;
		var crossz = ux * vy - uy * vx;
		var absSq = crossx * crossx + crossy * crossy + crossz * crossz;
		var area3D = Math.sqrt(absSq) / 2;
		return area3D
	};
	Triangle.centroid = function centroid(a, b, c) {
		var x = (a.x + b.x + c.x) / 3;
		var y = (a.y + b.y + c.y) / 3;
		return new Coordinate(x, y)
	};
	Triangle.inCentre = function inCentre(a, b, c) {
		var len0 = b.distance(c);
		var len1 = a.distance(c);
		var len2 = a.distance(b);
		var circum = len0 + len1 + len2;
		var inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum;
		var inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum;
		return new Coordinate(inCentreX, inCentreY)
	};

	var OffsetCurveSetBuilder = function OffsetCurveSetBuilder() {
		this._inputGeom = null;
		this._distance = null;
		this._curveBuilder = null;
		this._curveList = new ArrayList();
		var inputGeom = arguments[0];
		var distance = arguments[1];
		var curveBuilder = arguments[2];
		this._inputGeom = inputGeom;
		this._distance = distance;
		this._curveBuilder = curveBuilder;
	};
	OffsetCurveSetBuilder.prototype.addPoint = function addPoint(p) {
		if (this._distance <= 0.0) { return null }
		var coord = p.getCoordinates();
		var curve = this._curveBuilder.getLineCurve(coord, this._distance);
		this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);
	};
	OffsetCurveSetBuilder.prototype.addPolygon = function addPolygon(p) {
		var this$1$1 = this;

		var offsetDistance = this._distance;
		var offsetSide = Position.LEFT;
		if (this._distance < 0.0) {
			offsetDistance = -this._distance;
			offsetSide = Position.RIGHT;
		}
		var shell = p.getExteriorRing();
		var shellCoord = CoordinateArrays.removeRepeatedPoints(shell.getCoordinates());
		if (this._distance < 0.0 && this.isErodedCompletely(shell, this._distance)) { return null }
		if (this._distance <= 0.0 && shellCoord.length < 3) { return null }
		this.addPolygonRing(shellCoord, offsetDistance, offsetSide, Location.EXTERIOR, Location.INTERIOR);
		for (var i = 0; i < p.getNumInteriorRing(); i++) {
			var hole = p.getInteriorRingN(i);
			var holeCoord = CoordinateArrays.removeRepeatedPoints(hole.getCoordinates());
			if (this$1$1._distance > 0.0 && this$1$1.isErodedCompletely(hole, -this$1$1._distance)) { continue }
			this$1$1.addPolygonRing(holeCoord, offsetDistance, Position.opposite(offsetSide), Location.INTERIOR, Location.EXTERIOR);
		}
	};
	OffsetCurveSetBuilder.prototype.isTriangleErodedCompletely = function isTriangleErodedCompletely(triangleCoord, bufferDistance) {
		var tri = new Triangle(triangleCoord[0], triangleCoord[1], triangleCoord[2]);
		var inCentre = tri.inCentre();
		var distToCentre = CGAlgorithms.distancePointLine(inCentre, tri.p0, tri.p1);
		return distToCentre < Math.abs(bufferDistance)
	};
	OffsetCurveSetBuilder.prototype.addLineString = function addLineString(line) {
		if (this._distance <= 0.0 && !this._curveBuilder.getBufferParameters().isSingleSided()) { return null }
		var coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());
		var curve = this._curveBuilder.getLineCurve(coord, this._distance);
		this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);
	};
	OffsetCurveSetBuilder.prototype.addCurve = function addCurve(coord, leftLoc, rightLoc) {
		if (coord === null || coord.length < 2) { return null }
		var e = new NodedSegmentString(coord, new Label(0, Location.BOUNDARY, leftLoc, rightLoc));
		this._curveList.add(e);
	};
	OffsetCurveSetBuilder.prototype.getCurves = function getCurves() {
		this.add(this._inputGeom);
		return this._curveList
	};
	OffsetCurveSetBuilder.prototype.addPolygonRing = function addPolygonRing(coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {
		if (offsetDistance === 0.0 && coord.length < LinearRing.MINIMUM_VALID_SIZE) { return null }
		var leftLoc = cwLeftLoc;
		var rightLoc = cwRightLoc;
		if (coord.length >= LinearRing.MINIMUM_VALID_SIZE && CGAlgorithms.isCCW(coord)) {
			leftLoc = cwRightLoc;
			rightLoc = cwLeftLoc;
			side = Position.opposite(side);
		}
		var curve = this._curveBuilder.getRingCurve(coord, side, offsetDistance);
		this.addCurve(curve, leftLoc, rightLoc);
	};
	OffsetCurveSetBuilder.prototype.add = function add(g) {
		if (g.isEmpty()) { return null }
		if (g instanceof Polygon) { this.addPolygon(g); }
		else if (g instanceof LineString) { this.addLineString(g); }
		else if (g instanceof Point) { this.addPoint(g); }
		else if (g instanceof MultiPoint) { this.addCollection(g); }
		else if (g instanceof MultiLineString) { this.addCollection(g); }
		else if (g instanceof MultiPolygon) { this.addCollection(g); }
		else if (g instanceof GeometryCollection) { this.addCollection(g); }
		// else throw new UnsupportedOperationException(g.getClass().getName())
	};
	OffsetCurveSetBuilder.prototype.isErodedCompletely = function isErodedCompletely(ring, bufferDistance) {
		var ringCoord = ring.getCoordinates();
		// const minDiam = 0.0
		if (ringCoord.length < 4) { return bufferDistance < 0 }
		if (ringCoord.length === 4) { return this.isTriangleErodedCompletely(ringCoord, bufferDistance) }
		var env = ring.getEnvelopeInternal();
		var envMinDimension = Math.min(env.getHeight(), env.getWidth());
		if (bufferDistance < 0.0 && 2 * Math.abs(bufferDistance) > envMinDimension) { return true }
		return false
	};
	OffsetCurveSetBuilder.prototype.addCollection = function addCollection(gc) {
		var this$1$1 = this;

		for (var i = 0; i < gc.getNumGeometries(); i++) {
			var g = gc.getGeometryN(i);
			this$1$1.add(g);
		}
	};
	OffsetCurveSetBuilder.prototype.interfaces_ = function interfaces_() {
		return []
	};
	OffsetCurveSetBuilder.prototype.getClass = function getClass() {
		return OffsetCurveSetBuilder
	};

	var PointOnGeometryLocator = function PointOnGeometryLocator() { };

	PointOnGeometryLocator.prototype.locate = function locate(p) { };
	PointOnGeometryLocator.prototype.interfaces_ = function interfaces_() {
		return []
	};
	PointOnGeometryLocator.prototype.getClass = function getClass() {
		return PointOnGeometryLocator
	};

	var GeometryCollectionIterator = function GeometryCollectionIterator() {
		this._parent = null;
		this._atStart = null;
		this._max = null;
		this._index = null;
		this._subcollectionIterator = null;
		var parent = arguments[0];
		this._parent = parent;
		this._atStart = true;
		this._index = 0;
		this._max = parent.getNumGeometries();
	};
	GeometryCollectionIterator.prototype.next = function next() {
		if (this._atStart) {
			this._atStart = false;
			if (GeometryCollectionIterator.isAtomic(this._parent)) { this._index++; }
			return this._parent
		}
		if (this._subcollectionIterator !== null) {
			if (this._subcollectionIterator.hasNext()) {
				return this._subcollectionIterator.next()
			} else {
				this._subcollectionIterator = null;
			}
		}
		if (this._index >= this._max) {
			throw new NoSuchElementException()
		}
		var obj = this._parent.getGeometryN(this._index++);
		if (obj instanceof GeometryCollection) {
			this._subcollectionIterator = new GeometryCollectionIterator(obj);
			return this._subcollectionIterator.next()
		}
		return obj
	};
	GeometryCollectionIterator.prototype.remove = function remove() {
		throw new Error(this.getClass().getName())
	};
	GeometryCollectionIterator.prototype.hasNext = function hasNext() {
		if (this._atStart) {
			return true
		}
		if (this._subcollectionIterator !== null) {
			if (this._subcollectionIterator.hasNext()) {
				return true
			}
			this._subcollectionIterator = null;
		}
		if (this._index >= this._max) {
			return false
		}
		return true
	};
	GeometryCollectionIterator.prototype.interfaces_ = function interfaces_() {
		return [Iterator]
	};
	GeometryCollectionIterator.prototype.getClass = function getClass() {
		return GeometryCollectionIterator
	};
	GeometryCollectionIterator.isAtomic = function isAtomic(geom) {
		return !(geom instanceof GeometryCollection)
	};

	var SimplePointInAreaLocator = function SimplePointInAreaLocator() {
		this._geom = null;
		var geom = arguments[0];
		this._geom = geom;
	};
	SimplePointInAreaLocator.prototype.locate = function locate(p) {
		return SimplePointInAreaLocator.locate(p, this._geom)
	};
	SimplePointInAreaLocator.prototype.interfaces_ = function interfaces_() {
		return [PointOnGeometryLocator]
	};
	SimplePointInAreaLocator.prototype.getClass = function getClass() {
		return SimplePointInAreaLocator
	};
	SimplePointInAreaLocator.isPointInRing = function isPointInRing(p, ring) {
		if (!ring.getEnvelopeInternal().intersects(p)) { return false }
		return CGAlgorithms.isPointInRing(p, ring.getCoordinates())
	};
	SimplePointInAreaLocator.containsPointInPolygon = function containsPointInPolygon(p, poly) {
		if (poly.isEmpty()) { return false }
		var shell = poly.getExteriorRing();
		if (!SimplePointInAreaLocator.isPointInRing(p, shell)) { return false }
		for (var i = 0; i < poly.getNumInteriorRing(); i++) {
			var hole = poly.getInteriorRingN(i);
			if (SimplePointInAreaLocator.isPointInRing(p, hole)) { return false }
		}
		return true
	};
	SimplePointInAreaLocator.containsPoint = function containsPoint(p, geom) {
		if (geom instanceof Polygon) {
			return SimplePointInAreaLocator.containsPointInPolygon(p, geom)
		} else if (geom instanceof GeometryCollection) {
			var geomi = new GeometryCollectionIterator(geom);
			while (geomi.hasNext()) {
				var g2 = geomi.next();
				if (g2 !== geom) { if (SimplePointInAreaLocator.containsPoint(p, g2)) { return true } }
			}
		}
		return false
	};
	SimplePointInAreaLocator.locate = function locate(p, geom) {
		if (geom.isEmpty()) { return Location.EXTERIOR }
		if (SimplePointInAreaLocator.containsPoint(p, geom)) { return Location.INTERIOR }
		return Location.EXTERIOR
	};

	var EdgeEndStar = function EdgeEndStar() {
		this._edgeMap = new TreeMap();
		this._edgeList = null;
		this._ptInAreaLocation = [Location.NONE, Location.NONE];
	};
	EdgeEndStar.prototype.getNextCW = function getNextCW(ee) {
		this.getEdges();
		var i = this._edgeList.indexOf(ee);
		var iNextCW = i - 1;
		if (i === 0) { iNextCW = this._edgeList.size() - 1; }
		return this._edgeList.get(iNextCW)
	};
	EdgeEndStar.prototype.propagateSideLabels = function propagateSideLabels(geomIndex) {
		var startLoc = Location.NONE;
		for (var it = this.iterator(); it.hasNext();) {
			var e = it.next();
			var label = e.getLabel();
			if (label.isArea(geomIndex) && label.getLocation(geomIndex, Position.LEFT) !== Location.NONE) { startLoc = label.getLocation(geomIndex, Position.LEFT); }
		}
		if (startLoc === Location.NONE) { return null }
		var currLoc = startLoc;
		for (var it$1 = this.iterator(); it$1.hasNext();) {
			var e$1 = it$1.next();
			var label$1 = e$1.getLabel();
			if (label$1.getLocation(geomIndex, Position.ON) === Location.NONE) { label$1.setLocation(geomIndex, Position.ON, currLoc); }
			if (label$1.isArea(geomIndex)) {
				var leftLoc = label$1.getLocation(geomIndex, Position.LEFT);
				var rightLoc = label$1.getLocation(geomIndex, Position.RIGHT);
				if (rightLoc !== Location.NONE) {
					if (rightLoc !== currLoc) { throw new TopologyException('side location conflict', e$1.getCoordinate()) }
					if (leftLoc === Location.NONE) {
						Assert.shouldNeverReachHere('found single null side (at ' + e$1.getCoordinate() + ')');
					}
					currLoc = leftLoc;
				} else {
					Assert.isTrue(label$1.getLocation(geomIndex, Position.LEFT) === Location.NONE, 'found single null side');
					label$1.setLocation(geomIndex, Position.RIGHT, currLoc);
					label$1.setLocation(geomIndex, Position.LEFT, currLoc);
				}
			}
		}
	};
	EdgeEndStar.prototype.getCoordinate = function getCoordinate() {
		var it = this.iterator();
		if (!it.hasNext()) { return null }
		var e = it.next();
		return e.getCoordinate()
	};
	EdgeEndStar.prototype.print = function print(out) {
		System.out.println('EdgeEndStar:   ' + this.getCoordinate());
		for (var it = this.iterator(); it.hasNext();) {
			var e = it.next();
			e.print(out);
		}
	};
	EdgeEndStar.prototype.isAreaLabelsConsistent = function isAreaLabelsConsistent(geomGraph) {
		this.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());
		return this.checkAreaLabelsConsistent(0)
	};
	EdgeEndStar.prototype.checkAreaLabelsConsistent = function checkAreaLabelsConsistent(geomIndex) {
		var edges = this.getEdges();
		if (edges.size() <= 0) { return true }
		var lastEdgeIndex = edges.size() - 1;
		var startLabel = edges.get(lastEdgeIndex).getLabel();
		var startLoc = startLabel.getLocation(geomIndex, Position.LEFT);
		Assert.isTrue(startLoc !== Location.NONE, 'Found unlabelled area edge');
		var currLoc = startLoc;
		for (var it = this.iterator(); it.hasNext();) {
			var e = it.next();
			var label = e.getLabel();
			Assert.isTrue(label.isArea(geomIndex), 'Found non-area edge');
			var leftLoc = label.getLocation(geomIndex, Position.LEFT);
			var rightLoc = label.getLocation(geomIndex, Position.RIGHT);
			if (leftLoc === rightLoc) {
				return false
			}
			if (rightLoc !== currLoc) {
				return false
			}
			currLoc = leftLoc;
		}
		return true
	};
	EdgeEndStar.prototype.findIndex = function findIndex(eSearch) {
		var this$1$1 = this;

		this.iterator();
		for (var i = 0; i < this._edgeList.size(); i++) {
			var e = this$1$1._edgeList.get(i);
			if (e === eSearch) { return i }
		}
		return -1
	};
	EdgeEndStar.prototype.iterator = function iterator() {
		return this.getEdges().iterator()
	};
	EdgeEndStar.prototype.getEdges = function getEdges() {
		if (this._edgeList === null) {
			this._edgeList = new ArrayList(this._edgeMap.values());
		}
		return this._edgeList
	};
	EdgeEndStar.prototype.getLocation = function getLocation(geomIndex, p, geom) {
		if (this._ptInAreaLocation[geomIndex] === Location.NONE) {
			this._ptInAreaLocation[geomIndex] = SimplePointInAreaLocator.locate(p, geom[geomIndex].getGeometry());
		}
		return this._ptInAreaLocation[geomIndex]
	};
	EdgeEndStar.prototype.toString = function toString() {
		var buf = new StringBuffer();
		buf.append('EdgeEndStar:   ' + this.getCoordinate());
		buf.append('\n');
		for (var it = this.iterator(); it.hasNext();) {
			var e = it.next();
			buf.append(e);
			buf.append('\n');
		}
		return buf.toString()
	};
	EdgeEndStar.prototype.computeEdgeEndLabels = function computeEdgeEndLabels(boundaryNodeRule) {
		for (var it = this.iterator(); it.hasNext();) {
			var ee = it.next();
			ee.computeLabel(boundaryNodeRule);
		}
	};
	EdgeEndStar.prototype.computeLabelling = function computeLabelling(geomGraph) {
		var this$1$1 = this;

		this.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());
		this.propagateSideLabels(0);
		this.propagateSideLabels(1);
		var hasDimensionalCollapseEdge = [false, false];
		for (var it = this.iterator(); it.hasNext();) {
			var e = it.next();
			var label = e.getLabel();
			for (var geomi = 0; geomi < 2; geomi++) {
				if (label.isLine(geomi) && label.getLocation(geomi) === Location.BOUNDARY) { hasDimensionalCollapseEdge[geomi] = true; }
			}
		}
		for (var it$1 = this.iterator(); it$1.hasNext();) {
			var e$1 = it$1.next();
			var label$1 = e$1.getLabel();
			for (var geomi$1 = 0; geomi$1 < 2; geomi$1++) {
				if (label$1.isAnyNull(geomi$1)) {
					var loc = Location.NONE;
					if (hasDimensionalCollapseEdge[geomi$1]) {
						loc = Location.EXTERIOR;
					} else {
						var p = e$1.getCoordinate();
						loc = this$1$1.getLocation(geomi$1, p, geomGraph);
					}
					label$1.setAllLocationsIfNull(geomi$1, loc);
				}
			}
		}
	};
	EdgeEndStar.prototype.getDegree = function getDegree() {
		return this._edgeMap.size()
	};
	EdgeEndStar.prototype.insertEdgeEnd = function insertEdgeEnd(e, obj) {
		this._edgeMap.put(e, obj);
		this._edgeList = null;
	};
	EdgeEndStar.prototype.interfaces_ = function interfaces_() {
		return []
	};
	EdgeEndStar.prototype.getClass = function getClass() {
		return EdgeEndStar
	};

	var DirectedEdgeStar = (function (EdgeEndStar$$1) {
		function DirectedEdgeStar() {
			EdgeEndStar$$1.call(this);
			this._resultAreaEdgeList = null;
			this._label = null;
			this._SCANNING_FOR_INCOMING = 1;
			this._LINKING_TO_OUTGOING = 2;
		}

		if (EdgeEndStar$$1) DirectedEdgeStar.__proto__ = EdgeEndStar$$1;
		DirectedEdgeStar.prototype = Object.create(EdgeEndStar$$1 && EdgeEndStar$$1.prototype);
		DirectedEdgeStar.prototype.constructor = DirectedEdgeStar;
		DirectedEdgeStar.prototype.linkResultDirectedEdges = function linkResultDirectedEdges() {
			var this$1$1 = this;

			this.getResultAreaEdges();
			var firstOut = null;
			var incoming = null;
			var state = this._SCANNING_FOR_INCOMING;
			for (var i = 0; i < this._resultAreaEdgeList.size(); i++) {
				var nextOut = this$1$1._resultAreaEdgeList.get(i);
				var nextIn = nextOut.getSym();
				if (!nextOut.getLabel().isArea()) { continue }
				if (firstOut === null && nextOut.isInResult()) { firstOut = nextOut; }
				switch (state) {
					case this$1$1._SCANNING_FOR_INCOMING:
						if (!nextIn.isInResult()) { continue }
						incoming = nextIn;
						state = this$1$1._LINKING_TO_OUTGOING;
						break
					case this$1$1._LINKING_TO_OUTGOING:
						if (!nextOut.isInResult()) { continue }
						incoming.setNext(nextOut);
						state = this$1$1._SCANNING_FOR_INCOMING;
						break
				}
			}
			if (state === this._LINKING_TO_OUTGOING) {
				if (firstOut === null) { throw new TopologyException('no outgoing dirEdge found', this.getCoordinate()) }
				Assert.isTrue(firstOut.isInResult(), 'unable to link last incoming dirEdge');
				incoming.setNext(firstOut);
			}
		};
		DirectedEdgeStar.prototype.insert = function insert(ee) {
			var de = ee;
			this.insertEdgeEnd(de, de);
		};
		DirectedEdgeStar.prototype.getRightmostEdge = function getRightmostEdge() {
			var edges = this.getEdges();
			var size = edges.size();
			if (size < 1) { return null }
			var de0 = edges.get(0);
			if (size === 1) { return de0 }
			var deLast = edges.get(size - 1);
			var quad0 = de0.getQuadrant();
			var quad1 = deLast.getQuadrant();
			if (Quadrant.isNorthern(quad0) && Quadrant.isNorthern(quad1)) { return de0; } else if (!Quadrant.isNorthern(quad0) && !Quadrant.isNorthern(quad1)) { return deLast; } else {
				// const nonHorizontalEdge = null
				if (de0.getDy() !== 0) { return de0; } else if (deLast.getDy() !== 0) { return deLast }
			}
			Assert.shouldNeverReachHere('found two horizontal edges incident on node');
			return null
		};
		DirectedEdgeStar.prototype.print = function print(out) {
			System.out.println('DirectedEdgeStar: ' + this.getCoordinate());
			for (var it = this.iterator(); it.hasNext();) {
				var de = it.next();
				out.print('out ');
				de.print(out);
				out.println();
				out.print('in ');
				de.getSym().print(out);
				out.println();
			}
		};
		DirectedEdgeStar.prototype.getResultAreaEdges = function getResultAreaEdges() {
			var this$1$1 = this;

			if (this._resultAreaEdgeList !== null) { return this._resultAreaEdgeList }
			this._resultAreaEdgeList = new ArrayList();
			for (var it = this.iterator(); it.hasNext();) {
				var de = it.next();
				if (de.isInResult() || de.getSym().isInResult()) { this$1$1._resultAreaEdgeList.add(de); }
			}
			return this._resultAreaEdgeList
		};
		DirectedEdgeStar.prototype.updateLabelling = function updateLabelling(nodeLabel) {
			for (var it = this.iterator(); it.hasNext();) {
				var de = it.next();
				var label = de.getLabel();
				label.setAllLocationsIfNull(0, nodeLabel.getLocation(0));
				label.setAllLocationsIfNull(1, nodeLabel.getLocation(1));
			}
		};
		DirectedEdgeStar.prototype.linkAllDirectedEdges = function linkAllDirectedEdges() {
			var this$1$1 = this;

			this.getEdges();
			var prevOut = null;
			var firstIn = null;
			for (var i = this._edgeList.size() - 1; i >= 0; i--) {
				var nextOut = this$1$1._edgeList.get(i);
				var nextIn = nextOut.getSym();
				if (firstIn === null) { firstIn = nextIn; }
				if (prevOut !== null) { nextIn.setNext(prevOut); }
				prevOut = nextOut;
			}
			firstIn.setNext(prevOut);
		};
		DirectedEdgeStar.prototype.computeDepths = function computeDepths() {
			var this$1$1 = this;

			if (arguments.length === 1) {
				var de = arguments[0];
				var edgeIndex = this.findIndex(de);
				// const label = de.getLabel()
				var startDepth = de.getDepth(Position.LEFT);
				var targetLastDepth = de.getDepth(Position.RIGHT);
				var nextDepth = this.computeDepths(edgeIndex + 1, this._edgeList.size(), startDepth);
				var lastDepth = this.computeDepths(0, edgeIndex, nextDepth);
				if (lastDepth !== targetLastDepth) { throw new TopologyException('depth mismatch at ' + de.getCoordinate()) }
			} else if (arguments.length === 3) {
				var startIndex = arguments[0];
				var endIndex = arguments[1];
				var startDepth$1 = arguments[2];
				var currDepth = startDepth$1;
				for (var i = startIndex; i < endIndex; i++) {
					var nextDe = this$1$1._edgeList.get(i);
					// const label = nextDe.getLabel()
					nextDe.setEdgeDepths(Position.RIGHT, currDepth);
					currDepth = nextDe.getDepth(Position.LEFT);
				}
				return currDepth
			}
		};
		DirectedEdgeStar.prototype.mergeSymLabels = function mergeSymLabels() {
			for (var it = this.iterator(); it.hasNext();) {
				var de = it.next();
				var label = de.getLabel();
				label.merge(de.getSym().getLabel());
			}
		};
		DirectedEdgeStar.prototype.linkMinimalDirectedEdges = function linkMinimalDirectedEdges(er) {
			var this$1$1 = this;

			var firstOut = null;
			var incoming = null;
			var state = this._SCANNING_FOR_INCOMING;
			for (var i = this._resultAreaEdgeList.size() - 1; i >= 0; i--) {
				var nextOut = this$1$1._resultAreaEdgeList.get(i);
				var nextIn = nextOut.getSym();
				if (firstOut === null && nextOut.getEdgeRing() === er) { firstOut = nextOut; }
				switch (state) {
					case this$1$1._SCANNING_FOR_INCOMING:
						if (nextIn.getEdgeRing() !== er) { continue }
						incoming = nextIn;
						state = this$1$1._LINKING_TO_OUTGOING;
						break
					case this$1$1._LINKING_TO_OUTGOING:
						if (nextOut.getEdgeRing() !== er) { continue }
						incoming.setNextMin(nextOut);
						state = this$1$1._SCANNING_FOR_INCOMING;
						break
				}
			}
			if (state === this._LINKING_TO_OUTGOING) {
				Assert.isTrue(firstOut !== null, 'found null for first outgoing dirEdge');
				Assert.isTrue(firstOut.getEdgeRing() === er, 'unable to link last incoming dirEdge');
				incoming.setNextMin(firstOut);
			}
		};
		DirectedEdgeStar.prototype.getOutgoingDegree = function getOutgoingDegree() {
			if (arguments.length === 0) {
				var degree = 0;
				for (var it = this.iterator(); it.hasNext();) {
					var de = it.next();
					if (de.isInResult()) { degree++; }
				}
				return degree
			} else if (arguments.length === 1) {
				var er = arguments[0];
				var degree$1 = 0;
				for (var it$1 = this.iterator(); it$1.hasNext();) {
					var de$1 = it$1.next();
					if (de$1.getEdgeRing() === er) { degree$1++; }
				}
				return degree$1
			}
		};
		DirectedEdgeStar.prototype.getLabel = function getLabel() {
			return this._label
		};
		DirectedEdgeStar.prototype.findCoveredLineEdges = function findCoveredLineEdges() {
			var startLoc = Location.NONE;
			for (var it = this.iterator(); it.hasNext();) {
				var nextOut = it.next();
				var nextIn = nextOut.getSym();
				if (!nextOut.isLineEdge()) {
					if (nextOut.isInResult()) {
						startLoc = Location.INTERIOR;
						break
					}
					if (nextIn.isInResult()) {
						startLoc = Location.EXTERIOR;
						break
					}
				}
			}
			if (startLoc === Location.NONE) { return null }
			var currLoc = startLoc;
			for (var it$1 = this.iterator(); it$1.hasNext();) {
				var nextOut$1 = it$1.next();
				var nextIn$1 = nextOut$1.getSym();
				if (nextOut$1.isLineEdge()) {
					nextOut$1.getEdge().setCovered(currLoc === Location.INTERIOR);
				} else {
					if (nextOut$1.isInResult()) { currLoc = Location.EXTERIOR; }
					if (nextIn$1.isInResult()) { currLoc = Location.INTERIOR; }
				}
			}
		};
		DirectedEdgeStar.prototype.computeLabelling = function computeLabelling(geom) {
			var this$1$1 = this;

			EdgeEndStar$$1.prototype.computeLabelling.call(this, geom);
			this._label = new Label(Location.NONE);
			for (var it = this.iterator(); it.hasNext();) {
				var ee = it.next();
				var e = ee.getEdge();
				var eLabel = e.getLabel();
				for (var i = 0; i < 2; i++) {
					var eLoc = eLabel.getLocation(i);
					if (eLoc === Location.INTERIOR || eLoc === Location.BOUNDARY) { this$1$1._label.setLocation(i, Location.INTERIOR); }
				}
			}
		};
		DirectedEdgeStar.prototype.interfaces_ = function interfaces_() {
			return []
		};
		DirectedEdgeStar.prototype.getClass = function getClass() {
			return DirectedEdgeStar
		};

		return DirectedEdgeStar;
	}(EdgeEndStar));

	var OverlayNodeFactory = (function (NodeFactory$$1) {
		function OverlayNodeFactory() {
			NodeFactory$$1.apply(this, arguments);
		}

		if (NodeFactory$$1) OverlayNodeFactory.__proto__ = NodeFactory$$1;
		OverlayNodeFactory.prototype = Object.create(NodeFactory$$1 && NodeFactory$$1.prototype);
		OverlayNodeFactory.prototype.constructor = OverlayNodeFactory;

		OverlayNodeFactory.prototype.createNode = function createNode(coord) {
			return new Node(coord, new DirectedEdgeStar())
		};
		OverlayNodeFactory.prototype.interfaces_ = function interfaces_() {
			return []
		};
		OverlayNodeFactory.prototype.getClass = function getClass() {
			return OverlayNodeFactory
		};

		return OverlayNodeFactory;
	}(NodeFactory));

	var OrientedCoordinateArray = function OrientedCoordinateArray() {
		this._pts = null;
		this._orientation = null;
		var pts = arguments[0];
		this._pts = pts;
		this._orientation = OrientedCoordinateArray.orientation(pts);
	};
	OrientedCoordinateArray.prototype.compareTo = function compareTo(o1) {
		var oca = o1;
		var comp = OrientedCoordinateArray.compareOriented(this._pts, this._orientation, oca._pts, oca._orientation);
		return comp
	};
	OrientedCoordinateArray.prototype.interfaces_ = function interfaces_() {
		return [Comparable]
	};
	OrientedCoordinateArray.prototype.getClass = function getClass() {
		return OrientedCoordinateArray
	};
	OrientedCoordinateArray.orientation = function orientation(pts) {
		return CoordinateArrays.increasingDirection(pts) === 1
	};
	OrientedCoordinateArray.compareOriented = function compareOriented(pts1, orientation1, pts2, orientation2) {
		var dir1 = orientation1 ? 1 : -1;
		var dir2 = orientation2 ? 1 : -1;
		var limit1 = orientation1 ? pts1.length : -1;
		var limit2 = orientation2 ? pts2.length : -1;
		var i1 = orientation1 ? 0 : pts1.length - 1;
		var i2 = orientation2 ? 0 : pts2.length - 1;
		// const comp = 0
		while (true) {
			var compPt = pts1[i1].compareTo(pts2[i2]);
			if (compPt !== 0) { return compPt }
			i1 += dir1;
			i2 += dir2;
			var done1 = i1 === limit1;
			var done2 = i2 === limit2;
			if (done1 && !done2) { return -1 }
			if (!done1 && done2) { return 1 }
			if (done1 && done2) { return 0 }
		}
	};

	var EdgeList = function EdgeList() {
		this._edges = new ArrayList();
		this._ocaMap = new TreeMap();
	};
	EdgeList.prototype.print = function print(out) {
		var this$1$1 = this;

		out.print('MULTILINESTRING ( ');
		for (var j = 0; j < this._edges.size(); j++) {
			var e = this$1$1._edges.get(j);
			if (j > 0) { out.print(','); }
			out.print('(');
			var pts = e.getCoordinates();
			for (var i = 0; i < pts.length; i++) {
				if (i > 0) { out.print(','); }
				out.print(pts[i].x + ' ' + pts[i].y);
			}
			out.println(')');
		}
		out.print(')  ');
	};
	EdgeList.prototype.addAll = function addAll(edgeColl) {
		var this$1$1 = this;

		for (var i = edgeColl.iterator(); i.hasNext();) {
			this$1$1.add(i.next());
		}
	};
	EdgeList.prototype.findEdgeIndex = function findEdgeIndex(e) {
		var this$1$1 = this;

		for (var i = 0; i < this._edges.size(); i++) {
			if (this$1$1._edges.get(i).equals(e)) { return i }
		}
		return -1
	};
	EdgeList.prototype.iterator = function iterator() {
		return this._edges.iterator()
	};
	EdgeList.prototype.getEdges = function getEdges() {
		return this._edges
	};
	EdgeList.prototype.get = function get(i) {
		return this._edges.get(i)
	};
	EdgeList.prototype.findEqualEdge = function findEqualEdge(e) {
		var oca = new OrientedCoordinateArray(e.getCoordinates());
		var matchEdge = this._ocaMap.get(oca);
		return matchEdge
	};
	EdgeList.prototype.add = function add(e) {
		this._edges.add(e);
		var oca = new OrientedCoordinateArray(e.getCoordinates());
		this._ocaMap.put(oca, e);
	};
	EdgeList.prototype.interfaces_ = function interfaces_() {
		return []
	};
	EdgeList.prototype.getClass = function getClass() {
		return EdgeList
	};

	var SegmentIntersector = function SegmentIntersector() { };

	SegmentIntersector.prototype.processIntersections = function processIntersections(e0, segIndex0, e1, segIndex1) { };
	SegmentIntersector.prototype.isDone = function isDone() { };
	SegmentIntersector.prototype.interfaces_ = function interfaces_() {
		return []
	};
	SegmentIntersector.prototype.getClass = function getClass() {
		return SegmentIntersector
	};

	var IntersectionAdder = function IntersectionAdder() {
		this._hasIntersection = false;
		this._hasProper = false;
		this._hasProperInterior = false;
		this._hasInterior = false;
		this._properIntersectionPoint = null;
		this._li = null;
		this._isSelfIntersection = null;
		this.numIntersections = 0;
		this.numInteriorIntersections = 0;
		this.numProperIntersections = 0;
		this.numTests = 0;
		var li = arguments[0];
		this._li = li;
	};
	IntersectionAdder.prototype.isTrivialIntersection = function isTrivialIntersection(e0, segIndex0, e1, segIndex1) {
		if (e0 === e1) {
			if (this._li.getIntersectionNum() === 1) {
				if (IntersectionAdder.isAdjacentSegments(segIndex0, segIndex1)) { return true }
				if (e0.isClosed()) {
					var maxSegIndex = e0.size() - 1;
					if ((segIndex0 === 0 && segIndex1 === maxSegIndex) ||
						(segIndex1 === 0 && segIndex0 === maxSegIndex)) {
						return true
					}
				}
			}
		}
		return false
	};
	IntersectionAdder.prototype.getProperIntersectionPoint = function getProperIntersectionPoint() {
		return this._properIntersectionPoint
	};
	IntersectionAdder.prototype.hasProperInteriorIntersection = function hasProperInteriorIntersection() {
		return this._hasProperInterior
	};
	IntersectionAdder.prototype.getLineIntersector = function getLineIntersector() {
		return this._li
	};
	IntersectionAdder.prototype.hasProperIntersection = function hasProperIntersection() {
		return this._hasProper
	};
	IntersectionAdder.prototype.processIntersections = function processIntersections(e0, segIndex0, e1, segIndex1) {
		if (e0 === e1 && segIndex0 === segIndex1) { return null }
		this.numTests++;
		var p00 = e0.getCoordinates()[segIndex0];
		var p01 = e0.getCoordinates()[segIndex0 + 1];
		var p10 = e1.getCoordinates()[segIndex1];
		var p11 = e1.getCoordinates()[segIndex1 + 1];
		this._li.computeIntersection(p00, p01, p10, p11);
		if (this._li.hasIntersection()) {
			this.numIntersections++;
			if (this._li.isInteriorIntersection()) {
				this.numInteriorIntersections++;
				this._hasInterior = true;
			}
			if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {
				this._hasIntersection = true;
				e0.addIntersections(this._li, segIndex0, 0);
				e1.addIntersections(this._li, segIndex1, 1);
				if (this._li.isProper()) {
					this.numProperIntersections++;
					this._hasProper = true;
					this._hasProperInterior = true;
				}
			}
		}
	};
	IntersectionAdder.prototype.hasIntersection = function hasIntersection() {
		return this._hasIntersection
	};
	IntersectionAdder.prototype.isDone = function isDone() {
		return false
	};
	IntersectionAdder.prototype.hasInteriorIntersection = function hasInteriorIntersection() {
		return this._hasInterior
	};
	IntersectionAdder.prototype.interfaces_ = function interfaces_() {
		return [SegmentIntersector]
	};
	IntersectionAdder.prototype.getClass = function getClass() {
		return IntersectionAdder
	};
	IntersectionAdder.isAdjacentSegments = function isAdjacentSegments(i1, i2) {
		return Math.abs(i1 - i2) === 1
	};

	var EdgeIntersection = function EdgeIntersection() {
		this.coord = null;
		this.segmentIndex = null;
		this.dist = null;
		var coord = arguments[0];
		var segmentIndex = arguments[1];
		var dist = arguments[2];
		this.coord = new Coordinate(coord);
		this.segmentIndex = segmentIndex;
		this.dist = dist;
	};
	EdgeIntersection.prototype.getSegmentIndex = function getSegmentIndex() {
		return this.segmentIndex
	};
	EdgeIntersection.prototype.getCoordinate = function getCoordinate() {
		return this.coord
	};
	EdgeIntersection.prototype.print = function print(out) {
		out.print(this.coord);
		out.print(' seg # = ' + this.segmentIndex);
		out.println(' dist = ' + this.dist);
	};
	EdgeIntersection.prototype.compareTo = function compareTo(obj) {
		var other = obj;
		return this.compare(other.segmentIndex, other.dist)
	};
	EdgeIntersection.prototype.isEndPoint = function isEndPoint(maxSegmentIndex) {
		if (this.segmentIndex === 0 && this.dist === 0.0) { return true }
		if (this.segmentIndex === maxSegmentIndex) { return true }
		return false
	};
	EdgeIntersection.prototype.toString = function toString() {
		return this.coord + ' seg # = ' + this.segmentIndex + ' dist = ' + this.dist
	};
	EdgeIntersection.prototype.getDistance = function getDistance() {
		return this.dist
	};
	EdgeIntersection.prototype.compare = function compare(segmentIndex, dist) {
		if (this.segmentIndex < segmentIndex) { return -1 }
		if (this.segmentIndex > segmentIndex) { return 1 }
		if (this.dist < dist) { return -1 }
		if (this.dist > dist) { return 1 }
		return 0
	};
	EdgeIntersection.prototype.interfaces_ = function interfaces_() {
		return [Comparable]
	};
	EdgeIntersection.prototype.getClass = function getClass() {
		return EdgeIntersection
	};

	var EdgeIntersectionList = function EdgeIntersectionList() {
		this._nodeMap = new TreeMap();
		this.edge = null;
		var edge = arguments[0];
		this.edge = edge;
	};
	EdgeIntersectionList.prototype.print = function print(out) {
		out.println('Intersections:');
		for (var it = this.iterator(); it.hasNext();) {
			var ei = it.next();
			ei.print(out);
		}
	};
	EdgeIntersectionList.prototype.iterator = function iterator() {
		return this._nodeMap.values().iterator()
	};
	EdgeIntersectionList.prototype.addSplitEdges = function addSplitEdges(edgeList) {
		var this$1$1 = this;

		this.addEndpoints();
		var it = this.iterator();
		var eiPrev = it.next();
		while (it.hasNext()) {
			var ei = it.next();
			var newEdge = this$1$1.createSplitEdge(eiPrev, ei);
			edgeList.add(newEdge);
			eiPrev = ei;
		}
	};
	EdgeIntersectionList.prototype.addEndpoints = function addEndpoints() {
		var maxSegIndex = this.edge.pts.length - 1;
		this.add(this.edge.pts[0], 0, 0.0);
		this.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0);
	};
	EdgeIntersectionList.prototype.createSplitEdge = function createSplitEdge(ei0, ei1) {
		var this$1$1 = this;

		var npts = ei1.segmentIndex - ei0.segmentIndex + 2;
		var lastSegStartPt = this.edge.pts[ei1.segmentIndex];
		var useIntPt1 = ei1.dist > 0.0 || !ei1.coord.equals2D(lastSegStartPt);
		if (!useIntPt1) {
			npts--;
		}
		var pts = new Array(npts).fill(null);
		var ipt = 0;
		pts[ipt++] = new Coordinate(ei0.coord);
		for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
			pts[ipt++] = this$1$1.edge.pts[i];
		}
		if (useIntPt1) { pts[ipt] = ei1.coord; }
		return new Edge(pts, new Label(this.edge._label))
	};
	EdgeIntersectionList.prototype.add = function add(intPt, segmentIndex, dist) {
		var eiNew = new EdgeIntersection(intPt, segmentIndex, dist);
		var ei = this._nodeMap.get(eiNew);
		if (ei !== null) {
			return ei
		}
		this._nodeMap.put(eiNew, eiNew);
		return eiNew
	};
	EdgeIntersectionList.prototype.isIntersection = function isIntersection(pt) {
		for (var it = this.iterator(); it.hasNext();) {
			var ei = it.next();
			if (ei.coord.equals(pt)) { return true }
		}
		return false
	};
	EdgeIntersectionList.prototype.interfaces_ = function interfaces_() {
		return []
	};
	EdgeIntersectionList.prototype.getClass = function getClass() {
		return EdgeIntersectionList
	};

	var MonotoneChainIndexer = function MonotoneChainIndexer() { };

	MonotoneChainIndexer.prototype.getChainStartIndices = function getChainStartIndices(pts) {
		var this$1$1 = this;

		var start = 0;
		var startIndexList = new ArrayList();
		startIndexList.add(new Integer(start));
		do {
			var last = this$1$1.findChainEnd(pts, start);
			startIndexList.add(new Integer(last));
			start = last;
		} while (start < pts.length - 1)
		var startIndex = MonotoneChainIndexer.toIntArray(startIndexList);
		return startIndex
	};
	MonotoneChainIndexer.prototype.findChainEnd = function findChainEnd(pts, start) {
		var chainQuad = Quadrant.quadrant(pts[start], pts[start + 1]);
		var last = start + 1;
		while (last < pts.length) {
			var quad = Quadrant.quadrant(pts[last - 1], pts[last]);
			if (quad !== chainQuad) { break }
			last++;
		}
		return last - 1
	};
	MonotoneChainIndexer.prototype.interfaces_ = function interfaces_() {
		return []
	};
	MonotoneChainIndexer.prototype.getClass = function getClass() {
		return MonotoneChainIndexer
	};
	MonotoneChainIndexer.toIntArray = function toIntArray(list) {
		var array = new Array(list.size()).fill(null);
		for (var i = 0; i < array.length; i++) {
			array[i] = list.get(i).intValue();
		}
		return array
	};

	var MonotoneChainEdge = function MonotoneChainEdge() {
		this.e = null;
		this.pts = null;
		this.startIndex = null;
		this.env1 = new Envelope();
		this.env2 = new Envelope();
		var e = arguments[0];
		this.e = e;
		this.pts = e.getCoordinates();
		var mcb = new MonotoneChainIndexer();
		this.startIndex = mcb.getChainStartIndices(this.pts);
	};
	MonotoneChainEdge.prototype.getCoordinates = function getCoordinates() {
		return this.pts
	};
	MonotoneChainEdge.prototype.getMaxX = function getMaxX(chainIndex) {
		var x1 = this.pts[this.startIndex[chainIndex]].x;
		var x2 = this.pts[this.startIndex[chainIndex + 1]].x;
		return x1 > x2 ? x1 : x2
	};
	MonotoneChainEdge.prototype.getMinX = function getMinX(chainIndex) {
		var x1 = this.pts[this.startIndex[chainIndex]].x;
		var x2 = this.pts[this.startIndex[chainIndex + 1]].x;
		return x1 < x2 ? x1 : x2
	};
	MonotoneChainEdge.prototype.computeIntersectsForChain = function computeIntersectsForChain() {
		if (arguments.length === 4) {
			var chainIndex0 = arguments[0];
			var mce = arguments[1];
			var chainIndex1 = arguments[2];
			var si = arguments[3];
			this.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);
		} else if (arguments.length === 6) {
			var start0 = arguments[0];
			var end0 = arguments[1];
			var mce$1 = arguments[2];
			var start1 = arguments[3];
			var end1 = arguments[4];
			var ei = arguments[5];
			var p00 = this.pts[start0];
			var p01 = this.pts[end0];
			var p10 = mce$1.pts[start1];
			var p11 = mce$1.pts[end1];
			if (end0 - start0 === 1 && end1 - start1 === 1) {
				ei.addIntersections(this.e, start0, mce$1.e, start1);
				return null
			}
			this.env1.init(p00, p01);
			this.env2.init(p10, p11);
			if (!this.env1.intersects(this.env2)) { return null }
			var mid0 = Math.trunc((start0 + end0) / 2);
			var mid1 = Math.trunc((start1 + end1) / 2);
			if (start0 < mid0) {
				if (start1 < mid1) { this.computeIntersectsForChain(start0, mid0, mce$1, start1, mid1, ei); }
				if (mid1 < end1) { this.computeIntersectsForChain(start0, mid0, mce$1, mid1, end1, ei); }
			}
			if (mid0 < end0) {
				if (start1 < mid1) { this.computeIntersectsForChain(mid0, end0, mce$1, start1, mid1, ei); }
				if (mid1 < end1) { this.computeIntersectsForChain(mid0, end0, mce$1, mid1, end1, ei); }
			}
		}
	};
	MonotoneChainEdge.prototype.getStartIndexes = function getStartIndexes() {
		return this.startIndex
	};
	MonotoneChainEdge.prototype.computeIntersects = function computeIntersects(mce, si) {
		var this$1$1 = this;

		for (var i = 0; i < this.startIndex.length - 1; i++) {
			for (var j = 0; j < mce.startIndex.length - 1; j++) {
				this$1$1.computeIntersectsForChain(i, mce, j, si);
			}
		}
	};
	MonotoneChainEdge.prototype.interfaces_ = function interfaces_() {
		return []
	};
	MonotoneChainEdge.prototype.getClass = function getClass() {
		return MonotoneChainEdge
	};

	var Depth = function Depth() {
		var this$1$1 = this;

		this._depth = Array(2).fill().map(function () { return Array(3); });
		for (var i = 0; i < 2; i++) {
			for (var j = 0; j < 3; j++) {
				this$1$1._depth[i][j] = Depth.NULL_VALUE;
			}
		}
	};

	var staticAccessors$31 = { NULL_VALUE: { configurable: true } };
	Depth.prototype.getDepth = function getDepth(geomIndex, posIndex) {
		return this._depth[geomIndex][posIndex]
	};
	Depth.prototype.setDepth = function setDepth(geomIndex, posIndex, depthValue) {
		this._depth[geomIndex][posIndex] = depthValue;
	};
	Depth.prototype.isNull = function isNull() {
		var this$1$1 = this;

		if (arguments.length === 0) {
			for (var i = 0; i < 2; i++) {
				for (var j = 0; j < 3; j++) {
					if (this$1$1._depth[i][j] !== Depth.NULL_VALUE) { return false }
				}
			}
			return true
		} else if (arguments.length === 1) {
			var geomIndex = arguments[0];
			return this._depth[geomIndex][1] === Depth.NULL_VALUE
		} else if (arguments.length === 2) {
			var geomIndex$1 = arguments[0];
			var posIndex = arguments[1];
			return this._depth[geomIndex$1][posIndex] === Depth.NULL_VALUE
		}
	};
	Depth.prototype.normalize = function normalize() {
		var this$1$1 = this;

		for (var i = 0; i < 2; i++) {
			if (!this$1$1.isNull(i)) {
				var minDepth = this$1$1._depth[i][1];
				if (this$1$1._depth[i][2] < minDepth) { minDepth = this$1$1._depth[i][2]; }
				if (minDepth < 0) { minDepth = 0; }
				for (var j = 1; j < 3; j++) {
					var newValue = 0;
					if (this$1$1._depth[i][j] > minDepth) { newValue = 1; }
					this$1$1._depth[i][j] = newValue;
				}
			}
		}
	};
	Depth.prototype.getDelta = function getDelta(geomIndex) {
		return this._depth[geomIndex][Position.RIGHT] - this._depth[geomIndex][Position.LEFT]
	};
	Depth.prototype.getLocation = function getLocation(geomIndex, posIndex) {
		if (this._depth[geomIndex][posIndex] <= 0) { return Location.EXTERIOR }
		return Location.INTERIOR
	};
	Depth.prototype.toString = function toString() {
		return 'A: ' + this._depth[0][1] + ',' + this._depth[0][2] + ' B: ' + this._depth[1][1] + ',' + this._depth[1][2]
	};
	Depth.prototype.add = function add() {
		var this$1$1 = this;

		if (arguments.length === 1) {
			var lbl = arguments[0];
			for (var i = 0; i < 2; i++) {
				for (var j = 1; j < 3; j++) {
					var loc = lbl.getLocation(i, j);
					if (loc === Location.EXTERIOR || loc === Location.INTERIOR) {
						if (this$1$1.isNull(i, j)) {
							this$1$1._depth[i][j] = Depth.depthAtLocation(loc);
						} else { this$1$1._depth[i][j] += Depth.depthAtLocation(loc); }
					}
				}
			}
		} else if (arguments.length === 3) {
			var geomIndex = arguments[0];
			var posIndex = arguments[1];
			var location = arguments[2];
			if (location === Location.INTERIOR) { this._depth[geomIndex][posIndex]++; }
		}
	};
	Depth.prototype.interfaces_ = function interfaces_() {
		return []
	};
	Depth.prototype.getClass = function getClass() {
		return Depth
	};
	Depth.depthAtLocation = function depthAtLocation(location) {
		if (location === Location.EXTERIOR) { return 0 }
		if (location === Location.INTERIOR) { return 1 }
		return Depth.NULL_VALUE
	};
	staticAccessors$31.NULL_VALUE.get = function () { return -1 };

	Object.defineProperties(Depth, staticAccessors$31);

	var Edge = (function (GraphComponent$$1) {
		function Edge() {
			GraphComponent$$1.call(this);
			this.pts = null;
			this._env = null;
			this.eiList = new EdgeIntersectionList(this);
			this._name = null;
			this._mce = null;
			this._isIsolated = true;
			this._depth = new Depth();
			this._depthDelta = 0;
			if (arguments.length === 1) {
				var pts = arguments[0];
				Edge.call(this, pts, null);
			} else if (arguments.length === 2) {
				var pts$1 = arguments[0];
				var label = arguments[1];
				this.pts = pts$1;
				this._label = label;
			}
		}

		if (GraphComponent$$1) Edge.__proto__ = GraphComponent$$1;
		Edge.prototype = Object.create(GraphComponent$$1 && GraphComponent$$1.prototype);
		Edge.prototype.constructor = Edge;
		Edge.prototype.getDepth = function getDepth() {
			return this._depth
		};
		Edge.prototype.getCollapsedEdge = function getCollapsedEdge() {
			var newPts = new Array(2).fill(null);
			newPts[0] = this.pts[0];
			newPts[1] = this.pts[1];
			var newe = new Edge(newPts, Label.toLineLabel(this._label));
			return newe
		};
		Edge.prototype.isIsolated = function isIsolated() {
			return this._isIsolated
		};
		Edge.prototype.getCoordinates = function getCoordinates() {
			return this.pts
		};
		Edge.prototype.setIsolated = function setIsolated(isIsolated) {
			this._isIsolated = isIsolated;
		};
		Edge.prototype.setName = function setName(name) {
			this._name = name;
		};
		Edge.prototype.equals = function equals(o) {
			var this$1$1 = this;

			if (!(o instanceof Edge)) { return false }
			var e = o;
			if (this.pts.length !== e.pts.length) { return false }
			var isEqualForward = true;
			var isEqualReverse = true;
			var iRev = this.pts.length;
			for (var i = 0; i < this.pts.length; i++) {
				if (!this$1$1.pts[i].equals2D(e.pts[i])) {
					isEqualForward = false;
				}
				if (!this$1$1.pts[i].equals2D(e.pts[--iRev])) {
					isEqualReverse = false;
				}
				if (!isEqualForward && !isEqualReverse) { return false }
			}
			return true
		};
		Edge.prototype.getCoordinate = function getCoordinate() {
			if (arguments.length === 0) {
				if (this.pts.length > 0) { return this.pts[0] }
				return null
			} else if (arguments.length === 1) {
				var i = arguments[0];
				return this.pts[i]
			}
		};
		Edge.prototype.print = function print(out) {
			var this$1$1 = this;

			out.print('edge ' + this._name + ': ');
			out.print('LINESTRING (');
			for (var i = 0; i < this.pts.length; i++) {
				if (i > 0) { out.print(','); }
				out.print(this$1$1.pts[i].x + ' ' + this$1$1.pts[i].y);
			}
			out.print(')  ' + this._label + ' ' + this._depthDelta);
		};
		Edge.prototype.computeIM = function computeIM(im) {
			Edge.updateIM(this._label, im);
		};
		Edge.prototype.isCollapsed = function isCollapsed() {
			if (!this._label.isArea()) { return false }
			if (this.pts.length !== 3) { return false }
			if (this.pts[0].equals(this.pts[2])) { return true }
			return false
		};
		Edge.prototype.isClosed = function isClosed() {
			return this.pts[0].equals(this.pts[this.pts.length - 1])
		};
		Edge.prototype.getMaximumSegmentIndex = function getMaximumSegmentIndex() {
			return this.pts.length - 1
		};
		Edge.prototype.getDepthDelta = function getDepthDelta() {
			return this._depthDelta
		};
		Edge.prototype.getNumPoints = function getNumPoints() {
			return this.pts.length
		};
		Edge.prototype.printReverse = function printReverse(out) {
			var this$1$1 = this;

			out.print('edge ' + this._name + ': ');
			for (var i = this.pts.length - 1; i >= 0; i--) {
				out.print(this$1$1.pts[i] + ' ');
			}
			out.println('');
		};
		Edge.prototype.getMonotoneChainEdge = function getMonotoneChainEdge() {
			if (this._mce === null) { this._mce = new MonotoneChainEdge(this); }
			return this._mce
		};
		Edge.prototype.getEnvelope = function getEnvelope() {
			var this$1$1 = this;

			if (this._env === null) {
				this._env = new Envelope();
				for (var i = 0; i < this.pts.length; i++) {
					this$1$1._env.expandToInclude(this$1$1.pts[i]);
				}
			}
			return this._env
		};
		Edge.prototype.addIntersection = function addIntersection(li, segmentIndex, geomIndex, intIndex) {
			var intPt = new Coordinate(li.getIntersection(intIndex));
			var normalizedSegmentIndex = segmentIndex;
			var dist = li.getEdgeDistance(geomIndex, intIndex);
			var nextSegIndex = normalizedSegmentIndex + 1;
			if (nextSegIndex < this.pts.length) {
				var nextPt = this.pts[nextSegIndex];
				if (intPt.equals2D(nextPt)) {
					normalizedSegmentIndex = nextSegIndex;
					dist = 0.0;
				}
			}
			this.eiList.add(intPt, normalizedSegmentIndex, dist);
		};
		Edge.prototype.toString = function toString() {
			var this$1$1 = this;

			var buf = new StringBuffer();
			buf.append('edge ' + this._name + ': ');
			buf.append('LINESTRING (');
			for (var i = 0; i < this.pts.length; i++) {
				if (i > 0) { buf.append(','); }
				buf.append(this$1$1.pts[i].x + ' ' + this$1$1.pts[i].y);
			}
			buf.append(')  ' + this._label + ' ' + this._depthDelta);
			return buf.toString()
		};
		Edge.prototype.isPointwiseEqual = function isPointwiseEqual(e) {
			var this$1$1 = this;

			if (this.pts.length !== e.pts.length) { return false }
			for (var i = 0; i < this.pts.length; i++) {
				if (!this$1$1.pts[i].equals2D(e.pts[i])) {
					return false
				}
			}
			return true
		};
		Edge.prototype.setDepthDelta = function setDepthDelta(depthDelta) {
			this._depthDelta = depthDelta;
		};
		Edge.prototype.getEdgeIntersectionList = function getEdgeIntersectionList() {
			return this.eiList
		};
		Edge.prototype.addIntersections = function addIntersections(li, segmentIndex, geomIndex) {
			var this$1$1 = this;

			for (var i = 0; i < li.getIntersectionNum(); i++) {
				this$1$1.addIntersection(li, segmentIndex, geomIndex, i);
			}
		};
		Edge.prototype.interfaces_ = function interfaces_() {
			return []
		};
		Edge.prototype.getClass = function getClass() {
			return Edge
		};
		Edge.updateIM = function updateIM() {
			if (arguments.length === 2) {
				var label = arguments[0];
				var im = arguments[1];
				im.setAtLeastIfValid(label.getLocation(0, Position.ON), label.getLocation(1, Position.ON), 1);
				if (label.isArea()) {
					im.setAtLeastIfValid(label.getLocation(0, Position.LEFT), label.getLocation(1, Position.LEFT), 2);
					im.setAtLeastIfValid(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), 2);
				}
			} else { return GraphComponent$$1.prototype.updateIM.apply(this, arguments) }
		};

		return Edge;
	}(GraphComponent));

	var BufferBuilder = function BufferBuilder(bufParams) {
		this._workingPrecisionModel = null;
		this._workingNoder = null;
		this._geomFact = null;
		this._graph = null;
		this._edgeList = new EdgeList();
		this._bufParams = bufParams || null;
	};
	BufferBuilder.prototype.setWorkingPrecisionModel = function setWorkingPrecisionModel(pm) {
		this._workingPrecisionModel = pm;
	};
	BufferBuilder.prototype.insertUniqueEdge = function insertUniqueEdge(e) {
		var existingEdge = this._edgeList.findEqualEdge(e);
		if (existingEdge !== null) {
			var existingLabel = existingEdge.getLabel();
			var labelToMerge = e.getLabel();
			if (!existingEdge.isPointwiseEqual(e)) {
				labelToMerge = new Label(e.getLabel());
				labelToMerge.flip();
			}
			existingLabel.merge(labelToMerge);
			var mergeDelta = BufferBuilder.depthDelta(labelToMerge);
			var existingDelta = existingEdge.getDepthDelta();
			var newDelta = existingDelta + mergeDelta;
			existingEdge.setDepthDelta(newDelta);
		} else {
			this._edgeList.add(e);
			e.setDepthDelta(BufferBuilder.depthDelta(e.getLabel()));
		}
	};
	BufferBuilder.prototype.buildSubgraphs = function buildSubgraphs(subgraphList, polyBuilder) {
		var processedGraphs = new ArrayList();
		for (var i = subgraphList.iterator(); i.hasNext();) {
			var subgraph = i.next();
			var p = subgraph.getRightmostCoordinate();
			var locater = new SubgraphDepthLocater(processedGraphs);
			var outsideDepth = locater.getDepth(p);
			subgraph.computeDepth(outsideDepth);
			subgraph.findResultEdges();
			processedGraphs.add(subgraph);
			polyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes());
		}
	};
	BufferBuilder.prototype.createSubgraphs = function createSubgraphs(graph) {
		var subgraphList = new ArrayList();
		for (var i = graph.getNodes().iterator(); i.hasNext();) {
			var node = i.next();
			if (!node.isVisited()) {
				var subgraph = new BufferSubgraph();
				subgraph.create(node);
				subgraphList.add(subgraph);
			}
		}
		Collections.sort(subgraphList, Collections.reverseOrder());
		return subgraphList
	};
	BufferBuilder.prototype.createEmptyResultGeometry = function createEmptyResultGeometry() {
		var emptyGeom = this._geomFact.createPolygon();
		return emptyGeom
	};
	BufferBuilder.prototype.getNoder = function getNoder(precisionModel) {
		if (this._workingNoder !== null) { return this._workingNoder }
		var noder = new MCIndexNoder();
		var li = new RobustLineIntersector();
		li.setPrecisionModel(precisionModel);
		noder.setSegmentIntersector(new IntersectionAdder(li));
		return noder
	};
	BufferBuilder.prototype.buffer = function buffer(g, distance) {
		var precisionModel = this._workingPrecisionModel;
		if (precisionModel === null) { precisionModel = g.getPrecisionModel(); }
		this._geomFact = g.getFactory();
		var curveBuilder = new OffsetCurveBuilder(precisionModel, this._bufParams);
		var curveSetBuilder = new OffsetCurveSetBuilder(g, distance, curveBuilder);
		var bufferSegStrList = curveSetBuilder.getCurves();
		if (bufferSegStrList.size() <= 0) {
			return this.createEmptyResultGeometry()
		}
		this.computeNodedEdges(bufferSegStrList, precisionModel);
		this._graph = new PlanarGraph(new OverlayNodeFactory());
		this._graph.addEdges(this._edgeList.getEdges());
		var subgraphList = this.createSubgraphs(this._graph);
		var polyBuilder = new PolygonBuilder(this._geomFact);
		this.buildSubgraphs(subgraphList, polyBuilder);
		var resultPolyList = polyBuilder.getPolygons();
		if (resultPolyList.size() <= 0) {
			return this.createEmptyResultGeometry()
		}
		var resultGeom = this._geomFact.buildGeometry(resultPolyList);
		return resultGeom
	};
	BufferBuilder.prototype.computeNodedEdges = function computeNodedEdges(bufferSegStrList, precisionModel) {
		var this$1$1 = this;

		var noder = this.getNoder(precisionModel);
		noder.computeNodes(bufferSegStrList);
		var nodedSegStrings = noder.getNodedSubstrings();
		for (var i = nodedSegStrings.iterator(); i.hasNext();) {
			var segStr = i.next();
			var pts = segStr.getCoordinates();
			if (pts.length === 2 && pts[0].equals2D(pts[1])) { continue }
			var oldLabel = segStr.getData();
			var edge = new Edge(segStr.getCoordinates(), new Label(oldLabel));
			this$1$1.insertUniqueEdge(edge);
		}
	};
	BufferBuilder.prototype.setNoder = function setNoder(noder) {
		this._workingNoder = noder;
	};
	BufferBuilder.prototype.interfaces_ = function interfaces_() {
		return []
	};
	BufferBuilder.prototype.getClass = function getClass() {
		return BufferBuilder
	};
	BufferBuilder.depthDelta = function depthDelta(label) {
		var lLoc = label.getLocation(0, Position.LEFT);
		var rLoc = label.getLocation(0, Position.RIGHT);
		if (lLoc === Location.INTERIOR && rLoc === Location.EXTERIOR) { return 1; } else if (lLoc === Location.EXTERIOR && rLoc === Location.INTERIOR) { return -1 }
		return 0
	};
	BufferBuilder.convertSegStrings = function convertSegStrings(it) {
		var fact = new GeometryFactory();
		var lines = new ArrayList();
		while (it.hasNext()) {
			var ss = it.next();
			var line = fact.createLineString(ss.getCoordinates());
			lines.add(line);
		}
		return fact.buildGeometry(lines)
	};

	var ScaledNoder = function ScaledNoder() {
		this._noder = null;
		this._scaleFactor = null;
		this._offsetX = null;
		this._offsetY = null;
		this._isScaled = false;
		if (arguments.length === 2) {
			var noder = arguments[0];
			var scaleFactor = arguments[1];
			this._noder = noder;
			this._scaleFactor = scaleFactor;
			this._offsetX = 0.0;
			this._offsetY = 0.0;
			this._isScaled = !this.isIntegerPrecision();
		} else if (arguments.length === 4) {
			var noder$1 = arguments[0];
			var scaleFactor$1 = arguments[1];
			var offsetX = arguments[2];
			var offsetY = arguments[3];
			this._noder = noder$1;
			this._scaleFactor = scaleFactor$1;
			this._offsetX = offsetX;
			this._offsetY = offsetY;
			this._isScaled = !this.isIntegerPrecision();
		}
	};
	ScaledNoder.prototype.rescale = function rescale() {
		var this$1$1 = this;

		if (hasInterface(arguments[0], Collection)) {
			var segStrings = arguments[0];
			for (var i = segStrings.iterator(); i.hasNext();) {
				var ss = i.next();
				this$1$1.rescale(ss.getCoordinates());
			}
		} else if (arguments[0] instanceof Array) {
			var pts = arguments[0];
			// let p0 = null
			// let p1 = null
			// if (pts.length === 2) {
			// p0 = new Coordinate(pts[0])
			// p1 = new Coordinate(pts[1])
			// }
			for (var i$1 = 0; i$1 < pts.length; i$1++) {
				pts[i$1].x = pts[i$1].x / this$1$1._scaleFactor + this$1$1._offsetX;
				pts[i$1].y = pts[i$1].y / this$1$1._scaleFactor + this$1$1._offsetY;
			}
			if (pts.length === 2 && pts[0].equals2D(pts[1])) {
				System.out.println(pts);
			}
		}
	};
	ScaledNoder.prototype.scale = function scale() {
		var this$1$1 = this;

		if (hasInterface(arguments[0], Collection)) {
			var segStrings = arguments[0];
			var nodedSegmentStrings = new ArrayList();
			for (var i = segStrings.iterator(); i.hasNext();) {
				var ss = i.next();
				nodedSegmentStrings.add(new NodedSegmentString(this$1$1.scale(ss.getCoordinates()), ss.getData()));
			}
			return nodedSegmentStrings
		} else if (arguments[0] instanceof Array) {
			var pts = arguments[0];
			var roundPts = new Array(pts.length).fill(null);
			for (var i$1 = 0; i$1 < pts.length; i$1++) {
				roundPts[i$1] = new Coordinate(Math.round((pts[i$1].x - this$1$1._offsetX) * this$1$1._scaleFactor), Math.round((pts[i$1].y - this$1$1._offsetY) * this$1$1._scaleFactor), pts[i$1].z);
			}
			var roundPtsNoDup = CoordinateArrays.removeRepeatedPoints(roundPts);
			return roundPtsNoDup
		}
	};
	ScaledNoder.prototype.isIntegerPrecision = function isIntegerPrecision() {
		return this._scaleFactor === 1.0
	};
	ScaledNoder.prototype.getNodedSubstrings = function getNodedSubstrings() {
		var splitSS = this._noder.getNodedSubstrings();
		if (this._isScaled) { this.rescale(splitSS); }
		return splitSS
	};
	ScaledNoder.prototype.computeNodes = function computeNodes(inputSegStrings) {
		var intSegStrings = inputSegStrings;
		if (this._isScaled) { intSegStrings = this.scale(inputSegStrings); }
		this._noder.computeNodes(intSegStrings);
	};
	ScaledNoder.prototype.interfaces_ = function interfaces_() {
		return [Noder]
	};
	ScaledNoder.prototype.getClass = function getClass() {
		return ScaledNoder
	};

	var NodingValidator = function NodingValidator() {
		this._li = new RobustLineIntersector();
		this._segStrings = null;
		var segStrings = arguments[0];
		this._segStrings = segStrings;
	};

	var staticAccessors$33 = { fact: { configurable: true } };
	NodingValidator.prototype.checkEndPtVertexIntersections = function checkEndPtVertexIntersections() {
		var this$1$1 = this;

		if (arguments.length === 0) {
			for (var i = this._segStrings.iterator(); i.hasNext();) {
				var ss = i.next();
				var pts = ss.getCoordinates();
				this$1$1.checkEndPtVertexIntersections(pts[0], this$1$1._segStrings);
				this$1$1.checkEndPtVertexIntersections(pts[pts.length - 1], this$1$1._segStrings);
			}
		} else if (arguments.length === 2) {
			var testPt = arguments[0];
			var segStrings = arguments[1];
			for (var i$1 = segStrings.iterator(); i$1.hasNext();) {
				var ss$1 = i$1.next();
				var pts$1 = ss$1.getCoordinates();
				for (var j = 1; j < pts$1.length - 1; j++) {
					if (pts$1[j].equals(testPt)) { throw new RuntimeException('found endpt/interior pt intersection at index ' + j + ' :pt ' + testPt) }
				}
			}
		}
	};
	NodingValidator.prototype.checkInteriorIntersections = function checkInteriorIntersections() {
		var this$1$1 = this;

		if (arguments.length === 0) {
			for (var i = this._segStrings.iterator(); i.hasNext();) {
				var ss0 = i.next();
				for (var j = this._segStrings.iterator(); j.hasNext();) {
					var ss1 = j.next();
					this$1$1.checkInteriorIntersections(ss0, ss1);
				}
			}
		} else if (arguments.length === 2) {
			var ss0$1 = arguments[0];
			var ss1$1 = arguments[1];
			var pts0 = ss0$1.getCoordinates();
			var pts1 = ss1$1.getCoordinates();
			for (var i0 = 0; i0 < pts0.length - 1; i0++) {
				for (var i1 = 0; i1 < pts1.length - 1; i1++) {
					this$1$1.checkInteriorIntersections(ss0$1, i0, ss1$1, i1);
				}
			}
		} else if (arguments.length === 4) {
			var e0 = arguments[0];
			var segIndex0 = arguments[1];
			var e1 = arguments[2];
			var segIndex1 = arguments[3];
			if (e0 === e1 && segIndex0 === segIndex1) { return null }
			var p00 = e0.getCoordinates()[segIndex0];
			var p01 = e0.getCoordinates()[segIndex0 + 1];
			var p10 = e1.getCoordinates()[segIndex1];
			var p11 = e1.getCoordinates()[segIndex1 + 1];
			this._li.computeIntersection(p00, p01, p10, p11);
			if (this._li.hasIntersection()) {
				if (this._li.isProper() || this.hasInteriorIntersection(this._li, p00, p01) || this.hasInteriorIntersection(this._li, p10, p11)) {
					throw new RuntimeException('found non-noded intersection at ' + p00 + '-' + p01 + ' and ' + p10 + '-' + p11)
				}
			}
		}
	};
	NodingValidator.prototype.checkValid = function checkValid() {
		this.checkEndPtVertexIntersections();
		this.checkInteriorIntersections();
		this.checkCollapses();
	};
	NodingValidator.prototype.checkCollapses = function checkCollapses() {
		var this$1$1 = this;

		if (arguments.length === 0) {
			for (var i = this._segStrings.iterator(); i.hasNext();) {
				var ss = i.next();
				this$1$1.checkCollapses(ss);
			}
		} else if (arguments.length === 1) {
			var ss$1 = arguments[0];
			var pts = ss$1.getCoordinates();
			for (var i$1 = 0; i$1 < pts.length - 2; i$1++) {
				this$1$1.checkCollapse(pts[i$1], pts[i$1 + 1], pts[i$1 + 2]);
			}
		}
	};
	NodingValidator.prototype.hasInteriorIntersection = function hasInteriorIntersection(li, p0, p1) {
		for (var i = 0; i < li.getIntersectionNum(); i++) {
			var intPt = li.getIntersection(i);
			if (!(intPt.equals(p0) || intPt.equals(p1))) { return true }
		}
		return false
	};
	NodingValidator.prototype.checkCollapse = function checkCollapse(p0, p1, p2) {
		if (p0.equals(p2)) { throw new RuntimeException('found non-noded collapse at ' + NodingValidator.fact.createLineString([p0, p1, p2])) }
	};
	NodingValidator.prototype.interfaces_ = function interfaces_() {
		return []
	};
	NodingValidator.prototype.getClass = function getClass() {
		return NodingValidator
	};
	staticAccessors$33.fact.get = function () { return new GeometryFactory() };

	Object.defineProperties(NodingValidator, staticAccessors$33);

	var HotPixel = function HotPixel() {
		this._li = null;
		this._pt = null;
		this._originalPt = null;
		this._ptScaled = null;
		this._p0Scaled = null;
		this._p1Scaled = null;
		this._scaleFactor = null;
		this._minx = null;
		this._maxx = null;
		this._miny = null;
		this._maxy = null;
		this._corner = new Array(4).fill(null);
		this._safeEnv = null;
		var pt = arguments[0];
		var scaleFactor = arguments[1];
		var li = arguments[2];
		this._originalPt = pt;
		this._pt = pt;
		this._scaleFactor = scaleFactor;
		this._li = li;
		if (scaleFactor <= 0) { throw new IllegalArgumentException('Scale factor must be non-zero') }
		if (scaleFactor !== 1.0) {
			this._pt = new Coordinate(this.scale(pt.x), this.scale(pt.y));
			this._p0Scaled = new Coordinate();
			this._p1Scaled = new Coordinate();
		}
		this.initCorners(this._pt);
	};

	var staticAccessors$34 = { SAFE_ENV_EXPANSION_FACTOR: { configurable: true } };
	HotPixel.prototype.intersectsScaled = function intersectsScaled(p0, p1) {
		var segMinx = Math.min(p0.x, p1.x);
		var segMaxx = Math.max(p0.x, p1.x);
		var segMiny = Math.min(p0.y, p1.y);
		var segMaxy = Math.max(p0.y, p1.y);
		var isOutsidePixelEnv = this._maxx < segMinx || this._minx > segMaxx || this._maxy < segMiny || this._miny > segMaxy;
		if (isOutsidePixelEnv) { return false }
		var intersects = this.intersectsToleranceSquare(p0, p1);
		Assert.isTrue(!(isOutsidePixelEnv && intersects), 'Found bad envelope test');
		return intersects
	};
	HotPixel.prototype.initCorners = function initCorners(pt) {
		var tolerance = 0.5;
		this._minx = pt.x - tolerance;
		this._maxx = pt.x + tolerance;
		this._miny = pt.y - tolerance;
		this._maxy = pt.y + tolerance;
		this._corner[0] = new Coordinate(this._maxx, this._maxy);
		this._corner[1] = new Coordinate(this._minx, this._maxy);
		this._corner[2] = new Coordinate(this._minx, this._miny);
		this._corner[3] = new Coordinate(this._maxx, this._miny);
	};
	HotPixel.prototype.intersects = function intersects(p0, p1) {
		if (this._scaleFactor === 1.0) { return this.intersectsScaled(p0, p1) }
		this.copyScaled(p0, this._p0Scaled);
		this.copyScaled(p1, this._p1Scaled);
		return this.intersectsScaled(this._p0Scaled, this._p1Scaled)
	};
	HotPixel.prototype.scale = function scale(val) {
		return Math.round(val * this._scaleFactor)
	};
	HotPixel.prototype.getCoordinate = function getCoordinate() {
		return this._originalPt
	};
	HotPixel.prototype.copyScaled = function copyScaled(p, pScaled) {
		pScaled.x = this.scale(p.x);
		pScaled.y = this.scale(p.y);
	};
	HotPixel.prototype.getSafeEnvelope = function getSafeEnvelope() {
		if (this._safeEnv === null) {
			var safeTolerance = HotPixel.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
			this._safeEnv = new Envelope(this._originalPt.x - safeTolerance, this._originalPt.x + safeTolerance, this._originalPt.y - safeTolerance, this._originalPt.y + safeTolerance);
		}
		return this._safeEnv
	};
	HotPixel.prototype.intersectsPixelClosure = function intersectsPixelClosure(p0, p1) {
		this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);
		if (this._li.hasIntersection()) { return true }
		this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);
		if (this._li.hasIntersection()) { return true }
		this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);
		if (this._li.hasIntersection()) { return true }
		this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);
		if (this._li.hasIntersection()) { return true }
		return false
	};
	HotPixel.prototype.intersectsToleranceSquare = function intersectsToleranceSquare(p0, p1) {
		var intersectsLeft = false;
		var intersectsBottom = false;
		this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);
		if (this._li.isProper()) { return true }
		this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);
		if (this._li.isProper()) { return true }
		if (this._li.hasIntersection()) { intersectsLeft = true; }
		this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);
		if (this._li.isProper()) { return true }
		if (this._li.hasIntersection()) { intersectsBottom = true; }
		this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);
		if (this._li.isProper()) { return true }
		if (intersectsLeft && intersectsBottom) { return true }
		if (p0.equals(this._pt)) { return true }
		if (p1.equals(this._pt)) { return true }
		return false
	};
	HotPixel.prototype.addSnappedNode = function addSnappedNode(segStr, segIndex) {
		var p0 = segStr.getCoordinate(segIndex);
		var p1 = segStr.getCoordinate(segIndex + 1);
		if (this.intersects(p0, p1)) {
			segStr.addIntersection(this.getCoordinate(), segIndex);
			return true
		}
		return false
	};
	HotPixel.prototype.interfaces_ = function interfaces_() {
		return []
	};
	HotPixel.prototype.getClass = function getClass() {
		return HotPixel
	};
	staticAccessors$34.SAFE_ENV_EXPANSION_FACTOR.get = function () { return 0.75 };

	Object.defineProperties(HotPixel, staticAccessors$34);

	var MonotoneChainSelectAction = function MonotoneChainSelectAction() {
		this.tempEnv1 = new Envelope();
		this.selectedSegment = new LineSegment();
	};
	MonotoneChainSelectAction.prototype.select = function select() {
		if (arguments.length === 1); else if (arguments.length === 2) {
			var mc = arguments[0];
			var startIndex = arguments[1];
			mc.getLineSegment(startIndex, this.selectedSegment);
			this.select(this.selectedSegment);
		}
	};
	MonotoneChainSelectAction.prototype.interfaces_ = function interfaces_() {
		return []
	};
	MonotoneChainSelectAction.prototype.getClass = function getClass() {
		return MonotoneChainSelectAction
	};

	var MCIndexPointSnapper = function MCIndexPointSnapper() {
		this._index = null;
		var index = arguments[0];
		this._index = index;
	};

	var staticAccessors$35 = { HotPixelSnapAction: { configurable: true } };
	MCIndexPointSnapper.prototype.snap = function snap() {
		if (arguments.length === 1) {
			var hotPixel = arguments[0];
			return this.snap(hotPixel, null, -1)
		} else if (arguments.length === 3) {
			var hotPixel$1 = arguments[0];
			var parentEdge = arguments[1];
			var hotPixelVertexIndex = arguments[2];
			var pixelEnv = hotPixel$1.getSafeEnvelope();
			var hotPixelSnapAction = new HotPixelSnapAction(hotPixel$1, parentEdge, hotPixelVertexIndex);
			this._index.query(pixelEnv, {
				interfaces_: function () {
					return [ItemVisitor]
				},
				visitItem: function (item) {
					var testChain = item;
					testChain.select(pixelEnv, hotPixelSnapAction);
				}
			});
			return hotPixelSnapAction.isNodeAdded()
		}
	};
	MCIndexPointSnapper.prototype.interfaces_ = function interfaces_() {
		return []
	};
	MCIndexPointSnapper.prototype.getClass = function getClass() {
		return MCIndexPointSnapper
	};
	staticAccessors$35.HotPixelSnapAction.get = function () { return HotPixelSnapAction };

	Object.defineProperties(MCIndexPointSnapper, staticAccessors$35);

	var HotPixelSnapAction = (function (MonotoneChainSelectAction$$1) {
		function HotPixelSnapAction() {
			MonotoneChainSelectAction$$1.call(this);
			this._hotPixel = null;
			this._parentEdge = null;
			this._hotPixelVertexIndex = null;
			this._isNodeAdded = false;
			var hotPixel = arguments[0];
			var parentEdge = arguments[1];
			var hotPixelVertexIndex = arguments[2];
			this._hotPixel = hotPixel;
			this._parentEdge = parentEdge;
			this._hotPixelVertexIndex = hotPixelVertexIndex;
		}

		if (MonotoneChainSelectAction$$1) HotPixelSnapAction.__proto__ = MonotoneChainSelectAction$$1;
		HotPixelSnapAction.prototype = Object.create(MonotoneChainSelectAction$$1 && MonotoneChainSelectAction$$1.prototype);
		HotPixelSnapAction.prototype.constructor = HotPixelSnapAction;
		HotPixelSnapAction.prototype.isNodeAdded = function isNodeAdded() {
			return this._isNodeAdded
		};
		HotPixelSnapAction.prototype.select = function select() {
			if (arguments.length === 2) {
				var mc = arguments[0];
				var startIndex = arguments[1];
				var ss = mc.getContext();
				if (this._parentEdge !== null) {
					if (ss === this._parentEdge && startIndex === this._hotPixelVertexIndex) { return null }
				}
				this._isNodeAdded = this._hotPixel.addSnappedNode(ss, startIndex);
			} else { return MonotoneChainSelectAction$$1.prototype.select.apply(this, arguments) }
		};
		HotPixelSnapAction.prototype.interfaces_ = function interfaces_() {
			return []
		};
		HotPixelSnapAction.prototype.getClass = function getClass() {
			return HotPixelSnapAction
		};

		return HotPixelSnapAction;
	}(MonotoneChainSelectAction));

	var InteriorIntersectionFinderAdder = function InteriorIntersectionFinderAdder() {
		this._li = null;
		this._interiorIntersections = null;
		var li = arguments[0];
		this._li = li;
		this._interiorIntersections = new ArrayList();
	};
	InteriorIntersectionFinderAdder.prototype.processIntersections = function processIntersections(e0, segIndex0, e1, segIndex1) {
		var this$1$1 = this;

		if (e0 === e1 && segIndex0 === segIndex1) { return null }
		var p00 = e0.getCoordinates()[segIndex0];
		var p01 = e0.getCoordinates()[segIndex0 + 1];
		var p10 = e1.getCoordinates()[segIndex1];
		var p11 = e1.getCoordinates()[segIndex1 + 1];
		this._li.computeIntersection(p00, p01, p10, p11);
		if (this._li.hasIntersection()) {
			if (this._li.isInteriorIntersection()) {
				for (var intIndex = 0; intIndex < this._li.getIntersectionNum(); intIndex++) {
					this$1$1._interiorIntersections.add(this$1$1._li.getIntersection(intIndex));
				}
				e0.addIntersections(this._li, segIndex0, 0);
				e1.addIntersections(this._li, segIndex1, 1);
			}
		}
	};
	InteriorIntersectionFinderAdder.prototype.isDone = function isDone() {
		return false
	};
	InteriorIntersectionFinderAdder.prototype.getInteriorIntersections = function getInteriorIntersections() {
		return this._interiorIntersections
	};
	InteriorIntersectionFinderAdder.prototype.interfaces_ = function interfaces_() {
		return [SegmentIntersector]
	};
	InteriorIntersectionFinderAdder.prototype.getClass = function getClass() {
		return InteriorIntersectionFinderAdder
	};

	var MCIndexSnapRounder = function MCIndexSnapRounder() {
		this._pm = null;
		this._li = null;
		this._scaleFactor = null;
		this._noder = null;
		this._pointSnapper = null;
		this._nodedSegStrings = null;
		var pm = arguments[0];
		this._pm = pm;
		this._li = new RobustLineIntersector();
		this._li.setPrecisionModel(pm);
		this._scaleFactor = pm.getScale();
	};
	MCIndexSnapRounder.prototype.checkCorrectness = function checkCorrectness(inputSegmentStrings) {
		var resultSegStrings = NodedSegmentString.getNodedSubstrings(inputSegmentStrings);
		var nv = new NodingValidator(resultSegStrings);
		try {
			nv.checkValid();
		} catch (ex) {
			if (ex instanceof Exception) {
				ex.printStackTrace();
			} else { throw ex }
		} finally { }
	};
	MCIndexSnapRounder.prototype.getNodedSubstrings = function getNodedSubstrings() {
		return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings)
	};
	MCIndexSnapRounder.prototype.snapRound = function snapRound(segStrings, li) {
		var intersections = this.findInteriorIntersections(segStrings, li);
		this.computeIntersectionSnaps(intersections);
		this.computeVertexSnaps(segStrings);
	};
	MCIndexSnapRounder.prototype.findInteriorIntersections = function findInteriorIntersections(segStrings, li) {
		var intFinderAdder = new InteriorIntersectionFinderAdder(li);
		this._noder.setSegmentIntersector(intFinderAdder);
		this._noder.computeNodes(segStrings);
		return intFinderAdder.getInteriorIntersections()
	};
	MCIndexSnapRounder.prototype.computeVertexSnaps = function computeVertexSnaps() {
		var this$1$1 = this;

		if (hasInterface(arguments[0], Collection)) {
			var edges = arguments[0];
			for (var i0 = edges.iterator(); i0.hasNext();) {
				var edge0 = i0.next();
				this$1$1.computeVertexSnaps(edge0);
			}
		} else if (arguments[0] instanceof NodedSegmentString) {
			var e = arguments[0];
			var pts0 = e.getCoordinates();
			for (var i = 0; i < pts0.length; i++) {
				var hotPixel = new HotPixel(pts0[i], this$1$1._scaleFactor, this$1$1._li);
				var isNodeAdded = this$1$1._pointSnapper.snap(hotPixel, e, i);
				if (isNodeAdded) {
					e.addIntersection(pts0[i], i);
				}
			}
		}
	};
	MCIndexSnapRounder.prototype.computeNodes = function computeNodes(inputSegmentStrings) {
		this._nodedSegStrings = inputSegmentStrings;
		this._noder = new MCIndexNoder();
		this._pointSnapper = new MCIndexPointSnapper(this._noder.getIndex());
		this.snapRound(inputSegmentStrings, this._li);
	};
	MCIndexSnapRounder.prototype.computeIntersectionSnaps = function computeIntersectionSnaps(snapPts) {
		var this$1$1 = this;

		for (var it = snapPts.iterator(); it.hasNext();) {
			var snapPt = it.next();
			var hotPixel = new HotPixel(snapPt, this$1$1._scaleFactor, this$1$1._li);
			this$1$1._pointSnapper.snap(hotPixel);
		}
	};
	MCIndexSnapRounder.prototype.interfaces_ = function interfaces_() {
		return [Noder]
	};
	MCIndexSnapRounder.prototype.getClass = function getClass() {
		return MCIndexSnapRounder
	};

	var BufferOp = function BufferOp() {
		this._argGeom = null;
		this._distance = null;
		this._bufParams = new BufferParameters();
		this._resultGeometry = null;
		this._saveException = null;
		if (arguments.length === 1) {
			var g = arguments[0];
			this._argGeom = g;
		} else if (arguments.length === 2) {
			var g$1 = arguments[0];
			var bufParams = arguments[1];
			this._argGeom = g$1;
			this._bufParams = bufParams;
		}
	};

	var staticAccessors$32 = { CAP_ROUND: { configurable: true }, CAP_BUTT: { configurable: true }, CAP_FLAT: { configurable: true }, CAP_SQUARE: { configurable: true }, MAX_PRECISION_DIGITS: { configurable: true } };
	BufferOp.prototype.bufferFixedPrecision = function bufferFixedPrecision(fixedPM) {
		var noder = new ScaledNoder(new MCIndexSnapRounder(new PrecisionModel(1.0)), fixedPM.getScale());
		var bufBuilder = new BufferBuilder(this._bufParams);
		bufBuilder.setWorkingPrecisionModel(fixedPM);
		bufBuilder.setNoder(noder);
		this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);
	};
	BufferOp.prototype.bufferReducedPrecision = function bufferReducedPrecision() {
		var this$1$1 = this;

		if (arguments.length === 0) {
			for (var precDigits = BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--) {
				try {
					this$1$1.bufferReducedPrecision(precDigits);
				} catch (ex) {
					if (ex instanceof TopologyException) {
						this$1$1._saveException = ex;
					} else { throw ex }
				} finally { }
				if (this$1$1._resultGeometry !== null) { return null }
			}
			throw this._saveException
		} else if (arguments.length === 1) {
			var precisionDigits = arguments[0];
			var sizeBasedScaleFactor = BufferOp.precisionScaleFactor(this._argGeom, this._distance, precisionDigits);
			var fixedPM = new PrecisionModel(sizeBasedScaleFactor);
			this.bufferFixedPrecision(fixedPM);
		}
	};
	BufferOp.prototype.computeGeometry = function computeGeometry() {
		this.bufferOriginalPrecision();
		if (this._resultGeometry !== null) { return null }
		var argPM = this._argGeom.getFactory().getPrecisionModel();
		if (argPM.getType() === PrecisionModel.FIXED) { this.bufferFixedPrecision(argPM); } else { this.bufferReducedPrecision(); }
	};
	BufferOp.prototype.setQuadrantSegments = function setQuadrantSegments(quadrantSegments) {
		this._bufParams.setQuadrantSegments(quadrantSegments);
	};
	BufferOp.prototype.bufferOriginalPrecision = function bufferOriginalPrecision() {
		try {
			var bufBuilder = new BufferBuilder(this._bufParams);
			this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);
		} catch (ex) {
			if (ex instanceof RuntimeException) {
				this._saveException = ex;
			} else { throw ex }
		} finally { }
	};
	BufferOp.prototype.getResultGeometry = function getResultGeometry(distance) {
		this._distance = distance;
		this.computeGeometry();
		return this._resultGeometry
	};
	BufferOp.prototype.setEndCapStyle = function setEndCapStyle(endCapStyle) {
		this._bufParams.setEndCapStyle(endCapStyle);
	};
	BufferOp.prototype.interfaces_ = function interfaces_() {
		return []
	};
	BufferOp.prototype.getClass = function getClass() {
		return BufferOp
	};
	BufferOp.bufferOp = function bufferOp() {
		if (arguments.length === 2) {
			var g = arguments[0];
			var distance = arguments[1];
			var gBuf = new BufferOp(g);
			var geomBuf = gBuf.getResultGeometry(distance);
			return geomBuf
		} else if (arguments.length === 3) {
			if (Number.isInteger(arguments[2]) && (arguments[0] instanceof Geometry && typeof arguments[1] === 'number')) {
				var g$1 = arguments[0];
				var distance$1 = arguments[1];
				var quadrantSegments = arguments[2];
				var bufOp = new BufferOp(g$1);
				bufOp.setQuadrantSegments(quadrantSegments);
				var geomBuf$1 = bufOp.getResultGeometry(distance$1);
				return geomBuf$1
			} else if (arguments[2] instanceof BufferParameters && (arguments[0] instanceof Geometry && typeof arguments[1] === 'number')) {
				var g$2 = arguments[0];
				var distance$2 = arguments[1];
				var params = arguments[2];
				var bufOp$1 = new BufferOp(g$2, params);
				var geomBuf$2 = bufOp$1.getResultGeometry(distance$2);
				return geomBuf$2
			}
		} else if (arguments.length === 4) {
			var g$3 = arguments[0];
			var distance$3 = arguments[1];
			var quadrantSegments$1 = arguments[2];
			var endCapStyle = arguments[3];
			var bufOp$2 = new BufferOp(g$3);
			bufOp$2.setQuadrantSegments(quadrantSegments$1);
			bufOp$2.setEndCapStyle(endCapStyle);
			var geomBuf$3 = bufOp$2.getResultGeometry(distance$3);
			return geomBuf$3
		}
	};
	BufferOp.precisionScaleFactor = function precisionScaleFactor(g, distance, maxPrecisionDigits) {
		var env = g.getEnvelopeInternal();
		var envMax = MathUtil.max(Math.abs(env.getMaxX()), Math.abs(env.getMaxY()), Math.abs(env.getMinX()), Math.abs(env.getMinY()));
		var expandByDistance = distance > 0.0 ? distance : 0.0;
		var bufEnvMax = envMax + 2 * expandByDistance;
		var bufEnvPrecisionDigits = Math.trunc(Math.log(bufEnvMax) / Math.log(10) + 1.0);
		var minUnitLog10 = maxPrecisionDigits - bufEnvPrecisionDigits;
		var scaleFactor = Math.pow(10.0, minUnitLog10);
		return scaleFactor
	};
	staticAccessors$32.CAP_ROUND.get = function () { return BufferParameters.CAP_ROUND };
	staticAccessors$32.CAP_BUTT.get = function () { return BufferParameters.CAP_FLAT };
	staticAccessors$32.CAP_FLAT.get = function () { return BufferParameters.CAP_FLAT };
	staticAccessors$32.CAP_SQUARE.get = function () { return BufferParameters.CAP_SQUARE };
	staticAccessors$32.MAX_PRECISION_DIGITS.get = function () { return 12 };

	Object.defineProperties(BufferOp, staticAccessors$32);

	var PointPairDistance = function PointPairDistance() {
		this._pt = [new Coordinate(), new Coordinate()];
		this._distance = Double.NaN;
		this._isNull = true;
	};
	PointPairDistance.prototype.getCoordinates = function getCoordinates() {
		return this._pt
	};
	PointPairDistance.prototype.getCoordinate = function getCoordinate(i) {
		return this._pt[i]
	};
	PointPairDistance.prototype.setMinimum = function setMinimum() {
		if (arguments.length === 1) {
			var ptDist = arguments[0];
			this.setMinimum(ptDist._pt[0], ptDist._pt[1]);
		} else if (arguments.length === 2) {
			var p0 = arguments[0];
			var p1 = arguments[1];
			if (this._isNull) {
				this.initialize(p0, p1);
				return null
			}
			var dist = p0.distance(p1);
			if (dist < this._distance) { this.initialize(p0, p1, dist); }
		}
	};
	PointPairDistance.prototype.initialize = function initialize() {
		if (arguments.length === 0) {
			this._isNull = true;
		} else if (arguments.length === 2) {
			var p0 = arguments[0];
			var p1 = arguments[1];
			this._pt[0].setCoordinate(p0);
			this._pt[1].setCoordinate(p1);
			this._distance = p0.distance(p1);
			this._isNull = false;
		} else if (arguments.length === 3) {
			var p0$1 = arguments[0];
			var p1$1 = arguments[1];
			var distance = arguments[2];
			this._pt[0].setCoordinate(p0$1);
			this._pt[1].setCoordinate(p1$1);
			this._distance = distance;
			this._isNull = false;
		}
	};
	PointPairDistance.prototype.getDistance = function getDistance() {
		return this._distance
	};
	PointPairDistance.prototype.setMaximum = function setMaximum() {
		if (arguments.length === 1) {
			var ptDist = arguments[0];
			this.setMaximum(ptDist._pt[0], ptDist._pt[1]);
		} else if (arguments.length === 2) {
			var p0 = arguments[0];
			var p1 = arguments[1];
			if (this._isNull) {
				this.initialize(p0, p1);
				return null
			}
			var dist = p0.distance(p1);
			if (dist > this._distance) { this.initialize(p0, p1, dist); }
		}
	};
	PointPairDistance.prototype.interfaces_ = function interfaces_() {
		return []
	};
	PointPairDistance.prototype.getClass = function getClass() {
		return PointPairDistance
	};

	var DistanceToPointFinder = function DistanceToPointFinder() { };

	DistanceToPointFinder.prototype.interfaces_ = function interfaces_() {
		return []
	};
	DistanceToPointFinder.prototype.getClass = function getClass() {
		return DistanceToPointFinder
	};
	DistanceToPointFinder.computeDistance = function computeDistance() {
		if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof LineString && arguments[1] instanceof Coordinate)) {
			var line = arguments[0];
			var pt = arguments[1];
			var ptDist = arguments[2];
			var coords = line.getCoordinates();
			var tempSegment = new LineSegment();
			for (var i = 0; i < coords.length - 1; i++) {
				tempSegment.setCoordinates(coords[i], coords[i + 1]);
				var closestPt = tempSegment.closestPoint(pt);
				ptDist.setMinimum(closestPt, pt);
			}
		} else if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof Polygon && arguments[1] instanceof Coordinate)) {
			var poly = arguments[0];
			var pt$1 = arguments[1];
			var ptDist$1 = arguments[2];
			DistanceToPointFinder.computeDistance(poly.getExteriorRing(), pt$1, ptDist$1);
			for (var i$1 = 0; i$1 < poly.getNumInteriorRing(); i$1++) {
				DistanceToPointFinder.computeDistance(poly.getInteriorRingN(i$1), pt$1, ptDist$1);
			}
		} else if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof Geometry && arguments[1] instanceof Coordinate)) {
			var geom = arguments[0];
			var pt$2 = arguments[1];
			var ptDist$2 = arguments[2];
			if (geom instanceof LineString) {
				DistanceToPointFinder.computeDistance(geom, pt$2, ptDist$2);
			} else if (geom instanceof Polygon) {
				DistanceToPointFinder.computeDistance(geom, pt$2, ptDist$2);
			} else if (geom instanceof GeometryCollection) {
				var gc = geom;
				for (var i$2 = 0; i$2 < gc.getNumGeometries(); i$2++) {
					var g = gc.getGeometryN(i$2);
					DistanceToPointFinder.computeDistance(g, pt$2, ptDist$2);
				}
			} else {
				ptDist$2.setMinimum(geom.getCoordinate(), pt$2);
			}
		} else if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof LineSegment && arguments[1] instanceof Coordinate)) {
			var segment = arguments[0];
			var pt$3 = arguments[1];
			var ptDist$3 = arguments[2];
			var closestPt$1 = segment.closestPoint(pt$3);
			ptDist$3.setMinimum(closestPt$1, pt$3);
		}
	};

	var BufferCurveMaximumDistanceFinder = function BufferCurveMaximumDistanceFinder(inputGeom) {
		this._maxPtDist = new PointPairDistance();
		this._inputGeom = inputGeom || null;
	};

	var staticAccessors$36 = { MaxPointDistanceFilter: { configurable: true }, MaxMidpointDistanceFilter: { configurable: true } };
	BufferCurveMaximumDistanceFinder.prototype.computeMaxMidpointDistance = function computeMaxMidpointDistance(curve) {
		var distFilter = new MaxMidpointDistanceFilter(this._inputGeom);
		curve.apply(distFilter);
		this._maxPtDist.setMaximum(distFilter.getMaxPointDistance());
	};
	BufferCurveMaximumDistanceFinder.prototype.computeMaxVertexDistance = function computeMaxVertexDistance(curve) {
		var distFilter = new MaxPointDistanceFilter(this._inputGeom);
		curve.apply(distFilter);
		this._maxPtDist.setMaximum(distFilter.getMaxPointDistance());
	};
	BufferCurveMaximumDistanceFinder.prototype.findDistance = function findDistance(bufferCurve) {
		this.computeMaxVertexDistance(bufferCurve);
		this.computeMaxMidpointDistance(bufferCurve);
		return this._maxPtDist.getDistance()
	};
	BufferCurveMaximumDistanceFinder.prototype.getDistancePoints = function getDistancePoints() {
		return this._maxPtDist
	};
	BufferCurveMaximumDistanceFinder.prototype.interfaces_ = function interfaces_() {
		return []
	};
	BufferCurveMaximumDistanceFinder.prototype.getClass = function getClass() {
		return BufferCurveMaximumDistanceFinder
	};
	staticAccessors$36.MaxPointDistanceFilter.get = function () { return MaxPointDistanceFilter };
	staticAccessors$36.MaxMidpointDistanceFilter.get = function () { return MaxMidpointDistanceFilter };

	Object.defineProperties(BufferCurveMaximumDistanceFinder, staticAccessors$36);

	var MaxPointDistanceFilter = function MaxPointDistanceFilter(geom) {
		this._maxPtDist = new PointPairDistance();
		this._minPtDist = new PointPairDistance();
		this._geom = geom || null;
	};
	MaxPointDistanceFilter.prototype.filter = function filter(pt) {
		this._minPtDist.initialize();
		DistanceToPointFinder.computeDistance(this._geom, pt, this._minPtDist);
		this._maxPtDist.setMaximum(this._minPtDist);
	};
	MaxPointDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance() {
		return this._maxPtDist
	};
	MaxPointDistanceFilter.prototype.interfaces_ = function interfaces_() {
		return [CoordinateFilter]
	};
	MaxPointDistanceFilter.prototype.getClass = function getClass() {
		return MaxPointDistanceFilter
	};

	var MaxMidpointDistanceFilter = function MaxMidpointDistanceFilter(geom) {
		this._maxPtDist = new PointPairDistance();
		this._minPtDist = new PointPairDistance();
		this._geom = geom || null;
	};
	MaxMidpointDistanceFilter.prototype.filter = function filter(seq, index) {
		if (index === 0) { return null }
		var p0 = seq.getCoordinate(index - 1);
		var p1 = seq.getCoordinate(index);
		var midPt = new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
		this._minPtDist.initialize();
		DistanceToPointFinder.computeDistance(this._geom, midPt, this._minPtDist);
		this._maxPtDist.setMaximum(this._minPtDist);
	};
	MaxMidpointDistanceFilter.prototype.isDone = function isDone() {
		return false
	};
	MaxMidpointDistanceFilter.prototype.isGeometryChanged = function isGeometryChanged() {
		return false
	};
	MaxMidpointDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance() {
		return this._maxPtDist
	};
	MaxMidpointDistanceFilter.prototype.interfaces_ = function interfaces_() {
		return [CoordinateSequenceFilter]
	};
	MaxMidpointDistanceFilter.prototype.getClass = function getClass() {
		return MaxMidpointDistanceFilter
	};

	var PolygonExtracter = function PolygonExtracter(comps) {
		this._comps = comps || null;
	};
	PolygonExtracter.prototype.filter = function filter(geom) {
		if (geom instanceof Polygon) { this._comps.add(geom); }
	};
	PolygonExtracter.prototype.interfaces_ = function interfaces_() {
		return [GeometryFilter]
	};
	PolygonExtracter.prototype.getClass = function getClass() {
		return PolygonExtracter
	};
	PolygonExtracter.getPolygons = function getPolygons() {
		if (arguments.length === 1) {
			var geom = arguments[0];
			return PolygonExtracter.getPolygons(geom, new ArrayList())
		} else if (arguments.length === 2) {
			var geom$1 = arguments[0];
			var list = arguments[1];
			if (geom$1 instanceof Polygon) {
				list.add(geom$1);
			} else if (geom$1 instanceof GeometryCollection) {
				geom$1.apply(new PolygonExtracter(list));
			}
			return list
		}
	};

	var LinearComponentExtracter = function LinearComponentExtracter() {
		this._lines = null;
		this._isForcedToLineString = false;
		if (arguments.length === 1) {
			var lines = arguments[0];
			this._lines = lines;
		} else if (arguments.length === 2) {
			var lines$1 = arguments[0];
			var isForcedToLineString = arguments[1];
			this._lines = lines$1;
			this._isForcedToLineString = isForcedToLineString;
		}
	};
	LinearComponentExtracter.prototype.filter = function filter(geom) {
		if (this._isForcedToLineString && geom instanceof LinearRing) {
			var line = geom.getFactory().createLineString(geom.getCoordinateSequence());
			this._lines.add(line);
			return null
		}
		if (geom instanceof LineString) { this._lines.add(geom); }
	};
	LinearComponentExtracter.prototype.setForceToLineString = function setForceToLineString(isForcedToLineString) {
		this._isForcedToLineString = isForcedToLineString;
	};
	LinearComponentExtracter.prototype.interfaces_ = function interfaces_() {
		return [GeometryComponentFilter]
	};
	LinearComponentExtracter.prototype.getClass = function getClass() {
		return LinearComponentExtracter
	};
	LinearComponentExtracter.getGeometry = function getGeometry() {
		if (arguments.length === 1) {
			var geom = arguments[0];
			return geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom))
		} else if (arguments.length === 2) {
			var geom$1 = arguments[0];
			var forceToLineString = arguments[1];
			return geom$1.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom$1, forceToLineString))
		}
	};
	LinearComponentExtracter.getLines = function getLines() {
		if (arguments.length === 1) {
			var geom = arguments[0];
			return LinearComponentExtracter.getLines(geom, false)
		} else if (arguments.length === 2) {
			if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {
				var geoms = arguments[0];
				var lines$1 = arguments[1];
				for (var i = geoms.iterator(); i.hasNext();) {
					var g = i.next();
					LinearComponentExtracter.getLines(g, lines$1);
				}
				return lines$1
			} else if (arguments[0] instanceof Geometry && typeof arguments[1] === 'boolean') {
				var geom$1 = arguments[0];
				var forceToLineString = arguments[1];
				var lines = new ArrayList();
				geom$1.apply(new LinearComponentExtracter(lines, forceToLineString));
				return lines
			} else if (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {
				var geom$2 = arguments[0];
				var lines$2 = arguments[1];
				if (geom$2 instanceof LineString) {
					lines$2.add(geom$2);
				} else {
					geom$2.apply(new LinearComponentExtracter(lines$2));
				}
				return lines$2
			}
		} else if (arguments.length === 3) {
			if (typeof arguments[2] === 'boolean' && (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection))) {
				var geoms$1 = arguments[0];
				var lines$3 = arguments[1];
				var forceToLineString$1 = arguments[2];
				for (var i$1 = geoms$1.iterator(); i$1.hasNext();) {
					var g$1 = i$1.next();
					LinearComponentExtracter.getLines(g$1, lines$3, forceToLineString$1);
				}
				return lines$3
			} else if (typeof arguments[2] === 'boolean' && (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection))) {
				var geom$3 = arguments[0];
				var lines$4 = arguments[1];
				var forceToLineString$2 = arguments[2];
				geom$3.apply(new LinearComponentExtracter(lines$4, forceToLineString$2));
				return lines$4
			}
		}
	};

	var PointLocator = function PointLocator() {
		this._boundaryRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;
		this._isIn = null;
		this._numBoundaries = null;
		if (arguments.length === 0); else if (arguments.length === 1) {
			var boundaryRule = arguments[0];
			if (boundaryRule === null) { throw new IllegalArgumentException('Rule must be non-null') }
			this._boundaryRule = boundaryRule;
		}
	};
	PointLocator.prototype.locateInternal = function locateInternal() {
		var this$1$1 = this;

		if (arguments[0] instanceof Coordinate && arguments[1] instanceof Polygon) {
			var p = arguments[0];
			var poly = arguments[1];
			if (poly.isEmpty()) { return Location.EXTERIOR }
			var shell = poly.getExteriorRing();
			var shellLoc = this.locateInPolygonRing(p, shell);
			if (shellLoc === Location.EXTERIOR) { return Location.EXTERIOR }
			if (shellLoc === Location.BOUNDARY) { return Location.BOUNDARY }
			for (var i = 0; i < poly.getNumInteriorRing(); i++) {
				var hole = poly.getInteriorRingN(i);
				var holeLoc = this$1$1.locateInPolygonRing(p, hole);
				if (holeLoc === Location.INTERIOR) { return Location.EXTERIOR }
				if (holeLoc === Location.BOUNDARY) { return Location.BOUNDARY }
			}
			return Location.INTERIOR
		} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof LineString) {
			var p$1 = arguments[0];
			var l = arguments[1];
			if (!l.getEnvelopeInternal().intersects(p$1)) { return Location.EXTERIOR }
			var pt = l.getCoordinates();
			if (!l.isClosed()) {
				if (p$1.equals(pt[0]) || p$1.equals(pt[pt.length - 1])) {
					return Location.BOUNDARY
				}
			}
			if (CGAlgorithms.isOnLine(p$1, pt)) { return Location.INTERIOR }
			return Location.EXTERIOR
		} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Point) {
			var p$2 = arguments[0];
			var pt$1 = arguments[1];
			var ptCoord = pt$1.getCoordinate();
			if (ptCoord.equals2D(p$2)) { return Location.INTERIOR }
			return Location.EXTERIOR
		}
	};
	PointLocator.prototype.locateInPolygonRing = function locateInPolygonRing(p, ring) {
		if (!ring.getEnvelopeInternal().intersects(p)) { return Location.EXTERIOR }
		return CGAlgorithms.locatePointInRing(p, ring.getCoordinates())
	};
	PointLocator.prototype.intersects = function intersects(p, geom) {
		return this.locate(p, geom) !== Location.EXTERIOR
	};
	PointLocator.prototype.updateLocationInfo = function updateLocationInfo(loc) {
		if (loc === Location.INTERIOR) { this._isIn = true; }
		if (loc === Location.BOUNDARY) { this._numBoundaries++; }
	};
	PointLocator.prototype.computeLocation = function computeLocation(p, geom) {
		var this$1$1 = this;

		if (geom instanceof Point) {
			this.updateLocationInfo(this.locateInternal(p, geom));
		}
		if (geom instanceof LineString) {
			this.updateLocationInfo(this.locateInternal(p, geom));
		} else if (geom instanceof Polygon) {
			this.updateLocationInfo(this.locateInternal(p, geom));
		} else if (geom instanceof MultiLineString) {
			var ml = geom;
			for (var i = 0; i < ml.getNumGeometries(); i++) {
				var l = ml.getGeometryN(i);
				this$1$1.updateLocationInfo(this$1$1.locateInternal(p, l));
			}
		} else if (geom instanceof MultiPolygon) {
			var mpoly = geom;
			for (var i$1 = 0; i$1 < mpoly.getNumGeometries(); i$1++) {
				var poly = mpoly.getGeometryN(i$1);
				this$1$1.updateLocationInfo(this$1$1.locateInternal(p, poly));
			}
		} else if (geom instanceof GeometryCollection) {
			var geomi = new GeometryCollectionIterator(geom);
			while (geomi.hasNext()) {
				var g2 = geomi.next();
				if (g2 !== geom) { this$1$1.computeLocation(p, g2); }
			}
		}
	};
	PointLocator.prototype.locate = function locate(p, geom) {
		if (geom.isEmpty()) { return Location.EXTERIOR }
		if (geom instanceof LineString) {
			return this.locateInternal(p, geom)
		} else if (geom instanceof Polygon) {
			return this.locateInternal(p, geom)
		}
		this._isIn = false;
		this._numBoundaries = 0;
		this.computeLocation(p, geom);
		if (this._boundaryRule.isInBoundary(this._numBoundaries)) { return Location.BOUNDARY }
		if (this._numBoundaries > 0 || this._isIn) { return Location.INTERIOR }
		return Location.EXTERIOR
	};
	PointLocator.prototype.interfaces_ = function interfaces_() {
		return []
	};
	PointLocator.prototype.getClass = function getClass() {
		return PointLocator
	};

	var GeometryLocation = function GeometryLocation() {
		this._component = null;
		this._segIndex = null;
		this._pt = null;
		if (arguments.length === 2) {
			var component = arguments[0];
			var pt = arguments[1];
			GeometryLocation.call(this, component, GeometryLocation.INSIDE_AREA, pt);
		} else if (arguments.length === 3) {
			var component$1 = arguments[0];
			var segIndex = arguments[1];
			var pt$1 = arguments[2];
			this._component = component$1;
			this._segIndex = segIndex;
			this._pt = pt$1;
		}
	};

	var staticAccessors$38 = { INSIDE_AREA: { configurable: true } };
	GeometryLocation.prototype.isInsideArea = function isInsideArea() {
		return this._segIndex === GeometryLocation.INSIDE_AREA
	};
	GeometryLocation.prototype.getCoordinate = function getCoordinate() {
		return this._pt
	};
	GeometryLocation.prototype.getGeometryComponent = function getGeometryComponent() {
		return this._component
	};
	GeometryLocation.prototype.getSegmentIndex = function getSegmentIndex() {
		return this._segIndex
	};
	GeometryLocation.prototype.interfaces_ = function interfaces_() {
		return []
	};
	GeometryLocation.prototype.getClass = function getClass() {
		return GeometryLocation
	};
	staticAccessors$38.INSIDE_AREA.get = function () { return -1 };

	Object.defineProperties(GeometryLocation, staticAccessors$38);

	var PointExtracter = function PointExtracter(pts) {
		this._pts = pts || null;
	};
	PointExtracter.prototype.filter = function filter(geom) {
		if (geom instanceof Point) { this._pts.add(geom); }
	};
	PointExtracter.prototype.interfaces_ = function interfaces_() {
		return [GeometryFilter]
	};
	PointExtracter.prototype.getClass = function getClass() {
		return PointExtracter
	};
	PointExtracter.getPoints = function getPoints() {
		if (arguments.length === 1) {
			var geom = arguments[0];
			if (geom instanceof Point) {
				return Collections.singletonList(geom)
			}
			return PointExtracter.getPoints(geom, new ArrayList())
		} else if (arguments.length === 2) {
			var geom$1 = arguments[0];
			var list = arguments[1];
			if (geom$1 instanceof Point) {
				list.add(geom$1);
			} else if (geom$1 instanceof GeometryCollection) {
				geom$1.apply(new PointExtracter(list));
			}
			return list
		}
	};

	var ConnectedElementLocationFilter = function ConnectedElementLocationFilter() {
		this._locations = null;
		var locations = arguments[0];
		this._locations = locations;
	};
	ConnectedElementLocationFilter.prototype.filter = function filter(geom) {
		if (geom instanceof Point || geom instanceof LineString || geom instanceof Polygon) { this._locations.add(new GeometryLocation(geom, 0, geom.getCoordinate())); }
	};
	ConnectedElementLocationFilter.prototype.interfaces_ = function interfaces_() {
		return [GeometryFilter]
	};
	ConnectedElementLocationFilter.prototype.getClass = function getClass() {
		return ConnectedElementLocationFilter
	};
	ConnectedElementLocationFilter.getLocations = function getLocations(geom) {
		var locations = new ArrayList();
		geom.apply(new ConnectedElementLocationFilter(locations));
		return locations
	};

	var DistanceOp = function DistanceOp() {
		this._geom = null;
		this._terminateDistance = 0.0;
		this._ptLocator = new PointLocator();
		this._minDistanceLocation = null;
		this._minDistance = Double.MAX_VALUE;
		if (arguments.length === 2) {
			var g0 = arguments[0];
			var g1 = arguments[1];
			this._geom = [g0, g1];
			this._terminateDistance = 0.0;
		} else if (arguments.length === 3) {
			var g0$1 = arguments[0];
			var g1$1 = arguments[1];
			var terminateDistance = arguments[2];
			this._geom = new Array(2).fill(null);
			this._geom[0] = g0$1;
			this._geom[1] = g1$1;
			this._terminateDistance = terminateDistance;
		}
	};
	DistanceOp.prototype.computeContainmentDistance = function computeContainmentDistance() {
		var this$1$1 = this;

		if (arguments.length === 0) {
			var locPtPoly = new Array(2).fill(null);
			this.computeContainmentDistance(0, locPtPoly);
			if (this._minDistance <= this._terminateDistance) { return null }
			this.computeContainmentDistance(1, locPtPoly);
		} else if (arguments.length === 2) {
			var polyGeomIndex = arguments[0];
			var locPtPoly$1 = arguments[1];
			var locationsIndex = 1 - polyGeomIndex;
			var polys = PolygonExtracter.getPolygons(this._geom[polyGeomIndex]);
			if (polys.size() > 0) {
				var insideLocs = ConnectedElementLocationFilter.getLocations(this._geom[locationsIndex]);
				this.computeContainmentDistance(insideLocs, polys, locPtPoly$1);
				if (this._minDistance <= this._terminateDistance) {
					this._minDistanceLocation[locationsIndex] = locPtPoly$1[0];
					this._minDistanceLocation[polyGeomIndex] = locPtPoly$1[1];
					return null
				}
			}
		} else if (arguments.length === 3) {
			if (arguments[2] instanceof Array && (hasInterface(arguments[0], List) && hasInterface(arguments[1], List))) {
				var locs = arguments[0];
				var polys$1 = arguments[1];
				var locPtPoly$2 = arguments[2];
				for (var i = 0; i < locs.size(); i++) {
					var loc = locs.get(i);
					for (var j = 0; j < polys$1.size(); j++) {
						this$1$1.computeContainmentDistance(loc, polys$1.get(j), locPtPoly$2);
						if (this$1$1._minDistance <= this$1$1._terminateDistance) { return null }
					}
				}
			} else if (arguments[2] instanceof Array && (arguments[0] instanceof GeometryLocation && arguments[1] instanceof Polygon)) {
				var ptLoc = arguments[0];
				var poly = arguments[1];
				var locPtPoly$3 = arguments[2];
				var pt = ptLoc.getCoordinate();
				if (Location.EXTERIOR !== this._ptLocator.locate(pt, poly)) {
					this._minDistance = 0.0;
					locPtPoly$3[0] = ptLoc;
					locPtPoly$3[1] = new GeometryLocation(poly, pt);

					return null
				}
			}
		}
	};
	DistanceOp.prototype.computeMinDistanceLinesPoints = function computeMinDistanceLinesPoints(lines, points, locGeom) {
		var this$1$1 = this;

		for (var i = 0; i < lines.size(); i++) {
			var line = lines.get(i);
			for (var j = 0; j < points.size(); j++) {
				var pt = points.get(j);
				this$1$1.computeMinDistance(line, pt, locGeom);
				if (this$1$1._minDistance <= this$1$1._terminateDistance) { return null }
			}
		}
	};
	DistanceOp.prototype.computeFacetDistance = function computeFacetDistance() {
		var locGeom = new Array(2).fill(null);
		var lines0 = LinearComponentExtracter.getLines(this._geom[0]);
		var lines1 = LinearComponentExtracter.getLines(this._geom[1]);
		var pts0 = PointExtracter.getPoints(this._geom[0]);
		var pts1 = PointExtracter.getPoints(this._geom[1]);
		this.computeMinDistanceLines(lines0, lines1, locGeom);
		this.updateMinDistance(locGeom, false);
		if (this._minDistance <= this._terminateDistance) { return null }
		locGeom[0] = null;
		locGeom[1] = null;
		this.computeMinDistanceLinesPoints(lines0, pts1, locGeom);
		this.updateMinDistance(locGeom, false);
		if (this._minDistance <= this._terminateDistance) { return null }
		locGeom[0] = null;
		locGeom[1] = null;
		this.computeMinDistanceLinesPoints(lines1, pts0, locGeom);
		this.updateMinDistance(locGeom, true);
		if (this._minDistance <= this._terminateDistance) { return null }
		locGeom[0] = null;
		locGeom[1] = null;
		this.computeMinDistancePoints(pts0, pts1, locGeom);
		this.updateMinDistance(locGeom, false);
	};
	DistanceOp.prototype.nearestLocations = function nearestLocations() {
		this.computeMinDistance();
		return this._minDistanceLocation
	};
	DistanceOp.prototype.updateMinDistance = function updateMinDistance(locGeom, flip) {
		if (locGeom[0] === null) { return null }
		if (flip) {
			this._minDistanceLocation[0] = locGeom[1];
			this._minDistanceLocation[1] = locGeom[0];
		} else {
			this._minDistanceLocation[0] = locGeom[0];
			this._minDistanceLocation[1] = locGeom[1];
		}
	};
	DistanceOp.prototype.nearestPoints = function nearestPoints() {
		this.computeMinDistance();
		var nearestPts = [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];
		return nearestPts
	};
	DistanceOp.prototype.computeMinDistance = function computeMinDistance() {
		var this$1$1 = this;

		if (arguments.length === 0) {
			if (this._minDistanceLocation !== null) { return null }
			this._minDistanceLocation = new Array(2).fill(null);
			this.computeContainmentDistance();
			if (this._minDistance <= this._terminateDistance) { return null }
			this.computeFacetDistance();
		} else if (arguments.length === 3) {
			if (arguments[2] instanceof Array && (arguments[0] instanceof LineString && arguments[1] instanceof Point)) {
				var line = arguments[0];
				var pt = arguments[1];
				var locGeom = arguments[2];
				if (line.getEnvelopeInternal().distance(pt.getEnvelopeInternal()) > this._minDistance) { return null }
				var coord0 = line.getCoordinates();
				var coord = pt.getCoordinate();
				for (var i = 0; i < coord0.length - 1; i++) {
					var dist = CGAlgorithms.distancePointLine(coord, coord0[i], coord0[i + 1]);
					if (dist < this$1$1._minDistance) {
						this$1$1._minDistance = dist;
						var seg = new LineSegment(coord0[i], coord0[i + 1]);
						var segClosestPoint = seg.closestPoint(coord);
						locGeom[0] = new GeometryLocation(line, i, segClosestPoint);
						locGeom[1] = new GeometryLocation(pt, 0, coord);
					}
					if (this$1$1._minDistance <= this$1$1._terminateDistance) { return null }
				}
			} else if (arguments[2] instanceof Array && (arguments[0] instanceof LineString && arguments[1] instanceof LineString)) {
				var line0 = arguments[0];
				var line1 = arguments[1];
				var locGeom$1 = arguments[2];
				if (line0.getEnvelopeInternal().distance(line1.getEnvelopeInternal()) > this._minDistance) { return null }
				var coord0$1 = line0.getCoordinates();
				var coord1 = line1.getCoordinates();
				for (var i$1 = 0; i$1 < coord0$1.length - 1; i$1++) {
					for (var j = 0; j < coord1.length - 1; j++) {
						var dist$1 = CGAlgorithms.distanceLineLine(coord0$1[i$1], coord0$1[i$1 + 1], coord1[j], coord1[j + 1]);
						if (dist$1 < this$1$1._minDistance) {
							this$1$1._minDistance = dist$1;
							var seg0 = new LineSegment(coord0$1[i$1], coord0$1[i$1 + 1]);
							var seg1 = new LineSegment(coord1[j], coord1[j + 1]);
							var closestPt = seg0.closestPoints(seg1);
							locGeom$1[0] = new GeometryLocation(line0, i$1, closestPt[0]);
							locGeom$1[1] = new GeometryLocation(line1, j, closestPt[1]);
						}
						if (this$1$1._minDistance <= this$1$1._terminateDistance) { return null }
					}
				}
			}
		}
	};
	DistanceOp.prototype.computeMinDistancePoints = function computeMinDistancePoints(points0, points1, locGeom) {
		var this$1$1 = this;

		for (var i = 0; i < points0.size(); i++) {
			var pt0 = points0.get(i);
			for (var j = 0; j < points1.size(); j++) {
				var pt1 = points1.get(j);
				var dist = pt0.getCoordinate().distance(pt1.getCoordinate());
				if (dist < this$1$1._minDistance) {
					this$1$1._minDistance = dist;
					locGeom[0] = new GeometryLocation(pt0, 0, pt0.getCoordinate());
					locGeom[1] = new GeometryLocation(pt1, 0, pt1.getCoordinate());
				}
				if (this$1$1._minDistance <= this$1$1._terminateDistance) { return null }
			}
		}
	};
	DistanceOp.prototype.distance = function distance() {
		if (this._geom[0] === null || this._geom[1] === null) { throw new IllegalArgumentException('null geometries are not supported') }
		if (this._geom[0].isEmpty() || this._geom[1].isEmpty()) { return 0.0 }
		this.computeMinDistance();
		return this._minDistance
	};
	DistanceOp.prototype.computeMinDistanceLines = function computeMinDistanceLines(lines0, lines1, locGeom) {
		var this$1$1 = this;

		for (var i = 0; i < lines0.size(); i++) {
			var line0 = lines0.get(i);
			for (var j = 0; j < lines1.size(); j++) {
				var line1 = lines1.get(j);
				this$1$1.computeMinDistance(line0, line1, locGeom);
				if (this$1$1._minDistance <= this$1$1._terminateDistance) { return null }
			}
		}
	};
	DistanceOp.prototype.interfaces_ = function interfaces_() {
		return []
	};
	DistanceOp.prototype.getClass = function getClass() {
		return DistanceOp
	};
	DistanceOp.distance = function distance(g0, g1) {
		var distOp = new DistanceOp(g0, g1);
		return distOp.distance()
	};
	DistanceOp.isWithinDistance = function isWithinDistance(g0, g1, distance) {
		var distOp = new DistanceOp(g0, g1, distance);
		return distOp.distance() <= distance
	};
	DistanceOp.nearestPoints = function nearestPoints(g0, g1) {
		var distOp = new DistanceOp(g0, g1);
		return distOp.nearestPoints()
	};

	var PointPairDistance$2 = function PointPairDistance() {
		this._pt = [new Coordinate(), new Coordinate()];
		this._distance = Double.NaN;
		this._isNull = true;
	};
	PointPairDistance$2.prototype.getCoordinates = function getCoordinates() {
		return this._pt
	};
	PointPairDistance$2.prototype.getCoordinate = function getCoordinate(i) {
		return this._pt[i]
	};
	PointPairDistance$2.prototype.setMinimum = function setMinimum() {
		if (arguments.length === 1) {
			var ptDist = arguments[0];
			this.setMinimum(ptDist._pt[0], ptDist._pt[1]);
		} else if (arguments.length === 2) {
			var p0 = arguments[0];
			var p1 = arguments[1];
			if (this._isNull) {
				this.initialize(p0, p1);
				return null
			}
			var dist = p0.distance(p1);
			if (dist < this._distance) { this.initialize(p0, p1, dist); }
		}
	};
	PointPairDistance$2.prototype.initialize = function initialize() {
		if (arguments.length === 0) {
			this._isNull = true;
		} else if (arguments.length === 2) {
			var p0 = arguments[0];
			var p1 = arguments[1];
			this._pt[0].setCoordinate(p0);
			this._pt[1].setCoordinate(p1);
			this._distance = p0.distance(p1);
			this._isNull = false;
		} else if (arguments.length === 3) {
			var p0$1 = arguments[0];
			var p1$1 = arguments[1];
			var distance = arguments[2];
			this._pt[0].setCoordinate(p0$1);
			this._pt[1].setCoordinate(p1$1);
			this._distance = distance;
			this._isNull = false;
		}
	};
	PointPairDistance$2.prototype.toString = function toString() {
		return WKTWriter.toLineString(this._pt[0], this._pt[1])
	};
	PointPairDistance$2.prototype.getDistance = function getDistance() {
		return this._distance
	};
	PointPairDistance$2.prototype.setMaximum = function setMaximum() {
		if (arguments.length === 1) {
			var ptDist = arguments[0];
			this.setMaximum(ptDist._pt[0], ptDist._pt[1]);
		} else if (arguments.length === 2) {
			var p0 = arguments[0];
			var p1 = arguments[1];
			if (this._isNull) {
				this.initialize(p0, p1);
				return null
			}
			var dist = p0.distance(p1);
			if (dist > this._distance) { this.initialize(p0, p1, dist); }
		}
	};
	PointPairDistance$2.prototype.interfaces_ = function interfaces_() {
		return []
	};
	PointPairDistance$2.prototype.getClass = function getClass() {
		return PointPairDistance$2
	};

	var DistanceToPoint = function DistanceToPoint() { };

	DistanceToPoint.prototype.interfaces_ = function interfaces_() {
		return []
	};
	DistanceToPoint.prototype.getClass = function getClass() {
		return DistanceToPoint
	};
	DistanceToPoint.computeDistance = function computeDistance() {
		if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof LineString && arguments[1] instanceof Coordinate)) {
			var line = arguments[0];
			var pt = arguments[1];
			var ptDist = arguments[2];
			var tempSegment = new LineSegment();
			var coords = line.getCoordinates();
			for (var i = 0; i < coords.length - 1; i++) {
				tempSegment.setCoordinates(coords[i], coords[i + 1]);
				var closestPt = tempSegment.closestPoint(pt);
				ptDist.setMinimum(closestPt, pt);
			}
		} else if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof Polygon && arguments[1] instanceof Coordinate)) {
			var poly = arguments[0];
			var pt$1 = arguments[1];
			var ptDist$1 = arguments[2];
			DistanceToPoint.computeDistance(poly.getExteriorRing(), pt$1, ptDist$1);
			for (var i$1 = 0; i$1 < poly.getNumInteriorRing(); i$1++) {
				DistanceToPoint.computeDistance(poly.getInteriorRingN(i$1), pt$1, ptDist$1);
			}
		} else if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof Geometry && arguments[1] instanceof Coordinate)) {
			var geom = arguments[0];
			var pt$2 = arguments[1];
			var ptDist$2 = arguments[2];
			if (geom instanceof LineString) {
				DistanceToPoint.computeDistance(geom, pt$2, ptDist$2);
			} else if (geom instanceof Polygon) {
				DistanceToPoint.computeDistance(geom, pt$2, ptDist$2);
			} else if (geom instanceof GeometryCollection) {
				var gc = geom;
				for (var i$2 = 0; i$2 < gc.getNumGeometries(); i$2++) {
					var g = gc.getGeometryN(i$2);
					DistanceToPoint.computeDistance(g, pt$2, ptDist$2);
				}
			} else {
				ptDist$2.setMinimum(geom.getCoordinate(), pt$2);
			}
		} else if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof LineSegment && arguments[1] instanceof Coordinate)) {
			var segment = arguments[0];
			var pt$3 = arguments[1];
			var ptDist$3 = arguments[2];
			var closestPt$1 = segment.closestPoint(pt$3);
			ptDist$3.setMinimum(closestPt$1, pt$3);
		}
	};

	var DiscreteHausdorffDistance = function DiscreteHausdorffDistance() {
		this._g0 = null;
		this._g1 = null;
		this._ptDist = new PointPairDistance$2();
		this._densifyFrac = 0.0;
		var g0 = arguments[0];
		var g1 = arguments[1];
		this._g0 = g0;
		this._g1 = g1;
	};

	var staticAccessors$39 = { MaxPointDistanceFilter: { configurable: true }, MaxDensifiedByFractionDistanceFilter: { configurable: true } };
	DiscreteHausdorffDistance.prototype.getCoordinates = function getCoordinates() {
		return this._ptDist.getCoordinates()
	};
	DiscreteHausdorffDistance.prototype.setDensifyFraction = function setDensifyFraction(densifyFrac) {
		if (densifyFrac > 1.0 || densifyFrac <= 0.0) { throw new IllegalArgumentException('Fraction is not in range (0.0 - 1.0]') }
		this._densifyFrac = densifyFrac;
	};
	DiscreteHausdorffDistance.prototype.compute = function compute(g0, g1) {
		this.computeOrientedDistance(g0, g1, this._ptDist);
		this.computeOrientedDistance(g1, g0, this._ptDist);
	};
	DiscreteHausdorffDistance.prototype.distance = function distance() {
		this.compute(this._g0, this._g1);
		return this._ptDist.getDistance()
	};
	DiscreteHausdorffDistance.prototype.computeOrientedDistance = function computeOrientedDistance(discreteGeom, geom, ptDist) {
		var distFilter = new MaxPointDistanceFilter$1(geom);
		discreteGeom.apply(distFilter);
		ptDist.setMaximum(distFilter.getMaxPointDistance());
		if (this._densifyFrac > 0) {
			var fracFilter = new MaxDensifiedByFractionDistanceFilter(geom, this._densifyFrac);
			discreteGeom.apply(fracFilter);
			ptDist.setMaximum(fracFilter.getMaxPointDistance());
		}
	};
	DiscreteHausdorffDistance.prototype.orientedDistance = function orientedDistance() {
		this.computeOrientedDistance(this._g0, this._g1, this._ptDist);
		return this._ptDist.getDistance()
	};
	DiscreteHausdorffDistance.prototype.interfaces_ = function interfaces_() {
		return []
	};
	DiscreteHausdorffDistance.prototype.getClass = function getClass() {
		return DiscreteHausdorffDistance
	};
	DiscreteHausdorffDistance.distance = function distance() {
		if (arguments.length === 2) {
			var g0 = arguments[0];
			var g1 = arguments[1];
			var dist = new DiscreteHausdorffDistance(g0, g1);
			return dist.distance()
		} else if (arguments.length === 3) {
			var g0$1 = arguments[0];
			var g1$1 = arguments[1];
			var densifyFrac = arguments[2];
			var dist$1 = new DiscreteHausdorffDistance(g0$1, g1$1);
			dist$1.setDensifyFraction(densifyFrac);
			return dist$1.distance()
		}
	};
	staticAccessors$39.MaxPointDistanceFilter.get = function () { return MaxPointDistanceFilter$1 };
	staticAccessors$39.MaxDensifiedByFractionDistanceFilter.get = function () { return MaxDensifiedByFractionDistanceFilter };

	Object.defineProperties(DiscreteHausdorffDistance, staticAccessors$39);

	var MaxPointDistanceFilter$1 = function MaxPointDistanceFilter() {
		this._maxPtDist = new PointPairDistance$2();
		this._minPtDist = new PointPairDistance$2();
		this._euclideanDist = new DistanceToPoint();
		this._geom = null;
		var geom = arguments[0];
		this._geom = geom;
	};
	MaxPointDistanceFilter$1.prototype.filter = function filter(pt) {
		this._minPtDist.initialize();
		DistanceToPoint.computeDistance(this._geom, pt, this._minPtDist);
		this._maxPtDist.setMaximum(this._minPtDist);
	};
	MaxPointDistanceFilter$1.prototype.getMaxPointDistance = function getMaxPointDistance() {
		return this._maxPtDist
	};
	MaxPointDistanceFilter$1.prototype.interfaces_ = function interfaces_() {
		return [CoordinateFilter]
	};
	MaxPointDistanceFilter$1.prototype.getClass = function getClass() {
		return MaxPointDistanceFilter$1
	};

	var MaxDensifiedByFractionDistanceFilter = function MaxDensifiedByFractionDistanceFilter() {
		this._maxPtDist = new PointPairDistance$2();
		this._minPtDist = new PointPairDistance$2();
		this._geom = null;
		this._numSubSegs = 0;
		var geom = arguments[0];
		var fraction = arguments[1];
		this._geom = geom;
		this._numSubSegs = Math.trunc(Math.round(1.0 / fraction));
	};
	MaxDensifiedByFractionDistanceFilter.prototype.filter = function filter(seq, index) {
		var this$1$1 = this;

		if (index === 0) { return null }
		var p0 = seq.getCoordinate(index - 1);
		var p1 = seq.getCoordinate(index);
		var delx = (p1.x - p0.x) / this._numSubSegs;
		var dely = (p1.y - p0.y) / this._numSubSegs;
		for (var i = 0; i < this._numSubSegs; i++) {
			var x = p0.x + i * delx;
			var y = p0.y + i * dely;
			var pt = new Coordinate(x, y);
			this$1$1._minPtDist.initialize();
			DistanceToPoint.computeDistance(this$1$1._geom, pt, this$1$1._minPtDist);
			this$1$1._maxPtDist.setMaximum(this$1$1._minPtDist);
		}
	};
	MaxDensifiedByFractionDistanceFilter.prototype.isDone = function isDone() {
		return false
	};
	MaxDensifiedByFractionDistanceFilter.prototype.isGeometryChanged = function isGeometryChanged() {
		return false
	};
	MaxDensifiedByFractionDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance() {
		return this._maxPtDist
	};
	MaxDensifiedByFractionDistanceFilter.prototype.interfaces_ = function interfaces_() {
		return [CoordinateSequenceFilter]
	};
	MaxDensifiedByFractionDistanceFilter.prototype.getClass = function getClass() {
		return MaxDensifiedByFractionDistanceFilter
	};

	var BufferDistanceValidator = function BufferDistanceValidator(input, bufDistance, result) {
		this._minValidDistance = null;
		this._maxValidDistance = null;
		this._minDistanceFound = null;
		this._maxDistanceFound = null;
		this._isValid = true;
		this._errMsg = null;
		this._errorLocation = null;
		this._errorIndicator = null;
		this._input = input || null;
		this._bufDistance = bufDistance || null;
		this._result = result || null;
	};

	var staticAccessors$37 = { VERBOSE: { configurable: true }, MAX_DISTANCE_DIFF_FRAC: { configurable: true } };
	BufferDistanceValidator.prototype.checkMaximumDistance = function checkMaximumDistance(input, bufCurve, maxDist) {
		var haus = new DiscreteHausdorffDistance(bufCurve, input);
		haus.setDensifyFraction(0.25);
		this._maxDistanceFound = haus.orientedDistance();
		if (this._maxDistanceFound > maxDist) {
			this._isValid = false;
			var pts = haus.getCoordinates();
			this._errorLocation = pts[1];
			this._errorIndicator = input.getFactory().createLineString(pts);
			this._errMsg = 'Distance between buffer curve and input is too large (' + this._maxDistanceFound + ' at ' + WKTWriter.toLineString(pts[0], pts[1]) + ')';
		}
	};
	BufferDistanceValidator.prototype.isValid = function isValid() {
		var posDistance = Math.abs(this._bufDistance);
		var distDelta = BufferDistanceValidator.MAX_DISTANCE_DIFF_FRAC * posDistance;
		this._minValidDistance = posDistance - distDelta;
		this._maxValidDistance = posDistance + distDelta;
		if (this._input.isEmpty() || this._result.isEmpty()) { return true }
		if (this._bufDistance > 0.0) {
			this.checkPositiveValid();
		} else {
			this.checkNegativeValid();
		}
		if (BufferDistanceValidator.VERBOSE) {
			System.out.println('Min Dist= ' + this._minDistanceFound + '  err= ' + (1.0 - this._minDistanceFound / this._bufDistance) + '  Max Dist= ' + this._maxDistanceFound + '  err= ' + (this._maxDistanceFound / this._bufDistance - 1.0));
		}
		return this._isValid
	};
	BufferDistanceValidator.prototype.checkNegativeValid = function checkNegativeValid() {
		if (!(this._input instanceof Polygon || this._input instanceof MultiPolygon || this._input instanceof GeometryCollection)) {
			return null
		}
		var inputCurve = this.getPolygonLines(this._input);
		this.checkMinimumDistance(inputCurve, this._result, this._minValidDistance);
		if (!this._isValid) { return null }
		this.checkMaximumDistance(inputCurve, this._result, this._maxValidDistance);
	};
	BufferDistanceValidator.prototype.getErrorIndicator = function getErrorIndicator() {
		return this._errorIndicator
	};
	BufferDistanceValidator.prototype.checkMinimumDistance = function checkMinimumDistance(g1, g2, minDist) {
		var distOp = new DistanceOp(g1, g2, minDist);
		this._minDistanceFound = distOp.distance();
		if (this._minDistanceFound < minDist) {
			this._isValid = false;
			var pts = distOp.nearestPoints();
			this._errorLocation = distOp.nearestPoints()[1];
			this._errorIndicator = g1.getFactory().createLineString(pts);
			this._errMsg = 'Distance between buffer curve and input is too small (' + this._minDistanceFound + ' at ' + WKTWriter.toLineString(pts[0], pts[1]) + ' )';
		}
	};
	BufferDistanceValidator.prototype.checkPositiveValid = function checkPositiveValid() {
		var bufCurve = this._result.getBoundary();
		this.checkMinimumDistance(this._input, bufCurve, this._minValidDistance);
		if (!this._isValid) { return null }
		this.checkMaximumDistance(this._input, bufCurve, this._maxValidDistance);
	};
	BufferDistanceValidator.prototype.getErrorLocation = function getErrorLocation() {
		return this._errorLocation
	};
	BufferDistanceValidator.prototype.getPolygonLines = function getPolygonLines(g) {
		var lines = new ArrayList();
		var lineExtracter = new LinearComponentExtracter(lines);
		var polys = PolygonExtracter.getPolygons(g);
		for (var i = polys.iterator(); i.hasNext();) {
			var poly = i.next();
			poly.apply(lineExtracter);
		}
		return g.getFactory().buildGeometry(lines)
	};
	BufferDistanceValidator.prototype.getErrorMessage = function getErrorMessage() {
		return this._errMsg
	};
	BufferDistanceValidator.prototype.interfaces_ = function interfaces_() {
		return []
	};
	BufferDistanceValidator.prototype.getClass = function getClass() {
		return BufferDistanceValidator
	};
	staticAccessors$37.VERBOSE.get = function () { return false };
	staticAccessors$37.MAX_DISTANCE_DIFF_FRAC.get = function () { return 0.012 };

	Object.defineProperties(BufferDistanceValidator, staticAccessors$37);

	var BufferResultValidator = function BufferResultValidator(input, distance, result) {
		this._isValid = true;
		this._errorMsg = null;
		this._errorLocation = null;
		this._errorIndicator = null;
		this._input = input || null;
		this._distance = distance || null;
		this._result = result || null;
	};

	var staticAccessors$40 = { VERBOSE: { configurable: true }, MAX_ENV_DIFF_FRAC: { configurable: true } };
	BufferResultValidator.prototype.isValid = function isValid() {
		this.checkPolygonal();
		if (!this._isValid) { return this._isValid }
		this.checkExpectedEmpty();
		if (!this._isValid) { return this._isValid }
		this.checkEnvelope();
		if (!this._isValid) { return this._isValid }
		this.checkArea();
		if (!this._isValid) { return this._isValid }
		this.checkDistance();
		return this._isValid
	};
	BufferResultValidator.prototype.checkEnvelope = function checkEnvelope() {
		if (this._distance < 0.0) { return null }
		var padding = this._distance * BufferResultValidator.MAX_ENV_DIFF_FRAC;
		if (padding === 0.0) { padding = 0.001; }
		var expectedEnv = new Envelope(this._input.getEnvelopeInternal());
		expectedEnv.expandBy(this._distance);
		var bufEnv = new Envelope(this._result.getEnvelopeInternal());
		bufEnv.expandBy(padding);
		if (!bufEnv.contains(expectedEnv)) {
			this._isValid = false;
			this._errorMsg = 'Buffer envelope is incorrect';
			this._errorIndicator = this._input.getFactory().toGeometry(bufEnv);
		}
		this.report('Envelope');
	};
	BufferResultValidator.prototype.checkDistance = function checkDistance() {
		var distValid = new BufferDistanceValidator(this._input, this._distance, this._result);
		if (!distValid.isValid()) {
			this._isValid = false;
			this._errorMsg = distValid.getErrorMessage();
			this._errorLocation = distValid.getErrorLocation();
			this._errorIndicator = distValid.getErrorIndicator();
		}
		this.report('Distance');
	};
	BufferResultValidator.prototype.checkArea = function checkArea() {
		var inputArea = this._input.getArea();
		var resultArea = this._result.getArea();
		if (this._distance > 0.0 && inputArea > resultArea) {
			this._isValid = false;
			this._errorMsg = 'Area of positive buffer is smaller than input';
			this._errorIndicator = this._result;
		}
		if (this._distance < 0.0 && inputArea < resultArea) {
			this._isValid = false;
			this._errorMsg = 'Area of negative buffer is larger than input';
			this._errorIndicator = this._result;
		}
		this.report('Area');
	};
	BufferResultValidator.prototype.checkPolygonal = function checkPolygonal() {
		if (!(this._result instanceof Polygon || this._result instanceof MultiPolygon)) { this._isValid = false; }
		this._errorMsg = 'Result is not polygonal';
		this._errorIndicator = this._result;
		this.report('Polygonal');
	};
	BufferResultValidator.prototype.getErrorIndicator = function getErrorIndicator() {
		return this._errorIndicator
	};
	BufferResultValidator.prototype.getErrorLocation = function getErrorLocation() {
		return this._errorLocation
	};
	BufferResultValidator.prototype.checkExpectedEmpty = function checkExpectedEmpty() {
		if (this._input.getDimension() >= 2) { return null }
		if (this._distance > 0.0) { return null }
		if (!this._result.isEmpty()) {
			this._isValid = false;
			this._errorMsg = 'Result is non-empty';
			this._errorIndicator = this._result;
		}
		this.report('ExpectedEmpty');
	};
	BufferResultValidator.prototype.report = function report(checkName) {
		if (!BufferResultValidator.VERBOSE) { return null }
		System.out.println('Check ' + checkName + ': ' + (this._isValid ? 'passed' : 'FAILED'));
	};
	BufferResultValidator.prototype.getErrorMessage = function getErrorMessage() {
		return this._errorMsg
	};
	BufferResultValidator.prototype.interfaces_ = function interfaces_() {
		return []
	};
	BufferResultValidator.prototype.getClass = function getClass() {
		return BufferResultValidator
	};
	BufferResultValidator.isValidMsg = function isValidMsg(g, distance, result) {
		var validator = new BufferResultValidator(g, distance, result);
		if (!validator.isValid()) { return validator.getErrorMessage() }
		return null
	};
	BufferResultValidator.isValid = function isValid(g, distance, result) {
		var validator = new BufferResultValidator(g, distance, result);
		if (validator.isValid()) { return true }
		return false
	};
	staticAccessors$40.VERBOSE.get = function () { return false };
	staticAccessors$40.MAX_ENV_DIFF_FRAC.get = function () { return 0.012 };

	Object.defineProperties(BufferResultValidator, staticAccessors$40);

	// operation.buffer

	var BasicSegmentString = function BasicSegmentString() {
		this._pts = null;
		this._data = null;
		var pts = arguments[0];
		var data = arguments[1];
		this._pts = pts;
		this._data = data;
	};
	BasicSegmentString.prototype.getCoordinates = function getCoordinates() {
		return this._pts
	};
	BasicSegmentString.prototype.size = function size() {
		return this._pts.length
	};
	BasicSegmentString.prototype.getCoordinate = function getCoordinate(i) {
		return this._pts[i]
	};
	BasicSegmentString.prototype.isClosed = function isClosed() {
		return this._pts[0].equals(this._pts[this._pts.length - 1])
	};
	BasicSegmentString.prototype.getSegmentOctant = function getSegmentOctant(index) {
		if (index === this._pts.length - 1) { return -1 }
		return Octant.octant(this.getCoordinate(index), this.getCoordinate(index + 1))
	};
	BasicSegmentString.prototype.setData = function setData(data) {
		this._data = data;
	};
	BasicSegmentString.prototype.getData = function getData() {
		return this._data
	};
	BasicSegmentString.prototype.toString = function toString() {
		return WKTWriter.toLineString(new CoordinateArraySequence(this._pts))
	};
	BasicSegmentString.prototype.interfaces_ = function interfaces_() {
		return [SegmentString]
	};
	BasicSegmentString.prototype.getClass = function getClass() {
		return BasicSegmentString
	};

	var InteriorIntersectionFinder = function InteriorIntersectionFinder() {
		this._findAllIntersections = false;
		this._isCheckEndSegmentsOnly = false;
		this._li = null;
		this._interiorIntersection = null;
		this._intSegments = null;
		this._intersections = new ArrayList();
		this._intersectionCount = 0;
		this._keepIntersections = true;
		var li = arguments[0];
		this._li = li;
		this._interiorIntersection = null;
	};
	InteriorIntersectionFinder.prototype.getInteriorIntersection = function getInteriorIntersection() {
		return this._interiorIntersection
	};
	InteriorIntersectionFinder.prototype.setCheckEndSegmentsOnly = function setCheckEndSegmentsOnly(isCheckEndSegmentsOnly) {
		this._isCheckEndSegmentsOnly = isCheckEndSegmentsOnly;
	};
	InteriorIntersectionFinder.prototype.getIntersectionSegments = function getIntersectionSegments() {
		return this._intSegments
	};
	InteriorIntersectionFinder.prototype.count = function count() {
		return this._intersectionCount
	};
	InteriorIntersectionFinder.prototype.getIntersections = function getIntersections() {
		return this._intersections
	};
	InteriorIntersectionFinder.prototype.setFindAllIntersections = function setFindAllIntersections(findAllIntersections) {
		this._findAllIntersections = findAllIntersections;
	};
	InteriorIntersectionFinder.prototype.setKeepIntersections = function setKeepIntersections(keepIntersections) {
		this._keepIntersections = keepIntersections;
	};
	InteriorIntersectionFinder.prototype.processIntersections = function processIntersections(e0, segIndex0, e1, segIndex1) {
		if (!this._findAllIntersections && this.hasIntersection()) { return null }
		if (e0 === e1 && segIndex0 === segIndex1) { return null }
		if (this._isCheckEndSegmentsOnly) {
			var isEndSegPresent = this.isEndSegment(e0, segIndex0) || this.isEndSegment(e1, segIndex1);
			if (!isEndSegPresent) { return null }
		}
		var p00 = e0.getCoordinates()[segIndex0];
		var p01 = e0.getCoordinates()[segIndex0 + 1];
		var p10 = e1.getCoordinates()[segIndex1];
		var p11 = e1.getCoordinates()[segIndex1 + 1];
		this._li.computeIntersection(p00, p01, p10, p11);
		if (this._li.hasIntersection()) {
			if (this._li.isInteriorIntersection()) {
				this._intSegments = new Array(4).fill(null);
				this._intSegments[0] = p00;
				this._intSegments[1] = p01;
				this._intSegments[2] = p10;
				this._intSegments[3] = p11;
				this._interiorIntersection = this._li.getIntersection(0);
				if (this._keepIntersections) { this._intersections.add(this._interiorIntersection); }
				this._intersectionCount++;
			}
		}
	};
	InteriorIntersectionFinder.prototype.isEndSegment = function isEndSegment(segStr, index) {
		if (index === 0) { return true }
		if (index >= segStr.size() - 2) { return true }
		return false
	};
	InteriorIntersectionFinder.prototype.hasIntersection = function hasIntersection() {
		return this._interiorIntersection !== null
	};
	InteriorIntersectionFinder.prototype.isDone = function isDone() {
		if (this._findAllIntersections) { return false }
		return this._interiorIntersection !== null
	};
	InteriorIntersectionFinder.prototype.interfaces_ = function interfaces_() {
		return [SegmentIntersector]
	};
	InteriorIntersectionFinder.prototype.getClass = function getClass() {
		return InteriorIntersectionFinder
	};
	InteriorIntersectionFinder.createAllIntersectionsFinder = function createAllIntersectionsFinder(li) {
		var finder = new InteriorIntersectionFinder(li);
		finder.setFindAllIntersections(true);
		return finder
	};
	InteriorIntersectionFinder.createAnyIntersectionFinder = function createAnyIntersectionFinder(li) {
		return new InteriorIntersectionFinder(li)
	};
	InteriorIntersectionFinder.createIntersectionCounter = function createIntersectionCounter(li) {
		var finder = new InteriorIntersectionFinder(li);
		finder.setFindAllIntersections(true);
		finder.setKeepIntersections(false);
		return finder
	};

	var FastNodingValidator = function FastNodingValidator() {
		this._li = new RobustLineIntersector();
		this._segStrings = null;
		this._findAllIntersections = false;
		this._segInt = null;
		this._isValid = true;
		var segStrings = arguments[0];
		this._segStrings = segStrings;
	};
	FastNodingValidator.prototype.execute = function execute() {
		if (this._segInt !== null) { return null }
		this.checkInteriorIntersections();
	};
	FastNodingValidator.prototype.getIntersections = function getIntersections() {
		return this._segInt.getIntersections()
	};
	FastNodingValidator.prototype.isValid = function isValid() {
		this.execute();
		return this._isValid
	};
	FastNodingValidator.prototype.setFindAllIntersections = function setFindAllIntersections(findAllIntersections) {
		this._findAllIntersections = findAllIntersections;
	};
	FastNodingValidator.prototype.checkInteriorIntersections = function checkInteriorIntersections() {
		this._isValid = true;
		this._segInt = new InteriorIntersectionFinder(this._li);
		this._segInt.setFindAllIntersections(this._findAllIntersections);
		var noder = new MCIndexNoder();
		noder.setSegmentIntersector(this._segInt);
		noder.computeNodes(this._segStrings);
		if (this._segInt.hasIntersection()) {
			this._isValid = false;
			return null
		}
	};
	FastNodingValidator.prototype.checkValid = function checkValid() {
		this.execute();
		if (!this._isValid) { throw new TopologyException(this.getErrorMessage(), this._segInt.getInteriorIntersection()) }
	};
	FastNodingValidator.prototype.getErrorMessage = function getErrorMessage() {
		if (this._isValid) { return 'no intersections found' }
		var intSegs = this._segInt.getIntersectionSegments();
		return 'found non-noded intersection between ' + WKTWriter.toLineString(intSegs[0], intSegs[1]) + ' and ' + WKTWriter.toLineString(intSegs[2], intSegs[3])
	};
	FastNodingValidator.prototype.interfaces_ = function interfaces_() {
		return []
	};
	FastNodingValidator.prototype.getClass = function getClass() {
		return FastNodingValidator
	};
	FastNodingValidator.computeIntersections = function computeIntersections(segStrings) {
		var nv = new FastNodingValidator(segStrings);
		nv.setFindAllIntersections(true);
		nv.isValid();
		return nv.getIntersections()
	};

	var EdgeNodingValidator = function EdgeNodingValidator() {
		this._nv = null;
		var edges = arguments[0];
		this._nv = new FastNodingValidator(EdgeNodingValidator.toSegmentStrings(edges));
	};
	EdgeNodingValidator.prototype.checkValid = function checkValid() {
		this._nv.checkValid();
	};
	EdgeNodingValidator.prototype.interfaces_ = function interfaces_() {
		return []
	};
	EdgeNodingValidator.prototype.getClass = function getClass() {
		return EdgeNodingValidator
	};
	EdgeNodingValidator.toSegmentStrings = function toSegmentStrings(edges) {
		var segStrings = new ArrayList();
		for (var i = edges.iterator(); i.hasNext();) {
			var e = i.next();
			segStrings.add(new BasicSegmentString(e.getCoordinates(), e));
		}
		return segStrings
	};
	EdgeNodingValidator.checkValid = function checkValid(edges) {
		var validator = new EdgeNodingValidator(edges);
		validator.checkValid();
	};

	var GeometryCollectionMapper = function GeometryCollectionMapper(mapOp) {
		this._mapOp = mapOp;
	};
	GeometryCollectionMapper.prototype.map = function map(gc) {
		var this$1$1 = this;

		var mapped = new ArrayList();
		for (var i = 0; i < gc.getNumGeometries(); i++) {
			var g = this$1$1._mapOp.map(gc.getGeometryN(i));
			if (!g.isEmpty()) { mapped.add(g); }
		}
		return gc.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(mapped))
	};
	GeometryCollectionMapper.prototype.interfaces_ = function interfaces_() {
		return []
	};
	GeometryCollectionMapper.prototype.getClass = function getClass() {
		return GeometryCollectionMapper
	};
	GeometryCollectionMapper.map = function map(gc, op) {
		var mapper = new GeometryCollectionMapper(op);
		return mapper.map(gc)
	};

	var LineBuilder = function LineBuilder() {
		this._op = null;
		this._geometryFactory = null;
		this._ptLocator = null;
		this._lineEdgesList = new ArrayList();
		this._resultLineList = new ArrayList();
		var op = arguments[0];
		var geometryFactory = arguments[1];
		var ptLocator = arguments[2];
		this._op = op;
		this._geometryFactory = geometryFactory;
		this._ptLocator = ptLocator;
	};
	LineBuilder.prototype.collectLines = function collectLines(opCode) {
		var this$1$1 = this;

		for (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {
			var de = it.next();
			this$1$1.collectLineEdge(de, opCode, this$1$1._lineEdgesList);
			this$1$1.collectBoundaryTouchEdge(de, opCode, this$1$1._lineEdgesList);
		}
	};
	LineBuilder.prototype.labelIsolatedLine = function labelIsolatedLine(e, targetIndex) {
		var loc = this._ptLocator.locate(e.getCoordinate(), this._op.getArgGeometry(targetIndex));
		e.getLabel().setLocation(targetIndex, loc);
	};
	LineBuilder.prototype.build = function build(opCode) {
		this.findCoveredLineEdges();
		this.collectLines(opCode);
		this.buildLines(opCode);
		return this._resultLineList
	};
	LineBuilder.prototype.collectLineEdge = function collectLineEdge(de, opCode, edges) {
		var label = de.getLabel();
		var e = de.getEdge();
		if (de.isLineEdge()) {
			if (!de.isVisited() && OverlayOp.isResultOfOp(label, opCode) && !e.isCovered()) {
				edges.add(e);
				de.setVisitedEdge(true);
			}
		}
	};
	LineBuilder.prototype.findCoveredLineEdges = function findCoveredLineEdges() {
		var this$1$1 = this;

		for (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {
			var node = nodeit.next();
			node.getEdges().findCoveredLineEdges();
		}
		for (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {
			var de = it.next();
			var e = de.getEdge();
			if (de.isLineEdge() && !e.isCoveredSet()) {
				var isCovered = this$1$1._op.isCoveredByA(de.getCoordinate());
				e.setCovered(isCovered);
			}
		}
	};
	LineBuilder.prototype.labelIsolatedLines = function labelIsolatedLines(edgesList) {
		var this$1$1 = this;

		for (var it = edgesList.iterator(); it.hasNext();) {
			var e = it.next();
			var label = e.getLabel();
			if (e.isIsolated()) {
				if (label.isNull(0)) { this$1$1.labelIsolatedLine(e, 0); } else { this$1$1.labelIsolatedLine(e, 1); }
			}
		}
	};
	LineBuilder.prototype.buildLines = function buildLines(opCode) {
		var this$1$1 = this;

		for (var it = this._lineEdgesList.iterator(); it.hasNext();) {
			var e = it.next();
			// const label = e.getLabel()
			var line = this$1$1._geometryFactory.createLineString(e.getCoordinates());
			this$1$1._resultLineList.add(line);
			e.setInResult(true);
		}
	};
	LineBuilder.prototype.collectBoundaryTouchEdge = function collectBoundaryTouchEdge(de, opCode, edges) {
		var label = de.getLabel();
		if (de.isLineEdge()) { return null }
		if (de.isVisited()) { return null }
		if (de.isInteriorAreaEdge()) { return null }
		if (de.getEdge().isInResult()) { return null }
		Assert.isTrue(!(de.isInResult() || de.getSym().isInResult()) || !de.getEdge().isInResult());
		if (OverlayOp.isResultOfOp(label, opCode) && opCode === OverlayOp.INTERSECTION) {
			edges.add(de.getEdge());
			de.setVisitedEdge(true);
		}
	};
	LineBuilder.prototype.interfaces_ = function interfaces_() {
		return []
	};
	LineBuilder.prototype.getClass = function getClass() {
		return LineBuilder
	};

	var PointBuilder = function PointBuilder() {
		this._op = null;
		this._geometryFactory = null;
		this._resultPointList = new ArrayList();
		var op = arguments[0];
		var geometryFactory = arguments[1];
		// const ptLocator = arguments[2]
		this._op = op;
		this._geometryFactory = geometryFactory;
	};
	PointBuilder.prototype.filterCoveredNodeToPoint = function filterCoveredNodeToPoint(n) {
		var coord = n.getCoordinate();
		if (!this._op.isCoveredByLA(coord)) {
			var pt = this._geometryFactory.createPoint(coord);
			this._resultPointList.add(pt);
		}
	};
	PointBuilder.prototype.extractNonCoveredResultNodes = function extractNonCoveredResultNodes(opCode) {
		var this$1$1 = this;

		for (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {
			var n = nodeit.next();
			if (n.isInResult()) { continue }
			if (n.isIncidentEdgeInResult()) { continue }
			if (n.getEdges().getDegree() === 0 || opCode === OverlayOp.INTERSECTION) {
				var label = n.getLabel();
				if (OverlayOp.isResultOfOp(label, opCode)) {
					this$1$1.filterCoveredNodeToPoint(n);
				}
			}
		}
	};
	PointBuilder.prototype.build = function build(opCode) {
		this.extractNonCoveredResultNodes(opCode);
		return this._resultPointList
	};
	PointBuilder.prototype.interfaces_ = function interfaces_() {
		return []
	};
	PointBuilder.prototype.getClass = function getClass() {
		return PointBuilder
	};

	var GeometryTransformer = function GeometryTransformer() {
		this._inputGeom = null;
		this._factory = null;
		this._pruneEmptyGeometry = true;
		this._preserveGeometryCollectionType = true;
		this._preserveCollections = false;
		this._preserveType = false;
	};
	GeometryTransformer.prototype.transformPoint = function transformPoint(geom, parent) {
		return this._factory.createPoint(this.transformCoordinates(geom.getCoordinateSequence(), geom))
	};
	GeometryTransformer.prototype.transformPolygon = function transformPolygon(geom, parent) {
		var this$1$1 = this;

		var isAllValidLinearRings = true;
		var shell = this.transformLinearRing(geom.getExteriorRing(), geom);
		if (shell === null || !(shell instanceof LinearRing) || shell.isEmpty()) { isAllValidLinearRings = false; }
		var holes = new ArrayList();
		for (var i = 0; i < geom.getNumInteriorRing(); i++) {
			var hole = this$1$1.transformLinearRing(geom.getInteriorRingN(i), geom);
			if (hole === null || hole.isEmpty()) {
				continue
			}
			if (!(hole instanceof LinearRing)) { isAllValidLinearRings = false; }
			holes.add(hole);
		}
		if (isAllValidLinearRings) { return this._factory.createPolygon(shell, holes.toArray([])); } else {
			var components = new ArrayList();
			if (shell !== null) { components.add(shell); }
			components.addAll(holes);
			return this._factory.buildGeometry(components)
		}
	};
	GeometryTransformer.prototype.createCoordinateSequence = function createCoordinateSequence(coords) {
		return this._factory.getCoordinateSequenceFactory().create(coords)
	};
	GeometryTransformer.prototype.getInputGeometry = function getInputGeometry() {
		return this._inputGeom
	};
	GeometryTransformer.prototype.transformMultiLineString = function transformMultiLineString(geom, parent) {
		var this$1$1 = this;

		var transGeomList = new ArrayList();
		for (var i = 0; i < geom.getNumGeometries(); i++) {
			var transformGeom = this$1$1.transformLineString(geom.getGeometryN(i), geom);
			if (transformGeom === null) { continue }
			if (transformGeom.isEmpty()) { continue }
			transGeomList.add(transformGeom);
		}
		return this._factory.buildGeometry(transGeomList)
	};
	GeometryTransformer.prototype.transformCoordinates = function transformCoordinates(coords, parent) {
		return this.copy(coords)
	};
	GeometryTransformer.prototype.transformLineString = function transformLineString(geom, parent) {
		return this._factory.createLineString(this.transformCoordinates(geom.getCoordinateSequence(), geom))
	};
	GeometryTransformer.prototype.transformMultiPoint = function transformMultiPoint(geom, parent) {
		var this$1$1 = this;

		var transGeomList = new ArrayList();
		for (var i = 0; i < geom.getNumGeometries(); i++) {
			var transformGeom = this$1$1.transformPoint(geom.getGeometryN(i), geom);
			if (transformGeom === null) { continue }
			if (transformGeom.isEmpty()) { continue }
			transGeomList.add(transformGeom);
		}
		return this._factory.buildGeometry(transGeomList)
	};
	GeometryTransformer.prototype.transformMultiPolygon = function transformMultiPolygon(geom, parent) {
		var this$1$1 = this;

		var transGeomList = new ArrayList();
		for (var i = 0; i < geom.getNumGeometries(); i++) {
			var transformGeom = this$1$1.transformPolygon(geom.getGeometryN(i), geom);
			if (transformGeom === null) { continue }
			if (transformGeom.isEmpty()) { continue }
			transGeomList.add(transformGeom);
		}
		return this._factory.buildGeometry(transGeomList)
	};
	GeometryTransformer.prototype.copy = function copy(seq) {
		return seq.copy()
	};
	GeometryTransformer.prototype.transformGeometryCollection = function transformGeometryCollection(geom, parent) {
		var this$1$1 = this;

		var transGeomList = new ArrayList();
		for (var i = 0; i < geom.getNumGeometries(); i++) {
			var transformGeom = this$1$1.transform(geom.getGeometryN(i));
			if (transformGeom === null) { continue }
			if (this$1$1._pruneEmptyGeometry && transformGeom.isEmpty()) { continue }
			transGeomList.add(transformGeom);
		}
		if (this._preserveGeometryCollectionType) { return this._factory.createGeometryCollection(GeometryFactory.toGeometryArray(transGeomList)) }
		return this._factory.buildGeometry(transGeomList)
	};
	GeometryTransformer.prototype.transform = function transform(inputGeom) {
		this._inputGeom = inputGeom;
		this._factory = inputGeom.getFactory();
		if (inputGeom instanceof Point) { return this.transformPoint(inputGeom, null) }
		if (inputGeom instanceof MultiPoint) { return this.transformMultiPoint(inputGeom, null) }
		if (inputGeom instanceof LinearRing) { return this.transformLinearRing(inputGeom, null) }
		if (inputGeom instanceof LineString) { return this.transformLineString(inputGeom, null) }
		if (inputGeom instanceof MultiLineString) { return this.transformMultiLineString(inputGeom, null) }
		if (inputGeom instanceof Polygon) { return this.transformPolygon(inputGeom, null) }
		if (inputGeom instanceof MultiPolygon) { return this.transformMultiPolygon(inputGeom, null) }
		if (inputGeom instanceof GeometryCollection) { return this.transformGeometryCollection(inputGeom, null) }
		throw new IllegalArgumentException('Unknown Geometry subtype: ' + inputGeom.getClass().getName())
	};
	GeometryTransformer.prototype.transformLinearRing = function transformLinearRing(geom, parent) {
		var seq = this.transformCoordinates(geom.getCoordinateSequence(), geom);
		if (seq === null) { return this._factory.createLinearRing(null) }
		var seqSize = seq.size();
		if (seqSize > 0 && seqSize < 4 && !this._preserveType) { return this._factory.createLineString(seq) }
		return this._factory.createLinearRing(seq)
	};
	GeometryTransformer.prototype.interfaces_ = function interfaces_() {
		return []
	};
	GeometryTransformer.prototype.getClass = function getClass() {
		return GeometryTransformer
	};

	var LineStringSnapper = function LineStringSnapper() {
		this._snapTolerance = 0.0;
		this._srcPts = null;
		this._seg = new LineSegment();
		this._allowSnappingToSourceVertices = false;
		this._isClosed = false;
		if (arguments[0] instanceof LineString && typeof arguments[1] === 'number') {
			var srcLine = arguments[0];
			var snapTolerance = arguments[1];
			LineStringSnapper.call(this, srcLine.getCoordinates(), snapTolerance);
		} else if (arguments[0] instanceof Array && typeof arguments[1] === 'number') {
			var srcPts = arguments[0];
			var snapTolerance$1 = arguments[1];
			this._srcPts = srcPts;
			this._isClosed = LineStringSnapper.isClosed(srcPts);
			this._snapTolerance = snapTolerance$1;
		}
	};
	LineStringSnapper.prototype.snapVertices = function snapVertices(srcCoords, snapPts) {
		var this$1$1 = this;

		var end = this._isClosed ? srcCoords.size() - 1 : srcCoords.size();
		for (var i = 0; i < end; i++) {
			var srcPt = srcCoords.get(i);
			var snapVert = this$1$1.findSnapForVertex(srcPt, snapPts);
			if (snapVert !== null) {
				srcCoords.set(i, new Coordinate(snapVert));
				if (i === 0 && this$1$1._isClosed) { srcCoords.set(srcCoords.size() - 1, new Coordinate(snapVert)); }
			}
		}
	};
	LineStringSnapper.prototype.findSnapForVertex = function findSnapForVertex(pt, snapPts) {
		var this$1$1 = this;

		for (var i = 0; i < snapPts.length; i++) {
			if (pt.equals2D(snapPts[i])) { return null }
			if (pt.distance(snapPts[i]) < this$1$1._snapTolerance) { return snapPts[i] }
		}
		return null
	};
	LineStringSnapper.prototype.snapTo = function snapTo(snapPts) {
		var coordList = new CoordinateList(this._srcPts);
		this.snapVertices(coordList, snapPts);
		this.snapSegments(coordList, snapPts);
		var newPts = coordList.toCoordinateArray();
		return newPts
	};
	LineStringSnapper.prototype.snapSegments = function snapSegments(srcCoords, snapPts) {
		var this$1$1 = this;

		if (snapPts.length === 0) { return null }
		var distinctPtCount = snapPts.length;
		if (snapPts[0].equals2D(snapPts[snapPts.length - 1])) { distinctPtCount = snapPts.length - 1; }
		for (var i = 0; i < distinctPtCount; i++) {
			var snapPt = snapPts[i];
			var index = this$1$1.findSegmentIndexToSnap(snapPt, srcCoords);
			if (index >= 0) {
				srcCoords.add(index + 1, new Coordinate(snapPt), false);
			}
		}
	};
	LineStringSnapper.prototype.findSegmentIndexToSnap = function findSegmentIndexToSnap(snapPt, srcCoords) {
		var this$1$1 = this;

		var minDist = Double.MAX_VALUE;
		var snapIndex = -1;
		for (var i = 0; i < srcCoords.size() - 1; i++) {
			this$1$1._seg.p0 = srcCoords.get(i);
			this$1$1._seg.p1 = srcCoords.get(i + 1);
			if (this$1$1._seg.p0.equals2D(snapPt) || this$1$1._seg.p1.equals2D(snapPt)) {
				if (this$1$1._allowSnappingToSourceVertices) { continue; } else { return -1 }
			}
			var dist = this$1$1._seg.distance(snapPt);
			if (dist < this$1$1._snapTolerance && dist < minDist) {
				minDist = dist;
				snapIndex = i;
			}
		}
		return snapIndex
	};
	LineStringSnapper.prototype.setAllowSnappingToSourceVertices = function setAllowSnappingToSourceVertices(allowSnappingToSourceVertices) {
		this._allowSnappingToSourceVertices = allowSnappingToSourceVertices;
	};
	LineStringSnapper.prototype.interfaces_ = function interfaces_() {
		return []
	};
	LineStringSnapper.prototype.getClass = function getClass() {
		return LineStringSnapper
	};
	LineStringSnapper.isClosed = function isClosed(pts) {
		if (pts.length <= 1) { return false }
		return pts[0].equals2D(pts[pts.length - 1])
	};

	var GeometrySnapper = function GeometrySnapper(srcGeom) {
		this._srcGeom = srcGeom || null;
	};

	var staticAccessors$41 = { SNAP_PRECISION_FACTOR: { configurable: true } };
	GeometrySnapper.prototype.snapTo = function snapTo(snapGeom, snapTolerance) {
		var snapPts = this.extractTargetCoordinates(snapGeom);
		var snapTrans = new SnapTransformer(snapTolerance, snapPts);
		return snapTrans.transform(this._srcGeom)
	};
	GeometrySnapper.prototype.snapToSelf = function snapToSelf(snapTolerance, cleanResult) {
		var snapPts = this.extractTargetCoordinates(this._srcGeom);
		var snapTrans = new SnapTransformer(snapTolerance, snapPts, true);
		var snappedGeom = snapTrans.transform(this._srcGeom);
		var result = snappedGeom;
		if (cleanResult && hasInterface(result, Polygonal)) {
			result = snappedGeom.buffer(0);
		}
		return result
	};
	GeometrySnapper.prototype.computeSnapTolerance = function computeSnapTolerance(ringPts) {
		var minSegLen = this.computeMinimumSegmentLength(ringPts);
		var snapTol = minSegLen / 10;
		return snapTol
	};
	GeometrySnapper.prototype.extractTargetCoordinates = function extractTargetCoordinates(g) {
		var ptSet = new TreeSet();
		var pts = g.getCoordinates();
		for (var i = 0; i < pts.length; i++) {
			ptSet.add(pts[i]);
		}
		return ptSet.toArray(new Array(0).fill(null))
	};
	GeometrySnapper.prototype.computeMinimumSegmentLength = function computeMinimumSegmentLength(pts) {
		var minSegLen = Double.MAX_VALUE;
		for (var i = 0; i < pts.length - 1; i++) {
			var segLen = pts[i].distance(pts[i + 1]);
			if (segLen < minSegLen) { minSegLen = segLen; }
		}
		return minSegLen
	};
	GeometrySnapper.prototype.interfaces_ = function interfaces_() {
		return []
	};
	GeometrySnapper.prototype.getClass = function getClass() {
		return GeometrySnapper
	};
	GeometrySnapper.snap = function snap(g0, g1, snapTolerance) {
		var snapGeom = new Array(2).fill(null);
		var snapper0 = new GeometrySnapper(g0);
		snapGeom[0] = snapper0.snapTo(g1, snapTolerance);
		var snapper1 = new GeometrySnapper(g1);
		snapGeom[1] = snapper1.snapTo(snapGeom[0], snapTolerance);
		return snapGeom
	};
	GeometrySnapper.computeOverlaySnapTolerance = function computeOverlaySnapTolerance() {
		if (arguments.length === 1) {
			var g = arguments[0];
			var snapTolerance = GeometrySnapper.computeSizeBasedSnapTolerance(g);
			var pm = g.getPrecisionModel();
			if (pm.getType() === PrecisionModel.FIXED) {
				var fixedSnapTol = 1 / pm.getScale() * 2 / 1.415;
				if (fixedSnapTol > snapTolerance) { snapTolerance = fixedSnapTol; }
			}
			return snapTolerance
		} else if (arguments.length === 2) {
			var g0 = arguments[0];
			var g1 = arguments[1];
			return Math.min(GeometrySnapper.computeOverlaySnapTolerance(g0), GeometrySnapper.computeOverlaySnapTolerance(g1))
		}
	};
	GeometrySnapper.computeSizeBasedSnapTolerance = function computeSizeBasedSnapTolerance(g) {
		var env = g.getEnvelopeInternal();
		var minDimension = Math.min(env.getHeight(), env.getWidth());
		var snapTol = minDimension * GeometrySnapper.SNAP_PRECISION_FACTOR;
		return snapTol
	};
	GeometrySnapper.snapToSelf = function snapToSelf(geom, snapTolerance, cleanResult) {
		var snapper0 = new GeometrySnapper(geom);
		return snapper0.snapToSelf(snapTolerance, cleanResult)
	};
	staticAccessors$41.SNAP_PRECISION_FACTOR.get = function () { return 1e-9 };

	Object.defineProperties(GeometrySnapper, staticAccessors$41);

	var SnapTransformer = (function (GeometryTransformer$$1) {
		function SnapTransformer(snapTolerance, snapPts, isSelfSnap) {
			GeometryTransformer$$1.call(this);
			this._snapTolerance = snapTolerance || null;
			this._snapPts = snapPts || null;
			this._isSelfSnap = (isSelfSnap !== undefined) ? isSelfSnap : false;
		}

		if (GeometryTransformer$$1) SnapTransformer.__proto__ = GeometryTransformer$$1;
		SnapTransformer.prototype = Object.create(GeometryTransformer$$1 && GeometryTransformer$$1.prototype);
		SnapTransformer.prototype.constructor = SnapTransformer;
		SnapTransformer.prototype.snapLine = function snapLine(srcPts, snapPts) {
			var snapper = new LineStringSnapper(srcPts, this._snapTolerance);
			snapper.setAllowSnappingToSourceVertices(this._isSelfSnap);
			return snapper.snapTo(snapPts)
		};
		SnapTransformer.prototype.transformCoordinates = function transformCoordinates(coords, parent) {
			var srcPts = coords.toCoordinateArray();
			var newPts = this.snapLine(srcPts, this._snapPts);
			return this._factory.getCoordinateSequenceFactory().create(newPts)
		};
		SnapTransformer.prototype.interfaces_ = function interfaces_() {
			return []
		};
		SnapTransformer.prototype.getClass = function getClass() {
			return SnapTransformer
		};

		return SnapTransformer;
	}(GeometryTransformer));

	var CommonBits = function CommonBits() {
		this._isFirst = true;
		this._commonMantissaBitsCount = 53;
		this._commonBits = 0;
		this._commonSignExp = null;
	};
	CommonBits.prototype.getCommon = function getCommon() {
		return Double.longBitsToDouble(this._commonBits)
	};
	CommonBits.prototype.add = function add(num) {
		var numBits = Double.doubleToLongBits(num);
		if (this._isFirst) {
			this._commonBits = numBits;
			this._commonSignExp = CommonBits.signExpBits(this._commonBits);
			this._isFirst = false;
			return null
		}
		var numSignExp = CommonBits.signExpBits(numBits);
		if (numSignExp !== this._commonSignExp) {
			this._commonBits = 0;
			return null
		}
		this._commonMantissaBitsCount = CommonBits.numCommonMostSigMantissaBits(this._commonBits, numBits);
		this._commonBits = CommonBits.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));
	};
	CommonBits.prototype.toString = function toString() {
		if (arguments.length === 1) {
			var bits = arguments[0];
			var x = Double.longBitsToDouble(bits);
			var numStr = Double.toBinaryString(bits);
			var padStr = '0000000000000000000000000000000000000000000000000000000000000000' + numStr;
			var bitStr = padStr.substring(padStr.length - 64);
			var str = bitStr.substring(0, 1) + '  ' + bitStr.substring(1, 12) + '(exp) ' + bitStr.substring(12) + ' [ ' + x + ' ]';
			return str
		}
	};
	CommonBits.prototype.interfaces_ = function interfaces_() {
		return []
	};
	CommonBits.prototype.getClass = function getClass() {
		return CommonBits
	};
	CommonBits.getBit = function getBit(bits, i) {
		var mask = 1 << i;
		return (bits & mask) !== 0 ? 1 : 0
	};
	CommonBits.signExpBits = function signExpBits(num) {
		return num >> 52
	};
	CommonBits.zeroLowerBits = function zeroLowerBits(bits, nBits) {
		var invMask = (1 << nBits) - 1;
		var mask = ~invMask;
		var zeroed = bits & mask;
		return zeroed
	};
	CommonBits.numCommonMostSigMantissaBits = function numCommonMostSigMantissaBits(num1, num2) {
		var count = 0;
		for (var i = 52; i >= 0; i--) {
			if (CommonBits.getBit(num1, i) !== CommonBits.getBit(num2, i)) { return count }
			count++;
		}
		return 52
	};

	var CommonBitsRemover = function CommonBitsRemover() {
		this._commonCoord = null;
		this._ccFilter = new CommonCoordinateFilter();
	};

	var staticAccessors$42 = { CommonCoordinateFilter: { configurable: true }, Translater: { configurable: true } };
	CommonBitsRemover.prototype.addCommonBits = function addCommonBits(geom) {
		var trans = new Translater(this._commonCoord);
		geom.apply(trans);
		geom.geometryChanged();
	};
	CommonBitsRemover.prototype.removeCommonBits = function removeCommonBits(geom) {
		if (this._commonCoord.x === 0.0 && this._commonCoord.y === 0.0) { return geom }
		var invCoord = new Coordinate(this._commonCoord);
		invCoord.x = -invCoord.x;
		invCoord.y = -invCoord.y;
		var trans = new Translater(invCoord);
		geom.apply(trans);
		geom.geometryChanged();
		return geom
	};
	CommonBitsRemover.prototype.getCommonCoordinate = function getCommonCoordinate() {
		return this._commonCoord
	};
	CommonBitsRemover.prototype.add = function add(geom) {
		geom.apply(this._ccFilter);
		this._commonCoord = this._ccFilter.getCommonCoordinate();
	};
	CommonBitsRemover.prototype.interfaces_ = function interfaces_() {
		return []
	};
	CommonBitsRemover.prototype.getClass = function getClass() {
		return CommonBitsRemover
	};
	staticAccessors$42.CommonCoordinateFilter.get = function () { return CommonCoordinateFilter };
	staticAccessors$42.Translater.get = function () { return Translater };

	Object.defineProperties(CommonBitsRemover, staticAccessors$42);

	var CommonCoordinateFilter = function CommonCoordinateFilter() {
		this._commonBitsX = new CommonBits();
		this._commonBitsY = new CommonBits();
	};
	CommonCoordinateFilter.prototype.filter = function filter(coord) {
		this._commonBitsX.add(coord.x);
		this._commonBitsY.add(coord.y);
	};
	CommonCoordinateFilter.prototype.getCommonCoordinate = function getCommonCoordinate() {
		return new Coordinate(this._commonBitsX.getCommon(), this._commonBitsY.getCommon())
	};
	CommonCoordinateFilter.prototype.interfaces_ = function interfaces_() {
		return [CoordinateFilter]
	};
	CommonCoordinateFilter.prototype.getClass = function getClass() {
		return CommonCoordinateFilter
	};

	var Translater = function Translater() {
		this.trans = null;
		var trans = arguments[0];
		this.trans = trans;
	};
	Translater.prototype.filter = function filter(seq, i) {
		var xp = seq.getOrdinate(i, 0) + this.trans.x;
		var yp = seq.getOrdinate(i, 1) + this.trans.y;
		seq.setOrdinate(i, 0, xp);
		seq.setOrdinate(i, 1, yp);
	};
	Translater.prototype.isDone = function isDone() {
		return false
	};
	Translater.prototype.isGeometryChanged = function isGeometryChanged() {
		return true
	};
	Translater.prototype.interfaces_ = function interfaces_() {
		return [CoordinateSequenceFilter]
	};
	Translater.prototype.getClass = function getClass() {
		return Translater
	};

	var SnapOverlayOp = function SnapOverlayOp(g1, g2) {
		this._geom = new Array(2).fill(null);
		this._snapTolerance = null;
		this._cbr = null;
		this._geom[0] = g1;
		this._geom[1] = g2;
		this.computeSnapTolerance();
	};
	SnapOverlayOp.prototype.selfSnap = function selfSnap(geom) {
		var snapper0 = new GeometrySnapper(geom);
		var snapGeom = snapper0.snapTo(geom, this._snapTolerance);
		return snapGeom
	};
	SnapOverlayOp.prototype.removeCommonBits = function removeCommonBits(geom) {
		this._cbr = new CommonBitsRemover();
		this._cbr.add(geom[0]);
		this._cbr.add(geom[1]);
		var remGeom = new Array(2).fill(null);
		remGeom[0] = this._cbr.removeCommonBits(geom[0].copy());
		remGeom[1] = this._cbr.removeCommonBits(geom[1].copy());
		return remGeom
	};
	SnapOverlayOp.prototype.prepareResult = function prepareResult(geom) {
		this._cbr.addCommonBits(geom);
		return geom
	};
	SnapOverlayOp.prototype.getResultGeometry = function getResultGeometry(opCode) {
		var prepGeom = this.snap(this._geom);
		var result = OverlayOp.overlayOp(prepGeom[0], prepGeom[1], opCode);
		return this.prepareResult(result)
	};
	SnapOverlayOp.prototype.checkValid = function checkValid(g) {
		if (!g.isValid()) {
			System.out.println('Snapped geometry is invalid');
		}
	};
	SnapOverlayOp.prototype.computeSnapTolerance = function computeSnapTolerance() {
		this._snapTolerance = GeometrySnapper.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);
	};
	SnapOverlayOp.prototype.snap = function snap(geom) {
		var remGeom = this.removeCommonBits(geom);
		var snapGeom = GeometrySnapper.snap(remGeom[0], remGeom[1], this._snapTolerance);
		return snapGeom
	};
	SnapOverlayOp.prototype.interfaces_ = function interfaces_() {
		return []
	};
	SnapOverlayOp.prototype.getClass = function getClass() {
		return SnapOverlayOp
	};
	SnapOverlayOp.overlayOp = function overlayOp(g0, g1, opCode) {
		var op = new SnapOverlayOp(g0, g1);
		return op.getResultGeometry(opCode)
	};
	SnapOverlayOp.union = function union(g0, g1) {
		return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.UNION)
	};
	SnapOverlayOp.intersection = function intersection(g0, g1) {
		return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION)
	};
	SnapOverlayOp.symDifference = function symDifference(g0, g1) {
		return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE)
	};
	SnapOverlayOp.difference = function difference(g0, g1) {
		return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE)
	};

	var SnapIfNeededOverlayOp = function SnapIfNeededOverlayOp(g1, g2) {
		this._geom = new Array(2).fill(null);
		this._geom[0] = g1;
		this._geom[1] = g2;
	};
	SnapIfNeededOverlayOp.prototype.getResultGeometry = function getResultGeometry(opCode) {
		var result = null;
		var isSuccess = false;
		var savedException = null;
		try {
			result = OverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);
			var isValid = true;
			if (isValid) { isSuccess = true; }
		} catch (ex) {
			if (ex instanceof RuntimeException) {
				savedException = ex;
			} else { throw ex }
		} finally { }
		if (!isSuccess) {
			try {
				result = SnapOverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);
			} catch (ex) {
				if (ex instanceof RuntimeException) {
					throw savedException
				} else { throw ex }
			} finally { }
		}
		return result
	};
	SnapIfNeededOverlayOp.prototype.interfaces_ = function interfaces_() {
		return []
	};
	SnapIfNeededOverlayOp.prototype.getClass = function getClass() {
		return SnapIfNeededOverlayOp
	};
	SnapIfNeededOverlayOp.overlayOp = function overlayOp(g0, g1, opCode) {
		var op = new SnapIfNeededOverlayOp(g0, g1);
		return op.getResultGeometry(opCode)
	};
	SnapIfNeededOverlayOp.union = function union(g0, g1) {
		return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.UNION)
	};
	SnapIfNeededOverlayOp.intersection = function intersection(g0, g1) {
		return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION)
	};
	SnapIfNeededOverlayOp.symDifference = function symDifference(g0, g1) {
		return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE)
	};
	SnapIfNeededOverlayOp.difference = function difference(g0, g1) {
		return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE)
	};

	var MonotoneChain$2 = function MonotoneChain() {
		this.mce = null;
		this.chainIndex = null;
		var mce = arguments[0];
		var chainIndex = arguments[1];
		this.mce = mce;
		this.chainIndex = chainIndex;
	};
	MonotoneChain$2.prototype.computeIntersections = function computeIntersections(mc, si) {
		this.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);
	};
	MonotoneChain$2.prototype.interfaces_ = function interfaces_() {
		return []
	};
	MonotoneChain$2.prototype.getClass = function getClass() {
		return MonotoneChain$2
	};

	var SweepLineEvent = function SweepLineEvent() {
		this._label = null;
		this._xValue = null;
		this._eventType = null;
		this._insertEvent = null;
		this._deleteEventIndex = null;
		this._obj = null;
		if (arguments.length === 2) {
			var x = arguments[0];
			var insertEvent = arguments[1];
			this._eventType = SweepLineEvent.DELETE;
			this._xValue = x;
			this._insertEvent = insertEvent;
		} else if (arguments.length === 3) {
			var label = arguments[0];
			var x$1 = arguments[1];
			var obj = arguments[2];
			this._eventType = SweepLineEvent.INSERT;
			this._label = label;
			this._xValue = x$1;
			this._obj = obj;
		}
	};

	var staticAccessors$43 = { INSERT: { configurable: true }, DELETE: { configurable: true } };
	SweepLineEvent.prototype.isDelete = function isDelete() {
		return this._eventType === SweepLineEvent.DELETE
	};
	SweepLineEvent.prototype.setDeleteEventIndex = function setDeleteEventIndex(deleteEventIndex) {
		this._deleteEventIndex = deleteEventIndex;
	};
	SweepLineEvent.prototype.getObject = function getObject() {
		return this._obj
	};
	SweepLineEvent.prototype.compareTo = function compareTo(o) {
		var pe = o;
		if (this._xValue < pe._xValue) { return -1 }
		if (this._xValue > pe._xValue) { return 1 }
		if (this._eventType < pe._eventType) { return -1 }
		if (this._eventType > pe._eventType) { return 1 }
		return 0
	};
	SweepLineEvent.prototype.getInsertEvent = function getInsertEvent() {
		return this._insertEvent
	};
	SweepLineEvent.prototype.isInsert = function isInsert() {
		return this._eventType === SweepLineEvent.INSERT
	};
	SweepLineEvent.prototype.isSameLabel = function isSameLabel(ev) {
		if (this._label === null) { return false }
		return this._label === ev._label
	};
	SweepLineEvent.prototype.getDeleteEventIndex = function getDeleteEventIndex() {
		return this._deleteEventIndex
	};
	SweepLineEvent.prototype.interfaces_ = function interfaces_() {
		return [Comparable]
	};
	SweepLineEvent.prototype.getClass = function getClass() {
		return SweepLineEvent
	};
	staticAccessors$43.INSERT.get = function () { return 1 };
	staticAccessors$43.DELETE.get = function () { return 2 };

	Object.defineProperties(SweepLineEvent, staticAccessors$43);

	var EdgeSetIntersector = function EdgeSetIntersector() { };

	EdgeSetIntersector.prototype.interfaces_ = function interfaces_() {
		return []
	};
	EdgeSetIntersector.prototype.getClass = function getClass() {
		return EdgeSetIntersector
	};

	var SegmentIntersector$2 = function SegmentIntersector() {
		this._hasIntersection = false;
		this._hasProper = false;
		this._hasProperInterior = false;
		this._properIntersectionPoint = null;
		this._li = null;
		this._includeProper = null;
		this._recordIsolated = null;
		this._isSelfIntersection = null;
		this._numIntersections = 0;
		this.numTests = 0;
		this._bdyNodes = null;
		this._isDone = false;
		this._isDoneWhenProperInt = false;
		var li = arguments[0];
		var includeProper = arguments[1];
		var recordIsolated = arguments[2];
		this._li = li;
		this._includeProper = includeProper;
		this._recordIsolated = recordIsolated;
	};
	SegmentIntersector$2.prototype.isTrivialIntersection = function isTrivialIntersection(e0, segIndex0, e1, segIndex1) {
		if (e0 === e1) {
			if (this._li.getIntersectionNum() === 1) {
				if (SegmentIntersector$2.isAdjacentSegments(segIndex0, segIndex1)) { return true }
				if (e0.isClosed()) {
					var maxSegIndex = e0.getNumPoints() - 1;
					if ((segIndex0 === 0 && segIndex1 === maxSegIndex) ||
						(segIndex1 === 0 && segIndex0 === maxSegIndex)) {
						return true
					}
				}
			}
		}
		return false
	};
	SegmentIntersector$2.prototype.getProperIntersectionPoint = function getProperIntersectionPoint() {
		return this._properIntersectionPoint
	};
	SegmentIntersector$2.prototype.setIsDoneIfProperInt = function setIsDoneIfProperInt(isDoneWhenProperInt) {
		this._isDoneWhenProperInt = isDoneWhenProperInt;
	};
	SegmentIntersector$2.prototype.hasProperInteriorIntersection = function hasProperInteriorIntersection() {
		return this._hasProperInterior
	};
	SegmentIntersector$2.prototype.isBoundaryPointInternal = function isBoundaryPointInternal(li, bdyNodes) {
		for (var i = bdyNodes.iterator(); i.hasNext();) {
			var node = i.next();
			var pt = node.getCoordinate();
			if (li.isIntersection(pt)) { return true }
		}
		return false
	};
	SegmentIntersector$2.prototype.hasProperIntersection = function hasProperIntersection() {
		return this._hasProper
	};
	SegmentIntersector$2.prototype.hasIntersection = function hasIntersection() {
		return this._hasIntersection
	};
	SegmentIntersector$2.prototype.isDone = function isDone() {
		return this._isDone
	};
	SegmentIntersector$2.prototype.isBoundaryPoint = function isBoundaryPoint(li, bdyNodes) {
		if (bdyNodes === null) { return false }
		if (this.isBoundaryPointInternal(li, bdyNodes[0])) { return true }
		if (this.isBoundaryPointInternal(li, bdyNodes[1])) { return true }
		return false
	};
	SegmentIntersector$2.prototype.setBoundaryNodes = function setBoundaryNodes(bdyNodes0, bdyNodes1) {
		this._bdyNodes = new Array(2).fill(null);
		this._bdyNodes[0] = bdyNodes0;
		this._bdyNodes[1] = bdyNodes1;
	};
	SegmentIntersector$2.prototype.addIntersections = function addIntersections(e0, segIndex0, e1, segIndex1) {
		if (e0 === e1 && segIndex0 === segIndex1) { return null }
		this.numTests++;
		var p00 = e0.getCoordinates()[segIndex0];
		var p01 = e0.getCoordinates()[segIndex0 + 1];
		var p10 = e1.getCoordinates()[segIndex1];
		var p11 = e1.getCoordinates()[segIndex1 + 1];
		this._li.computeIntersection(p00, p01, p10, p11);
		if (this._li.hasIntersection()) {
			if (this._recordIsolated) {
				e0.setIsolated(false);
				e1.setIsolated(false);
			}
			this._numIntersections++;
			if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {
				this._hasIntersection = true;
				if (this._includeProper || !this._li.isProper()) {
					e0.addIntersections(this._li, segIndex0, 0);
					e1.addIntersections(this._li, segIndex1, 1);
				}
				if (this._li.isProper()) {
					this._properIntersectionPoint = this._li.getIntersection(0).copy();
					this._hasProper = true;
					if (this._isDoneWhenProperInt) {
						this._isDone = true;
					}
					if (!this.isBoundaryPoint(this._li, this._bdyNodes)) { this._hasProperInterior = true; }
				}
			}
		}
	};
	SegmentIntersector$2.prototype.interfaces_ = function interfaces_() {
		return []
	};
	SegmentIntersector$2.prototype.getClass = function getClass() {
		return SegmentIntersector$2
	};
	SegmentIntersector$2.isAdjacentSegments = function isAdjacentSegments(i1, i2) {
		return Math.abs(i1 - i2) === 1
	};

	var SimpleMCSweepLineIntersector = (function (EdgeSetIntersector$$1) {
		function SimpleMCSweepLineIntersector() {
			EdgeSetIntersector$$1.call(this);
			this.events = new ArrayList();
			this.nOverlaps = null;
		}

		if (EdgeSetIntersector$$1) SimpleMCSweepLineIntersector.__proto__ = EdgeSetIntersector$$1;
		SimpleMCSweepLineIntersector.prototype = Object.create(EdgeSetIntersector$$1 && EdgeSetIntersector$$1.prototype);
		SimpleMCSweepLineIntersector.prototype.constructor = SimpleMCSweepLineIntersector;
		SimpleMCSweepLineIntersector.prototype.prepareEvents = function prepareEvents() {
			var this$1$1 = this;

			Collections.sort(this.events);
			for (var i = 0; i < this.events.size(); i++) {
				var ev = this$1$1.events.get(i);
				if (ev.isDelete()) {
					ev.getInsertEvent().setDeleteEventIndex(i);
				}
			}
		};
		SimpleMCSweepLineIntersector.prototype.computeIntersections = function computeIntersections() {
			var this$1$1 = this;

			if (arguments.length === 1) {
				var si = arguments[0];
				this.nOverlaps = 0;
				this.prepareEvents();
				for (var i = 0; i < this.events.size(); i++) {
					var ev = this$1$1.events.get(i);
					if (ev.isInsert()) {
						this$1$1.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);
					}
					if (si.isDone()) {
						break
					}
				}
			} else if (arguments.length === 3) {
				if (arguments[2] instanceof SegmentIntersector$2 && (hasInterface(arguments[0], List) && hasInterface(arguments[1], List))) {
					var edges0 = arguments[0];
					var edges1 = arguments[1];
					var si$1 = arguments[2];
					this.addEdges(edges0, edges0);
					this.addEdges(edges1, edges1);
					this.computeIntersections(si$1);
				} else if (typeof arguments[2] === 'boolean' && (hasInterface(arguments[0], List) && arguments[1] instanceof SegmentIntersector$2)) {
					var edges = arguments[0];
					var si$2 = arguments[1];
					var testAllSegments = arguments[2];
					if (testAllSegments) { this.addEdges(edges, null); } else { this.addEdges(edges); }
					this.computeIntersections(si$2);
				}
			}
		};
		SimpleMCSweepLineIntersector.prototype.addEdge = function addEdge(edge, edgeSet) {
			var this$1$1 = this;

			var mce = edge.getMonotoneChainEdge();
			var startIndex = mce.getStartIndexes();
			for (var i = 0; i < startIndex.length - 1; i++) {
				var mc = new MonotoneChain$2(mce, i);
				var insertEvent = new SweepLineEvent(edgeSet, mce.getMinX(i), mc);
				this$1$1.events.add(insertEvent);
				this$1$1.events.add(new SweepLineEvent(mce.getMaxX(i), insertEvent));
			}
		};
		SimpleMCSweepLineIntersector.prototype.processOverlaps = function processOverlaps(start, end, ev0, si) {
			var this$1$1 = this;

			var mc0 = ev0.getObject();
			for (var i = start; i < end; i++) {
				var ev1 = this$1$1.events.get(i);
				if (ev1.isInsert()) {
					var mc1 = ev1.getObject();
					if (!ev0.isSameLabel(ev1)) {
						mc0.computeIntersections(mc1, si);
						this$1$1.nOverlaps++;
					}
				}
			}
		};
		SimpleMCSweepLineIntersector.prototype.addEdges = function addEdges() {
			var this$1$1 = this;

			if (arguments.length === 1) {
				var edges = arguments[0];
				for (var i = edges.iterator(); i.hasNext();) {
					var edge = i.next();
					this$1$1.addEdge(edge, edge);
				}
			} else if (arguments.length === 2) {
				var edges$1 = arguments[0];
				var edgeSet = arguments[1];
				for (var i$1 = edges$1.iterator(); i$1.hasNext();) {
					var edge$1 = i$1.next();
					this$1$1.addEdge(edge$1, edgeSet);
				}
			}
		};
		SimpleMCSweepLineIntersector.prototype.interfaces_ = function interfaces_() {
			return []
		};
		SimpleMCSweepLineIntersector.prototype.getClass = function getClass() {
			return SimpleMCSweepLineIntersector
		};

		return SimpleMCSweepLineIntersector;
	}(EdgeSetIntersector));

	var IntervalRTreeNode = function IntervalRTreeNode() {
		this._min = Double.POSITIVE_INFINITY;
		this._max = Double.NEGATIVE_INFINITY;
	};

	var staticAccessors$45 = { NodeComparator: { configurable: true } };
	IntervalRTreeNode.prototype.getMin = function getMin() {
		return this._min
	};
	IntervalRTreeNode.prototype.intersects = function intersects(queryMin, queryMax) {
		if (this._min > queryMax || this._max < queryMin) { return false }
		return true
	};
	IntervalRTreeNode.prototype.getMax = function getMax() {
		return this._max
	};
	IntervalRTreeNode.prototype.toString = function toString() {
		return WKTWriter.toLineString(new Coordinate(this._min, 0), new Coordinate(this._max, 0))
	};
	IntervalRTreeNode.prototype.interfaces_ = function interfaces_() {
		return []
	};
	IntervalRTreeNode.prototype.getClass = function getClass() {
		return IntervalRTreeNode
	};
	staticAccessors$45.NodeComparator.get = function () { return NodeComparator };

	Object.defineProperties(IntervalRTreeNode, staticAccessors$45);

	var NodeComparator = function NodeComparator() { };

	NodeComparator.prototype.compare = function compare(o1, o2) {
		var n1 = o1;
		var n2 = o2;
		var mid1 = (n1._min + n1._max) / 2;
		var mid2 = (n2._min + n2._max) / 2;
		if (mid1 < mid2) { return -1 }
		if (mid1 > mid2) { return 1 }
		return 0
	};
	NodeComparator.prototype.interfaces_ = function interfaces_() {
		return [Comparator]
	};
	NodeComparator.prototype.getClass = function getClass() {
		return NodeComparator
	};

	var IntervalRTreeLeafNode = (function (IntervalRTreeNode$$1) {
		function IntervalRTreeLeafNode() {
			IntervalRTreeNode$$1.call(this);
			this._item = null;
			var min = arguments[0];
			var max = arguments[1];
			var item = arguments[2];
			this._min = min;
			this._max = max;
			this._item = item;
		}

		if (IntervalRTreeNode$$1) IntervalRTreeLeafNode.__proto__ = IntervalRTreeNode$$1;
		IntervalRTreeLeafNode.prototype = Object.create(IntervalRTreeNode$$1 && IntervalRTreeNode$$1.prototype);
		IntervalRTreeLeafNode.prototype.constructor = IntervalRTreeLeafNode;
		IntervalRTreeLeafNode.prototype.query = function query(queryMin, queryMax, visitor) {
			if (!this.intersects(queryMin, queryMax)) { return null }
			visitor.visitItem(this._item);
		};
		IntervalRTreeLeafNode.prototype.interfaces_ = function interfaces_() {
			return []
		};
		IntervalRTreeLeafNode.prototype.getClass = function getClass() {
			return IntervalRTreeLeafNode
		};

		return IntervalRTreeLeafNode;
	}(IntervalRTreeNode));

	var IntervalRTreeBranchNode = (function (IntervalRTreeNode$$1) {
		function IntervalRTreeBranchNode() {
			IntervalRTreeNode$$1.call(this);
			this._node1 = null;
			this._node2 = null;
			var n1 = arguments[0];
			var n2 = arguments[1];
			this._node1 = n1;
			this._node2 = n2;
			this.buildExtent(this._node1, this._node2);
		}

		if (IntervalRTreeNode$$1) IntervalRTreeBranchNode.__proto__ = IntervalRTreeNode$$1;
		IntervalRTreeBranchNode.prototype = Object.create(IntervalRTreeNode$$1 && IntervalRTreeNode$$1.prototype);
		IntervalRTreeBranchNode.prototype.constructor = IntervalRTreeBranchNode;
		IntervalRTreeBranchNode.prototype.buildExtent = function buildExtent(n1, n2) {
			this._min = Math.min(n1._min, n2._min);
			this._max = Math.max(n1._max, n2._max);
		};
		IntervalRTreeBranchNode.prototype.query = function query(queryMin, queryMax, visitor) {
			if (!this.intersects(queryMin, queryMax)) {
				return null
			}
			if (this._node1 !== null) { this._node1.query(queryMin, queryMax, visitor); }
			if (this._node2 !== null) { this._node2.query(queryMin, queryMax, visitor); }
		};
		IntervalRTreeBranchNode.prototype.interfaces_ = function interfaces_() {
			return []
		};
		IntervalRTreeBranchNode.prototype.getClass = function getClass() {
			return IntervalRTreeBranchNode
		};

		return IntervalRTreeBranchNode;
	}(IntervalRTreeNode));

	var SortedPackedIntervalRTree = function SortedPackedIntervalRTree() {
		this._leaves = new ArrayList();
		this._root = null;
		this._level = 0;
	};
	SortedPackedIntervalRTree.prototype.buildTree = function buildTree() {
		var this$1$1 = this;

		Collections.sort(this._leaves, new IntervalRTreeNode.NodeComparator());
		var src = this._leaves;
		var temp = null;
		var dest = new ArrayList();
		while (true) {
			this$1$1.buildLevel(src, dest);
			if (dest.size() === 1) { return dest.get(0) }
			temp = src;
			src = dest;
			dest = temp;
		}
	};
	SortedPackedIntervalRTree.prototype.insert = function insert(min, max, item) {
		if (this._root !== null) { throw new Error('Index cannot be added to once it has been queried') }
		this._leaves.add(new IntervalRTreeLeafNode(min, max, item));
	};
	SortedPackedIntervalRTree.prototype.query = function query(min, max, visitor) {
		this.init();
		this._root.query(min, max, visitor);
	};
	SortedPackedIntervalRTree.prototype.buildRoot = function buildRoot() {
		if (this._root !== null) { return null }
		this._root = this.buildTree();
	};
	SortedPackedIntervalRTree.prototype.printNode = function printNode(node) {
		System.out.println(WKTWriter.toLineString(new Coordinate(node._min, this._level), new Coordinate(node._max, this._level)));
	};
	SortedPackedIntervalRTree.prototype.init = function init() {
		if (this._root !== null) { return null }
		this.buildRoot();
	};
	SortedPackedIntervalRTree.prototype.buildLevel = function buildLevel(src, dest) {
		this._level++;
		dest.clear();
		for (var i = 0; i < src.size(); i += 2) {
			var n1 = src.get(i);
			var n2 = i + 1 < src.size() ? src.get(i) : null;
			if (n2 === null) {
				dest.add(n1);
			} else {
				var node = new IntervalRTreeBranchNode(src.get(i), src.get(i + 1));
				dest.add(node);
			}
		}
	};
	SortedPackedIntervalRTree.prototype.interfaces_ = function interfaces_() {
		return []
	};
	SortedPackedIntervalRTree.prototype.getClass = function getClass() {
		return SortedPackedIntervalRTree
	};

	var ArrayListVisitor = function ArrayListVisitor() {
		this._items = new ArrayList();
	};
	ArrayListVisitor.prototype.visitItem = function visitItem(item) {
		this._items.add(item);
	};
	ArrayListVisitor.prototype.getItems = function getItems() {
		return this._items
	};
	ArrayListVisitor.prototype.interfaces_ = function interfaces_() {
		return [ItemVisitor]
	};
	ArrayListVisitor.prototype.getClass = function getClass() {
		return ArrayListVisitor
	};

	var IndexedPointInAreaLocator = function IndexedPointInAreaLocator() {
		this._index = null;
		var g = arguments[0];
		if (!hasInterface(g, Polygonal)) { throw new IllegalArgumentException('Argument must be Polygonal') }
		this._index = new IntervalIndexedGeometry(g);
	};

	var staticAccessors$44 = { SegmentVisitor: { configurable: true }, IntervalIndexedGeometry: { configurable: true } };
	IndexedPointInAreaLocator.prototype.locate = function locate(p) {
		var rcc = new RayCrossingCounter(p);
		var visitor = new SegmentVisitor(rcc);
		this._index.query(p.y, p.y, visitor);
		return rcc.getLocation()
	};
	IndexedPointInAreaLocator.prototype.interfaces_ = function interfaces_() {
		return [PointOnGeometryLocator]
	};
	IndexedPointInAreaLocator.prototype.getClass = function getClass() {
		return IndexedPointInAreaLocator
	};
	staticAccessors$44.SegmentVisitor.get = function () { return SegmentVisitor };
	staticAccessors$44.IntervalIndexedGeometry.get = function () { return IntervalIndexedGeometry };

	Object.defineProperties(IndexedPointInAreaLocator, staticAccessors$44);

	var SegmentVisitor = function SegmentVisitor() {
		this._counter = null;
		var counter = arguments[0];
		this._counter = counter;
	};
	SegmentVisitor.prototype.visitItem = function visitItem(item) {
		var seg = item;
		this._counter.countSegment(seg.getCoordinate(0), seg.getCoordinate(1));
	};
	SegmentVisitor.prototype.interfaces_ = function interfaces_() {
		return [ItemVisitor]
	};
	SegmentVisitor.prototype.getClass = function getClass() {
		return SegmentVisitor
	};

	var IntervalIndexedGeometry = function IntervalIndexedGeometry() {
		this._index = new SortedPackedIntervalRTree();
		var geom = arguments[0];
		this.init(geom);
	};
	IntervalIndexedGeometry.prototype.init = function init(geom) {
		var this$1$1 = this;

		var lines = LinearComponentExtracter.getLines(geom);
		for (var i = lines.iterator(); i.hasNext();) {
			var line = i.next();
			var pts = line.getCoordinates();
			this$1$1.addLine(pts);
		}
	};
	IntervalIndexedGeometry.prototype.addLine = function addLine(pts) {
		var this$1$1 = this;

		for (var i = 1; i < pts.length; i++) {
			var seg = new LineSegment(pts[i - 1], pts[i]);
			var min = Math.min(seg.p0.y, seg.p1.y);
			var max = Math.max(seg.p0.y, seg.p1.y);
			this$1$1._index.insert(min, max, seg);
		}
	};
	IntervalIndexedGeometry.prototype.query = function query() {
		if (arguments.length === 2) {
			var min = arguments[0];
			var max = arguments[1];
			var visitor = new ArrayListVisitor();
			this._index.query(min, max, visitor);
			return visitor.getItems()
		} else if (arguments.length === 3) {
			var min$1 = arguments[0];
			var max$1 = arguments[1];
			var visitor$1 = arguments[2];
			this._index.query(min$1, max$1, visitor$1);
		}
	};
	IntervalIndexedGeometry.prototype.interfaces_ = function interfaces_() {
		return []
	};
	IntervalIndexedGeometry.prototype.getClass = function getClass() {
		return IntervalIndexedGeometry
	};

	var GeometryGraph = (function (PlanarGraph$$1) {
		function GeometryGraph() {
			PlanarGraph$$1.call(this);
			this._parentGeom = null;
			this._lineEdgeMap = new HashMap();
			this._boundaryNodeRule = null;
			this._useBoundaryDeterminationRule = true;
			this._argIndex = null;
			this._boundaryNodes = null;
			this._hasTooFewPoints = false;
			this._invalidPoint = null;
			this._areaPtLocator = null;
			this._ptLocator = new PointLocator();
			if (arguments.length === 2) {
				var argIndex = arguments[0];
				var parentGeom = arguments[1];
				var boundaryNodeRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;
				this._argIndex = argIndex;
				this._parentGeom = parentGeom;
				this._boundaryNodeRule = boundaryNodeRule;
				if (parentGeom !== null) {
					this.add(parentGeom);
				}
			} else if (arguments.length === 3) {
				var argIndex$1 = arguments[0];
				var parentGeom$1 = arguments[1];
				var boundaryNodeRule$1 = arguments[2];
				this._argIndex = argIndex$1;
				this._parentGeom = parentGeom$1;
				this._boundaryNodeRule = boundaryNodeRule$1;
				if (parentGeom$1 !== null) {
					this.add(parentGeom$1);
				}
			}
		}

		if (PlanarGraph$$1) GeometryGraph.__proto__ = PlanarGraph$$1;
		GeometryGraph.prototype = Object.create(PlanarGraph$$1 && PlanarGraph$$1.prototype);
		GeometryGraph.prototype.constructor = GeometryGraph;
		GeometryGraph.prototype.insertBoundaryPoint = function insertBoundaryPoint(argIndex, coord) {
			var n = this._nodes.addNode(coord);
			var lbl = n.getLabel();
			var boundaryCount = 1;
			var loc = Location.NONE;
			loc = lbl.getLocation(argIndex, Position.ON);
			if (loc === Location.BOUNDARY) { boundaryCount++; }
			var newLoc = GeometryGraph.determineBoundary(this._boundaryNodeRule, boundaryCount);
			lbl.setLocation(argIndex, newLoc);
		};
		GeometryGraph.prototype.computeSelfNodes = function computeSelfNodes() {
			if (arguments.length === 2) {
				var li = arguments[0];
				var computeRingSelfNodes = arguments[1];
				return this.computeSelfNodes(li, computeRingSelfNodes, false)
			} else if (arguments.length === 3) {
				var li$1 = arguments[0];
				var computeRingSelfNodes$1 = arguments[1];
				var isDoneIfProperInt = arguments[2];
				var si = new SegmentIntersector$2(li$1, true, false);
				si.setIsDoneIfProperInt(isDoneIfProperInt);
				var esi = this.createEdgeSetIntersector();
				var isRings = this._parentGeom instanceof LinearRing || this._parentGeom instanceof Polygon || this._parentGeom instanceof MultiPolygon;
				var computeAllSegments = computeRingSelfNodes$1 || !isRings;
				esi.computeIntersections(this._edges, si, computeAllSegments);
				this.addSelfIntersectionNodes(this._argIndex);
				return si
			}
		};
		GeometryGraph.prototype.computeSplitEdges = function computeSplitEdges(edgelist) {
			for (var i = this._edges.iterator(); i.hasNext();) {
				var e = i.next();
				e.eiList.addSplitEdges(edgelist);
			}
		};
		GeometryGraph.prototype.computeEdgeIntersections = function computeEdgeIntersections(g, li, includeProper) {
			var si = new SegmentIntersector$2(li, includeProper, true);
			si.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());
			var esi = this.createEdgeSetIntersector();
			esi.computeIntersections(this._edges, g._edges, si);
			return si
		};
		GeometryGraph.prototype.getGeometry = function getGeometry() {
			return this._parentGeom
		};
		GeometryGraph.prototype.getBoundaryNodeRule = function getBoundaryNodeRule() {
			return this._boundaryNodeRule
		};
		GeometryGraph.prototype.hasTooFewPoints = function hasTooFewPoints() {
			return this._hasTooFewPoints
		};
		GeometryGraph.prototype.addPoint = function addPoint() {
			if (arguments[0] instanceof Point) {
				var p = arguments[0];
				var coord = p.getCoordinate();
				this.insertPoint(this._argIndex, coord, Location.INTERIOR);
			} else if (arguments[0] instanceof Coordinate) {
				var pt = arguments[0];
				this.insertPoint(this._argIndex, pt, Location.INTERIOR);
			}
		};
		GeometryGraph.prototype.addPolygon = function addPolygon(p) {
			var this$1$1 = this;

			this.addPolygonRing(p.getExteriorRing(), Location.EXTERIOR, Location.INTERIOR);
			for (var i = 0; i < p.getNumInteriorRing(); i++) {
				var hole = p.getInteriorRingN(i);
				this$1$1.addPolygonRing(hole, Location.INTERIOR, Location.EXTERIOR);
			}
		};
		GeometryGraph.prototype.addEdge = function addEdge(e) {
			this.insertEdge(e);
			var coord = e.getCoordinates();
			this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);
			this.insertPoint(this._argIndex, coord[coord.length - 1], Location.BOUNDARY);
		};
		GeometryGraph.prototype.addLineString = function addLineString(line) {
			var coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());
			if (coord.length < 2) {
				this._hasTooFewPoints = true;
				this._invalidPoint = coord[0];
				return null
			}
			var e = new Edge(coord, new Label(this._argIndex, Location.INTERIOR));
			this._lineEdgeMap.put(line, e);
			this.insertEdge(e);
			Assert.isTrue(coord.length >= 2, 'found LineString with single point');
			this.insertBoundaryPoint(this._argIndex, coord[0]);
			this.insertBoundaryPoint(this._argIndex, coord[coord.length - 1]);
		};
		GeometryGraph.prototype.getInvalidPoint = function getInvalidPoint() {
			return this._invalidPoint
		};
		GeometryGraph.prototype.getBoundaryPoints = function getBoundaryPoints() {
			var coll = this.getBoundaryNodes();
			var pts = new Array(coll.size()).fill(null);
			var i = 0;
			for (var it = coll.iterator(); it.hasNext();) {
				var node = it.next();
				pts[i++] = node.getCoordinate().copy();
			}
			return pts
		};
		GeometryGraph.prototype.getBoundaryNodes = function getBoundaryNodes() {
			if (this._boundaryNodes === null) { this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex); }
			return this._boundaryNodes
		};
		GeometryGraph.prototype.addSelfIntersectionNode = function addSelfIntersectionNode(argIndex, coord, loc) {
			if (this.isBoundaryNode(argIndex, coord)) { return null }
			if (loc === Location.BOUNDARY && this._useBoundaryDeterminationRule) { this.insertBoundaryPoint(argIndex, coord); } else { this.insertPoint(argIndex, coord, loc); }
		};
		GeometryGraph.prototype.addPolygonRing = function addPolygonRing(lr, cwLeft, cwRight) {
			if (lr.isEmpty()) { return null }
			var coord = CoordinateArrays.removeRepeatedPoints(lr.getCoordinates());
			if (coord.length < 4) {
				this._hasTooFewPoints = true;
				this._invalidPoint = coord[0];
				return null
			}
			var left = cwLeft;
			var right = cwRight;
			if (CGAlgorithms.isCCW(coord)) {
				left = cwRight;
				right = cwLeft;
			}
			var e = new Edge(coord, new Label(this._argIndex, Location.BOUNDARY, left, right));
			this._lineEdgeMap.put(lr, e);
			this.insertEdge(e);
			this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);
		};
		GeometryGraph.prototype.insertPoint = function insertPoint(argIndex, coord, onLocation) {
			var n = this._nodes.addNode(coord);
			var lbl = n.getLabel();
			if (lbl === null) {
				n._label = new Label(argIndex, onLocation);
			} else { lbl.setLocation(argIndex, onLocation); }
		};
		GeometryGraph.prototype.createEdgeSetIntersector = function createEdgeSetIntersector() {
			return new SimpleMCSweepLineIntersector()
		};
		GeometryGraph.prototype.addSelfIntersectionNodes = function addSelfIntersectionNodes(argIndex) {
			var this$1$1 = this;

			for (var i = this._edges.iterator(); i.hasNext();) {
				var e = i.next();
				var eLoc = e.getLabel().getLocation(argIndex);
				for (var eiIt = e.eiList.iterator(); eiIt.hasNext();) {
					var ei = eiIt.next();
					this$1$1.addSelfIntersectionNode(argIndex, ei.coord, eLoc);
				}
			}
		};
		GeometryGraph.prototype.add = function add() {
			if (arguments.length === 1) {
				var g = arguments[0];
				if (g.isEmpty()) { return null }
				if (g instanceof MultiPolygon) { this._useBoundaryDeterminationRule = false; }
				if (g instanceof Polygon) { this.addPolygon(g); }
				else if (g instanceof LineString) { this.addLineString(g); }
				else if (g instanceof Point) { this.addPoint(g); }
				else if (g instanceof MultiPoint) { this.addCollection(g); }
				else if (g instanceof MultiLineString) { this.addCollection(g); }
				else if (g instanceof MultiPolygon) { this.addCollection(g); }
				else if (g instanceof GeometryCollection) { this.addCollection(g); }
				else { throw new Error(g.getClass().getName()) }
			} else { return PlanarGraph$$1.prototype.add.apply(this, arguments) }
		};
		GeometryGraph.prototype.addCollection = function addCollection(gc) {
			var this$1$1 = this;

			for (var i = 0; i < gc.getNumGeometries(); i++) {
				var g = gc.getGeometryN(i);
				this$1$1.add(g);
			}
		};
		GeometryGraph.prototype.locate = function locate(pt) {
			if (hasInterface(this._parentGeom, Polygonal) && this._parentGeom.getNumGeometries() > 50) {
				if (this._areaPtLocator === null) {
					this._areaPtLocator = new IndexedPointInAreaLocator(this._parentGeom);
				}
				return this._areaPtLocator.locate(pt)
			}
			return this._ptLocator.locate(pt, this._parentGeom)
		};
		GeometryGraph.prototype.findEdge = function findEdge() {
			if (arguments.length === 1) {
				var line = arguments[0];
				return this._lineEdgeMap.get(line)
			} else { return PlanarGraph$$1.prototype.findEdge.apply(this, arguments) }
		};
		GeometryGraph.prototype.interfaces_ = function interfaces_() {
			return []
		};
		GeometryGraph.prototype.getClass = function getClass() {
			return GeometryGraph
		};
		GeometryGraph.determineBoundary = function determineBoundary(boundaryNodeRule, boundaryCount) {
			return boundaryNodeRule.isInBoundary(boundaryCount) ? Location.BOUNDARY : Location.INTERIOR
		};

		return GeometryGraph;
	}(PlanarGraph));

	var GeometryGraphOp = function GeometryGraphOp() {
		this._li = new RobustLineIntersector();
		this._resultPrecisionModel = null;
		this._arg = null;
		if (arguments.length === 1) {
			var g0 = arguments[0];
			this.setComputationPrecision(g0.getPrecisionModel());
			this._arg = new Array(1).fill(null);
			this._arg[0] = new GeometryGraph(0, g0);
		} else if (arguments.length === 2) {
			var g0$1 = arguments[0];
			var g1 = arguments[1];
			var boundaryNodeRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;
			if (g0$1.getPrecisionModel().compareTo(g1.getPrecisionModel()) >= 0) { this.setComputationPrecision(g0$1.getPrecisionModel()); } else { this.setComputationPrecision(g1.getPrecisionModel()); }
			this._arg = new Array(2).fill(null);
			this._arg[0] = new GeometryGraph(0, g0$1, boundaryNodeRule);
			this._arg[1] = new GeometryGraph(1, g1, boundaryNodeRule);
		} else if (arguments.length === 3) {
			var g0$2 = arguments[0];
			var g1$1 = arguments[1];
			var boundaryNodeRule$1 = arguments[2];
			if (g0$2.getPrecisionModel().compareTo(g1$1.getPrecisionModel()) >= 0) { this.setComputationPrecision(g0$2.getPrecisionModel()); } else { this.setComputationPrecision(g1$1.getPrecisionModel()); }
			this._arg = new Array(2).fill(null);
			this._arg[0] = new GeometryGraph(0, g0$2, boundaryNodeRule$1);
			this._arg[1] = new GeometryGraph(1, g1$1, boundaryNodeRule$1);
		}
	};
	GeometryGraphOp.prototype.getArgGeometry = function getArgGeometry(i) {
		return this._arg[i].getGeometry()
	};
	GeometryGraphOp.prototype.setComputationPrecision = function setComputationPrecision(pm) {
		this._resultPrecisionModel = pm;
		this._li.setPrecisionModel(this._resultPrecisionModel);
	};
	GeometryGraphOp.prototype.interfaces_ = function interfaces_() {
		return []
	};
	GeometryGraphOp.prototype.getClass = function getClass() {
		return GeometryGraphOp
	};

	// operation.geometrygraph

	var GeometryMapper = function GeometryMapper() { };

	GeometryMapper.prototype.interfaces_ = function interfaces_() {
		return []
	};
	GeometryMapper.prototype.getClass = function getClass() {
		return GeometryMapper
	};
	GeometryMapper.map = function map() {
		if (arguments[0] instanceof Geometry && hasInterface(arguments[1], GeometryMapper.MapOp)) {
			var geom = arguments[0];
			var op = arguments[1];
			var mapped = new ArrayList();
			for (var i = 0; i < geom.getNumGeometries(); i++) {
				var g = op.map(geom.getGeometryN(i));
				if (g !== null) { mapped.add(g); }
			}
			return geom.getFactory().buildGeometry(mapped)
		} else if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], GeometryMapper.MapOp)) {
			var geoms = arguments[0];
			var op$1 = arguments[1];
			var mapped$1 = new ArrayList();
			for (var i$1 = geoms.iterator(); i$1.hasNext();) {
				var g$1 = i$1.next();
				var gr = op$1.map(g$1);
				if (gr !== null) { mapped$1.add(gr); }
			}
			return mapped$1
		}
	};
	GeometryMapper.MapOp = function MapOp() { };

	var OverlayOp = (function (GeometryGraphOp) {
		function OverlayOp() {
			var g0 = arguments[0];
			var g1 = arguments[1];
			GeometryGraphOp.call(this, g0, g1);
			this._ptLocator = new PointLocator();
			this._geomFact = null;
			this._resultGeom = null;
			this._graph = null;
			this._edgeList = new EdgeList();
			this._resultPolyList = new ArrayList();
			this._resultLineList = new ArrayList();
			this._resultPointList = new ArrayList();
			this._graph = new PlanarGraph(new OverlayNodeFactory());
			this._geomFact = g0.getFactory();
		}

		if (GeometryGraphOp) OverlayOp.__proto__ = GeometryGraphOp;
		OverlayOp.prototype = Object.create(GeometryGraphOp && GeometryGraphOp.prototype);
		OverlayOp.prototype.constructor = OverlayOp;
		OverlayOp.prototype.insertUniqueEdge = function insertUniqueEdge(e) {
			var existingEdge = this._edgeList.findEqualEdge(e);
			if (existingEdge !== null) {
				var existingLabel = existingEdge.getLabel();
				var labelToMerge = e.getLabel();
				if (!existingEdge.isPointwiseEqual(e)) {
					labelToMerge = new Label(e.getLabel());
					labelToMerge.flip();
				}
				var depth = existingEdge.getDepth();
				if (depth.isNull()) {
					depth.add(existingLabel);
				}
				depth.add(labelToMerge);
				existingLabel.merge(labelToMerge);
			} else {
				this._edgeList.add(e);
			}
		};
		OverlayOp.prototype.getGraph = function getGraph() {
			return this._graph
		};
		OverlayOp.prototype.cancelDuplicateResultEdges = function cancelDuplicateResultEdges() {
			for (var it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {
				var de = it.next();
				var sym = de.getSym();
				if (de.isInResult() && sym.isInResult()) {
					de.setInResult(false);
					sym.setInResult(false);
				}
			}
		};
		OverlayOp.prototype.isCoveredByLA = function isCoveredByLA(coord) {
			if (this.isCovered(coord, this._resultLineList)) { return true }
			if (this.isCovered(coord, this._resultPolyList)) { return true }
			return false
		};
		OverlayOp.prototype.computeGeometry = function computeGeometry(resultPointList, resultLineList, resultPolyList, opcode) {
			var geomList = new ArrayList();
			geomList.addAll(resultPointList);
			geomList.addAll(resultLineList);
			geomList.addAll(resultPolyList);
			if (geomList.isEmpty()) { return OverlayOp.createEmptyResult(opcode, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact) }
			return this._geomFact.buildGeometry(geomList)
		};
		OverlayOp.prototype.mergeSymLabels = function mergeSymLabels() {
			for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {
				var node = nodeit.next();
				node.getEdges().mergeSymLabels();
			}
		};
		OverlayOp.prototype.isCovered = function isCovered(coord, geomList) {
			var this$1$1 = this;

			for (var it = geomList.iterator(); it.hasNext();) {
				var geom = it.next();
				var loc = this$1$1._ptLocator.locate(coord, geom);
				if (loc !== Location.EXTERIOR) { return true }
			}
			return false
		};
		OverlayOp.prototype.replaceCollapsedEdges = function replaceCollapsedEdges() {
			var newEdges = new ArrayList();
			for (var it = this._edgeList.iterator(); it.hasNext();) {
				var e = it.next();
				if (e.isCollapsed()) {
					it.remove();
					newEdges.add(e.getCollapsedEdge());
				}
			}
			this._edgeList.addAll(newEdges);
		};
		OverlayOp.prototype.updateNodeLabelling = function updateNodeLabelling() {
			for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {
				var node = nodeit.next();
				var lbl = node.getEdges().getLabel();
				node.getLabel().merge(lbl);
			}
		};
		OverlayOp.prototype.getResultGeometry = function getResultGeometry(overlayOpCode) {
			this.computeOverlay(overlayOpCode);
			return this._resultGeom
		};
		OverlayOp.prototype.insertUniqueEdges = function insertUniqueEdges(edges) {
			var this$1$1 = this;

			for (var i = edges.iterator(); i.hasNext();) {
				var e = i.next();
				this$1$1.insertUniqueEdge(e);
			}
		};
		OverlayOp.prototype.computeOverlay = function computeOverlay(opCode) {
			this.copyPoints(0);
			this.copyPoints(1);
			this._arg[0].computeSelfNodes(this._li, false);
			this._arg[1].computeSelfNodes(this._li, false);
			this._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);
			var baseSplitEdges = new ArrayList();
			this._arg[0].computeSplitEdges(baseSplitEdges);
			this._arg[1].computeSplitEdges(baseSplitEdges);
			// const splitEdges = baseSplitEdges
			this.insertUniqueEdges(baseSplitEdges);
			this.computeLabelsFromDepths();
			this.replaceCollapsedEdges();
			EdgeNodingValidator.checkValid(this._edgeList.getEdges());
			this._graph.addEdges(this._edgeList.getEdges());
			this.computeLabelling();
			this.labelIncompleteNodes();
			this.findResultAreaEdges(opCode);
			this.cancelDuplicateResultEdges();
			var polyBuilder = new PolygonBuilder(this._geomFact);
			polyBuilder.add(this._graph);
			this._resultPolyList = polyBuilder.getPolygons();
			var lineBuilder = new LineBuilder(this, this._geomFact, this._ptLocator);
			this._resultLineList = lineBuilder.build(opCode);
			var pointBuilder = new PointBuilder(this, this._geomFact, this._ptLocator);
			this._resultPointList = pointBuilder.build(opCode);
			this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, opCode);
		};
		OverlayOp.prototype.labelIncompleteNode = function labelIncompleteNode(n, targetIndex) {
			var loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());
			n.getLabel().setLocation(targetIndex, loc);
		};
		OverlayOp.prototype.copyPoints = function copyPoints(argIndex) {
			var this$1$1 = this;

			for (var i = this._arg[argIndex].getNodeIterator(); i.hasNext();) {
				var graphNode = i.next();
				var newNode = this$1$1._graph.addNode(graphNode.getCoordinate());
				newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));
			}
		};
		OverlayOp.prototype.findResultAreaEdges = function findResultAreaEdges(opCode) {
			for (var it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {
				var de = it.next();
				var label = de.getLabel();
				if (label.isArea() && !de.isInteriorAreaEdge() && OverlayOp.isResultOfOp(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), opCode)) {
					de.setInResult(true);
				}
			}
		};
		OverlayOp.prototype.computeLabelsFromDepths = function computeLabelsFromDepths() {
			for (var it = this._edgeList.iterator(); it.hasNext();) {
				var e = it.next();
				var lbl = e.getLabel();
				var depth = e.getDepth();
				if (!depth.isNull()) {
					depth.normalize();
					for (var i = 0; i < 2; i++) {
						if (!lbl.isNull(i) && lbl.isArea() && !depth.isNull(i)) {
							if (depth.getDelta(i) === 0) {
								lbl.toLine(i);
							} else {
								Assert.isTrue(!depth.isNull(i, Position.LEFT), 'depth of LEFT side has not been initialized');
								lbl.setLocation(i, Position.LEFT, depth.getLocation(i, Position.LEFT));
								Assert.isTrue(!depth.isNull(i, Position.RIGHT), 'depth of RIGHT side has not been initialized');
								lbl.setLocation(i, Position.RIGHT, depth.getLocation(i, Position.RIGHT));
							}
						}
					}
				}
			}
		};
		OverlayOp.prototype.computeLabelling = function computeLabelling() {
			var this$1$1 = this;

			for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {
				var node = nodeit.next();
				node.getEdges().computeLabelling(this$1$1._arg);
			}
			this.mergeSymLabels();
			this.updateNodeLabelling();
		};
		OverlayOp.prototype.labelIncompleteNodes = function labelIncompleteNodes() {
			var this$1$1 = this;

			// let nodeCount = 0
			for (var ni = this._graph.getNodes().iterator(); ni.hasNext();) {
				var n = ni.next();
				var label = n.getLabel();
				if (n.isIsolated()) {
					// nodeCount++
					if (label.isNull(0)) { this$1$1.labelIncompleteNode(n, 0); } else { this$1$1.labelIncompleteNode(n, 1); }
				}
				n.getEdges().updateLabelling(label);
			}
		};
		OverlayOp.prototype.isCoveredByA = function isCoveredByA(coord) {
			if (this.isCovered(coord, this._resultPolyList)) { return true }
			return false
		};
		OverlayOp.prototype.interfaces_ = function interfaces_() {
			return []
		};
		OverlayOp.prototype.getClass = function getClass() {
			return OverlayOp
		};

		return OverlayOp;
	}(GeometryGraphOp));

	OverlayOp.overlayOp = function (geom0, geom1, opCode) {
		var gov = new OverlayOp(geom0, geom1);
		var geomOv = gov.getResultGeometry(opCode);
		return geomOv
	};
	OverlayOp.intersection = function (g, other) {
		if (g.isEmpty() || other.isEmpty()) { return OverlayOp.createEmptyResult(OverlayOp.INTERSECTION, g, other, g.getFactory()) }
		if (g.isGeometryCollection()) {
			var g2 = other;
			return GeometryCollectionMapper.map(g, {
				interfaces_: function () {
					return [GeometryMapper.MapOp]
				},
				map: function (g) {
					return g.intersection(g2)
				}
			})
		}
		g.checkNotGeometryCollection(g);
		g.checkNotGeometryCollection(other);
		return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.INTERSECTION)
	};
	OverlayOp.symDifference = function (g, other) {
		if (g.isEmpty() || other.isEmpty()) {
			if (g.isEmpty() && other.isEmpty()) { return OverlayOp.createEmptyResult(OverlayOp.SYMDIFFERENCE, g, other, g.getFactory()) }
			if (g.isEmpty()) { return other.copy() }
			if (other.isEmpty()) { return g.copy() }
		}
		g.checkNotGeometryCollection(g);
		g.checkNotGeometryCollection(other);
		return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.SYMDIFFERENCE)
	};
	OverlayOp.resultDimension = function (opCode, g0, g1) {
		var dim0 = g0.getDimension();
		var dim1 = g1.getDimension();
		var resultDimension = -1;
		switch (opCode) {
			case OverlayOp.INTERSECTION:
				resultDimension = Math.min(dim0, dim1);
				break
			case OverlayOp.UNION:
				resultDimension = Math.max(dim0, dim1);
				break
			case OverlayOp.DIFFERENCE:
				resultDimension = dim0;
				break
			case OverlayOp.SYMDIFFERENCE:
				resultDimension = Math.max(dim0, dim1);
				break
		}
		return resultDimension
	};
	OverlayOp.createEmptyResult = function (overlayOpCode, a, b, geomFact) {
		var result = null;
		switch (OverlayOp.resultDimension(overlayOpCode, a, b)) {
			case -1:
				result = geomFact.createGeometryCollection(new Array(0).fill(null));
				break
			case 0:
				result = geomFact.createPoint();
				break
			case 1:
				result = geomFact.createLineString();
				break
			case 2:
				result = geomFact.createPolygon();
				break
		}
		return result
	};
	OverlayOp.difference = function (g, other) {
		if (g.isEmpty()) { return OverlayOp.createEmptyResult(OverlayOp.DIFFERENCE, g, other, g.getFactory()) }
		if (other.isEmpty()) { return g.copy() }
		g.checkNotGeometryCollection(g);
		g.checkNotGeometryCollection(other);
		return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.DIFFERENCE)
	};
	OverlayOp.isResultOfOp = function () {
		if (arguments.length === 2) {
			var label = arguments[0];
			var opCode = arguments[1];
			var loc0 = label.getLocation(0);
			var loc1 = label.getLocation(1);
			return OverlayOp.isResultOfOp(loc0, loc1, opCode)
		} else if (arguments.length === 3) {
			var loc0$1 = arguments[0];
			var loc1$1 = arguments[1];
			var overlayOpCode = arguments[2];
			if (loc0$1 === Location.BOUNDARY) { loc0$1 = Location.INTERIOR; }
			if (loc1$1 === Location.BOUNDARY) { loc1$1 = Location.INTERIOR; }
			switch (overlayOpCode) {
				case OverlayOp.INTERSECTION:
					return loc0$1 === Location.INTERIOR && loc1$1 === Location.INTERIOR
				case OverlayOp.UNION:
					return loc0$1 === Location.INTERIOR || loc1$1 === Location.INTERIOR
				case OverlayOp.DIFFERENCE:
					return loc0$1 === Location.INTERIOR && loc1$1 !== Location.INTERIOR
				case OverlayOp.SYMDIFFERENCE:
					return (loc0$1 === Location.INTERIOR && loc1$1 !== Location.INTERIOR) || (loc0$1 !== Location.INTERIOR && loc1$1 === Location.INTERIOR)
			}
			return false
		}
	};
	OverlayOp.INTERSECTION = 1;
	OverlayOp.UNION = 2;
	OverlayOp.DIFFERENCE = 3;
	OverlayOp.SYMDIFFERENCE = 4;

	var FuzzyPointLocator = function FuzzyPointLocator() {
		this._g = null;
		this._boundaryDistanceTolerance = null;
		this._linework = null;
		this._ptLocator = new PointLocator();
		this._seg = new LineSegment();
		var g = arguments[0];
		var boundaryDistanceTolerance = arguments[1];
		this._g = g;
		this._boundaryDistanceTolerance = boundaryDistanceTolerance;
		this._linework = this.extractLinework(g);
	};
	FuzzyPointLocator.prototype.isWithinToleranceOfBoundary = function isWithinToleranceOfBoundary(pt) {
		var this$1$1 = this;

		for (var i = 0; i < this._linework.getNumGeometries(); i++) {
			var line = this$1$1._linework.getGeometryN(i);
			var seq = line.getCoordinateSequence();
			for (var j = 0; j < seq.size() - 1; j++) {
				seq.getCoordinate(j, this$1$1._seg.p0);
				seq.getCoordinate(j + 1, this$1$1._seg.p1);
				var dist = this$1$1._seg.distance(pt);
				if (dist <= this$1$1._boundaryDistanceTolerance) { return true }
			}
		}
		return false
	};
	FuzzyPointLocator.prototype.getLocation = function getLocation(pt) {
		if (this.isWithinToleranceOfBoundary(pt)) { return Location.BOUNDARY }
		return this._ptLocator.locate(pt, this._g)
	};
	FuzzyPointLocator.prototype.extractLinework = function extractLinework(g) {
		var extracter = new PolygonalLineworkExtracter();
		g.apply(extracter);
		var linework = extracter.getLinework();
		var lines = GeometryFactory.toLineStringArray(linework);
		return g.getFactory().createMultiLineString(lines)
	};
	FuzzyPointLocator.prototype.interfaces_ = function interfaces_() {
		return []
	};
	FuzzyPointLocator.prototype.getClass = function getClass() {
		return FuzzyPointLocator
	};

	var PolygonalLineworkExtracter = function PolygonalLineworkExtracter() {
		this._linework = null;
		this._linework = new ArrayList();
	};
	PolygonalLineworkExtracter.prototype.getLinework = function getLinework() {
		return this._linework
	};
	PolygonalLineworkExtracter.prototype.filter = function filter(g) {
		var this$1$1 = this;

		if (g instanceof Polygon) {
			var poly = g;
			this._linework.add(poly.getExteriorRing());
			for (var i = 0; i < poly.getNumInteriorRing(); i++) {
				this$1$1._linework.add(poly.getInteriorRingN(i));
			}
		}
	};
	PolygonalLineworkExtracter.prototype.interfaces_ = function interfaces_() {
		return [GeometryFilter]
	};
	PolygonalLineworkExtracter.prototype.getClass = function getClass() {
		return PolygonalLineworkExtracter
	};

	var OffsetPointGenerator = function OffsetPointGenerator() {
		this._g = null;
		this._doLeft = true;
		this._doRight = true;
		var g = arguments[0];
		this._g = g;
	};
	OffsetPointGenerator.prototype.extractPoints = function extractPoints(line, offsetDistance, offsetPts) {
		var this$1$1 = this;

		var pts = line.getCoordinates();
		for (var i = 0; i < pts.length - 1; i++) {
			this$1$1.computeOffsetPoints(pts[i], pts[i + 1], offsetDistance, offsetPts);
		}
	};
	OffsetPointGenerator.prototype.setSidesToGenerate = function setSidesToGenerate(doLeft, doRight) {
		this._doLeft = doLeft;
		this._doRight = doRight;
	};
	OffsetPointGenerator.prototype.getPoints = function getPoints(offsetDistance) {
		var this$1$1 = this;

		var offsetPts = new ArrayList();
		var lines = LinearComponentExtracter.getLines(this._g);
		for (var i = lines.iterator(); i.hasNext();) {
			var line = i.next();
			this$1$1.extractPoints(line, offsetDistance, offsetPts);
		}
		return offsetPts
	};
	OffsetPointGenerator.prototype.computeOffsetPoints = function computeOffsetPoints(p0, p1, offsetDistance, offsetPts) {
		var dx = p1.x - p0.x;
		var dy = p1.y - p0.y;
		var len = Math.sqrt(dx * dx + dy * dy);
		var ux = offsetDistance * dx / len;
		var uy = offsetDistance * dy / len;
		var midX = (p1.x + p0.x) / 2;
		var midY = (p1.y + p0.y) / 2;
		if (this._doLeft) {
			var offsetLeft = new Coordinate(midX - uy, midY + ux);
			offsetPts.add(offsetLeft);
		}
		if (this._doRight) {
			var offsetRight = new Coordinate(midX + uy, midY - ux);
			offsetPts.add(offsetRight);
		}
	};
	OffsetPointGenerator.prototype.interfaces_ = function interfaces_() {
		return []
	};
	OffsetPointGenerator.prototype.getClass = function getClass() {
		return OffsetPointGenerator
	};

	var OverlayResultValidator = function OverlayResultValidator() {
		this._geom = null;
		this._locFinder = null;
		this._location = new Array(3).fill(null);
		this._invalidLocation = null;
		this._boundaryDistanceTolerance = OverlayResultValidator.TOLERANCE;
		this._testCoords = new ArrayList();
		var a = arguments[0];
		var b = arguments[1];
		var result = arguments[2];
		this._boundaryDistanceTolerance = OverlayResultValidator.computeBoundaryDistanceTolerance(a, b);
		this._geom = [a, b, result];
		this._locFinder = [new FuzzyPointLocator(this._geom[0], this._boundaryDistanceTolerance), new FuzzyPointLocator(this._geom[1], this._boundaryDistanceTolerance), new FuzzyPointLocator(this._geom[2], this._boundaryDistanceTolerance)];
	};

	var staticAccessors$46 = { TOLERANCE: { configurable: true } };
	OverlayResultValidator.prototype.reportResult = function reportResult(overlayOp, location, expectedInterior) {
		System.out.println('Overlay result invalid - A:' + Location.toLocationSymbol(location[0]) + ' B:' + Location.toLocationSymbol(location[1]) + ' expected:' + (expectedInterior ? 'i' : 'e') + ' actual:' + Location.toLocationSymbol(location[2]));
	};
	OverlayResultValidator.prototype.isValid = function isValid(overlayOp) {
		this.addTestPts(this._geom[0]);
		this.addTestPts(this._geom[1]);
		var isValid = this.checkValid(overlayOp);
		return isValid
	};
	OverlayResultValidator.prototype.checkValid = function checkValid() {
		var this$1$1 = this;

		if (arguments.length === 1) {
			var overlayOp = arguments[0];
			for (var i = 0; i < this._testCoords.size(); i++) {
				var pt = this$1$1._testCoords.get(i);
				if (!this$1$1.checkValid(overlayOp, pt)) {
					this$1$1._invalidLocation = pt;
					return false
				}
			}
			return true
		} else if (arguments.length === 2) {
			var overlayOp$1 = arguments[0];
			var pt$1 = arguments[1];
			this._location[0] = this._locFinder[0].getLocation(pt$1);
			this._location[1] = this._locFinder[1].getLocation(pt$1);
			this._location[2] = this._locFinder[2].getLocation(pt$1);
			if (OverlayResultValidator.hasLocation(this._location, Location.BOUNDARY)) { return true }
			return this.isValidResult(overlayOp$1, this._location)
		}
	};
	OverlayResultValidator.prototype.addTestPts = function addTestPts(g) {
		var ptGen = new OffsetPointGenerator(g);
		this._testCoords.addAll(ptGen.getPoints(5 * this._boundaryDistanceTolerance));
	};
	OverlayResultValidator.prototype.isValidResult = function isValidResult(overlayOp, location) {
		var expectedInterior = OverlayOp.isResultOfOp(location[0], location[1], overlayOp);
		var resultInInterior = location[2] === Location.INTERIOR;
		var isValid = !(expectedInterior ^ resultInInterior);
		if (!isValid) { this.reportResult(overlayOp, location, expectedInterior); }
		return isValid
	};
	OverlayResultValidator.prototype.getInvalidLocation = function getInvalidLocation() {
		return this._invalidLocation
	};
	OverlayResultValidator.prototype.interfaces_ = function interfaces_() {
		return []
	};
	OverlayResultValidator.prototype.getClass = function getClass() {
		return OverlayResultValidator
	};
	OverlayResultValidator.hasLocation = function hasLocation(location, loc) {
		for (var i = 0; i < 3; i++) {
			if (location[i] === loc) { return true }
		}
		return false
	};
	OverlayResultValidator.computeBoundaryDistanceTolerance = function computeBoundaryDistanceTolerance(g0, g1) {
		return Math.min(GeometrySnapper.computeSizeBasedSnapTolerance(g0), GeometrySnapper.computeSizeBasedSnapTolerance(g1))
	};
	OverlayResultValidator.isValid = function isValid(a, b, overlayOp, result) {
		var validator = new OverlayResultValidator(a, b, result);
		return validator.isValid(overlayOp)
	};
	staticAccessors$46.TOLERANCE.get = function () { return 0.000001 };

	Object.defineProperties(OverlayResultValidator, staticAccessors$46);

	// operation.overlay

	var GeometryCombiner = function GeometryCombiner(geoms) {
		this._geomFactory = null;
		this._skipEmpty = false;
		this._inputGeoms = null;
		this._geomFactory = GeometryCombiner.extractFactory(geoms);
		this._inputGeoms = geoms;
	};
	GeometryCombiner.prototype.extractElements = function extractElements(geom, elems) {
		var this$1$1 = this;

		if (geom === null) { return null }
		for (var i = 0; i < geom.getNumGeometries(); i++) {
			var elemGeom = geom.getGeometryN(i);
			if (this$1$1._skipEmpty && elemGeom.isEmpty()) { continue }
			elems.add(elemGeom);
		}
	};
	GeometryCombiner.prototype.combine = function combine() {
		var this$1$1 = this;

		var elems = new ArrayList();
		for (var i = this._inputGeoms.iterator(); i.hasNext();) {
			var g = i.next();
			this$1$1.extractElements(g, elems);
		}
		if (elems.size() === 0) {
			if (this._geomFactory !== null) {
				return this._geomFactory.createGeometryCollection(null)
			}
			return null
		}
		return this._geomFactory.buildGeometry(elems)
	};
	GeometryCombiner.prototype.interfaces_ = function interfaces_() {
		return []
	};
	GeometryCombiner.prototype.getClass = function getClass() {
		return GeometryCombiner
	};
	GeometryCombiner.combine = function combine() {
		if (arguments.length === 1) {
			var geoms = arguments[0];
			var combiner = new GeometryCombiner(geoms);
			return combiner.combine()
		} else if (arguments.length === 2) {
			var g0 = arguments[0];
			var g1 = arguments[1];
			var combiner$1 = new GeometryCombiner(GeometryCombiner.createList(g0, g1));
			return combiner$1.combine()
		} else if (arguments.length === 3) {
			var g0$1 = arguments[0];
			var g1$1 = arguments[1];
			var g2 = arguments[2];
			var combiner$2 = new GeometryCombiner(GeometryCombiner.createList(g0$1, g1$1, g2));
			return combiner$2.combine()
		}
	};
	GeometryCombiner.extractFactory = function extractFactory(geoms) {
		if (geoms.isEmpty()) { return null }
		return geoms.iterator().next().getFactory()
	};
	GeometryCombiner.createList = function createList() {
		if (arguments.length === 2) {
			var obj0 = arguments[0];
			var obj1 = arguments[1];
			var list = new ArrayList();
			list.add(obj0);
			list.add(obj1);
			return list
		} else if (arguments.length === 3) {
			var obj0$1 = arguments[0];
			var obj1$1 = arguments[1];
			var obj2 = arguments[2];
			var list$1 = new ArrayList();
			list$1.add(obj0$1);
			list$1.add(obj1$1);
			list$1.add(obj2);
			return list$1
		}
	};

	var CascadedPolygonUnion = function CascadedPolygonUnion() {
		this._inputPolys = null;
		this._geomFactory = null;
		var polys = arguments[0];
		this._inputPolys = polys;
		if (this._inputPolys === null) { this._inputPolys = new ArrayList(); }
	};

	var staticAccessors$47 = { STRTREE_NODE_CAPACITY: { configurable: true } };
	CascadedPolygonUnion.prototype.reduceToGeometries = function reduceToGeometries(geomTree) {
		var this$1$1 = this;

		var geoms = new ArrayList();
		for (var i = geomTree.iterator(); i.hasNext();) {
			var o = i.next();
			var geom = null;
			if (hasInterface(o, List)) {
				geom = this$1$1.unionTree(o);
			} else if (o instanceof Geometry) {
				geom = o;
			}
			geoms.add(geom);
		}
		return geoms
	};
	CascadedPolygonUnion.prototype.extractByEnvelope = function extractByEnvelope(env, geom, disjointGeoms) {
		var intersectingGeoms = new ArrayList();
		for (var i = 0; i < geom.getNumGeometries(); i++) {
			var elem = geom.getGeometryN(i);
			if (elem.getEnvelopeInternal().intersects(env)) { intersectingGeoms.add(elem); } else { disjointGeoms.add(elem); }
		}
		return this._geomFactory.buildGeometry(intersectingGeoms)
	};
	CascadedPolygonUnion.prototype.unionOptimized = function unionOptimized(g0, g1) {
		var g0Env = g0.getEnvelopeInternal();
		var g1Env = g1.getEnvelopeInternal();
		if (!g0Env.intersects(g1Env)) {
			var combo = GeometryCombiner.combine(g0, g1);
			return combo
		}
		if (g0.getNumGeometries() <= 1 && g1.getNumGeometries() <= 1) { return this.unionActual(g0, g1) }
		var commonEnv = g0Env.intersection(g1Env);
		return this.unionUsingEnvelopeIntersection(g0, g1, commonEnv)
	};
	CascadedPolygonUnion.prototype.union = function union() {
		if (this._inputPolys === null) { throw new Error('union() method cannot be called twice') }
		if (this._inputPolys.isEmpty()) { return null }
		this._geomFactory = this._inputPolys.iterator().next().getFactory();
		var index = new STRtree(CascadedPolygonUnion.STRTREE_NODE_CAPACITY);
		for (var i = this._inputPolys.iterator(); i.hasNext();) {
			var item = i.next();
			index.insert(item.getEnvelopeInternal(), item);
		}
		this._inputPolys = null;
		var itemTree = index.itemsTree();
		var unionAll = this.unionTree(itemTree);
		return unionAll
	};
	CascadedPolygonUnion.prototype.binaryUnion = function binaryUnion() {
		if (arguments.length === 1) {
			var geoms = arguments[0];
			return this.binaryUnion(geoms, 0, geoms.size())
		} else if (arguments.length === 3) {
			var geoms$1 = arguments[0];
			var start = arguments[1];
			var end = arguments[2];
			if (end - start <= 1) {
				var g0 = CascadedPolygonUnion.getGeometry(geoms$1, start);
				return this.unionSafe(g0, null)
			} else if (end - start === 2) {
				return this.unionSafe(CascadedPolygonUnion.getGeometry(geoms$1, start), CascadedPolygonUnion.getGeometry(geoms$1, start + 1))
			} else {
				var mid = Math.trunc((end + start) / 2);
				var g0$1 = this.binaryUnion(geoms$1, start, mid);
				var g1 = this.binaryUnion(geoms$1, mid, end);
				return this.unionSafe(g0$1, g1)
			}
		}
	};
	CascadedPolygonUnion.prototype.repeatedUnion = function repeatedUnion(geoms) {
		var union = null;
		for (var i = geoms.iterator(); i.hasNext();) {
			var g = i.next();
			if (union === null) { union = g.copy(); } else { union = union.union(g); }
		}
		return union
	};
	CascadedPolygonUnion.prototype.unionSafe = function unionSafe(g0, g1) {
		if (g0 === null && g1 === null) { return null }
		if (g0 === null) { return g1.copy() }
		if (g1 === null) { return g0.copy() }
		return this.unionOptimized(g0, g1)
	};
	CascadedPolygonUnion.prototype.unionActual = function unionActual(g0, g1) {
		return CascadedPolygonUnion.restrictToPolygons(g0.union(g1))
	};
	CascadedPolygonUnion.prototype.unionTree = function unionTree(geomTree) {
		var geoms = this.reduceToGeometries(geomTree);
		var union = this.binaryUnion(geoms);
		return union
	};
	CascadedPolygonUnion.prototype.unionUsingEnvelopeIntersection = function unionUsingEnvelopeIntersection(g0, g1, common) {
		var disjointPolys = new ArrayList();
		var g0Int = this.extractByEnvelope(common, g0, disjointPolys);
		var g1Int = this.extractByEnvelope(common, g1, disjointPolys);
		var union = this.unionActual(g0Int, g1Int);
		disjointPolys.add(union);
		var overallUnion = GeometryCombiner.combine(disjointPolys);
		return overallUnion
	};
	CascadedPolygonUnion.prototype.bufferUnion = function bufferUnion() {
		if (arguments.length === 1) {
			var geoms = arguments[0];
			var factory = geoms.get(0).getFactory();
			var gColl = factory.buildGeometry(geoms);
			var unionAll = gColl.buffer(0.0);
			return unionAll
		} else if (arguments.length === 2) {
			var g0 = arguments[0];
			var g1 = arguments[1];
			var factory$1 = g0.getFactory();
			var gColl$1 = factory$1.createGeometryCollection([g0, g1]);
			var unionAll$1 = gColl$1.buffer(0.0);
			return unionAll$1
		}
	};
	CascadedPolygonUnion.prototype.interfaces_ = function interfaces_() {
		return []
	};
	CascadedPolygonUnion.prototype.getClass = function getClass() {
		return CascadedPolygonUnion
	};
	CascadedPolygonUnion.restrictToPolygons = function restrictToPolygons(g) {
		if (hasInterface(g, Polygonal)) {
			return g
		}
		var polygons = PolygonExtracter.getPolygons(g);
		if (polygons.size() === 1) { return polygons.get(0) }
		return g.getFactory().createMultiPolygon(GeometryFactory.toPolygonArray(polygons))
	};
	CascadedPolygonUnion.getGeometry = function getGeometry(list, index) {
		if (index >= list.size()) { return null }
		return list.get(index)
	};
	CascadedPolygonUnion.union = function union(polys) {
		var op = new CascadedPolygonUnion(polys);
		return op.union()
	};
	staticAccessors$47.STRTREE_NODE_CAPACITY.get = function () { return 4 };

	Object.defineProperties(CascadedPolygonUnion, staticAccessors$47);

	var UnionOp = function UnionOp() { };

	UnionOp.prototype.interfaces_ = function interfaces_() {
		return []
	};
	UnionOp.prototype.getClass = function getClass() {
		return UnionOp
	};
	UnionOp.union = function union(g, other) {
		if (g.isEmpty() || other.isEmpty()) {
			if (g.isEmpty() && other.isEmpty()) { return OverlayOp.createEmptyResult(OverlayOp.UNION, g, other, g.getFactory()) }
			if (g.isEmpty()) { return other.copy() }
			if (other.isEmpty()) { return g.copy() }
		}
		g.checkNotGeometryCollection(g);
		g.checkNotGeometryCollection(other);
		return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.UNION)
	};

	// Adds floating point numbers with twice the normal precision.
	// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
	// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
	// 305–363 (1997).
	// Code adapted from GeographicLib by Charles F. F. Karney,
	// http://geographiclib.sourceforge.net/

	function adder() {
		return new Adder;
	}

	function Adder() {
		this.reset();
	}

	Adder.prototype = {
		constructor: Adder,
		reset: function () {
			this.s = // rounded value
				this.t = 0; // exact error
		},
		add: function (y) {
			add(temp, y, this.t);
			add(this, temp.s, this.s);
			if (this.s) this.t += temp.t;
			else this.s = temp.t;
		},
		valueOf: function () {
			return this.s;
		}
	};

	var temp = new Adder;

	function add(adder, a, b) {
		var x = adder.s = a + b,
			bv = x - a,
			av = x - bv;
		adder.t = (a - av) + (b - bv);
	}

	var epsilon = 1e-6;
	var pi = Math.PI;
	var halfPi = pi / 2;
	var quarterPi = pi / 4;
	var tau = pi * 2;

	var degrees = 180 / pi;
	var radians = pi / 180;

	var abs = Math.abs;
	var atan = Math.atan;
	var atan2 = Math.atan2;
	var cos = Math.cos;
	var sin = Math.sin;
	var sqrt = Math.sqrt;

	function acos(x) {
		return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
	}

	function asin(x) {
		return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
	}

	function noop() { }

	function streamGeometry(geometry, stream) {
		if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
			streamGeometryType[geometry.type](geometry, stream);
		}
	}

	var streamObjectType = {
		Feature: function (object, stream) {
			streamGeometry(object.geometry, stream);
		},
		FeatureCollection: function (object, stream) {
			var features = object.features, i = -1, n = features.length;
			while (++i < n) streamGeometry(features[i].geometry, stream);
		}
	};

	var streamGeometryType = {
		Sphere: function (object, stream) {
			stream.sphere();
		},
		Point: function (object, stream) {
			object = object.coordinates;
			stream.point(object[0], object[1], object[2]);
		},
		MultiPoint: function (object, stream) {
			var coordinates = object.coordinates, i = -1, n = coordinates.length;
			while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
		},
		LineString: function (object, stream) {
			streamLine(object.coordinates, stream, 0);
		},
		MultiLineString: function (object, stream) {
			var coordinates = object.coordinates, i = -1, n = coordinates.length;
			while (++i < n) streamLine(coordinates[i], stream, 0);
		},
		Polygon: function (object, stream) {
			streamPolygon(object.coordinates, stream);
		},
		MultiPolygon: function (object, stream) {
			var coordinates = object.coordinates, i = -1, n = coordinates.length;
			while (++i < n) streamPolygon(coordinates[i], stream);
		},
		GeometryCollection: function (object, stream) {
			var geometries = object.geometries, i = -1, n = geometries.length;
			while (++i < n) streamGeometry(geometries[i], stream);
		}
	};

	function streamLine(coordinates, stream, closed) {
		var i = -1, n = coordinates.length - closed, coordinate;
		stream.lineStart();
		while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
		stream.lineEnd();
	}

	function streamPolygon(coordinates, stream) {
		var i = -1, n = coordinates.length;
		stream.polygonStart();
		while (++i < n) streamLine(coordinates[i], stream, 1);
		stream.polygonEnd();
	}

	function geoStream(object, stream) {
		if (object && streamObjectType.hasOwnProperty(object.type)) {
			streamObjectType[object.type](object, stream);
		} else {
			streamGeometry(object, stream);
		}
	}

	adder();

	adder();

	function spherical(cartesian) {
		return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];
	}

	function cartesian(spherical) {
		var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);
		return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
	}

	function cartesianDot(a, b) {
		return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
	}

	function cartesianCross(a, b) {
		return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
	}

	// TODO return a
	function cartesianAddInPlace(a, b) {
		a[0] += b[0], a[1] += b[1], a[2] += b[2];
	}

	function cartesianScale(vector, k) {
		return [vector[0] * k, vector[1] * k, vector[2] * k];
	}

	// TODO return d
	function cartesianNormalizeInPlace(d) {
		var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
		d[0] /= l, d[1] /= l, d[2] /= l;
	}

	adder();

	function compose(a, b) {

		function compose(x, y) {
			return x = a(x, y), b(x[0], x[1]);
		}

		if (a.invert && b.invert) compose.invert = function (x, y) {
			return x = b.invert(x, y), x && a.invert(x[0], x[1]);
		};

		return compose;
	}

	function rotationIdentity(lambda, phi) {
		return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
	}

	rotationIdentity.invert = rotationIdentity;

	function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
		return (deltaLambda %= tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
			: rotationLambda(deltaLambda))
			: (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
				: rotationIdentity);
	}

	function forwardRotationLambda(deltaLambda) {
		return function (lambda, phi) {
			return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
		};
	}

	function rotationLambda(deltaLambda) {
		var rotation = forwardRotationLambda(deltaLambda);
		rotation.invert = forwardRotationLambda(-deltaLambda);
		return rotation;
	}

	function rotationPhiGamma(deltaPhi, deltaGamma) {
		var cosDeltaPhi = cos(deltaPhi),
			sinDeltaPhi = sin(deltaPhi),
			cosDeltaGamma = cos(deltaGamma),
			sinDeltaGamma = sin(deltaGamma);

		function rotation(lambda, phi) {
			var cosPhi = cos(phi),
				x = cos(lambda) * cosPhi,
				y = sin(lambda) * cosPhi,
				z = sin(phi),
				k = z * cosDeltaPhi + x * sinDeltaPhi;
			return [
				atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
				asin(k * cosDeltaGamma + y * sinDeltaGamma)
			];
		}

		rotation.invert = function (lambda, phi) {
			var cosPhi = cos(phi),
				x = cos(lambda) * cosPhi,
				y = sin(lambda) * cosPhi,
				z = sin(phi),
				k = z * cosDeltaGamma - y * sinDeltaGamma;
			return [
				atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
				asin(k * cosDeltaPhi - x * sinDeltaPhi)
			];
		};

		return rotation;
	}

	// Generates a circle centered at [0°, 0°], with a given radius and precision.
	function circleStream(stream, radius, delta, direction, t0, t1) {
		if (!delta) return;
		var cosRadius = cos(radius),
			sinRadius = sin(radius),
			step = direction * delta;
		if (t0 == null) {
			t0 = radius + direction * tau;
			t1 = radius - step / 2;
		} else {
			t0 = circleRadius(cosRadius, t0);
			t1 = circleRadius(cosRadius, t1);
			if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;
		}
		for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
			point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
			stream.point(point[0], point[1]);
		}
	}

	// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
	function circleRadius(cosRadius, point) {
		point = cartesian(point), point[0] -= cosRadius;
		cartesianNormalizeInPlace(point);
		var radius = acos(-point[1]);
		return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
	}

	function clipBuffer() {
		var lines = [],
			line;
		return {
			point: function (x, y) {
				line.push([x, y]);
			},
			lineStart: function () {
				lines.push(line = []);
			},
			lineEnd: noop,
			rejoin: function () {
				if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
			},
			result: function () {
				var result = lines;
				lines = [];
				line = null;
				return result;
			}
		};
	}

	function clipLine(a, b, x0, y0, x1, y1) {
		var ax = a[0],
			ay = a[1],
			bx = b[0],
			by = b[1],
			t0 = 0,
			t1 = 1,
			dx = bx - ax,
			dy = by - ay,
			r;

		r = x0 - ax;
		if (!dx && r > 0) return;
		r /= dx;
		if (dx < 0) {
			if (r < t0) return;
			if (r < t1) t1 = r;
		} else if (dx > 0) {
			if (r > t1) return;
			if (r > t0) t0 = r;
		}

		r = x1 - ax;
		if (!dx && r < 0) return;
		r /= dx;
		if (dx < 0) {
			if (r > t1) return;
			if (r > t0) t0 = r;
		} else if (dx > 0) {
			if (r < t0) return;
			if (r < t1) t1 = r;
		}

		r = y0 - ay;
		if (!dy && r > 0) return;
		r /= dy;
		if (dy < 0) {
			if (r < t0) return;
			if (r < t1) t1 = r;
		} else if (dy > 0) {
			if (r > t1) return;
			if (r > t0) t0 = r;
		}

		r = y1 - ay;
		if (!dy && r < 0) return;
		r /= dy;
		if (dy < 0) {
			if (r > t1) return;
			if (r > t0) t0 = r;
		} else if (dy > 0) {
			if (r < t0) return;
			if (r < t1) t1 = r;
		}

		if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
		if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
		return true;
	}

	function pointEqual(a, b) {
		return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
	}

	function Intersection(point, points, other, entry) {
		this.x = point;
		this.z = points;
		this.o = other; // another intersection
		this.e = entry; // is an entry?
		this.v = false; // visited
		this.n = this.p = null; // next & previous
	}

	// A generalized polygon clipping algorithm: given a polygon that has been cut
	// into its visible line segments, and rejoins the segments by interpolating
	// along the clip edge.
	function clipPolygon(segments, compareIntersection, startInside, interpolate, stream) {
		var subject = [],
			clip = [],
			i,
			n;

		segments.forEach(function (segment) {
			if ((n = segment.length - 1) <= 0) return;
			var n, p0 = segment[0], p1 = segment[n], x;

			// If the first and last points of a segment are coincident, then treat as a
			// closed ring. TODO if all rings are closed, then the winding order of the
			// exterior ring should be checked.
			if (pointEqual(p0, p1)) {
				stream.lineStart();
				for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
				stream.lineEnd();
				return;
			}

			subject.push(x = new Intersection(p0, segment, null, true));
			clip.push(x.o = new Intersection(p0, null, x, false));
			subject.push(x = new Intersection(p1, segment, null, false));
			clip.push(x.o = new Intersection(p1, null, x, true));
		});

		if (!subject.length) return;

		clip.sort(compareIntersection);
		link(subject);
		link(clip);

		for (i = 0, n = clip.length; i < n; ++i) {
			clip[i].e = startInside = !startInside;
		}

		var start = subject[0],
			points,
			point;

		while (1) {
			// Find first unvisited intersection.
			var current = start,
				isSubject = true;
			while (current.v) if ((current = current.n) === start) return;
			points = current.z;
			stream.lineStart();
			do {
				current.v = current.o.v = true;
				if (current.e) {
					if (isSubject) {
						for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
					} else {
						interpolate(current.x, current.n.x, 1, stream);
					}
					current = current.n;
				} else {
					if (isSubject) {
						points = current.p.z;
						for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
					} else {
						interpolate(current.x, current.p.x, -1, stream);
					}
					current = current.p;
				}
				current = current.o;
				points = current.z;
				isSubject = !isSubject;
			} while (!current.v);
			stream.lineEnd();
		}
	}

	function link(array) {
		if (!(n = array.length)) return;
		var n,
			i = 0,
			a = array[0],
			b;
		while (++i < n) {
			a.n = b = array[i];
			b.p = a;
			a = b;
		}
		a.n = b = array[0];
		b.p = a;
	}

	function ascending(a, b) {
		return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	}

	function bisector(compare) {
		if (compare.length === 1) compare = ascendingComparator(compare);
		return {
			left: function (a, x, lo, hi) {
				if (lo == null) lo = 0;
				if (hi == null) hi = a.length;
				while (lo < hi) {
					var mid = lo + hi >>> 1;
					if (compare(a[mid], x) < 0) lo = mid + 1;
					else hi = mid;
				}
				return lo;
			},
			right: function (a, x, lo, hi) {
				if (lo == null) lo = 0;
				if (hi == null) hi = a.length;
				while (lo < hi) {
					var mid = lo + hi >>> 1;
					if (compare(a[mid], x) > 0) hi = mid;
					else lo = mid + 1;
				}
				return lo;
			}
		};
	}

	function ascendingComparator(f) {
		return function (d, x) {
			return ascending(f(d), x);
		};
	}

	bisector(ascending);

	function merge(arrays) {
		var n = arrays.length,
			m,
			i = -1,
			j = 0,
			merged,
			array;

		while (++i < n) j += arrays[i].length;
		merged = new Array(j);

		while (--n >= 0) {
			array = arrays[n];
			m = array.length;
			while (--m >= 0) {
				merged[--j] = array[m];
			}
		}

		return merged;
	}

	var clipMax = 1e9, clipMin = -clipMax;

	// TODO Use d3-polygon’s polygonContains here for the ring check?
	// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

	function clipExtent(x0, y0, x1, y1) {

		function visible(x, y) {
			return x0 <= x && x <= x1 && y0 <= y && y <= y1;
		}

		function interpolate(from, to, direction, stream) {
			var a = 0, a1 = 0;
			if (from == null
				|| (a = corner(from, direction)) !== (a1 = corner(to, direction))
				|| comparePoint(from, to) < 0 ^ direction > 0) {
				do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
				while ((a = (a + direction + 4) % 4) !== a1);
			} else {
				stream.point(to[0], to[1]);
			}
		}

		function corner(p, direction) {
			return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3
				: abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1
					: abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0
						: direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
		}

		function compareIntersection(a, b) {
			return comparePoint(a.x, b.x);
		}

		function comparePoint(a, b) {
			var ca = corner(a, 1),
				cb = corner(b, 1);
			return ca !== cb ? ca - cb
				: ca === 0 ? b[1] - a[1]
					: ca === 1 ? a[0] - b[0]
						: ca === 2 ? a[1] - b[1]
							: b[0] - a[0];
		}

		return function (stream) {
			var activeStream = stream,
				bufferStream = clipBuffer(),
				segments,
				polygon,
				ring,
				x__, y__, v__, // first point
				x_, y_, v_, // previous point
				first,
				clean;

			var clipStream = {
				point: point,
				lineStart: lineStart,
				lineEnd: lineEnd,
				polygonStart: polygonStart,
				polygonEnd: polygonEnd
			};

			function point(x, y) {
				if (visible(x, y)) activeStream.point(x, y);
			}

			function polygonInside() {
				var winding = 0;

				for (var i = 0, n = polygon.length; i < n; ++i) {
					for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
						a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
						if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
						else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
					}
				}

				return winding;
			}

			// Buffer geometry within a polygon and then clip it en masse.
			function polygonStart() {
				activeStream = bufferStream, segments = [], polygon = [], clean = true;
			}

			function polygonEnd() {
				var startInside = polygonInside(),
					cleanInside = clean && startInside,
					visible = (segments = merge(segments)).length;
				if (cleanInside || visible) {
					stream.polygonStart();
					if (cleanInside) {
						stream.lineStart();
						interpolate(null, null, 1, stream);
						stream.lineEnd();
					}
					if (visible) {
						clipPolygon(segments, compareIntersection, startInside, interpolate, stream);
					}
					stream.polygonEnd();
				}
				activeStream = stream, segments = polygon = ring = null;
			}

			function lineStart() {
				clipStream.point = linePoint;
				if (polygon) polygon.push(ring = []);
				first = true;
				v_ = false;
				x_ = y_ = NaN;
			}

			// TODO rather than special-case polygons, simply handle them separately.
			// Ideally, coincident intersection points should be jittered to avoid
			// clipping issues.
			function lineEnd() {
				if (segments) {
					linePoint(x__, y__);
					if (v__ && v_) bufferStream.rejoin();
					segments.push(bufferStream.result());
				}
				clipStream.point = point;
				if (v_) activeStream.lineEnd();
			}

			function linePoint(x, y) {
				var v = visible(x, y);
				if (polygon) ring.push([x, y]);
				if (first) {
					x__ = x, y__ = y, v__ = v;
					first = false;
					if (v) {
						activeStream.lineStart();
						activeStream.point(x, y);
					}
				} else {
					if (v && v_) activeStream.point(x, y);
					else {
						var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
							b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
						if (clipLine(a, b, x0, y0, x1, y1)) {
							if (!v_) {
								activeStream.lineStart();
								activeStream.point(a[0], a[1]);
							}
							activeStream.point(b[0], b[1]);
							if (!v) activeStream.lineEnd();
							clean = false;
						} else if (v) {
							activeStream.lineStart();
							activeStream.point(x, y);
							clean = false;
						}
					}
				}
				x_ = x, y_ = y, v_ = v;
			}

			return clipStream;
		};
	}

	var sum = adder();

	function polygonContains(polygon, point) {
		var lambda = point[0],
			phi = point[1],
			normal = [sin(lambda), -cos(lambda), 0],
			angle = 0,
			winding = 0;

		sum.reset();

		for (var i = 0, n = polygon.length; i < n; ++i) {
			if (!(m = (ring = polygon[i]).length)) continue;
			var ring,
				m,
				point0 = ring[m - 1],
				lambda0 = point0[0],
				phi0 = point0[1] / 2 + quarterPi,
				sinPhi0 = sin(phi0),
				cosPhi0 = cos(phi0);

			for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
				var point1 = ring[j],
					lambda1 = point1[0],
					phi1 = point1[1] / 2 + quarterPi,
					sinPhi1 = sin(phi1),
					cosPhi1 = cos(phi1),
					delta = lambda1 - lambda0,
					sign = delta >= 0 ? 1 : -1,
					absDelta = sign * delta,
					antimeridian = absDelta > pi,
					k = sinPhi0 * sinPhi1;

				sum.add(atan2(k * sign * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));
				angle += antimeridian ? delta + sign * tau : delta;

				// Are the longitudes either side of the point’s meridian (lambda),
				// and are the latitudes smaller than the parallel (phi)?
				if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
					var arc = cartesianCross(cartesian(point0), cartesian(point1));
					cartesianNormalizeInPlace(arc);
					var intersection = cartesianCross(normal, arc);
					cartesianNormalizeInPlace(intersection);
					var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
					if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
						winding += antimeridian ^ delta >= 0 ? 1 : -1;
					}
				}
			}
		}

		// First, determine whether the South pole is inside or outside:
		//
		// It is inside if:
		// * the polygon winds around it in a clockwise direction.
		// * the polygon does not (cumulatively) wind around it, but has a negative
		//   (counter-clockwise) area.
		//
		// Second, count the (signed) number of times a segment crosses a lambda
		// from the point to the South pole.  If it is zero, then the point is the
		// same side as the South pole.

		return (angle < -epsilon || angle < epsilon && sum < -epsilon) ^ (winding & 1);
	}

	adder();

	function identity(x) {
		return x;
	}

	adder();
	adder();

	var x0 = Infinity,
		y0 = x0,
		x1 = -x0,
		y1 = x1;

	var boundsStream = {
		point: boundsPoint,
		lineStart: noop,
		lineEnd: noop,
		polygonStart: noop,
		polygonEnd: noop,
		result: function () {
			var bounds = [[x0, y0], [x1, y1]];
			x1 = y1 = -(y0 = x0 = Infinity);
			return bounds;
		}
	};

	function boundsPoint(x, y) {
		if (x < x0) x0 = x;
		if (x > x1) x1 = x;
		if (y < y0) y0 = y;
		if (y > y1) y1 = y;
	}

	adder();

	function clip(pointVisible, clipLine, interpolate, start) {
		return function (rotate, sink) {
			var line = clipLine(sink),
				rotatedStart = rotate.invert(start[0], start[1]),
				ringBuffer = clipBuffer(),
				ringSink = clipLine(ringBuffer),
				polygonStarted = false,
				polygon,
				segments,
				ring;

			var clip = {
				point: point,
				lineStart: lineStart,
				lineEnd: lineEnd,
				polygonStart: function () {
					clip.point = pointRing;
					clip.lineStart = ringStart;
					clip.lineEnd = ringEnd;
					segments = [];
					polygon = [];
				},
				polygonEnd: function () {
					clip.point = point;
					clip.lineStart = lineStart;
					clip.lineEnd = lineEnd;
					segments = merge(segments);
					var startInside = polygonContains(polygon, rotatedStart);
					if (segments.length) {
						if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
						clipPolygon(segments, compareIntersection, startInside, interpolate, sink);
					} else if (startInside) {
						if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
						sink.lineStart();
						interpolate(null, null, 1, sink);
						sink.lineEnd();
					}
					if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
					segments = polygon = null;
				},
				sphere: function () {
					sink.polygonStart();
					sink.lineStart();
					interpolate(null, null, 1, sink);
					sink.lineEnd();
					sink.polygonEnd();
				}
			};

			function point(lambda, phi) {
				var point = rotate(lambda, phi);
				if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi);
			}

			function pointLine(lambda, phi) {
				var point = rotate(lambda, phi);
				line.point(point[0], point[1]);
			}

			function lineStart() {
				clip.point = pointLine;
				line.lineStart();
			}

			function lineEnd() {
				clip.point = point;
				line.lineEnd();
			}

			function pointRing(lambda, phi) {
				ring.push([lambda, phi]);
				var point = rotate(lambda, phi);
				ringSink.point(point[0], point[1]);
			}

			function ringStart() {
				ringSink.lineStart();
				ring = [];
			}

			function ringEnd() {
				pointRing(ring[0][0], ring[0][1]);
				ringSink.lineEnd();

				var clean = ringSink.clean(),
					ringSegments = ringBuffer.result(),
					i, n = ringSegments.length, m,
					segment,
					point;

				ring.pop();
				polygon.push(ring);
				ring = null;

				if (!n) return;

				// No intersections.
				if (clean & 1) {
					segment = ringSegments[0];
					if ((m = segment.length - 1) > 0) {
						if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
						sink.lineStart();
						for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
						sink.lineEnd();
					}
					return;
				}

				// Rejoin connected segments.
				// TODO reuse ringBuffer.rejoin()?
				if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

				segments.push(ringSegments.filter(validSegment));
			}

			return clip;
		};
	}

	function validSegment(segment) {
		return segment.length > 1;
	}

	// Intersections are sorted along the clip edge. For both antimeridian cutting
	// and circle clipping, the same comparison is used.
	function compareIntersection(a, b) {
		return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])
			- ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
	}

	var clipAntimeridian = clip(
		function () { return true; },
		clipAntimeridianLine,
		clipAntimeridianInterpolate,
		[-pi, -halfPi]
	);

	// Takes a line and cuts into visible segments. Return values: 0 - there were
	// intersections or the line was empty; 1 - no intersections; 2 - there were
	// intersections, and the first and last segments should be rejoined.
	function clipAntimeridianLine(stream) {
		var lambda0 = NaN,
			phi0 = NaN,
			sign0 = NaN,
			clean; // no intersections

		return {
			lineStart: function () {
				stream.lineStart();
				clean = 1;
			},
			point: function (lambda1, phi1) {
				var sign1 = lambda1 > 0 ? pi : -pi,
					delta = abs(lambda1 - lambda0);
				if (abs(delta - pi) < epsilon) { // line crosses a pole
					stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
					stream.point(sign0, phi0);
					stream.lineEnd();
					stream.lineStart();
					stream.point(sign1, phi0);
					stream.point(lambda1, phi0);
					clean = 0;
				} else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian
					if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon; // handle degeneracies
					if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;
					phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
					stream.point(sign0, phi0);
					stream.lineEnd();
					stream.lineStart();
					stream.point(sign1, phi0);
					clean = 0;
				}
				stream.point(lambda0 = lambda1, phi0 = phi1);
				sign0 = sign1;
			},
			lineEnd: function () {
				stream.lineEnd();
				lambda0 = phi0 = NaN;
			},
			clean: function () {
				return 2 - clean; // if intersections, rejoin first and last segments
			}
		};
	}

	function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
		var cosPhi0,
			cosPhi1,
			sinLambda0Lambda1 = sin(lambda0 - lambda1);
		return abs(sinLambda0Lambda1) > epsilon
			? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)
				- sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))
				/ (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
			: (phi0 + phi1) / 2;
	}

	function clipAntimeridianInterpolate(from, to, direction, stream) {
		var phi;
		if (from == null) {
			phi = direction * halfPi;
			stream.point(-pi, phi);
			stream.point(0, phi);
			stream.point(pi, phi);
			stream.point(pi, 0);
			stream.point(pi, -phi);
			stream.point(0, -phi);
			stream.point(-pi, -phi);
			stream.point(-pi, 0);
			stream.point(-pi, phi);
		} else if (abs(from[0] - to[0]) > epsilon) {
			var lambda = from[0] < to[0] ? pi : -pi;
			phi = direction * lambda / 2;
			stream.point(-lambda, phi);
			stream.point(0, phi);
			stream.point(lambda, phi);
		} else {
			stream.point(to[0], to[1]);
		}
	}

	function clipCircle(radius, delta) {
		var cr = cos(radius),
			smallRadius = cr > 0,
			notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case

		function interpolate(from, to, direction, stream) {
			circleStream(stream, radius, delta, direction, from, to);
		}

		function visible(lambda, phi) {
			return cos(lambda) * cos(phi) > cr;
		}

		// Takes a line and cuts into visible segments. Return values used for polygon
		// clipping: 0 - there were intersections or the line was empty; 1 - no
		// intersections 2 - there were intersections, and the first and last segments
		// should be rejoined.
		function clipLine(stream) {
			var point0, // previous point
				c0, // code for previous point
				v0, // visibility of previous point
				v00, // visibility of first point
				clean; // no intersections
			return {
				lineStart: function () {
					v00 = v0 = false;
					clean = 1;
				},
				point: function (lambda, phi) {
					var point1 = [lambda, phi],
						point2,
						v = visible(lambda, phi),
						c = smallRadius
							? v ? 0 : code(lambda, phi)
							: v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
					if (!point0 && (v00 = v0 = v)) stream.lineStart();
					// Handle degeneracies.
					// TODO ignore if not clipping polygons.
					if (v !== v0) {
						point2 = intersect(point0, point1);
						if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {
							point1[0] += epsilon;
							point1[1] += epsilon;
							v = visible(point1[0], point1[1]);
						}
					}
					if (v !== v0) {
						clean = 0;
						if (v) {
							// outside going in
							stream.lineStart();
							point2 = intersect(point1, point0);
							stream.point(point2[0], point2[1]);
						} else {
							// inside going out
							point2 = intersect(point0, point1);
							stream.point(point2[0], point2[1]);
							stream.lineEnd();
						}
						point0 = point2;
					} else if (notHemisphere && point0 && smallRadius ^ v) {
						var t;
						// If the codes for two points are different, or are both zero,
						// and there this segment intersects with the small circle.
						if (!(c & c0) && (t = intersect(point1, point0, true))) {
							clean = 0;
							if (smallRadius) {
								stream.lineStart();
								stream.point(t[0][0], t[0][1]);
								stream.point(t[1][0], t[1][1]);
								stream.lineEnd();
							} else {
								stream.point(t[1][0], t[1][1]);
								stream.lineEnd();
								stream.lineStart();
								stream.point(t[0][0], t[0][1]);
							}
						}
					}
					if (v && (!point0 || !pointEqual(point0, point1))) {
						stream.point(point1[0], point1[1]);
					}
					point0 = point1, v0 = v, c0 = c;
				},
				lineEnd: function () {
					if (v0) stream.lineEnd();
					point0 = null;
				},
				// Rejoin first and last segments if there were intersections and the first
				// and last points were visible.
				clean: function () {
					return clean | ((v00 && v0) << 1);
				}
			};
		}

		// Intersects the great circle between a and b with the clip circle.
		function intersect(a, b, two) {
			var pa = cartesian(a),
				pb = cartesian(b);

			// We have two planes, n1.p = d1 and n2.p = d2.
			// Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
			var n1 = [1, 0, 0], // normal
				n2 = cartesianCross(pa, pb),
				n2n2 = cartesianDot(n2, n2),
				n1n2 = n2[0], // cartesianDot(n1, n2),
				determinant = n2n2 - n1n2 * n1n2;

			// Two polar points.
			if (!determinant) return !two && a;

			var c1 = cr * n2n2 / determinant,
				c2 = -cr * n1n2 / determinant,
				n1xn2 = cartesianCross(n1, n2),
				A = cartesianScale(n1, c1),
				B = cartesianScale(n2, c2);
			cartesianAddInPlace(A, B);

			// Solve |p(t)|^2 = 1.
			var u = n1xn2,
				w = cartesianDot(A, u),
				uu = cartesianDot(u, u),
				t2 = w * w - uu * (cartesianDot(A, A) - 1);

			if (t2 < 0) return;

			var t = sqrt(t2),
				q = cartesianScale(u, (-w - t) / uu);
			cartesianAddInPlace(q, A);
			q = spherical(q);

			if (!two) return q;

			// Two intersection points.
			var lambda0 = a[0],
				lambda1 = b[0],
				phi0 = a[1],
				phi1 = b[1],
				z;

			if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

			var delta = lambda1 - lambda0,
				polar = abs(delta - pi) < epsilon,
				meridian = polar || delta < epsilon;

			if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

			// Check that the first point is between a and b.
			if (meridian
				? polar
					? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)
					: phi0 <= q[1] && q[1] <= phi1
				: delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
				var q1 = cartesianScale(u, (-w + t) / uu);
				cartesianAddInPlace(q1, A);
				return [q, spherical(q1)];
			}
		}

		// Generates a 4-bit vector representing the location of a point relative to
		// the small circle's bounding box.
		function code(lambda, phi) {
			var r = smallRadius ? radius : pi - radius,
				code = 0;
			if (lambda < -r) code |= 1; // left
			else if (lambda > r) code |= 2; // right
			if (phi < -r) code |= 4; // below
			else if (phi > r) code |= 8; // above
			return code;
		}

		return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);
	}

	function transformer(methods) {
		return function (stream) {
			var s = new TransformStream;
			for (var key in methods) s[key] = methods[key];
			s.stream = stream;
			return s;
		};
	}

	function TransformStream() { }

	TransformStream.prototype = {
		constructor: TransformStream,
		point: function (x, y) { this.stream.point(x, y); },
		sphere: function () { this.stream.sphere(); },
		lineStart: function () { this.stream.lineStart(); },
		lineEnd: function () { this.stream.lineEnd(); },
		polygonStart: function () { this.stream.polygonStart(); },
		polygonEnd: function () { this.stream.polygonEnd(); }
	};

	function fitExtent(projection, extent, object) {
		var w = extent[1][0] - extent[0][0],
			h = extent[1][1] - extent[0][1],
			clip = projection.clipExtent && projection.clipExtent();

		projection
			.scale(150)
			.translate([0, 0]);

		if (clip != null) projection.clipExtent(null);

		geoStream(object, projection.stream(boundsStream));

		var b = boundsStream.result(),
			k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
			x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
			y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;

		if (clip != null) projection.clipExtent(clip);

		return projection
			.scale(k * 150)
			.translate([x, y]);
	}

	function fitSize(projection, size, object) {
		return fitExtent(projection, [[0, 0], size], object);
	}

	var maxDepth = 16, // maximum depth of subdivision
		cosMinDistance = cos(30 * radians); // cos(minimum angular distance)

	function resample(project, delta2) {
		return +delta2 ? resample$1(project, delta2) : resampleNone(project);
	}

	function resampleNone(project) {
		return transformer({
			point: function (x, y) {
				x = project(x, y);
				this.stream.point(x[0], x[1]);
			}
		});
	}

	function resample$1(project, delta2) {

		function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
			var dx = x1 - x0,
				dy = y1 - y0,
				d2 = dx * dx + dy * dy;
			if (d2 > 4 * delta2 && depth--) {
				var a = a0 + a1,
					b = b0 + b1,
					c = c0 + c1,
					m = sqrt(a * a + b * b + c * c),
					phi2 = asin(c /= m),
					lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),
					p = project(lambda2, phi2),
					x2 = p[0],
					y2 = p[1],
					dx2 = x2 - x0,
					dy2 = y2 - y0,
					dz = dy * dx2 - dx * dy2;
				if (dz * dz / d2 > delta2 // perpendicular projected distance
					|| abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
					|| a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
					resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
					stream.point(x2, y2);
					resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
				}
			}
		}
		return function (stream) {
			var lambda00, x00, y00, a00, b00, c00, // first point
				lambda0, x0, y0, a0, b0, c0; // previous point

			var resampleStream = {
				point: point,
				lineStart: lineStart,
				lineEnd: lineEnd,
				polygonStart: function () { stream.polygonStart(); resampleStream.lineStart = ringStart; },
				polygonEnd: function () { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
			};

			function point(x, y) {
				x = project(x, y);
				stream.point(x[0], x[1]);
			}

			function lineStart() {
				x0 = NaN;
				resampleStream.point = linePoint;
				stream.lineStart();
			}

			function linePoint(lambda, phi) {
				var c = cartesian([lambda, phi]), p = project(lambda, phi);
				resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
				stream.point(x0, y0);
			}

			function lineEnd() {
				resampleStream.point = point;
				stream.lineEnd();
			}

			function ringStart() {
				lineStart();
				resampleStream.point = ringPoint;
				resampleStream.lineEnd = ringEnd;
			}

			function ringPoint(lambda, phi) {
				linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
				resampleStream.point = linePoint;
			}

			function ringEnd() {
				resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
				resampleStream.lineEnd = lineEnd;
				lineEnd();
			}

			return resampleStream;
		};
	}

	var transformRadians = transformer({
		point: function (x, y) {
			this.stream.point(x * radians, y * radians);
		}
	});

	function projection(project) {
		return projectionMutator(function () { return project; })();
	}

	function projectionMutator(projectAt) {
		var project,
			k = 150, // scale
			x = 480, y = 250, // translate
			dx, dy, lambda = 0, phi = 0, // center
			deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, projectRotate, // rotate
			theta = null, preclip = clipAntimeridian, // clip angle
			x0 = null, y0, x1, y1, postclip = identity, // clip extent
			delta2 = 0.5, projectResample = resample(projectTransform, delta2), // precision
			cache,
			cacheStream;

		function projection(point) {
			point = projectRotate(point[0] * radians, point[1] * radians);
			return [point[0] * k + dx, dy - point[1] * k];
		}

		function invert(point) {
			point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);
			return point && [point[0] * degrees, point[1] * degrees];
		}

		function projectTransform(x, y) {
			return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];
		}

		projection.stream = function (stream) {
			return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));
		};

		projection.clipAngle = function (_) {
			return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians, 6 * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
		};

		projection.clipExtent = function (_) {
			return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
		};

		projection.scale = function (_) {
			return arguments.length ? (k = +_, recenter()) : k;
		};

		projection.translate = function (_) {
			return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
		};

		projection.center = function (_) {
			return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
		};

		projection.rotate = function (_) {
			return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
		};

		projection.precision = function (_) {
			return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
		};

		projection.fitExtent = function (extent, object) {
			return fitExtent(projection, extent, object);
		};

		projection.fitSize = function (size, object) {
			return fitSize(projection, size, object);
		};

		function recenter() {
			projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);
			var center = project(lambda, phi);
			dx = x - center[0] * k;
			dy = y + center[1] * k;
			return reset();
		}

		function reset() {
			cache = cacheStream = null;
			return projection;
		}

		return function () {
			project = projectAt.apply(this, arguments);
			projection.invert = project.invert && invert;
			return recenter();
		};
	}

	function azimuthalRaw(scale) {
		return function (x, y) {
			var cx = cos(x),
				cy = cos(y),
				k = scale(cx * cy);
			return [
				k * cy * sin(x),
				k * sin(y)
			];
		}
	}

	function azimuthalInvert(angle) {
		return function (x, y) {
			var z = sqrt(x * x + y * y),
				c = angle(z),
				sc = sin(c),
				cc = cos(c);
			return [
				atan2(x * sc, z * cc),
				asin(z && y * sc / z)
			];
		}
	}

	var azimuthalEqualAreaRaw = azimuthalRaw(function (cxcy) {
		return sqrt(2 / (1 + cxcy));
	});

	azimuthalEqualAreaRaw.invert = azimuthalInvert(function (z) {
		return 2 * asin(z / 2);
	});

	var azimuthalEquidistantRaw = azimuthalRaw(function (c) {
		return (c = acos(c)) && c / sin(c);
	});

	azimuthalEquidistantRaw.invert = azimuthalInvert(function (z) {
		return z;
	});

	function geoAzimuthalEquidistant() {
		return projection(azimuthalEquidistantRaw)
			.scale(79.4188)
			.clipAngle(180 - 1e-3);
	}

	function equirectangularRaw(lambda, phi) {
		return [lambda, phi];
	}

	equirectangularRaw.invert = equirectangularRaw;

	/**
	 * Calculates a buffer for input features for a given radius. Units supported are miles, kilometers, and degrees.
	 *
	 * When using a negative radius, the resulting geometry may be invalid if
	 * it's too small compared to the radius magnitude. If the input is a
	 * FeatureCollection, only valid members will be returned in the output
	 * FeatureCollection - i.e., the output collection may have fewer members than
	 * the input, or even be empty.
	 *
	 * @name buffer
	 * @param {FeatureCollection|Geometry|Feature<any>} geojson input to be buffered
	 * @param {number} radius distance to draw the buffer (negative values are allowed)
	 * @param {Object} [options={}] Optional parameters
	 * @param {string} [options.units="kilometers"] any of the options supported by turf units
	 * @param {number} [options.steps=8] number of steps
	 * @returns {FeatureCollection|Feature<Polygon|MultiPolygon>|undefined} buffered features
	 * @example
	 * var point = turf.point([-90.548630, 14.616599]);
	 * var buffered = turf.buffer(point, 500, {units: 'miles'});
	 *
	 * //addToMap
	 * var addToMap = [point, buffered]
	 */
	function buffer(geojson, radius, options) {
		// Optional params
		options = options || {};

		// use user supplied options or default values
		var units = options.units || "kilometers";
		var steps = options.steps || 8;

		// validation
		if (!geojson) throw new Error("geojson is required");
		if (typeof options !== "object") throw new Error("options must be an object");
		if (typeof steps !== "number") throw new Error("steps must be an number");

		// Allow negative buffers ("erosion") or zero-sized buffers ("repair geometry")
		if (radius === undefined) throw new Error("radius is required");
		if (steps <= 0) throw new Error("steps must be greater than 0");

		var results = [];
		switch (geojson.type) {
			case "GeometryCollection":
				geomEach(geojson, function (geometry) {
					var buffered = bufferFeature(geometry, radius, units, steps);
					if (buffered) results.push(buffered);
				});
				return featureCollection(results);
			case "FeatureCollection":
				featureEach(geojson, function (feature) {
					var multiBuffered = bufferFeature(feature, radius, units, steps);
					if (multiBuffered) {
						featureEach(multiBuffered, function (buffered) {
							if (buffered) results.push(buffered);
						});
					}
				});
				return featureCollection(results);
		}
		return bufferFeature(geojson, radius, units, steps);
	}

	/**
	 * Buffer single Feature/Geometry
	 *
	 * @private
	 * @param {Feature<any>} geojson input to be buffered
	 * @param {number} radius distance to draw the buffer
	 * @param {string} [units='kilometers'] any of the options supported by turf units
	 * @param {number} [steps=8] number of steps
	 * @returns {Feature<Polygon|MultiPolygon>} buffered feature
	 */
	function bufferFeature(geojson, radius, units, steps) {
		var properties = geojson.properties || {};
		var geometry = geojson.type === "Feature" ? geojson.geometry : geojson;

		// Geometry Types faster than jsts
		if (geometry.type === "GeometryCollection") {
			var results = [];
			geomEach(geojson, function (geometry) {
				var buffered = bufferFeature(geometry, radius, units, steps);
				if (buffered) results.push(buffered);
			});
			return featureCollection(results);
		}

		// Project GeoJSON to Azimuthal Equidistant projection (convert to Meters)
		var projection = defineProjection(geometry);
		var projected = {
			type: geometry.type,
			coordinates: projectCoords(geometry.coordinates, projection),
		};

		// JSTS buffer operation
		var reader = new GeoJSONReader();
		var geom = reader.read(projected);
		var distance = radiansToLength(lengthToRadians(radius, units), "meters");
		var buffered = BufferOp.bufferOp(geom, distance, steps);
		var writer = new GeoJSONWriter();
		buffered = writer.write(buffered);

		// Detect if empty geometries
		if (coordsIsNaN(buffered.coordinates)) return undefined;

		// Unproject coordinates (convert to Degrees)
		var result = {
			type: buffered.type,
			coordinates: unprojectCoords(buffered.coordinates, projection),
		};

		return feature(result, properties);
	}

	/**
	 * Coordinates isNaN
	 *
	 * @private
	 * @param {Array<any>} coords GeoJSON Coordinates
	 * @returns {boolean} if NaN exists
	 */
	function coordsIsNaN(coords) {
		if (Array.isArray(coords[0])) return coordsIsNaN(coords[0]);
		return isNaN(coords[0]);
	}

	/**
	 * Project coordinates to projection
	 *
	 * @private
	 * @param {Array<any>} coords to project
	 * @param {GeoProjection} proj D3 Geo Projection
	 * @returns {Array<any>} projected coordinates
	 */
	function projectCoords(coords, proj) {
		if (typeof coords[0] !== "object") return proj(coords);
		return coords.map(function (coord) {
			return projectCoords(coord, proj);
		});
	}

	/**
	 * Un-Project coordinates to projection
	 *
	 * @private
	 * @param {Array<any>} coords to un-project
	 * @param {GeoProjection} proj D3 Geo Projection
	 * @returns {Array<any>} un-projected coordinates
	 */
	function unprojectCoords(coords, proj) {
		if (typeof coords[0] !== "object") return proj.invert(coords);
		return coords.map(function (coord) {
			return unprojectCoords(coord, proj);
		});
	}

	/**
	 * Define Azimuthal Equidistant projection
	 *
	 * @private
	 * @param {Geometry|Feature<any>} geojson Base projection on center of GeoJSON
	 * @returns {GeoProjection} D3 Geo Azimuthal Equidistant Projection
	 */
	function defineProjection(geojson) {
		var coords = center(geojson).geometry.coordinates;
		var rotation = [-coords[0], -coords[1]];
		return geoAzimuthalEquidistant().rotate(rotation).scale(earthRadius);
	}

	/**
	 * Takes two {@link Polygon|polygon} or {@link MultiPolygon|multi-polygon} geometries and
	 * finds their polygonal intersection. If they don't intersect, returns null.
	 *
	 * @name intersect
	 * @param {Feature<Polygon | MultiPolygon>} poly1 the first polygon or multipolygon
	 * @param {Feature<Polygon | MultiPolygon>} poly2 the second polygon or multipolygon
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Object} [options.properties={}] Translate GeoJSON Properties to Feature
	 * @returns {Feature|null} returns a feature representing the area they share (either a {@link Polygon} or
	 * {@link MultiPolygon}). If they do not share any area, returns `null`.
	 * @example
	 * var poly1 = turf.polygon([[
	 *   [-122.801742, 45.48565],
	 *   [-122.801742, 45.60491],
	 *   [-122.584762, 45.60491],
	 *   [-122.584762, 45.48565],
	 *   [-122.801742, 45.48565]
	 * ]]);
	 *
	 * var poly2 = turf.polygon([[
	 *   [-122.520217, 45.535693],
	 *   [-122.64038, 45.553967],
	 *   [-122.720031, 45.526554],
	 *   [-122.669906, 45.507309],
	 *   [-122.723464, 45.446643],
	 *   [-122.532577, 45.408574],
	 *   [-122.487258, 45.477466],
	 *   [-122.520217, 45.535693]
	 * ]]);
	 *
	 * var intersection = turf.intersect(poly1, poly2);
	 *
	 * //addToMap
	 * var addToMap = [poly1, poly2, intersection];
	 */
	function intersect$1(poly1, poly2, options) {
		if (options === void 0) { options = {}; }
		var geom1 = getGeom(poly1);
		var geom2 = getGeom(poly2);
		var intersection = polygonClipping.intersection(geom1.coordinates, geom2.coordinates);
		if (intersection.length === 0)
			return null;
		if (intersection.length === 1)
			return polygon(intersection[0], options.properties);
		return multiPolygon(intersection, options.properties);
	}

	/**
	 * 图表图层类，对接geoJson数据
	 */
	class ChartsLayerEX {
		/**
		 * @param {SceneGIS.Viewer} viewer 
		 */
		constructor(viewer) {
			this.map = viewer;
			this.data = null;
			this.entityDatas = new SceneGIS.CustomDataSource(SceneGIS.createGuid());
			this.entityMap = new Map();
			this.showEntity = null;
			this._dataSourcePromise = null;
			this.map.dataSources.add(this.entityDatas);
			this.map.scene.globe.depthTestAgainstTerrain = true;
		}

		/**
		 * 添加图表
		 * @param {String|Object} geojson geojson格式的数据 
		 * @param {Object} options={} 配置项，除图表类型外具体参考ECharts配置项
		 * @param {String} options.type 图表类型： chart|bar|grid|network|pie
		 */
		add(geojson, options = {}) {
			if (options.type === "cluster") {
				this._dataSourcePromise = this.map.dataSources.add(
					SceneGIS.GeoJsonDataSource.load(geojson)
				);
				this.addCluster(this._dataSourcePromise, options);
				return this._dataSourcePromise;
			} else {
				return SceneGIS.GeoJsonDataSource.load(geojson).then(data => {
					const entityData = data.entities.values;

					if (options.type === 'chart') {
						this.addChart(entityData, options);
					} else if (options.type === 'bar') {
						this.addBar(entityData, 1, options);
					} else if (options.type === 'grid') {
						this.addGrid(entityData, options);
					} else if (options.type === 'network') {
						this.addNetwork(entityData, options);
					} else if (options.type === 'pie') {
						this.addPie(entityData, options);
					}

					// 添加hover事件
					this._hoverEvent();
					return data;
				});
			}
		}
		_random(min, max) {
			return Math.floor(Math.random() * (max - min) + min);
		}
		_sortByAttribute(entities, fieldName) {
			let maxValue = -1;
			entities.sort(function (a, b) {
				const value1 = parseInt(a.properties[fieldName]._value || 1);
				maxValue = value1 > maxValue ? value1 : maxValue;
				const value2 = parseInt(b.properties[fieldName]._value || 1);
				return value1 - value2;
			});
			return maxValue;
		}

		_sortByAttribute1(entities, fieldName) {
			entities.sort(function (a, b) {
				const value1 = parseInt(a.properties[fieldName]._value || 1);
				const value2 = parseInt(b.properties[fieldName]._value || 1);
				return value1 - value2;
			});
			return entities;
		}

		_sortByAttribute2(entities, fieldName) {
			if (entities.scaleMap && entities.scaleMap.has(fieldName)) {
				return entities.scaleMap.get(fieldName);
			}
			let maxValue = -1;
			let minValue = 10000000000;
			entities.sort(function (a, b) {
				const value1 = parseFloat(a.properties[fieldName]._value) || 0.0;
				if (value1) {
					maxValue = value1 > maxValue ? value1 : maxValue;
					minValue = value1 < minValue ? value1 : minValue;
				}
				const value2 = parseFloat(b.properties[fieldName]._value) || 0.0;
				return value1 - value2;
			});
			if (entities.scaleMap) {
				entities.scaleMap.set(fieldName, [minValue, maxValue]);
			}
			return [minValue, maxValue];
		}

		/**
		 * 
		 * @param {Object} entityData 数据
		 * @param {Object} options 
		 * @param {Number} [options.height=22000] 图表位置高度
		 * @param {Number} [options.extrudedHeight=23000] 图表高度
		 * @param {Array} [options.colorRamp] 图表颜色
		 */
		addChart(entityData, options) {
			let height = SceneGIS.defaultValue(options.height, 22000);
			let extrudedHeight = SceneGIS.defaultValue(options.extrudedHeight, 23000);
			let colorRamp = options.colorRamp || ['#0000FF', '#4169E1', '#6495ED', '#B0C4DE', '#1E90FF', '#4682B4', '#87CEFA', '#87CEEB', '#00BFFF', '#ADD8E6', '#B0E0E6'];

			let geometryInstances = [];
			const planeView = this.map.scene.planeView;
			entityData.forEach((entity, i) => {
				const lon = parseFloat(entity.properties.lon._value);
				const lat = parseFloat(entity.properties.lat._value);
				let positions = entity.polygon.hierarchy._value.positions;
				const color = new SceneGIS.Color.fromCssColorString(colorRamp[i]);
				const entityId = `polygon_${i}_${SceneGIS.createGuid()}`;
				extrudedHeight = extrudedHeight + parseInt(entity.properties.value);

				const instance = new SceneGIS.GeometryInstance({
					geometry: new SceneGIS.PolygonGeometry({
						height: height,
						polygonHierarchy: new SceneGIS.PolygonHierarchy(positions),
						extrudedHeight: extrudedHeight,
						vertexFormat: SceneGIS.PerInstanceColorAppearance.VERTEX_FORMAT,
						planeView: planeView
					}),
					attributes: {
						color: SceneGIS.ColorGeometryInstanceAttribute.fromColor(color),
					},
					id: entityId,
				});
				geometryInstances.push(instance);

				// 添加标注
				entity.polygon = undefined; // 去掉默认polygon绘制
				entity.label = {
					text: entity.properties.name,
					font: '36px 微软雅黑',
					// fillColor: SceneGIS.Color.SKYBLUE,
					fillColor: SceneGIS.Color.BLACK,
					// outlineColor: SceneGIS.Color.BLACK,
					// outlineWidth: 2,
					// style: SceneGIS.LabelStyle.FILL_AND_OUTLINE,
					scaleByDistance: new SceneGIS.NearFarScalar(100, 1.0, 200, 0.4)
				};
				if (planeView === true) {
					entity.position = new SceneGIS.Cartesian3(lon, lat, extrudedHeight + 100);
				} else {
					entity.position = SceneGIS.Cartesian3.fromDegrees(lon, lat, extrudedHeight + 10000);
				}
				this.entityDatas.entities.add(entity);
			});

			this.primitive = new SceneGIS.Primitive({
				geometryInstances: geometryInstances,
				appearance: new SceneGIS.PerInstanceColorAppearance({
					translucent: false,
					faceForward: true
				}),
				// releaseGeometryInstances:false  //如果要在primitive中查看到geometryInstances就需要开启
			});
			this.map.scene.primitives.add(this.primitive);
		}

		//Test 没啥用。不如直接remove以后再add
		updateChart(options) {
			console.log("this.primitive:", this.primitive, " options:", options);
			if (this.primitive && this.primitive._boundingSpheres && this.primitive._boundingSpheres.length > 0 && this.primitive._boundingSpheres[0].center) {
				let cartographic = SceneGIS.Cartographic.fromCartesian(this.primitive._boundingSpheres[0].center); //弧度
				let surface = SceneGIS.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, 2000);
				let offset = SceneGIS.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, options.height);
				let translation = SceneGIS.Cartesian3.subtract(offset, surface, new SceneGIS.Cartesian3());
				this.primitive.modelMatrix = SceneGIS.Matrix4.fromTranslation(translation);
			}

		}
		/**
		 * 
		 * @param {Object} entities 数据
		 * @param {Number} [duration=3]  生长时间
		 * @param {Object} options={} 
		 * @param {String} options.field 图表数据名称
		 * @param {Number} [options.scale=1] 图表尺寸
		 * @param {String} [options.unit="元"] 单位
		 * @param {Array} [options.colorRamp] 图表颜色
		 * @param {Number} [options.extrudeHeight=0] 图表高度
		 */
		addBar(entities, duration = 3, options = {}) {
			// 动画长出来
			const _field = options.field;
			const valueScale = options.scale || 1;
			const _unit = options.unit || "元";
			let colorRamp = options.colorRamp || ['#0000FF', '#4169E1', '#6495ED', '#B0C4DE', '#1E90FF', '#4682B4', '#87CEFA', '#87CEEB', '#00BFFF', '#ADD8E6', '#B0E0E6'];
			let extrudeHeight = options.extrudeHeight || 0;
			const planeView = this.map.scene.planeView;
			entities.forEach((entity, i) => {
				let name = undefined;
				if (entity.properties.name) {
					name = entity.properties.name._value;
				} else {
					name = '';
				}
				const lon = entity.properties.lon._value;
				const lat = entity.properties.lat._value;
				const value = parseInt(entity.properties[_field]._value);
				const beginHeight = SceneGIS.defined(entity.properties.beginHeight) ? entity.properties.beginHeight._value : 18000;

				const start = Date.now();
				const getText = function () {
					const timestamp = Date.now();
					const timeDifference = timestamp - start;
					const progress = SceneGIS.Math.clamp(timeDifference / (duration * 1000), 0, 1);
					let text = "";
					if (name === '') {
						text = parseInt(progress * value).toString() + _unit;
					} else {
						text = name + "\n" + parseInt(progress * value).toString() + _unit;
					}
					return text;
				};

				const getLength = function () {
					const timestamp = Date.now();
					const timeDifference = timestamp - start;
					const progress = SceneGIS.Math.clamp(timeDifference / (duration * 1000), 0, 1);
					const length = progress * (value + extrudeHeight) * valueScale;
					return length;
				};
				const getPosition = function () {
					const timestamp = Date.now();
					const timeDifference = timestamp - start;
					const progress = SceneGIS.Math.clamp(timeDifference / (duration * 1000), 0, 1);
					const height = beginHeight + progress * (value + extrudeHeight) * valueScale / 2;
					let position;
					if (planeView === true) {
						position = new SceneGIS.Cartesian3(lon, lat, height);
					} else {
						position = SceneGIS.Cartesian3.fromDegrees(lon, lat, height);
					}
					return position;
				};

				this.entityDatas.entities.add({
					id: `bar${i}_${SceneGIS.createGuid()}`,
					position: planeView === true ? new SceneGIS.Cartesian3(lon, lat, beginHeight)
						: SceneGIS.Cartesian3.fromDegrees(lon, lat, beginHeight),
					cylinder: {
						length: new SceneGIS.CallbackProperty(getLength, false),
						topRadius: SceneGIS.defined(entity.properties.radius) ? entity.properties.radius._value : 4000.0,
						bottomRadius: SceneGIS.defined(entity.properties.radius) ? entity.properties.radius._value : 4000.0,
						material: new SceneGIS.Color.fromCssColorString(colorRamp[i]).withAlpha(0.7),
						// material: getColorRamp([0.0, 1.0]),
						// material: getColorRamp([0.0, 1.0]),
					},
				});
				this.entityDatas.entities.add({
					id: `bar${i}_label_${SceneGIS.createGuid()}`,
					position: new SceneGIS.CallbackProperty(getPosition, false),
					label: {
						text: new SceneGIS.CallbackProperty(getText, false),
						// style: SceneGIS.LabelStyle.FILL_AND_OUTLINE,
						// fillColor: SceneGIS.Color.BLACK,
						fillColor: SceneGIS.Color.WHITE,
						font: "bold 24px Helvetica",
						// outlineColor: SceneGIS.Color.WHITE,
						disableDepthTestDistance: Number.POSITIVE_INFINITY,
						outlineWidth: 4,
						pixelOffset: new SceneGIS.Cartesian2(0, -18),
						verticalOrigin: SceneGIS.VerticalOrigin.BOTTOM,
						distanceDisplayCondition: new SceneGIS.DistanceDisplayCondition(0, 15000),
						scaleByDistance: new SceneGIS.NearFarScalar(1000, 1.2, 15000, 0.0)
					},
				});
			});
		}
		/**
		 * 
		 * @param {Object} entities 数据
		 * @param {Object} options={} 
		 * @param {Number} [options.alpha=0.6] 图表透明度
		 * @param {Array} [options.colorRamp] 图表颜色
		 */
		addGrid(entities, options = {}) {
			const _factor = 15;
			const COLOR_RRAMP = options.colorRamp || ["#2b83ba", "#64abb0", "#9dd3a7", "#c7e9ad", "#edf8b9", "#ffedaa", "#fec980", "#f99e59", "#e85b3a", "#d7191c"];
			entities = this._sortByAttribute1(entities, "month1");
			const num = entities.length;
			const alpha = SceneGIS.defaultValue(options.alpha, 0.6);
			const size = SceneGIS.defaultValue(options.size, 1000);
			const planeView = this.map.scene.planeView;
			entities.forEach((entity, i) => {
				const _value = parseInt(entity.properties["month1"]._value || 10);
				const scaleFactor = parseFloat(i * 10.0 / num);
				let _colorCss = COLOR_RRAMP[parseInt(scaleFactor)];
				const _color = new SceneGIS.Color.fromCssColorString(_colorCss).withAlpha(alpha);
				const _lon = parseFloat(entity.properties.lon._value);
				const _lat = parseFloat(entity.properties.lat._value);
				let _positions = [];
				let _position;
				if (planeView === true) {
					_positions = this.computeGridPositions([_lon, _lat,], size);
					_position = new SceneGIS.Cartesian3(_lon, _lat, _value / _factor + 100);
				} else {
					if (SceneGIS.defined(entity.properties.coordinates)) {
						_positions = entity.polygon.hierarchy._value.positions;
					} else {
						_positions = this.computeGridPositions([_lon, _lat,], size);
					}
					_position = SceneGIS.Cartesian3.fromDegrees(_lon, _lat, _value / _factor + 100);
				}
				const _entity = this.entityDatas.entities.add({
					id: `grid_${i}_${SceneGIS.createGuid()}`,
					position: _position,
					polygon: {
						hierarchy: new SceneGIS.PolygonHierarchy(_positions),
						extrudedHeight: _value / _factor,
						material: _color,
						closeBottom: false
					}
				});
				_entity.myColor = _color;
				_entity.lon = _lon;
				_entity.lat = _lat;
				_entity.myPosition = _position;
			});
		}
		//计算网格大小
		computeGridPositions(center, size) {
			let positions = [];
			const planeView = this.map.scene.planeView;
			if (planeView === true) {
				let pos0 = new SceneGIS.Cartesian3(center[0], center[1], 0);
				let pos1 = new SceneGIS.Cartesian3(center[0] + size, center[1], 0);
				let pos2 = new SceneGIS.Cartesian3(center[0] + size, center[1] + size, 0);
				let pos3 = new SceneGIS.Cartesian3(center[0], center[1] + size, 0);
				let pos4 = new SceneGIS.Cartesian3(center[0], center[1], 0);
				positions.push(pos0);
				positions.push(pos1);
				positions.push(pos2);
				positions.push(pos3);
				positions.push(pos4);
			} else {
				let cartCenter = SceneGIS.Cartesian3.fromDegrees(center[0], center[1], 0);
				let localMatrix = SceneGIS.Transforms.eastNorthUpToFixedFrame(cartCenter);
				let xNormal = SceneGIS.Matrix4.multiplyByPointAsVector(localMatrix, SceneGIS.Cartesian3.UNIT_X, new SceneGIS.Cartesian3);
				let yNormal = SceneGIS.Matrix4.multiplyByPointAsVector(localMatrix, SceneGIS.Cartesian3.UNIT_Y, new SceneGIS.Cartesian3);
				let addX = SceneGIS.Cartesian3.multiplyByScalar(xNormal, size, new SceneGIS.Cartesian3);
				let addY = SceneGIS.Cartesian3.multiplyByScalar(yNormal, size, new SceneGIS.Cartesian3);
				let pos0 = cartCenter.clone();
				let pos1 = SceneGIS.Cartesian3.add(cartCenter.clone(), addX, new SceneGIS.Cartesian3());
				let pos2 = SceneGIS.Cartesian3.add(SceneGIS.Cartesian3.add(cartCenter.clone(), addX, new SceneGIS.Cartesian3()), addY, new SceneGIS.Cartesian3());
				let pos3 = SceneGIS.Cartesian3.add(cartCenter.clone(), addY, new SceneGIS.Cartesian3());
				let pos4 = cartCenter.clone();
				positions.push(pos0);
				positions.push(pos1);
				positions.push(pos2);
				positions.push(pos3);
				positions.push(pos4);
			}
			return positions;
		}
		/**
		 * 
		 * @param {Object} entities 数据
		 * @param {Object} options={} 
		 * @param {String} [options.field='value'] 图表数据名称
		 * @param {Array} [options.showCityList] 中心城市的名字
		 * @param {Boolean} [options.showFlow=false] 是否流动
		 */
		addNetwork(entities, options = {}) {
			const _options = options || {};
			_options.id || SceneGIS.createGuid();
			const field = _options.field || 'value';
			const showCityList = _options.showCityList;
			const showFlow = _options.showFlow || false;
			const city = SceneGIS.defaultValue(_options.city, true);

			const COLOR_RRAMPTABLE5 = [
				"#fffde7",
				"#fff9c4",
				"#fff59d",
				"#fff176",
				"#ffee58",
				"#ffeb3b",
				"#fdd835",
				"#fbc02d",
				"#f9a825",
				"#f57f17"
			];

			let pointsData = [];
			let pointsDataMap = new Map();

			let linesData = [];
			let linesInfoData = new Map();

			let steps = 10;
			entities.forEach(entity => {
				const name = entity.properties.name._value;

				const value = parseInt(entity.properties[field] && entity.properties[field]._value || 0);
				let adjoin = entity.properties.adjoin._value; //array
				if (typeof (adjoin) === 'string') {
					adjoin = JSON.parse(adjoin);
				}
				const lon1 = parseFloat(entity.properties.x && entity.properties.x._value || 0);
				const lat1 = parseFloat(entity.properties.y && entity.properties.y._value || 0);
				const lon = parseFloat(lon1 || entity.properties.lon && entity.properties.lon._value);
				const lat = parseFloat(lat1 || entity.properties.lat && entity.properties.lat._value);
				pointsData.push({
					name: name,
					value: [lon, lat, value]
				});
				pointsDataMap.set(name, [lon, lat]);

				adjoin.forEach(toCity => {
					//过虑
					let _index = -1; //showCityList.findIndex(name) ;
					if (showCityList) {
						showCityList.some((value, index) => {
							if (value === name) {
								_index = index;
								return true;
							}
						});
						if (_index < 0) {
							return;
						}
					}
					let key = name + '-' + toCity.name;
					let key2 = toCity.name + '-' + name;
					let connectValue = toCity[field];
					if (linesInfoData.get(key) || linesInfoData.get(key2)) {
						return;
					}

					let _colorCss = COLOR_RRAMPTABLE5[0];
					linesInfoData.set(key, {
						fromName: name,
						toName: toCity.name,
						coords: [
							[lon, lat]
						],
						value: connectValue,
						lineStyle: {
							normal: {
								width: 1,
								color: _colorCss, //_colorCss,//'#00ff00''rgb(50, 50, 150)'
								opacity: 1.0, // scaleFactor / 10 + 0.5,
								curveness: .02 //弧度
							},
						},
						effect: {
							show: showFlow,
							period: 12,
							trailLength: 0.7,
							trailWidth: 4,
							symbol: "image://images/linePoint1.png",
							symbolSize: [3, 15],
						},
					});
				});
			});
			pointsData.sort(function (a, b) {
				const value1 = parseInt(a['value'][2] || 1);
				const value2 = parseInt(b['value'][2] || 1);
				return value1 - value2;
			});
			let pointLength = pointsData.length;
			let pointStep = pointLength / steps; //分为5个等级
			let sizeList = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24];
			if (!city) {
				sizeList = countySizeList;
			}
			const colorTable = city ? COLOR_RRAMPTABLE5 : countyColorTable; //色表选择
			let centerPointsDatas = [];
			pointsData.forEach((data, index) => {
				const scaleFactor = parseInt(index / pointStep);
				data.symbolSize = sizeList[scaleFactor];
				if (data['value'][2] === 0) {
					data.symbolSize = 2;
				}
				let _colorCss = colorTable[scaleFactor];
				data.itemStyle = {
					normal: {
						color: _colorCss,
						shadowBlur: data.symbolSize, //30,
						shadowColor: "#cccccc"
					}
				};
				data.label = {
					normal: {
						color: _colorCss,
						padding: [5, 10, 4],
						borderRadius: 5,
						backgroundColor: "rgba(0, 0, 0, 0.5)",
					}
				};
				pointsData[index] = data;
				//开始设置中心点
				let centerData = {
					name: data.name,
					value: data.value,
					symbolSize: data.symbolSize * 0.6,
					itemStyle: {
						normal: {
							color: '#FFFFFF'
						}
					}
				};
				centerPointsDatas.push(centerData);
			});

			//排序
			let arrayObj = Array.from(linesInfoData);
			arrayObj.sort(function (a, b) {
				return a[1]['value'] - b[1]['value'];
			});
			linesInfoData = new Map(arrayObj.map(i => [i[0], i[1]]));

			let lineLength = linesInfoData.size;
			let lineStep = lineLength / steps; //分为5个等级
			let i = 1;
			linesInfoData.forEach((line) => {
				line.coords.push(pointsDataMap.get(line.toName));
				const factor = parseInt(i / lineStep);
				let width = city ? factor / 10 * 3 : countyLineWidthList[factor];
				const _colorCss = colorTable[factor];
				let symbolSize = [width + 2.5, 18];
				if (line.value === 0) {
					width = 0;
					symbolSize = 0;
				}
				line.lineStyle.normal.width = width;
				line.lineStyle.normal.opacity = width / 2;
				line.effect.symbolSize = symbolSize;
				line.lineStyle.normal.color = _colorCss;
				linesData.push(line);
				i++;
			});
			let option = this.getOptionInfo(pointsData, centerPointsDatas, linesData, {
				showFlow: showFlow
			});
			this.eChartsLayer = new EchartsLayerEX(option, this.map);
		}
		/**
		 * 
		 * @param {Object} entities 数据
		 * @param {Object} option={}
		 * @param {String} options.field 总图表数据名称
		 * @param {Number} [options.valueScale] 图表尺寸
		 * @param {String} options.firstField 数据一名称
		 * @param {String} options.secondField 数据二名称
		 * @param {String} options.thirdField 数据三名称
		 * @param {String} [options.bottomHeight=0] 图表底部高度
		 */
		addPie(entities, option = {}) {
			this._positionMap = new Map(); //计算各省市以及区县的饼图轮廓
			const EXTRUDE_HEIGHT = 2200;
			const _field = option.field;
			const [minValue, maxValue] = this._sortByAttribute2(entities, _field);
			option.valueScale || EXTRUDE_HEIGHT * 0.5 / maxValue;
			const _geometryInstances = [];
			const leftOffset = 100;
			const planeView = this.map.scene.planeView;
			entities.forEach((entity, i) => {
				const _name = entity.properties.name._value;
				const _lon = parseFloat(entity.properties.lon._value);
				const _lat = parseFloat(entity.properties.lat._value);
				const _radius = parseFloat(SceneGIS.defaultValue(option.radius, 15000));
				const positions = this._getPositions(_name, _lon, _lat, _radius);
				const _totalValue = parseFloat(entity.properties[option.field]._value);
				const _scale1Value = parseFloat(entity.properties[option.firstField]._value);
				const _scale2Value = parseFloat(entity.properties[option.secondField]._value);
				const _scale3Value = parseFloat(entity.properties[option.thirdField]._value);

				const scale1 = parseFloat((_scale1Value / _totalValue).toFixed(2));
				const scale2 = parseFloat((_scale2Value / _totalValue).toFixed(2));
				const scale3 = parseFloat((_scale3Value / _totalValue).toFixed(2));

				const _minHeight = option.bottomHeight || 0;
				const [posArry1, posArry2, posArry3] = this._initThreePolygonPos(positions, [_lon, _lat], scale1, scale2, scale3);
				const _entityName1 = `pie1_${i}_${SceneGIS.createGuid()}`;
				const _extrudedHeight = 30 + _minHeight;
				const _color1 = SceneGIS.Color.fromCssColorString("#175D9F");
				const _instance1 = new SceneGIS.GeometryInstance({
					geometry: new SceneGIS.PolygonGeometry({
						height: _minHeight,
						polygonHierarchy: new SceneGIS.PolygonHierarchy(posArry1),
						extrudedHeight: _extrudedHeight,
						closeBottom: false,
						vertexFormat: SceneGIS.PerInstanceColorAppearance.VERTEX_FORMAT,
						planeView: planeView
					}),
					attributes: {
						color: SceneGIS.ColorGeometryInstanceAttribute.fromColor(_color1),
					},
					id: _entityName1,
				});
				_geometryInstances.push(_instance1);

				//_entity1
				const _entity1 = new SceneGIS.Entity({
					position: planeView === true ? new SceneGIS.Cartesian3(_lon, _lat, _extrudedHeight + 50)
						: SceneGIS.Cartesian3.fromDegrees(_lon, _lat, _extrudedHeight + 50),
					billboard: {
						image: this.billboardWithText(CoreEX.getAssetUrl("img/landLabel100per.png"),
							`第一产业${parseInt(scale1 * 100)}%`, {
							font: "19px Microsoft YaHei",
							color: "#F0F8FF",
							left: leftOffset
						}),
						verticalOrigin: SceneGIS.VerticalOrigin.BOTTOM,
						disableDepthTestDistance: Number.POSITIVE_INFINITY,
						scale: 0.8
					},
					polygon: {
						hierarchy: new SceneGIS.PolygonHierarchy(posArry1),
						material: SceneGIS.Color.YELLOW.withAlpha(0.7),
						extrudedHeight: _extrudedHeight + 2,
						height: _extrudedHeight,
						closeBottom: false,
					}
				});
				_entity1.myName = _entityName1;
				this.entityMap.set(_entityName1, _entity1);

				const _entityName2 = `pie2_${i}_${SceneGIS.createGuid()}`;
				const _color2 = SceneGIS.Color.fromCssColorString("#30E3C9");
				const _instance2 = new SceneGIS.GeometryInstance({
					geometry: new SceneGIS.PolygonGeometry({
						height: _minHeight,
						polygonHierarchy: new SceneGIS.PolygonHierarchy(posArry2),
						extrudedHeight: _extrudedHeight,
						closeBottom: false,
						vertexFormat: SceneGIS.PerInstanceColorAppearance.VERTEX_FORMAT,
						planeView: planeView
					}),
					attributes: {
						color: SceneGIS.ColorGeometryInstanceAttribute.fromColor(_color2),
					},
					id: _entityName2,
				});
				_geometryInstances.push(_instance2);
				//_entity2
				const _entity2 = new SceneGIS.Entity({
					position: planeView === true ? new SceneGIS.Cartesian3(_lon, _lat, _extrudedHeight + 50)
						: SceneGIS.Cartesian3.fromDegrees(_lon, _lat, _extrudedHeight + 50),
					billboard: {
						image: this.billboardWithText(CoreEX.getAssetUrl("img/landLabel100per.png"),
							`第二产业${parseInt(scale2 * 100)}%`, {
							font: "19px Microsoft YaHei",
							color: "#F0F8FF",
							left: leftOffset
						}),
						verticalOrigin: SceneGIS.VerticalOrigin.BOTTOM,
						disableDepthTestDistance: Number.POSITIVE_INFINITY,
						scale: 0.8
					},
					polygon: {
						hierarchy: new SceneGIS.PolygonHierarchy(posArry2),
						material: SceneGIS.Color.YELLOW.withAlpha(0.7),
						extrudedHeight: _extrudedHeight + 2,
						height: _extrudedHeight,
						closeBottom: false,
					}
				});
				_entity2.myName = _entityName2;
				this.entityMap.set(_entityName2, _entity2);

				const _entityName3 = `pie3_${i}_${SceneGIS.createGuid()}`;
				const _color3 = SceneGIS.Color.fromCssColorString("#17989F");
				const _instance3 = new SceneGIS.GeometryInstance({
					geometry: new SceneGIS.PolygonGeometry({
						height: _minHeight,
						polygonHierarchy: new SceneGIS.PolygonHierarchy(posArry3),
						extrudedHeight: _extrudedHeight,
						closeBottom: false,
						vertexFormat: SceneGIS.PerInstanceColorAppearance.VERTEX_FORMAT,
						planeView: planeView
					}),
					attributes: {
						color: SceneGIS.ColorGeometryInstanceAttribute.fromColor(_color3),
					},
					id: _entityName3,
				});
				_geometryInstances.push(_instance3);

				//_entity3
				const _entity3 = new SceneGIS.Entity({
					position: planeView === true ? new SceneGIS.Cartesian3(_lon, _lat, _extrudedHeight + 50)
						: SceneGIS.Cartesian3.fromDegrees(_lon, _lat, _extrudedHeight + 50),
					billboard: {
						image: this.billboardWithText(CoreEX.getAssetUrl("img/landLabel100per.png"),
							`第三产业${parseInt(scale3 * 100)}%`, {
							font: "19px Microsoft YaHei",
							color: "#F0F8FF",
							left: leftOffset
						}),
						verticalOrigin: SceneGIS.VerticalOrigin.BOTTOM,
						disableDepthTestDistance: Number.POSITIVE_INFINITY,
						scale: 0.8
					},
					polygon: {
						hierarchy: new SceneGIS.PolygonHierarchy(posArry3),
						material: SceneGIS.Color.YELLOW.withAlpha(0.7),
						extrudedHeight: _extrudedHeight + 2,
						height: _extrudedHeight,
						closeBottom: false,
					}
				});
				_entity3.myName = _entityName3;
				this.entityMap.set(_entityName3, _entity3);
			});

			this.piePrimitive = new SceneGIS.Primitive({
				geometryInstances: _geometryInstances,
				appearance: new SceneGIS.PerInstanceColorAppearance({
					translucent: false,
					faceForward: true
				}),
			});
			this.map.scene.primitives.add(this.piePrimitive);
		}

		addCluster(_dataSourcePromise, option = {}) {
			let baseIcon = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACEAAAAqCAYAAAA9IzKsAAAGd0lEQVRYha2Ye1AVVRzHv2d3440gMt4UUDGUYEdRFB+gTtLU6FRONuQDHzPagI/1NaOW2gO1xhFTCvUqDYqDFaaSzFBTpukY+G5SU686lqZWIlhekDfu3W1+68Uud/dy7wW//91zzu/7+9xzzp7z22Xx8x/BU1nMQiCAVACjAcQDeBZAMIBaAPcAXAFQDuCoKMn1nvhazAI8grCYhTgAy2Ub3jz7mxr083UVv1eoqKwG6puAQD/AFArE9GBI6s8wrB+rE3jsA7BRlOSrnYKwmIUQAOusdZi7+6jCFZ9U8KDW/b8LCwbSkjnMTOWUrkHIA7BKlOQaryEsZiEBQEnxCSV6Y4mC2kb3yZ0V7A8sm8ghLYX7A8AboiRfMILgXACMkW0oyypSorOKOgZAojiKX71HiSY/8jUap4OwmIUBjS0onWO2dSk+oXQsu5P2H1cwx2wLJl/yd+5vsxwWs9BVVXF+cb6t95FfVZemfbozvJjAIPZi6BIA1DcD96wqTl1TcfqaiiYX24xicjP424xhsCjJVntOCE7jcr/8SXEJ0L8nw9KJHJ4Lq8TBQ4dwcM9lWK1WCIKAvtHRmJySjLXpycg/BOwpUyDb2saT7xfHlN4zxnK5AGbqZsJiFoZXVuPUK2tk1tiiB5g8msPCcQ3Y9MkmfF1SApvNph9Es9SnN95buQJdIlKwMM+GB3Vt+wN8gW8/EFRTKEaKknzGeWOu3P694hJg9qgKpM+Yhn3FxS4BSLdu3UbG3Pk4fXgHdi7mtSfEUQ3NAOWhfK3NnH0WomrqMeGbM/qNSEsgjavHrIxM3Lh502VyR6mqipzczTh3vBirJvG6fspTU4/XKC8cno60wxcUZrShaA9s3boFt+/c8QjAUeuys5EYUaFtYEdRnsMXFMqd5giRWn5FvxmjTUzbhHv37/cagNTU1IxdhYWYPlZ/HJVbtHypjhCDL9/WQ6QOZNpTIMtyhyBIPxz+EWNEgHfiuHxHyzdYg7CYBf/mR4igy8hZ8b0YLl2ydBiAVFVVhVrr34gMb7sklI/yAvAnvtCHDbSZ9AbdgoH79+93CoJEHmFBbdsoH+Wl/AQh2FyczjX1QEhISKchyKPFYEWVx39cWylrSKBxcGW1ioiePTsFwPMcTN1N+PMf/VTTkQ+gmhMluc7fB9VGIOduqEhJGdkpiISBCbhbE9A69U8UGgj4+4Duj7rWPXsxPorpDI5dVjEgIRn9YmI6DDE9fQpKz+pnIe5xvktweETLRsbqIZpagF1HgXdXvAOOMyw92lXS0CFISh6Pfcf1m27E43xljhAHXk5kYHoOFB5REGAajqVLFnsFEBUZiY3ZG7SihupQR1GecYlasgNPIERJPh8Vzs6PjtdT0HW88DMbXhg/C+s+XAs/P1+3AMOShqLo893IOxreejK2EeWJDGfnKS+cKqv1C17lDGeDruMZOTb4RL6O70pLMW3qFISFdW0zhpYrcdAgbNqQjQ05BVhdHAajyoxjAOUBkN3a5lhPUPqTa/YoI4zWsFV0Gc1+iUNKnIoH9/+C1VoNX18fbfrv1gSi5LSKfeWKy+pq0igOWVO5UwBSRElWddW2xSw839iCX9I/tgVcv+u6vIP9hIkK/7+8q7SqqGtqN0QrC4qW8w3+PhgiSvI1GFXb1OHvg4w8iafKp13RKXurSsXFWypuVLgHID/yJf9WgFbpnjtRkotMoXh75yJeuzuehsiH/MiX/J0tDR9+UZI3RpvY+wWLed3F460onnzIj3yNwl2eQKIkfxTTg63dsYjXjtiOiOIonnzIz5VFu8egKMlZsRFsff5CfcHqTjSe4iiefNob7vYsFiV5ZXwUy8lf4DmIBrCAB8VRvLvxnl4Iywb0YZvz5vPaZ4D2RP00jsZTnCfmHkHQoQJgyaC+LG/7PB5+PsbjqH3bPB40jsbb454OhAPI/CExrGDbXD2IBjCXx9AYVkDjPAXwCsIBJHN4LCvcksnD95nH7T4CQL+pnfq9AfAawg5C74BvJcexrz7N4LV3y9xMHslxbC+12/u9krcfznztH8u6UYkIYI21DmO6BmnFCT2GDwH8Sx/RRElu9tDTcwj7eyN9sXN8uaRPCxMAlFLp4dBOs3FVlGS3744uPxe5kDMA7IkPOAHAPi7WU2OmGr31GKsX1acGIEbSZgKAR2/R3kCQnPcE/SYoSkp7gPbEAwAV9t/uBeA/cQV+vBGIpWQAAAAASUVORK5CYII='
				, clusterIcon = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACEAAAAqCAYAAAA9IzKsAAAETklEQVRYhcWYW2wUVRzGf2dnbFnb0hZIKmCrNYWmOyEKXlAqPPTB+IAkaHkjJmoo2CnVB8RgolU0BpOGUMzYRrRRE+uFpsTy4AORxFYU9aFVWfCWGHlBHqQtvVGYnTX/YUqGvbSz7Xb93ubM/3zfb8+ec3bPUZHGawRV1NILgDpgIxABbgOKgFHgH+As0A+cNEx7PIhv1NIJBBG19BrgBTvGth/+iBf++HucPy/EuTgM41egYBGUlUDVcsX9qxUPrFJjusbnQKth2ufmBRG19GLgzaExdn100gl1f+twaXT2T7ekCOo3hHiyLuSUFtIBvGSY9kjGEFFLvxs41n3KqWw95jA6OXt4oorCsGdriPra0F/A44ZpD6aCCKUB2GTH6GvpcipbuuYGIJJ+0v/VT5xK8RPfVHVJEFFLXzN5ld6dVmxx9ylnbukJOvqNw04rViS+4j8jRNTSS+Nxjr/4Qaz49G/xrABMS/zEV/wlJy0E0Pbx184dX/2UXYBpia/4S05KiKilr784zPZDX2TnK0intl5HlvZ2yUuCAPa1f+moyasLysDEFEiO5N0EEbX08pFxthz/fmFHYVqSMzLOY5KLbyTqTww66krwHXxekpwTg45k1/sh6vrPLsxkTKf+qJtX54dYe+bv3EKcOe/mrXUhopYenrrGSvkxyqUkT3KBsIxEyeUJiOd2INw8yZV8gdBjuVkUSfJyNYEYKi74fyC83OGQYdpj4TyGcw0ieeE8hoCx6dXxc6Rc5RTCy/sF3xLte6g6txAPXs/r80P0PLJOoXLEITmPrnPDem5AGKY9UL5MDTwcyQ3Fxoji9mVqQHJJ+BU9sHtzaMFHI6SgabMb+9aNNt/7o0aFOr2tNuXfzqypvjaEUaG+A/dIcDOEYdqyZz6194nQxOoVCzMc4iv+wNNeXtJICMiv4Tx2dJhaXA4z2ZT4ia/4S47fOmnsDdPuKith7/vNGkuLskMhhyHxE1/xT3yfcgIYpt1aWaZe6XxOY0nhPAEKobNZo7JMvSy+qWrSzkLDtF+vWq72v9esUTLHLV36Sf9VK9R+w7TfSFc341IwTLuleqU6cGS35h7pMpHUv9ukIf3FZ6aus65Hw7T3RcrVwSNNwUGkTuqNCnVQ+s9WH3RT2LPmTnW4o1FzrwFm0q35IHVSL/2CmAeC8Nb08/fcpTran9VYlJe6TtrbGzWkTur9e8G8IXwgjfdWqc53diWDyLO031elOqUuKEBGED6QhvXV6sO3GzTyb7nenqfD4QYNaZf3mQBkDOGBxIBnNtSoTw/t0Nw50NagUVujPpN2731GyvTiLN+7LFsKLAZeGxpjU2mh++dEluFl4F+5RDNMeyqgZ3AI79woN3aar1kHtgC9gO1rl9E4Z5j2+SAQmXwdiQB4wT0JAHh11UGNVTz4qacCkKvERJBUckcCmHUkMoUQJc4JeRYoCZU5IHPiEnDBe55dwH9gy4u8YW9PFQAAAABJRU5ErkJggg==';
			let image, numberTxt;
			this.map.scene.planeView;
			_dataSourcePromise.then((dataSource) => {
				// dataSource.show = false;
				dataSource.clustering.enabled = true;
				dataSource.clustering.pixelRange = 15;
				dataSource.clustering.minimumClusterSize = 3;
				let entities = dataSource.entities._entities;
				entities._array.map(v => {
					v.billboard.image._value = baseIcon;
					v.billboard.disableDepthTestDistance = Number.POSITIVE_INFINITY;
				});

				dataSource.clustering.clusterEvent.addEventListener((clusteredEntities, cluster) => {
					cluster.label.show = false;
					numberTxt = clusteredEntities.length > 99 ? '99+' : clusteredEntities.length.toString();
					cluster.billboard.show = true;
					cluster.billboard.id = cluster.label.id;
					cluster.billboard.verticalOrigin = SceneGIS.VerticalOrigin.BOTTOM;

					image = this.billboardWithText2(clusterIcon, numberTxt, {
						font: " 16px  Microsoft YaHei",
						imageScale: 3,
						color: "#FFFFFF",
						top: 18
					});
					cluster.billboard.image = image;
				});
			});
		}
		async billboardWithText2(imgUrl, text, option = {}) {
			let canvas = document.createElement("canvas");
			let img = new Image();
			img.src = imgUrl;
			const loadImg = function () {
				return new Promise((resolve, reject) => {
					img.onload = () => {
						canvas.width = img.width;
						canvas.height = img.height;
						const cxt = canvas.getContext("2d");
						cxt.drawImage(img, 0, 0);
						cxt.font = option.font || "normal bold 100px Microsoft YaHei";
						cxt.textBaseline = 'middle';
						cxt.textAlign = option.textAlign || 'center';
						const left = option.left || canvas.width / 2;
						const top = option.top || canvas.height / 2;
						cxt.fillStyle = option.color || "#000";
						cxt.fillText(text, left, top);
						canvas.height * 0.8;
						cxt.fillText(text, left, top);
						resolve();
					};
				});
			};
			await loadImg();
			return canvas;
		}

		async billboardWithText(imgUrl, text, option = {}) {
			let canvas = document.createElement("canvas");
			let img = new Image();
			img.src = imgUrl;
			const loadImg = function () {
				return new Promise((resolve, reject) => {
					img.onload = () => {
						const imageScale = option.imageScale || 1;
						canvas.width = img.width * imageScale;
						canvas.height = img.height * imageScale;
						const cxt = canvas.getContext("2d");
						cxt.drawImage(img, 0, 0, canvas.width, canvas.height);
						cxt.font = option.font || "normal bold 100px Microsoft YaHei";
						cxt.textBaseline = 'middle';
						cxt.textAlign = option.textAlign || 'center';
						const left = option.left || canvas.width / 2;
						const top = option.top || canvas.height / 2;

						cxt.fillStyle = option.color || "#000";
						cxt.fillText(text, left, top);
						canvas.height * 0.8;
						cxt.fillText(text, left, top);
						resolve();
					};
				});
			};
			await loadImg();
			return canvas;
		}

		_initThreePolygonPos(positions, center, scale1, scale2, scale3) {
			const planeView = this.map.scene.planeView;
			let posCenter;
			if (planeView === true) {
				posCenter = new SceneGIS.Cartesian3(center[0], center[1], 0);
			} else {
				posCenter = SceneGIS.Cartesian3.fromDegrees(center[0], center[1], 0);
			}
			const length = positions.length;
			let _step1 = parseInt(length * scale1);
			let _step2 = parseInt(length * (scale1 + scale2));
			_step1 = _step1 < 2 ? 2 : _step1;
			_step2 = (_step2 - _step1) < 2 ? _step1 + 2 : _step2;
			const posArry1 = positions.slice(0, _step1);
			posArry1.push(posCenter);
			const posArry2 = positions.slice(_step1 - 1, _step2);
			posArry2.push(posCenter);
			const posArry3 = positions.slice(_step2 - 1, length);
			posArry3.push(posCenter);
			return [posArry1, posArry2, posArry3];
		}

		_getPositions(name, lon, lat, RADIUS) {
			const planeView = this.map.scene.planeView;
			let _resPositions = [];
			if (this._positionMap.has(name)) {
				_resPositions = this._positionMap.get(name);
			} else {
				let _coordinates;
				if (planeView === true) {
					_coordinates = this.computeCirclePoints([lon, lat], RADIUS, 90);
				} else {
					const _circle = circle([lon, lat], RADIUS, {
						units: 'meters',
						steps: 90
					});
					_coordinates = _circle.geometry.coordinates[0];
				}

				_coordinates.forEach(lonlat => {
					let pos3D;
					if (planeView === true) {
						pos3D = new SceneGIS.Cartesian3(lonlat[0], lonlat[1], 0);
					} else {
						pos3D = SceneGIS.Cartesian3.fromDegrees(lonlat[0], lonlat[1]);
					}
					_resPositions.push(pos3D);
				});
				this._positionMap.set(name, _resPositions);
			}

			return _resPositions;
		}

		computeCirclePoints(center, radius, numPoints) {
			var points = [];
			var angleIncrement = (2 * Math.PI) / numPoints;

			for (var i = 0; i < numPoints; i++) {
				var angle = i * angleIncrement;

				// 计算点的坐标
				var x = center[0] + radius * Math.cos(angle);
				var y = center[1] + radius * Math.sin(angle);

				points.push([x, y]);
			}
			points.push(points[0]);

			return points;
		}

		getOptionInfo(pointsData, centerPointsDatas, linesData, options) {
			let _options = options || {};
			let showFlow = _options.showFlow || false;
			let series = [{
				name: 'network',
				type: "lines",
				//type: "lines3D",
				coordinateSystem: "GLMap",
				zlevel: 1,
				//blendMode: 'lighter',
				tooltip: {
					formatter: function (params) {
						let fromName = params.data.fromName;
						let toName = params.data.toName;
						return fromName + '-' + toName + ':' + params.value;
					}
				},
				effect: {
					show: showFlow,
					period: 14,
					trailLength: 0.7,
					trailWidth: 4,
					//symbol: "arrow", //'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow', 'none'
					//symbolSize: 3,
					//period: 4
					// smooth: false,
					symbol: "image://images/linePoint1.png",
					///symbolSize:[3, 15],
					// symbolSize:function(params){
					//     return [3, 15];
					// },
				},
				data: linesData
			},
			{
				type: "effectScatter",
				coordinateSystem: "GLMap",
				zlevel: 2,
				blendMode: 'lighten', //'lighter',
				rippleEffect: {
					brushType: "stroke" //fill
					//brushType: "fill" //fill
				},
				hoverAnimation: true,
				tooltip: {
					formatter: function (params) {
						return params.marker + " " + params.name + ':' + params.value[2];
					}
				},
				label: {
					normal: {
						show: true,
						fontSize: 16,
						//color: "#fff",
						//offset: [0, 20],
						textBorderColor: '#000000', //"#2aa4e8",
						position: "top", //"right",
						formatter: "{b}"
					}
				},
				data: pointsData
			},
			{
				type: "scatter",
				coordinateSystem: "GLMap",
				zlevel: 2,
				blendMode: 'lighten', //'lighter',

				hoverAnimation: true,
				tooltip: {
					formatter: function (params) {
						return params.marker + " " + params.name + ':' + params.value[2];
					}
				},
				label: {
					normal: {
						show: false,
						fontSize: 16,
						textBorderColor: '#000000', //"#2aa4e8",
						position: "top", //"right",
						formatter: "{b}"
					}
				},
				data: centerPointsDatas
			},
			];
			let option = {
				animation: false,
				//backgroundColor: "rgba(0, 0, 0, 0.2)",
				GLMap: {},
				tooltip: {
					trigger: 'item'
				},
				series: series
			};
			// console.warn('er');
			// console.warn(option);
			// console.warn(JSON.stringify(option));
			this.chartOption = option;
			return option;
		}

		_hoverEvent() {
			// 支持hover显示属性
			this.hoverHandler = new SceneGIS.ScreenSpaceEventHandler(this.map.canvas);
			this.hoverHandler.setInputAction((movement) => {
				var pickedFeature = this.map.scene.pick(movement.endPosition);
				if (!SceneGIS.defined(pickedFeature) || !SceneGIS.defined(pickedFeature.id) || typeof (pickedFeature.id) !== 'string' || !pickedFeature.id.includes("pie")) {
					return;
				} else {
					let name = pickedFeature.id;
					if (this.showEntity && this.showEntity.myName == name) {
						return;
					}
					if (this.showEntity) {
						this.entityDatas.entities.remove(this.showEntity);
						this.showEntity = null;
					}
					this.showEntity = this.entityMap.get(name);
					this.entityDatas.entities.add(this.showEntity);

					// let attributes = pickedFeature.primitive.getGeometryInstanceAttributes(pickedFeature.id);
					// let colorCss = SceneGIS.Color.fromCssColorString("#ff5D9F");
					// attributes.color = SceneGIS.ColorGeometryInstanceAttribute.toValue(colorCss);
				}
			}, SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
		}

		/**
		 * 移除图表
		 */
		remove() {
			if (this.primitive) {
				this.map.scene.primitives.remove(this.primitive);
			}
			if (this.piePrimitive) {
				this.map.scene.primitives.remove(this.piePrimitive);
			}
			if (this.eChartsLayer) {
				this.eChartsLayer.remove();
				this.eChartsLayer = null;
			}
			if (this._dataSourcePromise) {
				this._dataSourcePromise.then((ds) => {
					this.map.dataSources.remove(ds);
				});
				this._dataSourcePromise = null;
			}
			this.entityDatas.entities.removeAll();
		}

		setVisible(val) {
			if (this.primitive) {
				this.primitive.show = val;
			}
			if (this.piePrimitive) {
				this.piePrimitive.show = val;
			}
			if (this.eChartsLayer) {
				console.log("this.eChartsLaye", this.eChartsLaye);
			}
			if (this._dataSourcePromise) {
				this._dataSourcePromise.then((ds) => {
					ds.show = val;
				});
			}
			this.entityDatas.show = val;
		}
	}

	/**
	 * 和Ecahrts 融合图层，已经废弃
	 * @alias MapEchartsEX
	 * @constructor
	 * @param {Viewer} viewer viewer对象
	 * @param {Object} option  参数
	 * @param {String} option.id  图层id
	 * @param {Boolean} option.show  是否显示
	 * @param {Object} option.owner  所属对象
	 * 
	 */
	function MapEchartsEX(viewer, option) {
		option = Object.assign({}, option);
		this.option = option;
		this._id = option.id ? option.id : CoreEX.MathEX.createUID();
		this.viewer = viewer;
		this._cmd = undefined;
		this._owner = option.owner ? option.owner : undefined;
		init$a.bind(this)(option);

	}
	Object.defineProperties(MapEchartsEX.prototype, {
		/**
	  * 显隐控制
	  *
	  * @memberof  MapEchartsEX.prototype
	  * @type {Boolean}
	  */
		show: {
			get: function () {
				return this.show;
			},
			set: function (value) {
				if (value == false) {
					if (!this._cmd) return;
					this._cmd.hide();
				}
				else if (value == true) {
					if (!this._cmd) {
						init$a.bind(this)();
					} else {
						this._cmd.show();
					}
				}
			}
		},
		/**
		* 要素id
		* @memberof  MapEchartsEX.prototype
		* @readonly
		* @type {Boolean}
		*/
		id: {
			get: function () {
				return this._id;
			},
		},
		/**
		 * 要素的data
		 * @memberof   MapEchartsEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		data: {
			get: function () {
				return [this._cmd];
			},
		},
		/**
		 * 要素的所属
		 * @memberof  MapEchartsEX.prototype
		 * @readonly
		 * @type {Array<Entity>|Array<Primitive>}
		 */
		owner: {
			get: function () {
				return this._owner;
			},
			set: function (value) {
				this._owner = value;
			},
		},
	});

	MapEchartsEX.prototype.update = function (option) {
		let option1 = option.symbol.templete.mapEcharts;
		this._cmd.updateOverlay(option1.url);
		this.option = _.cloneDeep(option1);

	};

	/**
	 * 改变颜色
	 * @param {Object} option 颜色参数
	 * @param {SceneGIS.Color} option.color 颜色
	 */
	MapEchartsEX.prototype.changeColor = function (option) {
		// this.obj.color = option.color;
	};
	/**
	 * 销毁清除对象
	 */
	MapEchartsEX.prototype.destroy = function () {
		this._cmd.dispose();
	};


	function init$a() {
		let url = this.option.url;
		for (let key in this.option) {
			if (key == 'url') continue;
			this.option[key];
		}
		if (this.option.type === "echarts") {
			this._cmd = new ChartsLayerEX(url, this.viewer);
		}
	}

	/**
	 * 图标标绘
	 * @class IconPlot
	 * @param {Object} options
	 * @param {SceneGIS.Viewer} viewer
	 */
	function IconPlotEX(options, viewer) {
		this._viewer = viewer;
		this._callback = options.callback ? options.callback : () => { };
		this._draw = new CommanDrawEX({ callback: callback$b.bind(this) }, viewer);
		this._draw.setMode(CommanDrawModeEX$1.POINT);
		this._draw.pause = true;
		this._draw._drawComplete = false;

		this._picUrl = options.picUrl;
		this._drawItems = [];

		this._depthTestAgainstTerrain =
			this._viewer.scene.globe.depthTestAgainstTerrain;
		this._viewer.scene.globe.depthTestAgainstTerrain = true;
	}

	IconPlotEX.cmdName = "_IconPlotEX";

	Object.defineProperties(IconPlotEX.prototype, {
		picUrl: {
			get: function () {
				return this._picUrl;
			},
			set: function (val) {
				this._picUrl = val;
			},
		},
	});

	function callback$b(data) {
		console.log("object", document.URL);
		let pointDraw = this._viewer.entities.add({
			position: data.position,
			billboard: {
				image: `${this._picUrl}`,
				verticalOrigin: SceneGIS.VerticalOrigin.BOTTOM,
				horizontalOrigin: SceneGIS.HorizontalOrigin.CENTER,
				scale: 1,
			},
		});
		let item = {
			entity: pointDraw,
			commanDrawData: data,
		};
		if (this._callback) {
			this._callback(data);
		}
		this._drawItems.push(item);
	}

	IconPlotEX.prototype.clear = function () {
		for (let item of this._drawItems) {
			if (item.entity) {
				this._viewer.entities.remove(item.entity);
			} else if (item.primitive) {
				this._viewer.scene.primitives.remove(item.primitive);
			}
		}
		this._draw.removeAll();
	};

	IconPlotEX.prototype.destroy = function () {
		this._viewer.scene.globe.depthTestAgainstTerrain =
			this._depthTestAgainstTerrain;
		this.clear();
		this._draw.destroy();
	};

	/**
	 * 交互工具类型
	 * @readonly
	 * @enum {String}
	 */
	var InteractiveType = {
		/**
		 * 文字标绘
		 * @type {String}
		 */
		"WordPlotEX": "WordPlotEX",

		/**
		 * 图标标绘
		 * @type {String}
		 */
		"IconPlotEX": "IconPlotEX",
		/**
		* 画点
		* @type {String}
		*/
		"PointPlotEX": "PointPlotEX",

		/**
		* 画线
		* @type {String}
		*/
		"LinePlotEX": "LinePlotEX",

		/**
	  * 画面
	  * @type {String}
	  */
		"PolyGonPlotEX": "PolyGonPlotEX",

		/**
	   * 军事标绘
	   * @type {String}
	   */
		"MilitaryPlotEX": "MilitaryPlotEX",




	};
	var InteractiveType$1 = Object.freeze(InteractiveType);

	/**
	 * 线标绘
	 * @alias LinePlotEX
	 * @constructor
	 * @param {Object} options 
	 * @param {number} [options.bufferDistance=10] 缓冲区距离，默认10，单位米
	 * @param {SceneGIS.Color} [options.color=SceneGIS.Color.DARKORANGE.withAlpha(0.5)] 缓冲区颜色，默认SceneGIS.Color.DARKORANGE.withAlpha(0.5)
	 * @param {SceneGIS.Viewer} viewer 
	 */
	function LinePlotEX(options, viewer) {
		//检查
		CheckEX.typeOf("options.bufferDistance", options.bufferDistance, "number");
		CheckEX.instanceOf("options.color", options.color, SceneGIS.Color);

		this._viewer = viewer;
		this._callback = options.callback ? options.callback : () => { };
		this._draw = new CommanDrawEX({ callback: callback$a.bind(this) }, viewer);
		this._draw.setMode(CommanDrawModeEX$1.LINE);
		this._draw.pause = true;

		this._bufferDistance = options.bufferDistance ? options.bufferDistance : 10;
		this._icon = options.icon;

		this._drawItems = [];

		this._depthTestAgainstTerrain = this._viewer.scene.globe.depthTestAgainstTerrain;
		this._viewer.scene.globe.depthTestAgainstTerrain = true;
		this.planeView = viewer.scene.planeView;
	}

	LinePlotEX.cmdName = "_LinePlotEX";

	Object.defineProperties(LinePlotEX.prototype, {
		bufferDistance: {
			get: function () {
				return this._bufferDistance;
			},
			set: function (val) {
				if (isNumber(val)) {
					this._bufferDistance = val;
				}
			}
		}
	});

	Object.defineProperties(LinePlotEX.prototype, {
		icon: {
			get: function () {
				return this._icon;
			},
			set: function (val) {
				this._icon = val;
			}
		}
	});
	//缓冲
	function callback$a(data) {
		let positions = [];
		if (data.eventType && data.eventType === "rightClick") {
			for (let position of data.position) {
				if (this.planeView === true) {
					break;
				} else {
					let cartographic = SceneGIS.Cartographic.fromCartesian(position);
					let longitude = SceneGIS.Math.toDegrees(cartographic.longitude);
					let latitude = SceneGIS.Math.toDegrees(cartographic.latitude);
					positions.push([longitude, latitude]);
				}
			}
			let SceneGISPositions = [], buffered, bufferedPositions;
			if (this.planeView === true) {
				buffered = new SceneGIS.CorridorGeometry({
					vertexFormat: SceneGIS.VertexFormat.POSITION_ONLY,
					positions: data.position,
					width: this._bufferDistance,
					planeView: this.planeView
				});
				//为了拿到corridor的顶点信息
				SceneGIS.CorridorGeometry.createGeometry(buffered);
				bufferedPositions = buffered._totalPositions;
				for (let i in bufferedPositions) {
					SceneGISPositions.push(bufferedPositions[i]);
				}
			} else {
				let trufPolyline = lineString(positions);
				buffered = buffer(trufPolyline, this._bufferDistance, { units: 'meters' });
				bufferedPositions = buffered.geometry.coordinates[0];
				for (let position of bufferedPositions) {
					SceneGISPositions.push(position[0]);
					SceneGISPositions.push(position[1]);
				}
			}
			let lineBuffer = this._viewer.entities.add({
				polygon: {
					hierarchy: this.planeView === true ? new SceneGIS.PolygonHierarchy(SceneGIS.Cartesian3.unpackArray(SceneGISPositions))
						: new SceneGIS.PolygonHierarchy(SceneGIS.Cartesian3.fromDegreesArray(SceneGISPositions)),
					material: SceneGIS.Color.DARKORANGE.withAlpha(0.5),
				}
			});

			let item = {
				entity: lineBuffer,
				commanDrawData: data
			};
			if (this._callback) {
				this._callback(data);
			}

			this._drawItems.push(item);
		}
	}

	LinePlotEX.prototype.clear = function () {
		for (let item of this._drawItems) {
			if (item.entity) {
				this._viewer.entities.remove(item.entity);
			} else if (item.primitive) {
				this._viewer.scene.primitives.remove(item.primitive);
			}
		}
		this._draw.removeAll();
	};

	LinePlotEX.prototype.setMode = function (mode) {
		this._draw.setMode(mode);
	};
	LinePlotEX.prototype.destroy = function () {
		this._viewer.scene.globe.depthTestAgainstTerrain = this._depthTestAgainstTerrain;
		this.clear();
		this._draw.destroy();
	};

	/**
	 * 军事标绘
	 * @class MilitaryPlotEX
	 */
	class MilitaryPlotEX {
		/**
		 * 构造函数
		 * @param {Object} options 配置参数
		 * @param {String} options.type 标绘类型 "pincerArrow" "attackArrow" "straightArrow"
		 * @param {SceneGIS.Viewer} viewer Viewer对象
		 */
		constructor(options, viewer) {
			/**
			* viewer
			* @readonly
			* @type {Viewer}
		   */
			this._viewer = viewer;
			/**
		 * 回调函数
		 * @type {Bool}
		*/
			this.callback = undefined;
			viewer.scene.globe.depthTestAgainstTerrain = true;
			this.destroy();
			arrow.init(viewer);
			arrow.draw(options.type ? options.type : "pincerArrow");
		}
		destroy() {
			arrow.disable();
		}
		changeType(type) {
			arrow.draw(type);
		}
		clear() {
			arrow.disable();
		}


	}

	/**
	 * 点标绘
	 * @alias PointPlotEX
	 * @constructor
	 * @param {Object} options 
	 * @param {SceneGIS.Viewer} viewer 
	 */
	function PointPlotEX(options, viewer) {
		this._viewer = viewer;
		this._callback = options.callback ? options.callback : () => { };
		this._draw = new CommanDrawEX({ callback: callback$9.bind(this) }, viewer);
		this._draw.setMode(CommanDrawModeEX$1.POINT);
		this._draw.pause = true;
		this._draw._drawComplete = false;

		this._iconUrl = options.iconUrl;

		this._drawItems = [];

		this._depthTestAgainstTerrain = this._viewer.scene.globe.depthTestAgainstTerrain;
		this._viewer.scene.globe.depthTestAgainstTerrain = true;
	}

	PointPlotEX.cmdName = "_PointPlotEX";

	Object.defineProperties(PointPlotEX.prototype, {
		iconUrl: {
			get: function () {
				return this._iconUrl;
			},
			set: function (val) {
				this._iconUrl = val;
			}
		}
	});

	function callback$9(data) {
		let pointDraw = this._viewer.entities.add({
			position: data.position,
			label: {
				scale: 0.5,
				text: '位置:x=' + String(data.position.x) + ';y=' + String(data.position.y) + ';z=' + String(data.position.x),
				verticalOrigin: SceneGIS.VerticalOrigin.BOTTOM,
				horizontalOrigin: SceneGIS.HorizontalOrigin.LEFT,
				pixelOffset: new SceneGIS.Cartesian2(0, -30),
				showBackground: true,
				style: SceneGIS.LabelStyle.FILL,
				outlineWidth: 2,
			},
			billboard: {
				image: `${this.iconUrl}`,
				verticalOrigin: SceneGIS.VerticalOrigin.BOTTOM,
				horizontalOrigin: SceneGIS.HorizontalOrigin.CENTER,
				scale: 0.15
			}
		});
		let item = {
			entity: pointDraw,
			commanDrawData: data
		};
		if (this._callback) {
			this._callback(data);
		}
		this._drawItems.push(item);
	}

	PointPlotEX.prototype.clear = function () {
		for (let item of this._drawItems) {
			if (item.entity) {
				this._viewer.entities.remove(item.entity);
			} else if (item.primitive) {
				this._viewer.scene.primitives.remove(item.primitive);
			}
		}
		this._draw.removeAll();
	};

	PointPlotEX.prototype.destroy = function () {
		this._viewer.scene.globe.depthTestAgainstTerrain = this._depthTestAgainstTerrain;
		this.clear();
		this._draw.destroy();
	};

	/**
	 * 面标绘
	 * @class PolyGonPlotEX
	 * @param {Object} options 
	 * @param {number} [options.bufferDistance=10] 缓冲区距离，默认10，单位米
	 * @param {SceneGIS.Color} [options.color=SceneGIS.Color.DARKORANGE.withAlpha(0.5)]
	 * @param {SceneGIS.Viewer} viewer 
	 */
	function PolyGonPlotEX(options, viewer) {
		this._viewer = viewer;
		this._callback = options.callback ? options.callback : () => { };

		this._draw = new CommanDrawEX({ callback: callback$8.bind(this) }, viewer);
		this._draw.setMode(CommanDrawModeEX$1.POLYGON);
		this._draw.pause = false;

		this._bufferDistance = options.bufferDistance ? options.bufferDistance : 10;

		this._drawItems = [];
	}

	PolyGonPlotEX.cmdName = "_PolyGonPlotEx";
	function callback$8(data) {
		if (this._callback) {
			this._callback(data);
		}
	}

	/**
	 * 清除
	 */
	PolyGonPlotEX.prototype.clear = function () {
		for (let item of this._drawItems) {
			if (item.entity) {
				this._viewer.entities.remove(item.entity);
			} else if (item.primitive) {
				this._viewer.scene.primitives.remove(item.primitive);
			}
		}
		this._draw.removeAll();
	};

	/**
	 * 设置模式
	 * @param {CommanDrawMode} mode 模式，参见CommanDrawMode
	 */
	PolyGonPlotEX.prototype.setMode = function (mode) {
		this._draw.setMode(mode);
	};

	/**
	 * 文字标绘
	 * @alias WordPlot
	 * @constructor
	 * @param {Object} options 
	 * @param {SceneGIS.Viewer} viewer 
	 */
	function WordPlot(options, viewer) {
		this._viewer = viewer;
		this._callback = options.callback ? options.callback : () => { };
		this._draw = new CommanDrawEX({ callback: callback$7.bind(this) }, viewer);
		this._draw.setMode(CommanDrawModeEX$1.POINT);
		this._draw.pause = true;
		this._draw._drawComplete = false;

		this._text = options.text;
		this._iconUrl = options.iconUrl;
		this._drawItems = [];

		this._depthTestAgainstTerrain = this._viewer.scene.globe.depthTestAgainstTerrain;
		this._viewer.scene.globe.depthTestAgainstTerrain = true;
	}

	WordPlot.cmdName = "_WordPlot";

	Object.defineProperties(WordPlot.prototype, {
		text: {
			get: function () {
				return this._text;
			},
			set: function (val) {
				this._text = val;
			}
		}
	});
	Object.defineProperties(WordPlot.prototype, {
		iconUrl: {
			get: function () {
				return this.iconUrl;
			},
			set: function (val) {
				this.iconUrl = val;
			}
		}
	});


	function callback$7(data) {
		let pointDraw = this._viewer.entities.add({
			position: data.position,
			label: {
				scale: 0.5,
				text: this._text,
				verticalOrigin: SceneGIS.VerticalOrigin.BOTTOM,
				horizontalOrigin: SceneGIS.HorizontalOrigin.LEFT,
				pixelOffset: new SceneGIS.Cartesian2(0, -30),
				showBackground: true,
				style: SceneGIS.LabelStyle.FILL,
				outlineWidth: 2,
			},
			billboard: {
				image: `${this._iconUrl}`,
				verticalOrigin: SceneGIS.VerticalOrigin.BOTTOM,
				horizontalOrigin: SceneGIS.HorizontalOrigin.CENTER,
				scale: 0.15
			}
		});
		let item = {
			entity: pointDraw,
			commanDrawData: data
		};
		if (this._callback) {
			this._callback(data);
		}
		this._drawItems.push(item);
	}

	WordPlot.prototype.clear = function () {
		for (let item of this._drawItems) {
			if (item.entity) {
				this._viewer.entities.remove(item.entity);
			} else if (item.primitive) {
				this._viewer.scene.primitives.remove(item.primitive);
			}
		}
		this._draw.removeAll();
	};

	WordPlot.prototype.destroy = function () {
		this._viewer.scene.globe.depthTestAgainstTerrain = this._depthTestAgainstTerrain;
		this.clear();
		this._draw.destroy();
	};

	/** glb 图层,图层的层的以废弃，放在要素层
	 * @alias GlbLayerEX
	 * @constructor
	 * @param {Viewer} viewer
	 * @param {Object} data
	 */
	function GlbLayerEX(viewer, option) {
		CoreEX.GisBaseLayer.call(this, viewer, option);
		this._data = undefined;
		this._viewer = viewer;
		this._visible = SceneGIS.defaultValue(option.visible, true);
		if (this._visible) {
			init$9.bind(this)();
		}
		this._destroyed = false;
	}

	GlbLayerEX.prototype = Object.create(CoreEX.GisBaseLayer.prototype);
	GlbLayerEX.prototype.constructor = GlbLayerEX;

	Object.defineProperties(GlbLayerEX.prototype, {
		visible: {
			get: function () {
				if (this.data) {
					return this._visible;
				}
				return false;
			},
			set: function (value) {
				this._visible = value;
				if (this.data) {
					this.data.show = value;
				} else {
					if (value) {
						init$9.bind(this)();
					}
				}
			},
		},
		show: {
			get: function () {
				if (this.data) {
					return this.data.show;
				}
				return false;
			},
			set: function (value) {
				if (this.visible) {
					//在visible 为 false时,show 不起作用
					if (this.data) {
						this.data.show = value;
					} else {
						init$9.bind(this)();
					}
				}
			},
		},
		data: {
			get: function () {
				return SceneGIS.defined(this._data) ? this._data : undefined;
			},
		},
		/**
		 * 获取parameter 图层名称
		 * @memberof GlbLayerEX.prototype
		 *
		 * @type {String}
		 * @readonly
		 */
		name: {
			get: function () {
				return SceneGIS.defined(this.option) ? this.option.name : undefined;
			},
		},
		/**
		 * 获取parameter 图层id
		 * @memberof GlbLayerEX.prototype
		 *
		 * @type {String}
		 * @readonly
		 */
		id: {
			get: function () {
				return SceneGIS.defined(this.option) ? this.option.id : undefined;
			},
		},
		/**
		 * 获取viewer
		 * @memberof GlbLayerEX.prototype
		 *
		 * @type {Viewer}
		 * @readonly
		 */
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			},
		},
	});

	function init$9() {
		var optionss = this.option;
		console.log(typeof (optionss.models));
		if (typeof (optionss.models) === 'string') {
			optionss.models = JSON.parse(optionss.models);
		}
		var url = optionss.models.url;
		var entity;
		if (SceneGIS.defined(optionss.models.position)) {
			//计算平移矩阵
			var position = SceneGIS.Cartesian3.fromDegrees(
				optionss.models.position.longitude,
				optionss.models.position.latitude,
				optionss.models.position.height
			);
			var transformM = SceneGIS.Transforms.eastNorthUpToFixedFrame(position);
			//计算旋转矩阵
			var heading = SceneGIS.Math.toRadians(optionss.models.headingpitchroll.heading);
			var pitch = SceneGIS.Math.toRadians(optionss.models.headingpitchroll.pitch);
			var roll = SceneGIS.Math.toRadians(optionss.models.headingpitchroll.roll);
			var headingPitchRoll = new SceneGIS.HeadingPitchRoll(heading, pitch, roll);
			var rotate = SceneGIS.Matrix3.fromHeadingPitchRoll(headingPitchRoll, new SceneGIS.Matrix3());
			//var rotateM = SceneGIS.Transforms.headingPitchRollToFixedFrame(center, headingPitchRoll, SceneGIS.Ellipsoid.WGS84, SceneGIS.Transforms.eastNorthUpToFixedFrame, new SceneGIS.Matrix4());
			var rotateM = SceneGIS.Matrix4.fromRotationTranslation(rotate);

			//计算缩放矩阵
			var scaleM = SceneGIS.Matrix4.fromScale(new SceneGIS.Cartesian3(optionss.models.scale.x, optionss.models.scale.y, optionss.models.scale.z));

			//计算最后的矩阵
			var m1 = SceneGIS.Matrix4.multiply(transformM, rotateM, new SceneGIS.Matrix4());
			var matrix = SceneGIS.Matrix4.multiply(m1, scaleM, new SceneGIS.Matrix4());
			console.log("最终的glb姿态矩阵", matrix);
			// //加载模型
			this._data = entity = this.viewer.scene.primitives.add(SceneGIS.Model.fromGltf({
				url: url,
				modelMatrix: matrix,
				// color: new SceneGIS.Color(1, 0, 0, 1) 
			})
			);
		}
		else if (SceneGIS.defined(optionss.models.modelMatrix)) {
			var matrix = optionss.models.modelMatrix;
			this._data = entity = this.viewer.scene.primitives.add(SceneGIS.Model.fromGltf({
				url: url,
				modelMatrix: new SceneGIS.Matrix4(matrix[0], matrix[1], matrix[2], matrix[3],
					matrix[4], matrix[5], matrix[6], matrix[7],
					matrix[8], matrix[9], matrix[10], matrix[11],
					matrix[12], matrix[13], matrix[14], matrix[15]),

				// color: new SceneGIS.Color(1, 0, 0, 1) 
			}),

			);
		}
		if (optionss.models.isSave === true) {
			entity.modelMatrix = SceneGIS.clone(optionss.models.tempMatrix);
		}
		if (optionss.models.customShaderSource) {
			const customShader = new SceneGIS.CustomShader(optionss.models.customShaderSource);
			entity.customShader = customShader;
		}
		this._data = entity;
	}

	//要素定位
	GlbLayerEX.prototype.zoom = function () {
		//局部定位
		this.data;
	};

	//要素更改透明度
	GlbLayerEX.prototype.changeAlpha = function (alpha) {
		this._data.color = new SceneGIS.Color.WHITE.withAlpha(alpha);
	};

	GlbLayerEX.prototype.updateGlbMaxtrix = function (params) {
		let models = this.option.models;
		models.position.longitude = params.longitude || models.position.longitude;
		models.position.latitude = params.latitude || models.position.latitude;
		models.position.height = params.height || models.position.height;
		models.headingpitchroll.heading = params.heading || models.headingpitchroll.heading;
		models.headingpitchroll.pitch = params.pitch || models.headingpitchroll.pitch;
		models.headingpitchroll.roll = params.roll || models.headingpitchroll.roll;
		//计算平移矩阵
		var position = SceneGIS.Cartesian3.fromDegrees(
			models.position.longitude,
			models.position.latitude,
			models.position.height
		);
		var transformM = SceneGIS.Transforms.eastNorthUpToFixedFrame(position);
		//计算旋转矩阵
		var heading = SceneGIS.Math.toRadians(models.headingpitchroll.heading);
		var pitch = SceneGIS.Math.toRadians(models.headingpitchroll.pitch);
		var roll = SceneGIS.Math.toRadians(models.headingpitchroll.roll);
		var headingPitchRoll = new SceneGIS.HeadingPitchRoll(heading, pitch, roll);
		var rotate = SceneGIS.Matrix3.fromHeadingPitchRoll(headingPitchRoll, new SceneGIS.Matrix3());
		var rotateM = SceneGIS.Matrix4.fromRotationTranslation(rotate);
		//计算缩放矩阵
		var scaleM = SceneGIS.Matrix4.fromScale(new SceneGIS.Cartesian3(models.scale.x, models.scale.y, models.scale.z));

		//计算最后的矩阵
		var m1 = SceneGIS.Matrix4.multiply(transformM, rotateM, new SceneGIS.Matrix4());
		var matrix = SceneGIS.Matrix4.multiply(m1, scaleM, new SceneGIS.Matrix4());
		console.log("更新的glb姿态矩阵", matrix);
		this.data.modelMatrix = matrix;
	};

	GlbLayerEX.prototype.destroy = function () {
		if (!this._destroyed) {
			this._viewer.scene.primitives.remove(this._data);
			this._destroyed = true;
		}
	};

	/** glb 图层
	 * @alias GlbsLayerEX
	 * @constructor
	 * @param {Viewer} viewer
	 * @param {Object} data
	 */
	function GlbsLayerEX(viewer, option) {
		CoreEX.GisBaseLayer.call(this, viewer, option);
		this._data = new CoreEX.Dictionary();
		this._viewer = viewer;
		this._visible = SceneGIS.defaultValue(option.visible, true);
		var url = option.models.url + "glb.json";
		var self = this;
		fetch(url, { method: "get" }).then(res => res.json())
			.then(response => {
				var newres = response;
				//if (self._visible) {
				init$8.bind(self)(newres);
				//  }
			})
			.catch(error => {

				//resolve([]);console.error('Error:', error)
			}
			);


	}

	GlbsLayerEX.prototype = Object.create(CoreEX.GisBaseLayer.prototype);
	GlbsLayerEX.prototype.constructor = GlbsLayerEX;

	Object.defineProperties(GlbsLayerEX.prototype, {
		visible: {
			get: function () {
				if (this.data) {
					return this._visible;
				}
				return false;
			},
			set: function (value) {
				this._visible = value;
				if (this.data) {
					var values = Object.values(this.data.dirctionary);

					values.forEach((glb) => {
						glb.show = value;
					});
					//this.data
				}
			},
		},
		show: {
			get: function () {
				if (this.data) {
					return this.data[0].show;
				}
				return false;
			},
			set: function (value) {
				if (this.visible) {
					//在visible 为 false时,show 不起作用
					if (this.data) {
						var values = Object.values(this.data.dirctionary);
						values.forEach((glb) => {
							glb.show = value;
						});
					}
				}
			},
		},
		data: {
			get: function () {
				return SceneGIS.defined(this._data) ? this._data : undefined;
			},
		},
		/**
		 * 获取parameter 图层名称
		 * @memberof GlbsLayerEX.prototype
		 *
		 * @type {String}
		 * @readonly
		 */
		name: {
			get: function () {
				return SceneGIS.defined(this.option) ? this.option.name : undefined;
			},
		},
		/**
		 * 获取parameter 图层id
		 * @memberof GlbsLayerEX.prototype
		 *
		 * @type {String}
		 * @readonly
		 */
		id: {
			get: function () {
				return SceneGIS.defined(this.option) ? this.option.id : undefined;
			},
		},
		/**
		 * 获取viewer
		 * @memberof GlbsLayerEX.prototype
		 *
		 * @type {Viewer}
		 * @readonly
		 */
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			},
		},
	});

	function init$8(newre) {
		var optionss = this.option;
		var url = optionss.models.url;
		//var entity;
		if (SceneGIS.defined(optionss.models.position)) {
			//计算平移矩阵
			var position = SceneGIS.Cartesian3.fromDegrees(
				optionss.models.position.longitude,
				optionss.models.position.latitude,
				optionss.models.position.height
			);
			var transformM = SceneGIS.Transforms.eastNorthUpToFixedFrame(position);
			//计算旋转矩阵
			var heading = SceneGIS.Math.toRadians(optionss.models.headingpitchroll.heading);
			var pitch = SceneGIS.Math.toRadians(optionss.models.headingpitchroll.pitch);
			var roll = SceneGIS.Math.toRadians(optionss.models.headingpitchroll.roll);
			var headingPitchRoll = new SceneGIS.HeadingPitchRoll(heading, pitch, roll);
			var rotate = SceneGIS.Matrix3.fromHeadingPitchRoll(headingPitchRoll, new SceneGIS.Matrix3());
			//var rotateM = SceneGIS.Transforms.headingPitchRollToFixedFrame(center, headingPitchRoll, SceneGIS.Ellipsoid.WGS84, SceneGIS.Transforms.eastNorthUpToFixedFrame, new SceneGIS.Matrix4());
			var rotateM = SceneGIS.Matrix4.fromRotationTranslation(rotate);

			//计算缩放矩阵
			var scaleM = SceneGIS.Matrix4.fromScale(new SceneGIS.Cartesian3(optionss.models.scale.x, optionss.models.scale.y, optionss.models.scale.z));

			//计算最后的矩阵
			var m1 = SceneGIS.Matrix4.multiply(transformM, rotateM, new SceneGIS.Matrix4());
			var matrix = SceneGIS.Matrix4.multiply(m1, scaleM, new SceneGIS.Matrix4());
			console.log("最终的glb姿态矩阵", matrix);
			// //加载模型
			newre.forEach((item) => {
				let urlmodel = url + item.name + ".glb";
				let entity = this.viewer.scene.primitives.add(SceneGIS.Model.fromGltf({
					url: urlmodel,
					modelMatrix: matrix,
					show: optionss.visible  //默认显示，隐藏
					// color: new SceneGIS.Color(1, 0, 0, 1) 
				})
				);
				this._data.add(item.name, entity);
			});

		}

		else if (SceneGIS.defined(optionss.models.modelMatrix)) {
			var matrix = optionss.models.modelMatrix;
			newre.forEach((item) => {
				let urlmodel = url + item.name + ".glb";
				let entity = this.viewer.scene.primitives.add(SceneGIS.Model.fromGltf({
					url: urlmodel,
					modelMatrix: new SceneGIS.Matrix4(matrix[0], matrix[1], matrix[2], matrix[3],
						matrix[4], matrix[5], matrix[6], matrix[7],
						matrix[8], matrix[9], matrix[10], matrix[11],
						matrix[12], matrix[13], matrix[14], matrix[15]),

					show: optionss.visible

					// color: new SceneGIS.Color(1, 0, 0, 1) 
				}),

				);
				this._data.add(item.name, entity);
			});

		} console.log("load glb");
		//this._data = entity;     
	}

	//要素定位,具体的glb 定位
	GlbsLayerEX.prototype.zoom = function (name, color) {
		//局部定位

		this.data;
		if (this.data.contain(name)) {
			var glb = this.data.get(name);
			glb.color = color;


			var result = new SceneGIS.Cartesian3();
			var center = glb._boundingSphere.center;


			var ellipsoid = this.viewer.scene.globe.ellipsoid;
			// var pos = SceneGIS.Matrix4.getTranslation(glb.modelMatrix, result);



			var c = new SceneGIS.Cartesian3(-center.y, center.x, center.z);
			var pos = SceneGIS.Matrix4.multiplyByPoint(glb.modelMatrix, c, result);
			// var pos =new SceneGIS.Cartesian3();
			// pos.x=glb.modelMatrix[12]+center.x;
			// pos.y=glb.modelMatrix[13]+center.y
			// pos.z=glb.modelMatrix[14]+center.x




			var cart = ellipsoid.cartesianToCartographic(pos);

			var lat = SceneGIS.Math.toDegrees(cart.latitude);
			var lng = SceneGIS.Math.toDegrees(cart.longitude);
			var alt = cart.height;
			this.viewer.camera.flyTo({
				destination: new SceneGIS.Cartesian3.fromDegrees(lng, lat, alt + 5)

			});
		}


	};

	//高亮模型
	GlbsLayerEX.prototype.highLight = function (names = [], color) {
		names.forEach((name) => {
			if (this.data.contain(name)) {
				var glb = this.data.get(name);
				glb.color = color;
			}
		});

	};

	//弱化
	GlbsLayerEX.prototype.weaken = function (names = [], color) {
		this.data.forEach((key, value) => {
			if (names.indexOf(key) == -1) {
				value.color = color;
			}
		});

	};

	/** 自定义 图层,对接各类动态数据源,包括数组，geojons和echarts。
	 * @alias CustomLayerEX
	 * @constructor
	 * @param {Viewer} viewer
	 * @param {Object} option 图层节点配置参数
	 */
	function CustomLayerEX(viewer, array, option = {}) {
		CheckEX.instanceOf("viewer", viewer, SceneGIS.Viewer);

		this._viewer = viewer;

		//高亮
		this.highFeature = undefined;
		this.preM = {};
		this._visible = true;
		this._show = true;
		this.option = undefined;
		this._data = null;
		this._features = new CoreEX.Dictionary(); //这个是所有属性
		this._featureReadyPromise = undefined;

		if (SceneGIS.defined(array)) {
			this.load(array, option);
		}
	}

	Object.defineProperties(CustomLayerEX.prototype, {
		/**
		 * 图层是否打开
		 * @memberof CustomLayerEX.prototype
		 * @type {Boolean}
		 */
		visible: {
			//表示图层是否可见
			get: function () {
				return this._visible;
			},
			set: function (value) {
				this._visible = value;
				this.show = value;
			},
		},

		/**
		 * 图层是否显示
		 * @memberof CustomLayerEX.prototype
		 * @type {Boolean}
		 */
		show: {
			get: function () {
				return this._show;
			},
			set: function (value) {
				if (this._visible == false && value == true) {
					return;
				}
				//在visible为 false 时不起作用
				this._show = value;
				updateVisible$1(this);
			},
		},

		/**
		 * 获取promise 对象
		 *
		 * @memberof CustomLayerEX.prototype
		 *
		 * @type {Promise}
		 * @readonly
		 *
		 * @default undefined
		 */
		featureReadyPromise: {
			get: function () {
				return SceneGIS.defined(this._featureReadyPromise)
					? this._featureReadyPromise
					: undefined;
			},
		},

		/**
		 * 要素数据
		 *
		 * @memberof CustomLayerEX.prototype
		 * @type {CoreEX.Dictionary}
		 * @readonly
		 */
		features: {
			get: function () {
				return SceneGIS.defined(this._features) ? this._features : undefined;
			},
		},

		/**
		 * 获取viewer
		 * @memberof CustomLayerEX.prototype
		 *
		 * @type {viewer}
		 * @readonly
		 */
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			},
		},
	});

	function updateVisible$1(customEx) {
		customEx._features.forEach((key, feature) => {
			feature.show = customEx._show;
		});
	}

	//创建或者更新Features
	function createOrUpdateFeatures$3(customEx, array, option) {
		customEx.option.symbol;
		option.symbol.rule;
		//判断是否是二维数据
		let datageo = undefined,
			data = [];
		if (
			array.length == 2 &&
			array[0] instanceof Array &&
			array[1] instanceof Array
		) {
			datageo = array[1];
			data = array[0];
		} else {
			data = array;
		}
		for (var d of data) {
			//在这里拼接似乎有点怪，但是可以避免多次数组遍历
			if (d.symbol) {
				//优先选择对象symbol
				d.symbol;
			}

			if (!CoreEX.SceneJson.dataPrepare(datageo, d, option)) {
				continue;
			}

			var optionnew = CoreEX.SceneJson.symbolResolve(d, option);
			if (!optionnew) {
				continue;
			}

			var sgb = createOrUpdateFeature(d, optionnew, customEx);

			if (!sgb) {
				continue;
			}

			customEx._features.add(sgb.id, sgb); //用于根据id 快速获取feature。
		}
		return customEx._features;
	}

	//创建或者更新Feature
	function createOrUpdateFeature(row, option, customEx) {
		SceneGIS.Check.defined(
			`图层:${customEx.option.id} 的 symbol.custom`,
			option.custom
		);
		let custom = option.custom;
		let viewer = customEx.viewer;
		custom.id = option.id;
		//根据id开始判断
		if (customEx._features.contain(option.id)) {
			let feature = customEx._features.get(option.id);
			feature._row = row; //对象属性
			feature._positions = option.positions ? option.positions : [];
			//遍历更新属性
			for (var key in custom) {
				if (
					custom[key] &&
					(custom[key] instanceof Object || typeof custom[key] == "object")
				) {
					//这里更新的前提是对象暴露了相关属性。这里目前应该是错误的
					custom[key].positions = SceneGIS.defaultValue(
						custom[key].positions,
						option.positions
					);
					if (feature[key]) {
						//这里更新的前提是对象暴露了相关属性。这里目前应该是错误的
						feature[key] = option[key];
					}
				}
			}
			return undefined;
		} else {
			for (var key in custom) {
				//更新positions
				if (
					custom[key] &&
					(custom[key] instanceof Object || typeof custom[key] == "object")
				) {
					//这里更新的前提是对象暴露了相关属性。这里目前应该是错误的
					custom[key].positions = SceneGIS.defaultValue(
						custom[key].positions,
						option.positions
					);
				}
			}
			let feature = new CustomEntity(viewer, custom);
			feature.show = customEx._visible;
			feature._row = row; //对象属性
			feature._positions = option.positions ? option.positions : [];
			return feature;
		}
	}

	/**
	 *  根据id 获取对应feature,已经废弃
	 * @param {String} id 要素id:
	 * @return {CustomEntity} 要素
	 */
	CustomLayerEX.prototype.getFeatureById = function (id) {
		this.getById(id);
	};
	CustomLayerEX.prototype.zoomFeatureById = function (id, option = {}) {
		this.zoomById(id, option);
	};

	/**
	 * 加载要素，增加或者修改
	 * @param {Array|Object} data 对象或者对象数据
	 */
	CustomLayerEX.prototype.load = function (array, option) {
		this.destroy();
		option.id = SceneGIS.defaultValue(option.id, SceneGIS.createGuid()); //内置图层id 不受约束。

		if (!(array instanceof Array)) {
			throw new CoreEX.DeveloperError(`图层${option.id}的只支持数据类型的数据源`);
		}

		this.option = SceneGIS.defaultValue(option, {});
		this._visible = SceneGIS.defaultValue(option.visible, true);
		option.symbol = SceneGIS.defaultValue(option.symbol, {});
		this.option = option;
		this._featureReadyPromise = createOrUpdateFeatures$3(this, array, option);
	};

	/**
	 * 加载要素，本质调用的load方法
	 * @param {Array|Object} data 对象或者对象数据
	 */
	CustomLayerEX.prototype.add = function (option) {
		let cur = this._features.get(option.id);
		if (cur) {
			throw new CoreEX.DeveloperError(`要素${option.id}的已经存在`);
		}
		let custom = new CustomEntity(this.viewer, option);
		this._features.add(option.id, custom);
	};

	/**
	 * 根据id获取要素
	 * @param {String} id 要素id
	 * @return {CustomEntity|SceneGIS.Entity} 要素
	 */
	CustomLayerEX.prototype.getById = function (id) {
		if (id.indexOf("*") < 0) {
			id = this.id + "*" + id;
		}
		var feature = this._features.get(id);
		return feature;
	};

	/**
	 * 根据id删除要素
	 * @param {String} id 要素id
	 * @return {Boolean} 删除成功返回true,否则返回false
	 */
	CustomLayerEX.prototype.removeById = function (id) {
		var feature = this.getById(id);
		feature.destroy();

		return this._features.remove(id);
	};

	/**
	 * 定位要素
	 * @param {String} id 要素id
	 * @param {Object} option  定位参数
	 * @param {SceneGIS.HeadingPitchRange} option.offset  定位偏移量，默认new SceneGIS.HeadingPitchRange(5, -0.785, 5)
	 * @param {Number} option.maximumHeight  定位最大高度，默认是0
	 * @return {Boolean} 定位成功返回true,否则返回false
	 */
	CustomLayerEX.prototype.zoomById = function (id, option = {}) {
		var feature = this.getById(id);

		return CustomEntity.zoom(this.viewer, feature, option);
	};

	/**
	 * 高亮要素
	 * @param {String} id 要素id
	 * @param {option} option 高亮参数
	 * @param {SceneGIS.Color} [option.color=SceneGIS.Color.RED]  颜色,默认红色
	 */
	CustomLayerEX.prototype.highLightById = function (
		id,
		option = { color: SceneGIS.Color.RED }
	) {
		var feature = this.getById(id);
		if (this.highFeature) {
			this.highFeature._propertyNames.forEach((name) => {
				if (this.highFeature[name] && this.highFeature[name].material) {
					this.highFeature[name].material = this.preM[name];
				}
			});
		}
		if (feature) {
			feature._propertyNames.forEach((name) => {
				if (feature[name]) {
					this.preM[name] = feature[name].material;
					feature[name].material = option.material;
				}
			});
			this.highFeature = feature;
		}
	};

	/**
	 * 定位并高亮要素
	 * @param {String} id 要素id
	 * @param {option} option 高亮参数
	 * @param {SceneGIS.Color} [option.color=SceneGIS.Color.RED]  颜色,默认红色
	 * @param {SceneGIS.HeadingPitchRange} option.offset  定位偏移量，默认new SceneGIS.HeadingPitchRange(5, -0.785, 5)
	 * @param {Number} option.maximumHeight  定位最大高度，默认是0
	 */
	CustomLayerEX.prototype.zoomAndHLById = function (
		id,
		option = { color: SceneGIS.Color.RED }
	) {
		this.highLightById(id, option);
		this.zoomById(id, option);
	};

	/**
	 * 删除所有对象
	 * @return {boolean} 销毁成功返回true,否则返回false
	 */
	CustomLayerEX.prototype.removeAll = function () {
		this._features.forEach((key, value) => {
			value.destroy();
		});

		this._features.removeAll();
		return true;
	};

	/**
	 * 销毁图层
	 * @return {boolean} 销毁成功返回true,否则返回false
	 */
	CustomLayerEX.prototype.destroy = function () {
		this.removeAll();
	};

	/** czml 图层,对接czml数据
	 * @alias CustomLayerEX
	 * @constructor
	 * @param {Viewer} viewer
	 * @param {Object} option 图层节点配置参数
	 */
	function CzmlLayerEX(viewer, czml, option = {}) {
		CheckEX.instanceOf("viewer", viewer, SceneGIS.Viewer);

		this._viewer = viewer;

		this._ds = undefined;
		//高亮
		this.highFeature = undefined;
		this.preM = {};

		this._visible = true;
		this._show = true;
		this.option = undefined;
		this._data = null;
		this._features = new CoreEX.Dictionary(); //这个是所有属性
		this._featureReadyPromise = undefined;

		if (SceneGIS.defined(czml)) {
			this.load(czml, option);
		}
	}

	Object.defineProperties(CzmlLayerEX.prototype, {
		/**
		 * 图层是否打开
		 * @memberof CzmlLayerEX.prototype
		 * @type {Boolean}
		 */
		visible: {
			//表示图层是否可见
			get: function () {
				return this._visible;
			},
			set: function (value) {
				this._visible = value;
				this.show = value;
			},
		},

		/**
		 * 图层是否显示
		 * @memberof CzmlLayerEX.prototype
		 * @type {Boolean}
		 */
		show: {
			get: function () {
				return this._show;
			},
			set: function (value) {
				if (this._visible == false && value == true) {
					return;
				}
				//在visible为 false 时不起作用
				this._show = value;
				updateVisible(this);
			},
		},

		/**
		 * 获取promise 对象
		 *
		 * @memberof CzmlLayerEX.prototype
		 *
		 * @type {Promise}
		 * @readonly
		 *
		 * @default undefined
		 */
		featureReadyPromise: {
			get: function () {
				return SceneGIS.defined(this._featureReadyPromise)
					? this._featureReadyPromise
					: undefined;
			},
		},

		/**
		 * 要素数据
		 *
		 * @memberof CzmlLayerEX.prototype
		 * @type {CoreEX.Dictionary}
		 * @readonly
		 */
		features: {
			get: function () {
				return SceneGIS.defined(this._features) ? this._features : new CoreEX.Dictionary();
			},
		},

		/**
		 * 获取viewer
		 * @memberof CzmlLayerEX.prototype
		 *
		 * @type {viewer}
		 * @readonly
		 */
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			},
		},
	});

	function updateVisible(czmlEx) {
		if (czmlEx._data) {
			czmlEx._data.show = czmlEx._show;
		}
		// czmlEx._features.forEach((key, feature) => {
		//   feature.show = czmlEx._show;
		// });
	}

	//创建或者更新Features
	function createOrUpdateFeatures$2(czmlEx, czml, option) {
		czmlEx.option.symbol;
		option.symbol.rule;
		//判断是否是二维数据
		var dataSourcePromise = SceneGIS.CzmlDataSource.load(czml);

		//if (!czmlEx.viewer.version || czmlEx.viewer.version != "20051") {
		//console.log("add dataSourcePromise");
		return czmlEx.viewer.dataSources.add(dataSourcePromise).then((ds) => {
			czmlEx._ds = ds;
			czmlEx._data = ds;
			ds.show = czmlEx._visible;
			ds.entities.values.forEach((entity) => {
				entity.owner = czmlEx;
				czmlEx._features.add(entity.id, entity);
			});
			return czmlEx._features;
		});
		//}
	}

	/**
	 * 加载要素，增加或者修改
	 * @param {Array} czml 数组
	 * @param {Object} option 配置选项
	 */
	CzmlLayerEX.prototype.load = function (czml, option) {
		this.destroy();
		option.id = SceneGIS.defaultValue(option.id, SceneGIS.createGuid()); //内置图层id 不受约束。

		if (
			!(czml instanceof Array) ||
			czml.length == 0 ||
			czml[0].id != "document"
		) {
			throw new CoreEX.DeveloperError(`图层${option.id}的只支持czml数据源`);
		}

		this.option = SceneGIS.defaultValue(option, {});
		this._visible = SceneGIS.defaultValue(option.visible, true);
		option.symbol = SceneGIS.defaultValue(option.symbol, {});
		this._featureReadyPromise = createOrUpdateFeatures$2(this, czml, option);
	};

	/**
	 *  根据id 获取对应feature,已经废弃
	 * @param {String} id 要素id:
	 * @return {CustomEntity} 要素
	 */
	CzmlLayerEX.prototype.getFeatureById = function (id) {
		this.getById(id);
	};
	CzmlLayerEX.prototype.zoomFeatureById = function (id, option = {}) {
		this.zoomById(id, option);
	};

	/**
	 * 加载要素，本质调用的Entity的add方法
	 * @param {Array|Object} data 对象或者对象数据
	 */
	CzmlLayerEX.prototype.add = function (option) {
		let entity = this._ds.entities.add(option);
		return entity;
	};

	/**
	 * 根据id获取要素
	 * @param {String} id 要素id
	 * @return {CustomEntity|SceneGIS.Entity} 要素
	 */
	CzmlLayerEX.prototype.getById = function (id) {
		if (id.indexOf("*") < 0) {
			id = this.id + "*" + id;
		}
		var feature = this._features.get(id);
		return feature;
	};

	/**
	 * 根据id删除要素
	 * @param {String} id 要素id
	 * @return {Boolean} 删除成功返回true,否则返回false
	 */
	CzmlLayerEX.prototype.removeById = function (id) {
		this._ds.entities.removeById(id);

		return this._features.remove(id);
	};

	/**
	 * 定位要素
	 * @param {String} id 要素id
	 * @param {Object} option  定位参数
	 * @param {SceneGIS.HeadingPitchRange} option.offset  定位偏移量，默认new SceneGIS.HeadingPitchRange(5, -0.785, 5)
	 * @param {Number} option.maximumHeight  定位最大高度，默认是0
	 */
	CzmlLayerEX.prototype.zoomById = function (id, option = {}) {
		var feature = this.getById(id);

		this.viewer.flyTo(feature);
		return true;
	};

	/**
	 * 高亮要素
	 * @param {String} id 要素id
	 * @param {option} option 高亮参数
	 * @param {SceneGIS.Color} [option.color=SceneGIS.Color.RED]  颜色,默认红色
	 */
	CzmlLayerEX.prototype.highLightById = function (
		id,
		option = { color: SceneGIS.Color.RED, material: SceneGIS.Color.RED }
	) {
		var feature = this.getById(id);
		if (this.highFeature) {
			this.highFeature._propertyNames.forEach((name) => {
				if (this.highFeature[name]) {
					//清除原来的高亮
					if ("color" in this.highFeature[name]) {
						this.highFeature[name].color = this.preM[name];
					}
					if ("material" in this.highFeature[name]) {
						this.highFeature[name].material = this.preM[name];
					}
				}
			});
		}
		if (feature) {
			feature._propertyNames.forEach((name) => {
				if (feature[name]) {
					if ("color" in feature[name]) {
						this.preM[name] = feature[name].color;
						feature[name].color = option.color;
					}
					if ("material" in feature[name]) {
						this.preM[name] = feature[name].material;
						feature[name].material = option.material;
					}
				}
			});
			this.highFeature = feature;
		}

		return true;
	};

	/**
	 * 定位并高亮要素
	 * @param {String} id 要素id
	 * @param {option} option 高亮参数
	 * @param {SceneGIS.Color} [option.color=SceneGIS.Color.RED]  颜色,默认红色
	 * @param {SceneGIS.HeadingPitchRange} option.offset  定位偏移量，默认new SceneGIS.HeadingPitchRange(5, -0.785, 5)
	 * @param {Number} option.maximumHeight  定位最大高度，默认是0
	 */
	CzmlLayerEX.prototype.zoomAndHLById = function (
		id,
		option = { color: SceneGIS.Color.RED }
	) {
		this.highLightById(id, option);
		this.zoomById(id, option);
	};

	/**
	 * 删除所有对象
	 * @return {boolean} 销毁成功返回true,否则返回false
	 */
	CzmlLayerEX.prototype.removeAll = function () {
		return true;
	};

	/**
	 * 销毁图层
	 * @return {boolean} 销毁成功返回true,否则返回false
	 */
	CzmlLayerEX.prototype.destroy = function () {
		if (this._featureReadyPromise) {
			this._featureReadyPromise.then((features) => {
				this._ds.entities.removeAll();
			});
		}
	};

	/** GeojsonLayerEX 图层
	 * @alias GeojsonLayerEX
	 * @constructor
	 * @param {Viewer} viewer  ScenGIS的Viewer 对象
	 * @param {Object} geojson  geojson数据
	 * @param {Object} option  配置参数
	 */
	function GeojsonLayerEX(viewer, geojson, option = {}) {
		CheckEX.instanceOf("viewer", viewer, SceneGIS.Viewer);
		this._viewer = viewer;
		this._visible = true;
		this._show = true;
		this.option = undefined;

		this._data = null;
		this._features = new CoreEX.Dictionary(); //这个是所有属性
		this._featureReadyPromise = undefined;
		this._cmd = undefined;

		//高亮
		this.highFeature = undefined;
		this.preM = undefined;

		this._geojson = undefined;

		if (SceneGIS.defined(geojson)) {
			this.load(geojson, option);
		}
	}

	Object.defineProperties(GeojsonLayerEX.prototype, {
		/**
		 * 图层是否打开
		 * @memberof GeojsonLayerEX.prototype
		 * @type {Boolean}
		 */
		visible: {
			get: function () {
				return this._visible;
			},
			set: function (value) {
				this._visible = value;
				this.show = value;
			},
		},
		/**
		 * 图层是否显示
		 * @memberof GeojsonLayerEX.prototype
		 * @type {Boolean}
		 */
		show: {
			get: function () {
				return this._show;
			},
			set: function (value) {
				if (this._visible == false && value == true) {
					return;
				}
				//在visible为 false 时不起作用
				this._show = value;
				if (!this._data) {
					//mapCharts 对象,热力图等对象需要删除，重建
					if (value) {
						this.option.visible = value;
						this.load(this._geojson, this.option);
					}
					else {
						this.destroy();
					}
				} else {
					this._data.show = value;

				}
			},
		},
		/**
		 * 获取promise 对象
		 *
		 * @memberof GeojsonLayerEX.prototype
		 *
		 * @type {Promise}
		 * @readonly
		 *
		 * @default undefined
		 */
		featureReadyPromise: {
			get: function () {
				return SceneGIS.defined(this._featureReadyPromise)
					? this._featureReadyPromise
					: undefined;
			},
		},

		/**
		 * 要素数据
		 *
		 * @memberof GeojsonLayerEX.prototype
		 * @type {CoreEX.Dictionary}
		 * @readonly
		 */

		features: {
			get: function () {
				return SceneGIS.defined(this._features) ? this._features : undefined;
			},
		},
		/**
		 * 获取viewer
		 * @memberof GeojsonLayerEX.prototype
		 *
		 * @type {viewer}
		 * @readonly
		 */
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			},
		},
	});

	//创建具体要素
	function createOrUpdateFeatures$1(customEx, geojson, option) {
		var featureCollection = geojson;
		var symbol = option.symbol;
		let rule = option.symbol.rule;
		var dataSourcePromise = null;
		//console.log("createFeatures data", data);

		if (symbol.geojson) {
			//特有渲染对象
			SceneGIS.Check.defined(
				`图层${option.id}的 symbol.geojson.type`,
				symbol.geojson.type
			);
			dataSourcePromise = addCharts(
				featureCollection,
				symbol.geojson,
				customEx,
				customEx.autoRadiusConfig
			);
		} else {
			dataSourcePromise = SceneGIS.GeoJsonDataSource.load(featureCollection, {
				clampToGround: true,
				planeView: customEx.viewer.scene.planeView
			});
			customEx.viewer.dataSources.add(dataSourcePromise);
		}
		return dataSourcePromise.then((source) => {
			if (!source) return new CoreEX.Dictionary();
			customEx._data = source;
			customEx._data.show = customEx._visible;
			customEx._features.removeAll();
			let index_ = 0;
			source.entities.values.forEach((entity) => {
				//在这里实现渲染
				//id 很重要决定了能不能正确找到要素。
				let id_ = entity.properties.id ? entity.properties.id._value : entity.id;
				customEx._features.add(id_, entity);
				// entity.polygon.heightReference=SceneGIS.HeightReference.CLAMP_TO_GROUND
				// entity.polygon.perPositionHeight=false;
				//SceneGIS.Color.fromCssColorString(color[index++]);
				if (rule && !symbol.geojson) {
					//执行渲染规则
					let fun = new Function("node", "index", rule);
					fun(entity, index_);
				}
				index_++;
			});
			return customEx._features;
		});
	}

	//增加图表
	function addCharts(data, option, self, autoRadiusConfig) {
		if (
			option.type == "cluster" || //聚合图
			option.type == "chart" || //快状图
			option.type == "bar" || //快状图
			option.type == "grid" || //网格图
			option.type == "network" || //网络图
			option.type == "pie" //饼图
		) {
			self._cmd = new ChartsLayerEX(self.viewer);
			self._cmd.setVisible(self._visible);
			return self._cmd.add(data, option).then(() => {
				return undefined;
			});
		} else if (option.type === "heatmap2d") {
			self._cmd = new HeatMap2DEX(self.viewer);

			return self._cmd
				.loadGeoJsonData(data, undefined, undefined, autoRadiusConfig)
				.then(() => {
					self._cmd.setVisible(self._visible);
					return undefined;
				});
		} else if (option.type === "heatmap3d") {
			self._cmd = new HeatMap3DEX(self.viewer);
			return self._cmd
				.loadGeoJsonData(data, undefined, undefined, autoRadiusConfig)
				.then(() => {
					self._cmd.setVisible(self._visible);
					return undefined;
				});
		}

		return undefined;
	}

	/**
	 * 加载geojson数据，或者其他转换过来的额geojson数据，不支持增量更新
	 * @param {Object} geojson geojosn数据
	 * @param {Object} option 配置参数
	 */
	GeojsonLayerEX.prototype.load = function (geojson, option) {
		//清除，重新创建，不支持增量更新呢
		this.destroy();
		this._geojson = geojson;
		option.id = SceneGIS.defaultValue(option.id, SceneGIS.createGuid()); //内置图层id 不受约束。
		//检查是否为geojson数据
		if (
			!SceneGIS.defined(geojson.type) ||
			(geojson.type != "FeatureCollection" && geojson.type != "Feature")
		) {
			throw new CoreEX.DeveloperError(`图层${option.id}的只支持Geojson数据源`);
		}

		this.option = SceneGIS.defaultValue(option, {});
		this._visible = SceneGIS.defaultValue(option.visible, true);

		if (!this._visible) {
			return;
		}

		option.symbol = SceneGIS.defaultValue(option.symbol, {});

		if (option.symbol && option.symbol.geojson) {
			//具备特有的符号化对象
			this.autoRadiusConfig = option.symbol.geojson.autoRadiusConfig;
		}

		this._featureReadyPromise = createOrUpdateFeatures$1(this, geojson, option);
	};

	/**
	 *  图层销毁
	 * @return {*}
	 */
	GeojsonLayerEX.prototype.destroy = function () {
		var self = this;
		if (this._featureReadyPromise) {
			/**destroy 要保证数据销毁，这里如果不删掉，频繁加载可能会导致内存假泄露。
			 * 一旦假泄露，在Ex图层级别将删除不掉了，使用dataSource 删除将会很难定位数据集。
			 */
			this._featureReadyPromise.then((ds) => {
				self.viewer.dataSources.remove(self._data);
				//self._data.detroy();
			});
		}
		if (this._cmd) {
			this._cmd.remove();
			this._cmd = undefined;
		}
	};

	//更新，内部调用
	GeojsonLayerEX.prototype.update = function () { };

	GeojsonLayerEX.prototype.reset = function (option) {
		throw new CoreEX.DeveloperError("不在支持重置");
	};

	/**单个对象添加
	 * @param {Object} data 对象或者对象数据
	 */
	GeojsonLayerEX.prototype.add = function (option) {
		throw new CoreEX.DeveloperError("不在支持单个对象添加");
	};

	/**
	 * 根据id获取要素
	 * @param {String} id 要素id
	 * @return {CustomEntity|SceneGIS.Entity} 要素
	 */
	GeojsonLayerEX.prototype.getById = function (id) {
		if (this._cmd) {
			throw new CoreEX.DeveloperError("不在支持对象获取");
		}
		var feature = this._features.get(id);
		return feature;
	};

	/**
	 * 根据id删除要素
	 * @param {String} id 要素id
	 * @return {Boolean} 删除成功返回true,否则返回false
	 */
	GeojsonLayerEX.prototype.removeById = function (id) {
		if (this._cmd) {
			throw new CoreEX.DeveloperError("不在支持对象删除");
		}
		if (this._data) {
			this._data.entities.removeById(id);
			return this._features.remove(id);
		}
		return false;
	};

	/**
	 * 定位要素
	 * @param {String} id 要素id
	 * @param {Object} option  定位参数
	 * @param {SceneGIS.HeadingPitchRange} option.offset  定位偏移量，默认new SceneGIS.HeadingPitchRange(5, -0.785, 5)
	 * @param {Number} option.maximumHeight  定位最大高度，默认是0
	 */
	GeojsonLayerEX.prototype.zoomById = function (id, option = {}) {
		if (this._cmd) {
			throw new CoreEX.DeveloperError("不在支持对象定位");
		}
		var feature = this.getById(id);
		if (this._data) {
			this.viewer.flyTo(feature);
		}
	};

	/**
	 * 高亮要素
	 * @param {String} id 要素id
	 * @param {option} option 高亮参数
	 * @param {SceneGIS.Color} [option.color=SceneGIS.Color.RED]  颜色,默认红色
	 */
	GeojsonLayerEX.prototype.highLightById = function (
		id,
		option = { color: SceneGIS.Color.RED }
	) {
		if (this._cmd) {
			throw new CoreEX.DeveloperError("不在支持对象高亮");
		}
		var feature = this.getById(id);
		if (this._data) {
			if (this.highFeature) {
				//清除原来的高亮
				if (feature[name].color) {
					feature[name].color = this.preM;
				}
				if (feature[name].material) {
					feature[name].material = this.preM;
				}
			}
			feature._propertyNames.forEach((name) => {
				if (feature[name].color) {
					this.preM = feature[name].color;
					feature[name].color = option.color;
				}
				if (feature[name].material) {
					this.preM = feature[name].material;
					feature[name].material = option.color;
				}
				this.highFeature = feature;
			});
		}
	};

	/**
	 * 定位并高亮要素
	 * @param {String} id 要素id
	 * @param {option} option 高亮参数
	 * @param {SceneGIS.Color} [option.color=SceneGIS.Color.RED]  颜色,默认红色
	 * @param {SceneGIS.HeadingPitchRange} option.offset  定位偏移量，默认new SceneGIS.HeadingPitchRange(5, -0.785, 5)
	 * @param {Number} option.maximumHeight  定位最大高度，默认是0
	 */
	GeojsonLayerEX.prototype.zoomAndHLById = function (
		id,
		option = { color: SceneGIS.Color.RED }
	) {
		this.highLightById(id, option);
		this.zoomById(id, option);
	};

	/**
	 * 删除所有对象
	 * @return {boolean} 销毁成功返回true,否则返回false
	 */
	GeojsonLayerEX.prototype.removeAll = function () {
		if (this._cmd) {
			throw new CoreEX.DeveloperError("不在支持对象删除，请调用destroy");
		}
		if (this._data) {
			this._ds.entities.removeAll();
			this._features.removeAll();
			return true;
		}
		return false;
	};

	/** datasource 图层，基于Czml的扩展
	 * @alias TableLayerEX
	 * @constructor 
	 * @param {Viewer} viewer
	 * @param {Object} option
	 */
	function TableLayerEX(viewer, option) {

		CoreEX.GisBaseLayer.call(this, viewer, option);
		this._rows = new CoreEX.Dictionary();//用于定位和查询
		this._table = [];
		this._rowReadyPromise = undefined;

		init$7.bind(this)();

	}
	TableLayerEX.prototype = Object.create(CoreEX.GisBaseLayer.prototype);
	TableLayerEX.prototype.constructor = TableLayerEX;

	Object.defineProperties(TableLayerEX.prototype, {
		/**
	   * 获取promise 对象
	   *
	   * @memberof TableLayerEX.prototype
	   *
	   * @type {Promise}
	   * @readonly
	   *
	   * @default undefined
	   */
		rowReadyPromise: {
			get: function () {
				return SceneGIS.defined(this._rowReadyPromise) ? this._rowReadyPromise : undefined;
			}
		},
		visible: {//表示图层是否可见
			get: function () {

				return this._visible;

			},
			set: function (value) {
				if (this._visible == value) return;
				this._visible = value;
				// if(this.option.hasOwnProperty("lodLevel")){
				//   //在有lod,只赋值false。在visible 为真时，show的值由lod决定
				//   if(!value){
				//     this._show=value;
				//   }
				// }
				// else{//在没有lod时 visible 和show 是同步的。

				// }
				this._show = value;
				this.update();

			}
		},
		show: {
			get: function () {
				return this._show;
			},
			set: function (value) {
				if (this._visible) {//在visible为 false 时不起作用
					this._show = value;
					this.update();
				}

			}
		},
		table: {
			get: function () {

				return SceneGIS.defined(this._table) ? this._table : undefined;

			}
		}

	});

	function init$7() {
		this.getData();
		createFeaturesWithData(this);
	}


	function createFeaturesWithData(self) {
		self._rowReadyPromise = self._dataReadPromise.then((result) => {
			var _obj = JSON.stringify(result);
			result = JSON.parse(_obj);
			return createFeatures(result[0], result[1], self);
		});
		self._rowReadyPromise.then(() => {
			self.visible = SceneGIS.defined(self.option.visible) ? self.option.visible : true;
		});
	}



	function createFeatures(result, result1, self) {
		var data = result;
		self.option.symbol;
		for (var d of data) {
			//在这里拼接似乎有点怪，但是可以避免多次数组遍历

			if (!self.symbolPrepare(result1, d)) { continue; }

			//var sgb=createFeature(self._viewer,d,symbol,self);
			//if(!sgb) {continue;}

			//添加对应关系
			// var obj=sgb.getSymbolObj();
			// for(var prop of obj._propertyNames){
			//   var _o=obj[prop];
			//   if(_o){
			//     var _objs=_o.getObj();
			//     for(var _ot of _objs){
			//       if(_ot&&_ot.id){
			//         self._featuresdic.add(_ot.id,sgb);
			//       }

			//     }
			//   }

			// }


			self._rows.add(d.id, d);//用于根据id 快速获取feature。
			self._table.push(d);//用于根据id 快速获取feature。
		}

		return self._table;
	}



	/**
	 *  图层销毁
	 * @return {*}
	 */

	TableLayerEX.prototype.destroy = function () {
		var self = this;
		if (this._rowReadyPromise) {
			this._rowReadyPromise.then((ds) => {
				self.viewer.dataSources.remove(ds);
			});

		}
	};

	//更新，内部调用
	TableLayerEX.prototype.update = function () {
		if (this._rowReadyPromise);


	};

	/**
	 *  图层重新符号化,可保留原来符号，局部符号化
	 * @param {Object} symbol 要素id:
	 * @param {Object} symbol1 可选 符号化对象
	 * @param {Array} data  可选 部分扩展属性
	 * @return {*}
	 */
	TableLayerEX.prototype.symbolization = function (symbol, symbol1, data = []) {

		// var dataSourcePromise = SceneGIS.CzmlDataSource.load(czml);
		// this.viewer.dataSources.add(dataSourcePromise);
		// this._rowReadyPromise=dataSourcePromise;

	};


	/**
	 *  根据id 获取对应feature
	 * @param {String} id 要素id:
	 * @param {Object} symbolObj  符号化对象
	 * @return {*}
	 */
	TableLayerEX.prototype.getFeatureById = function (id, symbolObj) {
		return this.getFeatureByCesiumObjId(id, symbolObj)
	};


	/**
	 *  定位feature
	 * @param {String} id 要素id:
	 * @param {Object} symbolObj  符号化对象
	 */

	var zommfeature = undefined;
	TableLayerEX.prototype.zoomFeatureById = function (id, symbolObj) {
		var self = this;
		var feature = this.getFeatureByCesiumObjId(id, symbolObj);
		var self = this;
		if (feature.then) {
			feature.then((fea) => {
				if (zommfeature) {
					zommfeature._symbolObj.billboard.color = SceneGIS.Color.WHITE;
				}
				fea._symbolObj.show = true;
				fea._symbolObj.billboard.color = SceneGIS.Color.BLUE;
				zommfeature = fea;
				var hpr = new SceneGIS.HeadingPitchRange(0, -0.785, 500);
				self.viewer.flyTo(fea._symbolObj, { offset: hpr });


			}).catch((e) => {
				console.log(e);
			});
		}
		else {
			this.viewer.flyTo(feature._symbolObj);
		}


	};

	/** 图形图层,用于创建各类对象，对接各类数据源和对象。
	 * @alias GraphicLayerEX
	 * @constructor
	 * @param {Viewer} viewer Viewer对象
	 * @param {Object} option 图层节点配置参数
	 * @see CzmlLayerEX
	 * @see EchartsLayerEX
	 * @see GeojsonLayerEX
	 * @see CustomLayerEX
	 */
	function GraphicLayerEX(viewer, option = {}) {
		CheckEX.instanceOf(`图层${option.id}的 viewer`, viewer, SceneGIS.Viewer);
		option.id = option.id || CoreEX.MathEX.createUID(); //这里默认可以不传入id
		CoreEX.GisBaseLayer.call(this, viewer, option);
		this._data = undefined; //最终的图层数据源
		//高亮
		this.highFeature = undefined;
		this.preM = undefined;
		this._features = new CoreEX.Dictionary(); //用于定位和查询
		this.planeView = viewer.scene.planeView;
		if (SceneGIS.defined(option.data)) {
			this.load(option);
		}
	}

	GraphicLayerEX.prototype = Object.create(CoreEX.GisBaseLayer.prototype);
	GraphicLayerEX.prototype.constructor = GraphicLayerEX;

	Object.defineProperties(GraphicLayerEX.prototype, {
		/**
		 * 图层是否打开
		 * @memberof GraphicLayerEX.prototype
		 * @type {Boolean}
		 */
		visible: {
			//表示图层是否可见
			get: function () {
				return this._visible;
			},
			set: function (value) {
				this._visible = value;
				if (this._data) {
					//它不需要调用自己的show
					this._data.visible = value;
				}
			},
		},
		/**
		 * 图层是否显示
		 * @memberof GraphicLayerEX.prototype
		 * @type {Boolean}
		 */
		show: {
			get: function () {
				return this._show;
			},
			set: function (value) {
				if (this._visible == false && value == true) {
					return;
				}
				this._show = value;
				if (this._data) {
					this._data.show = value;
				}
				//设置显隐
			},
		},
		/**
		 * 获取内置layer
		 * @memberof GraphicLayerEX.prototype
		 *
		 * @type {Object}
		 * @readonly
		 */
		layer: {
			get: function () {
				return SceneGIS.defined(this._data) ? this._data : undefined;
			},
		},
		/**
		 * 获取图层要素
		 * @memberof GisBaseLayer.prototype
		 * @type {Dictionary}
		 * @readonly
		 */
		features: {
			get: function () {
				if (!this._data) return new CoreEX.Dictionary();
				return SceneGIS.defined(this._data._features) ? this._data._features : new CoreEX.Dictionary();
			},
		},
	});

	//数据转换，返回需要的图层
	function dataTransform(layerEx, originType, targetType, data) {
		let viewer = layerEx.viewer;
		let option = layerEx.option;
		let symbol = option.symbol;

		switch (targetType) {
			case "czml":
				let czmlData;
				if (originType == "czml") {
					czmlData = data;
				}
				if (originType == "array2" || originType == "array") {
					czmlData = DataTransform.arrayToCzml(data, symbol, symbolResolve);
				}
				if (originType == "geojson") {
					czmlData = DataTransform.geojsonToCzml(data);
				}
				return new CzmlLayerEX(viewer, czmlData, option);
			case "custom":
				let customData;
				if (originType == "array2" || originType == "array") {
					customData = data;
				}
				if (originType == "geojson") {
					customData = DataTransform.geojsonToCustom(data);
				}
				return new CustomLayerEX(viewer, customData, option);
			case "geojson":
				let geojsonData;
				if (originType == "geojson") {
					geojsonData = data;
				}
				if (originType == "array2" || originType == "array") {
					SceneGIS.Check.defined(
						`图层${option.id}的 symbol.geoType`,
						symbol.geoType
					);
					geojsonData =
						originType == "array2"
							? DataTransform.arrayToGeojson(
								data[0],
								symbol,
								symbolResolve,
								layerEx.planeView
							)
							: DataTransform.arrayToGeojson(
								data,
								symbol,
								symbolResolve,
								layerEx.planeView
							);
				}
				return new GeojsonLayerEX(viewer, geojsonData, option);

			case "echarts":
				if (originType == "echarts") {
					return new EchartsLayerEX(viewer, data, option);
				}
			default:
				if (originType == "czml") {
					return new CzmlLayerEX(viewer, data, option);
				} else if (originType == "array2" || originType == "array") {
					//这里需要单独循环样式解译
					return new CustomLayerEX(viewer, data, option);
				} else if (originType == "geojson") {
					return new GeojsonLayerEX(viewer, data, option);
				} else if (originType == "echarts") {
					return new EchartsLayerEX(viewer, data, option);
				}
		}
		//样式解译
		function symbolResolve(d) {
			//样式解译
			//在这里拼接似乎有点怪，但是可以避免多次数组遍历
			let arraygeo = undefined;
			if (originType == "array2") {
				data[0];
				arraygeo = data[1];
			}
			if (!layerEx.dataPrepare(arraygeo, d)) {
				return undefined;
			}
			var noption = layerEx.symbolResolve(d);
			return noption;
		}

		throw new CoreEX.DeveloperError(
			`图层${option.id} dataTransform 错误,数据源${originType}不支持渲染目标的类型${targetType}`
		);
	}

	//创建实际要管理的图层
	function createOrUpdateLayer(customEx) {
		customEx._featureReadyPromise = customEx._dataReadPromise.then((result) => {
			//数据拷贝
			var _obj = JSON.stringify(result);
			result = JSON.parse(_obj);

			let dataType = customEx.dataCheck(result);
			let symbolType = customEx.symbolCheck();
			let layer = dataTransform(customEx, dataType, symbolType, result);
			customEx._data = layer;
			return layer._featureReadyPromise;
		});
	}

	/**
	 *  根据id 获取对应feature,已经废弃
	 * @param {String} id 要素id:
	 * @return {CustomEntity} 要素
	 */
	GraphicLayerEX.prototype.getFeatureById = function (id) {
		this.getById(id);
	};
	GraphicLayerEX.prototype.zoomFeatureById = function (id, option = {}) {
		this.zoomById(id, option);
	};

	/**
	 * 加载要素，增加或者修改要素
	 * @param {Object} option 渲染的参数
	 */
	GraphicLayerEX.prototype.load = function (option = {}) {
		this.destroy(); //每次加载都销毁之前的图层
		SceneGIS.Check.defined("option.id", option.id); //到这里必须检查id
		SceneGIS.Check.typeOf.string(
			`图层${option.id} 的 option.layerType`,
			option.layerType
		);
		if (SceneGIS.defined(option.data)) {
			SceneGIS.Check.typeOf.object(
				`图层${option.id} 的 option.data`,
				option.data
			);
		} else if (SceneGIS.defined(option.attributeTable)) {
			//兼容旧版本
			SceneGIS.Check.typeOf.object(
				`图层${option.id} option.attributeTable`,
				option.attributeTable
			);
			option.data = option.attributeTable;
			delete option.attributeTable;
		} else {
			throw new SceneGIS.DeveloperError(
				`图层${option.id} option.data or option.attributeTable is required`
			);
		}
		this._visible = SceneGIS.defined(option.visible) ? option.visible : true;
		Object.assign(this.option, option);
		this.getData();
		this.option = option;
		createOrUpdateLayer(this);
	};

	/**
	 * 加载要素
	 * @param {Object} option 对象
	 */
	GraphicLayerEX.prototype.add = function (option) {
		SceneGIS.Check.defined("option.id", option.id); //到这里必须检查id
		if (option.id.indexOf("*") < 0) {
			option.id = this.id + "*" + option.id;
		}
		if (this.layer) {
			this.layer.add(option);
		}
	};

	/**
	 * 根据id获取要素
	 * @param {String} id 要素id
	 * @return {CustomEntity|SceneGIS.Entity} 要素
	 */
	GraphicLayerEX.prototype.getById = function (id) {
		if (id.indexOf("*") < 0) {
			id = this.id + "*" + id;
		}
		if (this.layer) {
			var feature = this.layer.getById(id);
			return feature;
		}
		return undefined;

	};

	/**
	 * 根据id删除要素
	 * @param {String} id 要素id
	 * @return {Boolean} 删除成功返回true,否则返回false
	 */
	GraphicLayerEX.prototype.removeById = function (id) {
		if (id.indexOf("*") < 0) {
			id = this.id + "*" + id;
		}
		if (this.layer) this.layer.removeById(id);
	};

	/**
	 * 定位要素
	 * @param {String} id 要素id
	 * @param {Object} option  定位参数
	 * @param {SceneGIS.HeadingPitchRange} option.offset  定位偏移量，默认new SceneGIS.HeadingPitchRange(5, -0.785, 5)
	 * @param {Number} option.maximumHeight  定位最大高度，默认是0
	 * @return {Boolean} 定位成功返回true,否则返回false
	 */
	GraphicLayerEX.prototype.zoomById = function (id, option = {}) {
		if (id.indexOf("*") < 0) {
			id = this.id + "*" + id;
		}
		if (this.layer) { return this.layer.zoomById(id, option); }

		return false;
	};

	/**
	 * 高亮要素
	 * @param {String} id 要素id
	 * @param {option} option 高亮参数
	 * @param {SceneGIS.Color} [option.color=SceneGIS.Color.RED]  颜色,默认红色
	 * @return {Boolean} 高亮成功返回true,否则返回false
	 */
	GraphicLayerEX.prototype.highLightById = function (
		id,
		option = { color: SceneGIS.Color.RED, material: SceneGIS.Color.RED }
	) {
		if (id.indexOf("*") < 0) {
			id = this.id + "*" + id;
		}
		if (this.layer) { return this.layer.highLightById(id, option); }
		return false;
	};

	/**
	 * 定位并高亮要素
	 * @param {String} id 要素id
	 * @param {option} option 高亮参数
	 * @param {SceneGIS.Color} [option.color=SceneGIS.Color.RED]  颜色,默认红色
	 * @param {SceneGIS.HeadingPitchRange} option.offset  定位偏移量，默认new SceneGIS.HeadingPitchRange(5, -0.785, 5)
	 * @param {Number} option.maximumHeight  定位最大高度，默认是0
	 */
	GraphicLayerEX.prototype.zoomAndHLById = function (
		id,
		option = { color: SceneGIS.Color.RED, material: SceneGIS.Color.RED }
	) {
		if (id.indexOf("*") < 0) {
			id = this.id + "*" + id;
		}

		if (this.layer) this.layer.zoomAndHLById(id, option);
	};

	/**
	 * 删除所有对象
	 * @return {boolean} 销毁成功返回true,否则返回false
	 */
	GraphicLayerEX.prototype.removeAll = function () {
		if (this.layer) this.layer.removeAll();
	};

	/**
	 * 销毁图层
	 * @return {boolean} 销毁成功返回true,否则返回false
	 */
	GraphicLayerEX.prototype.destroy = function () {
		if (this.layer) this.layer.destroy();
	};

	/**
	 * TileSetEffectType类型
	 *
	 * @enum {String}
	 */
	var TileSetEffectType = {
		/**
		 * 垂直渐变
		 * @type {String}
		 */
		verticalGradient: "verticalGradient",
		/**
		 * 动态色带
		 * @type {String}
		 */
		ribbon: "ribbon",
		/**
		 * 动态扫描
		 * @type {String}
		 */
		scan: "scan",
		/**
		 * 建筑生长
		 * @type {String}
		 */
		grow: "grow"




	};
	var TileSetEffectType$1 = Object.freeze(TileSetEffectType);

	/** I3S 图层类
	 * @alias I3SLayerEX
	 * @constructor
	 * @param {Viewer} viewer
	 * @param {String} option.id 图层id
	 * @param {SceneGIS.SceneGIS3DTileset.constructor} option.data 图层配置数据
	 * @param {Boolean} option.visible 图层显隐
	 * @param {Object} option.camera 图层相机配置
	 * @param {Number} [option.lodLevel=-1] lod等级,-1时表示不加入lod控制
	 * @param {String} option.symbol tileset titleset的位置和样式
	 * @param {String} option.symbol.transform tileset 变换矩阵 优先级最高
	 * @param {String} option.symbol.hpr tileset 位置和旋转值 优先级次高
	 * @param {String} option.symbol.mheight tileset 调整高度 优先级最低
	 * @param {TileSetEffectType} option.symbol.effect tileset 预置特效，主要为修改名字
	 */
	function I3SLayerEX(viewer, option) {
		CheckEX.instanceOf("viewer", viewer, SceneGIS.Viewer);
		CoreEX.GisBaseLayer.call(this, viewer, option);
		this._data = undefined;
		this._url = undefined;
		this.load(option);
	}

	I3SLayerEX.prototype = Object.create(CoreEX.GisBaseLayer.prototype);
	I3SLayerEX.prototype.constructor = I3SLayerEX;

	Object.defineProperties(I3SLayerEX.prototype, {
		/**
		 * 图层是否打开
		 * @memberof I3SLayerEX.prototype
		 * @type {Boolean}
		 */
		visible: {
			get: function () {
				if (this.data) {
					return this._visible;
				}
				return false;
			},
			set: function (value) {
				this._visible = value;
				this.show = value;

			},
		},
		/**
		 * 图层是否显示
		 * @memberof I3SLayerEX.prototype
		 * @type {Boolean}
		 */
		show: {
			get: function () {
				if (this.data) {
					return this.data.show;
				}
				return false;
			},
			set: function (value) {
				if (this._visible == false && value == true) {
					return;
				}
				if (this.data) {
					this.data.show = value;
				} else {
					if (value) {
						init$6.bind(this)();//表示首次根本不加载任何数据
					}
				}
			},
		},
		/**
		 * 图层数据
		 * @memberof I3SLayerEX.prototype
		 * @type {SceneGIS3DTileset}
		 * @readonly
		 */
		data: {
			get: function () {
				return SceneGIS.defined(this._data) ? this._data : undefined;
			},
		},
		/**
		 * 获取parameter 图层名称
		 * @memberof I3SLayerEX.prototype
		 *
		 * @type {String}
		 * @readonly
		 */
		name: {
			get: function () {
				return SceneGIS.defined(this.option) ? this.option.name : undefined;
			},
		},
		/**
		 * 获取parameter 图层id
		 * @memberof I3SLayerEX.prototype
		 *
		 * @type {String}
		 * @readonly
		 */
		id: {
			get: function () {
				return SceneGIS.defined(this.option) ? this.option.id : undefined;
			},
		},

	});

	function init$6() {
		let options = this.option.data ? this.option.data : this.option.models;
		if (!SceneGIS.defined(options.uri) && !SceneGIS.defined(options.url)) {
			throw CoreEX.DeveloperError("uri 或者url is required");
		}
		let optionsnew = CoreEX.UtilEX.deepClone(options);
		if (optionsnew.geoidTiledTerrainProvider) {
			optionsnew.geoidTiledTerrainProvider = new SceneGIS.ArcGISTiledElevationTerrainProvider(optionsnew.geoidTiledTerrainProvider);
		}
		let t3dtiles = new SceneGIS.I3SDataProvider(optionsnew);

		this._data = t3dtiles;

		this.viewer.scene.primitives
			.add(t3dtiles)
			.readyPromise.then(function (tileset) {

			});
	}


	/**
	 * 加载tileset 数据
	 * @param {Object} option 参考构造函数的option
	 */
	I3SLayerEX.prototype.load = function (option) {
		SceneGIS.Check.defined("option.id", option.id);
		SceneGIS.Check.typeOf.string("option.layerType", option.layerType);

		if (SceneGIS.defined(option.data)) {
			SceneGIS.Check.typeOf.object("option.data", option.data);
		} else if (SceneGIS.defined(option.models)) {
			SceneGIS.Check.typeOf.object("option.models", option.models);
		} else {
			throw new SceneGIS.DeveloperError(
				`图层${option.id}的option.data or option.models is required`
			);
		}

		let options = option.data ? option.data : option.models;
		if (!SceneGIS.defined(options.uri) && !SceneGIS.defined(options.url)) {
			throw CoreEX.DeveloperError("uri 或者url is required");
		}
		let url = options.uri ? options.uri : options.url;

		this._visible = SceneGIS.defaultValue(option.visible, true);
		option.symbol = SceneGIS.defaultValue(option.symbol, {});
		this.option = option;

		if (this._data && _.isEqual(this._url, url));
		this._url = options.uri ? options.uri : options.url;
		if (this._visible) {
			this.destroy();
			init$6.bind(this)();
		}
	};

	/**
	 *  根据id 获取对应feature
	 * @param {String} idField  要素id 字段:
	 * @param {Object} idValue  要素id 字段值
	 * @return {*}
	 */
	I3SLayerEX.prototype.getFeatureById = function (idField, idValue) {

	};

	/**
	 *  根据id 获取对应feature
	 * @param {String} idField  要素id 字段:
	 * @param {Object} idValue  要素id 字段值
	 * @return {*}
	 */
	I3SLayerEX.prototype.getById = function (idField, idValue) {

		return undefined;
	};


	/**
	 * 销毁图层
	 * @return {boolean} 销毁成功返回true,否则返回false
	 */
	I3SLayerEX.prototype.destroy = function () {
		if (this.viewer)
			this.viewer.scene.primitives.remove(this._data);

	};

	/**
	 * 影像图层类
	 * 
	 * @alias ImageryLayerEX
	 * @constructor
	 * @param {Viewer} viewer 三维Viewer 对象
	 * @param {Object} option 图层配置数据
	 * @param {String} option.id 图层id
	 * @param {SceneGIS.ImageryProvider.constructor} option.data 图层配置数据
	 * @param {Number} option.data.index 图层索引
	 * @param {Boolean} option.visible 图层显隐
	 * @param {Object} option.camera 图层相机配置
	 * @param {Number} [option.lodLevel=-1] lod等级,-1时表示不加入lod控制
	 * @param {String} option.symbol 地形符号化
	 * @param {SceneGIS.ImageryLayer.constructor} option.symbol.imageryLayer 影像参数
	 * @param {Object} option.symbol.imageryLayer.imageBasedLighting 环境光
	 * 
	 * 
	 */
	function ImageryLayerEX(viewer, option) {

		CheckEX.instanceOf("viewer", viewer, SceneGIS.Viewer);
		CoreEX.GisBaseLayer.call(this, viewer, option);

		this._provider = undefined;
		this._imageryLayer = undefined;
		this._imagery = undefined;
		this.imgeObject = undefined;
		this._data = undefined;
		this.option = undefined;
		this.load(option);


	}

	ImageryLayerEX.prototype = Object.create(CoreEX.GisBaseLayer.prototype);
	ImageryLayerEX.prototype.constructor = ImageryLayerEX;

	function init$5() {
		let len = this.viewer.imageryLayers._layers.length;
		var provider = this._provider;
		var options = CoreEX.UtilEX.deepClone(this._imagery);
		var options1 = CoreEX.UtilEX.deepClone(this._imageryLayer);
		var index = options.index || len;

		if (options.replace) {
			this.viewer.imageryLayers.removeAll();
		}
		let _imageBasedLighting = {};
		_imageBasedLighting = options1.imageBasedLighting ? options1.imageBasedLighting : options.imageBasedLighting;

		if (options.tilingScheme === "WebMercatorTilingScheme") {
			options.tilingScheme = new SceneGIS.WebMercatorTilingScheme(); //墨卡托投影
		}
		if (options.tilingScheme === "Geographic" || options.tilingScheme === "GeographicTilingScheme") {
			options.tilingScheme = new SceneGIS.GeographicTilingScheme({
				ellipsoid: SceneGIS.Ellipsoid.WGS84
			});
		}
		if (options.tilingScheme === "CartesianTilingScheme") {
			options.tilingScheme = new SceneGIS.CartesianTilingScheme(); //平面
		}
		switch (provider) {
			case "urlTemplateImageryProvider": {

				if (options.customTags === "tencentimg") {
					options.customTags = {
						sx: function (imageryProvider, x, y, level) {
							return x >> 4;
						},
						sy: function (imageryProvider, x, y, level) {
							return ((1 << level) - y) >> 4;
						},
					};
				}
				if (SceneGIS.defined(options.rectangle)) {
					options.rectangle = new SceneGIS.Rectangle(options.rectangle[0], options.rectangle[1], options.rectangle[2], options.rectangle[3]);
				}
				var imagerylayer = new SceneGIS.ImageryLayer(new SceneGIS.UrlTemplateImageryProvider(options), options1);
				this.viewer.imageryLayers.add(
					imagerylayer,
					index
				);


				if (_imageBasedLighting) {
					imagerylayer.imageBasedLighting = new SceneGIS.ImageBasedLighting(_imageBasedLighting);
				}

				this._data = imagerylayer;


				break;

			}
			case "singleTileImageryProvider": {
				let singleimage = new SceneGIS.ImageryLayer(new SceneGIS.SingleTileImageryProvider(options), options1);


				this.viewer.imageryLayers.add(
					singleimage,
					index
				);
				this._data = singleimage;
				break;

			}
			case "webMapTileServiceImageryProvider":
				{
					var imagerylayer;
					if (this.viewer.scene.planeView) {
						imagerylayer = new SceneGIS.CartesianImageryLayer(new SceneGIS.WebMapTileServiceImageryProvider(options), options1);
					}
					else {
						imagerylayer = new SceneGIS.ImageryLayer(new SceneGIS.WebMapTileServiceImageryProvider(options), options1);
					}

					this.viewer.imageryLayers.add(
						imagerylayer,
						index

					);

					if (_imageBasedLighting) {
						imagerylayer.imageBasedLighting = new SceneGIS.ImageBasedLighting(_imageBasedLighting);
					}

					this._data = imagerylayer;
					break;
				}
			case "arcGisMapServerImageryProvider": {
				var imagerylayer = new SceneGIS.ImageryLayer(new SceneGIS.ArcGisMapServerImageryProvider(options), options1);
				if (this.option.lodLevel > 0) {
					imagerylayer.isGisLod = true;
				}
				this.viewer.imageryLayers.add(
					imagerylayer,
					index

				);
				if (_imageBasedLighting) {
					imagerylayer.imageBasedLighting = new SceneGIS.ImageBasedLighting(_imageBasedLighting);
				}
				this._data = imagerylayer;
				break;
			}
			case "bingMapsImageryProvider": {
				var imagerylayer = new SceneGIS.ImageryLayer(new SceneGIS.BingMapsImageryProvider(options), options1);
				this.viewer.imageryLayers.add(
					imagerylayer,
					index

				);

				if (_imageBasedLighting) {
					imagerylayer.imageBasedLighting = new SceneGIS.ImageBasedLighting(_imageBasedLighting);
				}
				this._data = imagerylayer;

				break;
			}
			case "openStreetMapImageryProvider": {
				var imagerylayer = new SceneGIS.ImageryLayer(new SceneGIS.OpenStreetMapImageryProvider(options), options1);
				this.viewer.imageryLayers.add(
					imagerylayer,
					index

				);
				if (_imageBasedLighting) {
					imagerylayer.imageBasedLighting = new SceneGIS.ImageBasedLighting(_imageBasedLighting);
				}

				this._data = imagerylayer;
				break;
			}
			case "webMapServiceImageryProvider": {
				var imagerylayer = new SceneGIS.ImageryLayer(new SceneGIS.WebMapServiceImageryProvider(options), options1);
				this.viewer.imageryLayers.add(
					imagerylayer,
					index

				);

				if (_imageBasedLighting) {
					imagerylayer.imageBasedLighting = new SceneGIS.ImageBasedLighting(_imageBasedLighting);
				}

				this._data = imagerylayer;
				break;
			}
			//以下是平面坐标系
			case "cartesianTileImageryProvider": {
				var imagerylayer = new SceneGIS.CartesianImageryLayer(new SceneGIS.CartesianTileImageryProvider(options), options1);
				this.viewer.imageryLayers.add(
					imagerylayer,
					index

				);
				this._data = imagerylayer;
				break
			}
			case "cartesianArcGisMapServerImageryProvider": {
				var imagerylayer = new SceneGIS.CartesianImageryLayer(new SceneGIS.CartesianArcGisMapServerImageryProvider(options), options1);
				this.viewer.imageryLayers.add(
					imagerylayer,
					index

				);
				this._data = imagerylayer;
				break
			}
		}

		// if (this.option.symbol) {
		//   this.updateSymbol(this.option.symbol);
		// }
	}

	Object.defineProperties(ImageryLayerEX.prototype, {
		/**
		 * 图层是否打开
		 * @memberof ImageryLayerEX.prototype
		 * @type {Boolean}
		 */
		visible: {
			get: function () {
				if (this._data) {
					return this._visible;
				}
				return false;
			},
			set: function (value) {

				this._visible = value;
				this.show = value;

			}

		},
		/**
		* 图层是否显示
		* @memberof ImageryLayerEX.prototype
		* @type {Boolean}
		*/
		show: {
			get: function () {
				if (this._data) {
					return this._data.show;
				}
				return false;
			},
			set: function (value) {
				if (this._visible == false && value == true) {
					return;
				}
				if (this._data) {
					if (value) {
						this.viewer.imageryLayers.raiseToTop(this._data);
					}
					this._data.show = value;
				}
			}
		},

		/**
		 * 图层数据
		 * @memberof ImageryLayerEX.prototype
		 * @type {Object}
		 * @readonly
		 */
		data: {
			get: function () {
				return this._data;
			}
		}


	});

	/**
	 * 加载影像数据
	 * @param {Object}option 参考构造函数的option
	 */
	ImageryLayerEX.prototype.load = function (option) {
		this.destroy();
		SceneGIS.Check.defined("option.id", option.id);

		SceneGIS.Check.typeOf.string("option.layerType", option.layerType);

		if (SceneGIS.defined(option.data)) {
			SceneGIS.Check.typeOf.object("option.data", option.data);
		}
		else if (SceneGIS.defined(option.imagery)) {
			SceneGIS.Check.typeOf.object("option.imagery", option.imagery);
		}
		else {
			throw new SceneGIS.DeveloperError("option.data or option.imagery is required");
		}

		this._visible = SceneGIS.defaultValue(option.visible, true);

		this._provider = option.layerType;
		option.symbol = SceneGIS.defaultValue(option.symbol, {});
		this._imageryLayer = option.symbol.imageryLayer ? option.symbol.imageryLayer : option.imageryLayer;//兼容之前的版本
		this._imageryLayer = SceneGIS.defaultValue(this._imageryLayer, {});
		if (this._imageryLayer == "") {
			this._imageryLayer = {};
		}

		SceneGIS.Check.typeOf.object("this._imageryLayer", this._imageryLayer);
		this._imageryLayer.show = this._visible;
		this._imagery = option.data ? option.data : option.imagery;//兼容之前的版本

		this.option = option;
		init$5.bind(this)();
	};

	ImageryLayerEX.prototype.reset = function (options) {
		//调色
		this.updateSymbol(options.symbol.imageryLayer);
	};

	ImageryLayerEX.prototype.changeAlpha = function (alpha) {
		if (!this.option.symbol) {
			this.option.symbol = {
				imageryLayer: {
					alpha: alpha
				}
			};
		}
		if (!this.option.symbol.imageryLayer) {
			this.option.symbol.imageryLayer = {
				alpha: alpha
			};
		}
		this.option.symbol.imageryLayer.alpha = alpha;
		this._data.alpha = alpha;
	};

	/**
	 * 重新赋值imageryLayer的属性
	 * @param {Object} symbol 
	 * @param {Number} symbol.alpha 透明度
	 * @param {Number} symbol.gamma 伽马
	 * @param {Number} symbol.grayscale 灰度
	 * @param {Number} symbol.contrast 对比度
	 * @param {Number} symbol.invert 反色
	 * @param {Number} symbol.sepia 褐色
	 * @param {Number} symbol.brightness 亮度
	 * @param {Number} symbol.hue 色调
	 * @param {Number} symbol.saturation 饱和度
	 */
	ImageryLayerEX.prototype.updateSymbol = function (symbol) {
		if (SceneGIS.defined(symbol.alpha)) {
			this._data.alpha = symbol.alpha;
		}

		if (SceneGIS.defined(symbol.gamma)) {
			this._data.gamma = symbol.gamma;
		}

		if (SceneGIS.defined(symbol.gamma)) {
			this._data.gamma = symbol.gamma;
		}
		if (SceneGIS.defined(symbol.grayscale)) {
			this._data.grayscale = symbol.grayscale;
		}
		if (SceneGIS.defined(symbol.contrast)) {
			this._data.contrast = symbol.contrast;
		}
		if (SceneGIS.defined(symbol.invert)) {
			this._data.invert = symbol.invert;
		}
		if (SceneGIS.defined(symbol.sepia)) {
			this._data.sepia = symbol.sepia;
		}
		if (SceneGIS.defined(symbol.brightness)) {
			this._data.brightness = symbol.brightness;
		}
		if (SceneGIS.defined(symbol.hue)) {
			this._data.hue = symbol.hue;
		}
		if (SceneGIS.defined(symbol.saturation)) {
			this._data.saturation = symbol.saturation;
		}
	};


	/**
	* 销毁图层
	* @return {boolean} 销毁成功返回true,否则返回false
	*/
	ImageryLayerEX.prototype.destroy = function () {
		if (this.viewer)
			this.viewer.imageryLayers.remove(this._data);
		this._provider = undefined;
		this._imageryLayer = undefined;
		this._imagery = undefined;
		this.imgeObject = undefined;
		this._data = undefined;

	};

	/** tileSet 图层类
	 * @alias TileSetLayerEX
	 * @constructor
	 * @param {Viewer} viewer
	 * @param {String} option.id 图层id
	 * @param {SceneGIS.SceneGIS3DTileset.constructor} option.data 图层配置数据
	 * @param {Boolean} option.visible 图层显隐
	 * @param {Object} option.camera 图层相机配置
	 * @param {Number} [option.lodLevel=-1] lod等级,-1时表示不加入lod控制
	 * @param {String} option.symbol tileset titleset的位置和样式
	 * @param {String} option.symbol.transform tileset 变换矩阵 优先级最高
	 * @param {String} option.symbol.hpr tileset 位置和旋转值 优先级次高
	 * @param {String} option.symbol.mheight tileset 调整高度 优先级最低
	 * @param {TileSetEffectType} option.symbol.effect tileset 预置特效，主要为修改名字
	 */
	function TileSetLayerEX(viewer, option) {
		CheckEX.instanceOf("viewer", viewer, SceneGIS.Viewer);
		CoreEX.GisBaseLayer.call(this, viewer, option);
		this._data = undefined;
		this._url = undefined;
		this.load(option);
	}

	TileSetLayerEX.prototype = Object.create(CoreEX.GisBaseLayer.prototype);
	TileSetLayerEX.prototype.constructor = TileSetLayerEX;

	Object.defineProperties(TileSetLayerEX.prototype, {
		/**
		 * 图层是否打开
		 * @memberof TileSetLayerEX.prototype
		 * @type {Boolean}
		 */
		visible: {
			get: function () {
				if (this.data) {
					return this._visible;
				}
				return false;
			},
			set: function (value) {
				this._visible = value;
				this.show = value;

			},
		},
		/**
		 * 图层是否显示
		 * @memberof TileSetLayerEX.prototype
		 * @type {Boolean}
		 */
		show: {
			get: function () {
				if (this.data) {
					return this.data.show;
				}
				return false;
			},
			set: function (value) {
				if (this._visible == false && value == true) {
					return;
				}
				if (this.data) {
					this.data.show = value;
				} else {
					if (value) {
						init$4.bind(this)();//表示首次根本不加载任何数据
					}
				}
			},
		},
		/**
		 * 图层数据
		 * @memberof TileSetLayerEX.prototype
		 * @type {SceneGIS3DTileset}
		 * @readonly
		 */
		data: {
			get: function () {
				return SceneGIS.defined(this._data) ? this._data : undefined;
			},
		},
		/**
		 * 获取parameter 图层名称
		 * @memberof TileSetLayerEX.prototype
		 *
		 * @type {String}
		 * @readonly
		 */
		name: {
			get: function () {
				return SceneGIS.defined(this.option) ? this.option.name : undefined;
			},
		},
		/**
		 * 获取parameter 图层id
		 * @memberof TileSetLayerEX.prototype
		 *
		 * @type {String}
		 * @readonly
		 */
		id: {
			get: function () {
				return SceneGIS.defined(this.option) ? this.option.id : undefined;
			},
		},

	});

	function init$4() {
		var self = this;
		let options = this.option.data ? this.option.data : this.option.models;
		if (!SceneGIS.defined(options.uri) && !SceneGIS.defined(options.url)) {
			throw CoreEX.DeveloperError("uri 或者url is required");
		}
		let t3dtiles = new SceneGIS.SceneGIS3DTileset(options);

		this._data = t3dtiles;

		this.viewer.scene.primitives
			.add(t3dtiles)
			.readyPromise.then(function (tileset) {
				reset(self, self.option);

			});
	}

	function modifyModelMatrix(option, tileset) {
		var position = SceneGIS.Cartesian3.fromDegrees(
			option.lon,
			option.lat,
			option.alt ? option.alt : 0
		);

		var mat = SceneGIS.Transforms.eastNorthUpToFixedFrame(position);
		var rotationX = SceneGIS.Matrix4.fromRotationTranslation(
			SceneGIS.Matrix3.fromRotationX(
				SceneGIS.Math.toRadians(option.xangle ? -option.xangle : 0)
			)
		);

		SceneGIS.Matrix4.multiply(mat, rotationX, mat);
		var rotationY = SceneGIS.Matrix4.fromRotationTranslation(
			SceneGIS.Matrix3.fromRotationY(
				SceneGIS.Math.toRadians(option.yangle ? -option.yangle : 0)
			)
		);
		SceneGIS.Matrix4.multiply(mat, rotationY, mat);

		var rotationZ = SceneGIS.Matrix4.fromRotationTranslation(
			SceneGIS.Matrix3.fromRotationZ(
				SceneGIS.Math.toRadians(option.zangle ? -option.zangle : 0)
			)
		);
		SceneGIS.Matrix4.multiply(mat, rotationZ, mat);

		tileset._root.transform = mat;
	}

	function _changeHeight(height, tileset) {
		height = Number(height);
		if (isNaN(height)) {
			return;
		}
		var cartographic = SceneGIS.Cartographic.fromCartesian(
			tileset.boundingSphere.center
		);
		var surface = SceneGIS.Cartesian3.fromRadians(
			cartographic.longitude,
			cartographic.latitude,
			cartographic.height
		);
		var offset = SceneGIS.Cartesian3.fromRadians(
			cartographic.longitude,
			cartographic.latitude,
			height
		);
		var translation = SceneGIS.Cartesian3.subtract(
			offset,
			surface,
			new SceneGIS.Cartesian3()
		);
		tileset.modelMatrix = SceneGIS.Matrix4.fromTranslation(translation);
		// setTimeout(() => {
		//     var cartographic_T = SceneGIS.Cartographic.fromCartesian(tileset.boundingSphere.center);

		// }, 2000);
	}

	/**
	 * 加载tileset 数据
	 * @param {Object} option 参考构造函数的option
	 */
	TileSetLayerEX.prototype.load = function (option) {
		SceneGIS.Check.defined("option.id", option.id);
		SceneGIS.Check.typeOf.string("option.layerType", option.layerType);

		if (SceneGIS.defined(option.data)) {
			SceneGIS.Check.typeOf.object("option.data", option.data);
		} else if (SceneGIS.defined(option.models)) {
			SceneGIS.Check.typeOf.object("option.models", option.models);
		} else {
			throw new SceneGIS.DeveloperError(
				`图层${option.id}的option.data or option.models is required`
			);
		}

		let options = option.data ? option.data : option.models;
		if (!SceneGIS.defined(options.uri) && !SceneGIS.defined(options.url)) {
			throw CoreEX.DeveloperError("uri 或者url is required");
		}
		let url = options.uri ? options.uri : options.url;

		this._visible = SceneGIS.defaultValue(option.visible, true);
		option.symbol = SceneGIS.defaultValue(option.symbol, {});
		this.option = option;

		if (this._data && _.isEqual(this._url, url)) { //是相同的tileset ，仅仅修改
			reset(this, this.option);
			return;
		}
		this._url = options.uri ? options.uri : options.url;
		if (this._visible) {
			this.destroy();
			init$4.bind(this)();
		}
	};

	/**
	 *  根据id 获取对应feature
	 * @param {String} idField  要素id 字段:
	 * @param {Object} idValue  要素id 字段值
	 * @return {*}
	 */
	TileSetLayerEX.prototype.getFeatureById = function (idField, idValue) {
		this.getById(idField, idValue);
	};

	/**
	 *  根据id 获取对应feature
	 * @param {String} idField  要素id 字段:
	 * @param {Object} idValue  要素id 字段值
	 * @return {*}
	 */
	TileSetLayerEX.prototype.getById = function (idField, idValue) {
		var features = search(this.data, idField, idValue);
		if (features.length > 0) {
			var row_ = {};
			if (features[0].getPropertyNames) {
				var props = features[0].getPropertyNames();
				for (var name_ of props) {
					row_[name_] = features[0].getProperty(name_);
				}
			}
			var feature = undefined;
			//Feature.pack(row_, features[0]);
			return feature;
		}
		return undefined;
	};

	/**
	 *
	 * @param {SceneGIS3DTileset} layer
	 * @param {Number} alpha 透明值
	 */
	TileSetLayerEX.prototype.changeAlpha = function (alpha) {
		//透明度
		this._data.style = new SceneGIS.SceneGIS3DTileStyle({
			color: "rgba(255, 255, 255, " + alpha + ")",
		});
	};

	function search(titleSet, propertyName, propertyValue) {
		var tiles = titleSet._selectedTiles;
		var tilesLength = tiles.length;
		var tile;
		var features = [];
		for (var i = 0; i < tilesLength; i++) {
			tile = tiles[i];
			var tile_content = tile.content;
			if (tile_content) {
				//xuzhou_tile_content._features.length
				var featuresLength = 0;
				if (tile_content.featuresLength) {
					featuresLength = tile_content.featuresLength;
				} else {
					if (tile_content._features) {
						featuresLength = tile_content._features.length;
					}
				}
				for (var j = 0; j < featuresLength; j += 1) {
					var feature;
					if (tile_content.featuresLength) {
						feature = tile_content.getFeature(j); //.color = SceneGIS.Color.fromRandom();
						//console.log();
					} else {
						feature = tile_content._features[j];
					}
					//var name = feature.getProperty('ObjName');
					var groupname = feature.getProperty(propertyName);
					if (propertyValue.indexOf(groupname) < 0) {
						continue;
					}

					features.push(feature);

					console.log("搜索结果：" + propertyValue);
				}
			}
		}

		return features;
	}

	TileSetLayerEX.prototype.update = function (option) {
		this._data.show = option.visible;
		this._visible = option.visible;
	};

	let propertyType = {
		"imageBasedLighting": SceneGIS.ImageBasedLighting,
		"pbrMaterial": SceneGIS.pbrMaterial,
		"style": SceneGIS.SceneGIS3DTileStyle,
		"customShader": SceneGIS.CustomShader
	};


	//更新Symbol的参数
	function reset(tilesetEx, option) {
		let tileset = tilesetEx._data;
		let data_ = option.data ? option.data : option.models;



		//显隐
		tileset.show = tilesetEx._visible;
		let properties = data_;
		for (let property in properties) {
			if (property in tileset) {
				if (propertyType[property]) {
					tileset[property] = new propertyType[property](properties[property]);
				}
				else {
					tileset[property] = properties[property];
				}
			}
		}

		let hpr = SceneGIS.defaultValue(option.symbol.hpr, {});


		let matrix = option.symbol.transform ? option.symbol.transform : data_.tempMatrix;
		if (matrix) {
			tileset._root.transform = SceneGIS.clone(matrix);
		}
		else if (hpr.lon &&
			hpr.lat &&
			hpr.lon != -1 &&
			hpr.lat != -1) {
			modifyModelMatrix(hpr, tileset);
		} else if (option.lon &&
			option.lat &&
			option.lon != -1 &&
			option.lat != -1) {
			modifyModelMatrix(option, tileset);
		}
		else {
			//高度
			let height = option.symbol.mheight ? option.symbol.mheight : option.mheight;
			_changeHeight(height, tileset);
		}
		let effect = option.symbol.effect ? option.symbol.effect : option.symbol;
		if (effect && effect.name) {
			const customShader = CustomShadersEX.createCustomShader(
				effect,
				tileset
			);
			tileset.customShader = customShader;
		}


	}


	/**
	 * 销毁图层
	 * @return {boolean} 销毁成功返回true,否则返回false
	 */
	TileSetLayerEX.prototype.destroy = function () {
		if (this.viewer)
			this.viewer.scene.primitives.remove(this._data);

	};

	/**
	 * LayerType类型
	 *
	 * @enum {String}
	 */
	var LayerType = {
		/**
		 * 瓦片图层
		 * @type {String}
		 */
		tileset: "tileset",

		/**
		 * 多个gltf通过对位置添加
		 * @type {String}
		 */
		glbs: "glbs",

		/**
		 * 模板影像图层
		 * @type {String}
		 */
		urlTemplateImageryProvider: "urlTemplateImageryProvider",

		/**
		 * wmts图层
		 * @type {String}
		 */
		webMapTileServiceImageryProvider: "webMapTileServiceImageryProvider",
		/**
		 * 单个图片图层
		 * @type {String}
		 */
		singleTileImageryProvider: "singleTileImageryProvider",
		/**
		 * arcgis图层
		 * @type {String}
		 */
		arcGisMapServerImageryProvider: "arcGisMapServerImageryProvider",
		/**
		 * bingMap图层
		 * @type {String}
		 */
		bingMapsImageryProvider: "bingMapsImageryProvider",
		/**
		 * openStreetMap图层
		 * @type {String}
		 */
		openStreetMapImageryProvider: "openStreetMapImageryProvider",
		/**
		 * wms图层
		 * @type {String}
		 */
		webMapServiceImageryProvider: "webMapServiceImageryProvider",
		/**
		 * 平面影像
		 * @type {String}
		 */
		cartesianTileImageryProvider: "cartesianTileImageryProvider",

		/**
		 * 平面arcgis影像
		 * @type {String}
		 */
		cartesianArcGisMapServerImageryProvider:
			"cartesianArcGisMapServerImageryProvider",

		/**
		 * scenegis地形图层
		 * @type {String}
		 */
		scenegisTerrainProvider: "scenegisTerrainProvider",

		/**
		 * 超图地形图层
		 * @type {String}
		 */
		superMapTerrainProvider: "superMapTerrainProvider",

		/**
		 * 平面坐标系地形图层，高度为0
		 * @type {String}
		 */
		cartesianTerrainProvider: "cartesianTerrainProvider",
		/**
		 * 平面坐标系地形图层，高度来自文件
		 * @type {String}
		 */
		cartesianCustomTerrainProvider: "cartesianCustomTerrainProvider",
		/**
		 * group 虚拟节点图层
		 * @type {String}
		 */
		group: "group",
		/**
		 * graphic 动态图层，geojson，dataSource，custom等图层都可以使用该图层
		 * @type {String}
		 */
		graphic: "graphic",

		/**
		 * 图表图层，不具备地理位置
		 * @type {String}
		 */
		table: "table",

		/**
		 * 网图层
		 * @type {String}
		 */
		pipe: "pipe",

		/**
		 * i3s
		 * @type {String}
		 */
		pipe: "i3s",

		/**
		 * s3m
		 * @type {String}
		 */
		pipe: "s3m",
		/**
		 * shp
		 * @type {String}
		 */
		shp: "shp",
	};
	var LayerType$1 = Object.freeze(LayerType);

	/**
	 * 地形图层管理类
	 *
	 * @alias TerrainLayerEX
	 * @constructor
	 * @param {Viewer} viewer 三维Viewer 对象
	 * @param {Object} option 图层配置数据
	 * @param {String} option.id 图层id
	 * @param {String} option.name 图层名称
	 * @param {layerType} option.layerType 图层类型,地形有四种类型，球面两种:scenegisTerrainProvider和superMapTerrainProvider。平面两种:cartesianTerrainProvider和cartesianCustomTerrainProvider
	 * @param {String} option.symbol 地形符号化
	 * @param {Number} [option.symbol.exaggerate=1.0] 地形夸张
	 * @param {Number} [option.lodLevel=-1] lod等级,-1时表示不加入lod控制
	 * @param {Boolean} [option.visible=true] 是否可见
	 * @param {Object} [option.camera] 相机定位位置
	 * @param {SceneGISTerrainProvider.constructor} [option.data] 模型参数,请查阅SceneGISTerrainProvider构造函数
	 * @example
	 *let option={
	 *  "id": "scenegisTerrain",
	 *  "name": "scenegisTerrain地形",
	 *  "layerType": "scenegisTerrainProvider",
	 *  "symbol": {
	 *    exaggerate:1.0
	 *  },
	 *  "lodLevel": -1,
	 *  "visible": true,
	 *  "camera": "",
	 *  "data": {
	 *    "enableCache": true,
	 *    "url": "http://10.10.10.19:9000/dem/NJ_DEM_WGS84_1/",
	 *    "requestWaterMask": true,
	 *    "requestVertexNormals": true
	 *  }
	 *}
	 */
	function TerrainLayerEX(viewer, option) {
		CheckEX.instanceOf("viewer", viewer, SceneGIS.Viewer);

		CoreEX.GisBaseLayer.call(this, viewer, option);
		this.load(option);
	}

	TerrainLayerEX.prototype = Object.create(CoreEX.GisBaseLayer.prototype);
	TerrainLayerEX.prototype.constructor = TerrainLayerEX;

	function init$3() {
		var provider = this._provider;
		let terrainLayer = null;
		if (this._visible) {
			switch (provider) {
				case "scenegisTerrainProvider":
					terrainLayer = new SceneGIS.SceneGISTerrainProvider(this._model);
					this.viewer.scene.terrainProvider = terrainLayer;
					this._data = terrainLayer;
					break;

				case "superMapTerrainProvider":
					console.log("this._model:", this._model);
					terrainLayer = new SuperMap3D.SuperMapTerrainProvider(this._model);
					this.viewer.scene.terrainProvider = terrainLayer;
					this._data = terrainLayer;
					break;
				//以下为平面地形
				case "cartesianTerrainProvider":
					terrainLayer = new SceneGIS.CartesianTerrainProvider(this._model);
					this.viewer.scene.terrainProvider = terrainLayer;
					this._data = terrainLayer;
					break;

				case "cartesianCustomTerrainProvider":
					console.log("this._model:", this._model);
					terrainLayer = new SceneGIS.CartesianCustomTerrainProvider(
						this._model
					);
					this.viewer.scene.terrainProvider = terrainLayer;
					this._data = terrainLayer;
					break;
			}
		}
	}

	Object.defineProperties(TerrainLayerEX.prototype, {
		/**
		 * 图层是否打开
		 * @memberof TerrainLayerEX.prototype
		 * @type {Boolean}
		 */
		visible: {
			get: function () {
				if (this._data) {
					return this._visible;
				}
				return false;
			},
			set: function (value) {
				this._visible = value;
				if (!value) {
					this._data = undefined;
					if (this.viewer.scene.planeView) {
						this.viewer.scene.terrainProvider = new SceneGIS.CartesianTerrainProvider();
					}
					else {
						this.viewer.scene.terrainProvider =
							new SceneGIS.EllipsoidTerrainProvider({});
					}

				} else {
					init$3.bind(this)();
				}
			},
		},
		/**
		 * 地形数据
		 * @memberof TerrainLayerEX.prototype
		 * @type {TerrainProvider}
		 * @readonly
		 */
		data: {
			get: function () {
				return this._data;
			},
		},

		/**
		 * 地形夸张
		 * @memberof TerrainLayerEX.prototype
		 * @type {Number}
		 */
		exaggerate: {
			get: function () {
				return this.viewer.scene.globe.terrainExaggeration;
			},
			set: function (value) {
				this.viewer.scene.globe.terrainExaggeration = value;
			},
		},
	});

	TerrainLayerEX.prototype.Exaggerate = function (val) {
		this.viewer.scene.globe.terrainExaggeration = val; //方法保留，兼容以前版本
	};

	/**
	 * 加载要素，增加或者修改
	 * @param {Array|Object} data 对象或者对象数据
	 */
	TerrainLayerEX.prototype.load = function (option) {
		SceneGIS.Check.defined("option.id", option.id);

		if (SceneGIS.defined(option.data)) {
			SceneGIS.Check.typeOf.object("option.data", option.data);
		} else if (SceneGIS.defined(option.models)) {
			SceneGIS.Check.typeOf.object("option.models", option.models);
		} else {
			throw new SceneGIS.DeveloperError(
				`图层${option.id}的 option.data or option.models is required`
			);
		}

		option.symbol = SceneGIS.defaultValue(option.symbol, {});
		let exaggerate = SceneGIS.defaultValue(option.symbol.exaggerate, 1.0);
		this.exaggerate = exaggerate;
		let planeView = this.viewer.scene.planeView;
		//检查支持图层
		CheckEX.SysOf(planeView, option.layerType);
		this._provider = option.layerType;
		this.imgeObject = undefined;
		this._visible = SceneGIS.defaultValue(option.visible, true);
		this._data = undefined;
		this._model = option.data ? option.data : option.models; //兼容之前的版本参数
		this.option = option;
		init$3.bind(this)();
	};

	/**
	 * 销毁图层
	 * @return {boolean} 销毁成功返回true,否则返回false
	 */
	TerrainLayerEX.prototype.destroy = function () {
		this._data = undefined;
		if (this.viewer.scene.planeView) {
			this.viewer.scene.terrainProvider = new SceneGIS.CartesianTerrainProvider();
		}
		else {
			this.viewer.scene.terrainProvider =
				new SceneGIS.EllipsoidTerrainProvider({});
		}
	};

	//路况数据分级
	//[0,2] 畅通  [2,3]轻度拥堵    [3,4]中度拥堵     [4,5]严重拥堵
	// 绿色：00D74D   黄色：FFD200  橙色：FF7309  红色：FF0000
	var level1 = SceneGIS.Color.fromCssColorString("#00D74D");
	var level2 = SceneGIS.Color.fromCssColorString("#FFD200");
	var level3 = SceneGIS.Color.fromCssColorString("#FF7309");
	var level4 = SceneGIS.Color.fromCssColorString("#FF0000");

	/*
		10 高速及其连接线
		20 主干路及其连接线
		30 次干路（一级）及其连接线
		40 次干路（二级）及其连接线  
		50 次干路（三级）及其连接线
		60 支路
		70 社区道路
	*/
	/**
	 * 显示路况
	 */
	class PipeLayerEX extends CoreEX.GisBaseLayer {
		/**
		 *
		 * @param {Object} viewer 地图对象
		 * @param {Object} options
		 * @param {Object} [options.url] 实时路况的地址
		 * @param {Object} [options.materialType='static'] 实时路况的类型  'static' 只显示颜色静态   'flow' 流动
		 */
		constructor(viewer, option) {
			CheckEX.instanceOf("viewer", viewer, SceneGIS.Viewer);
			super(viewer, option);
			let options = option.data || {};
			this._viewer = viewer;
			this._scene = viewer.scene;
			this._camera = viewer.camera;
			this._dataSource = new SceneGIS.CustomDataSource(
				"PipeLayerEX" + SceneGIS.createGuid()
			);
			let _options = options || {};
			this._debugShow = SceneGIS.defaultValue(_options.debugShow, false);
			this._requestBylevel = SceneGIS.defaultValue(
				_options.requestBylevel,
				false
			);
			this._materialType = SceneGIS.defaultValue(_options.materialType, "static"); //'static'  'flow'
			this._url = SceneGIS.defaultValue(_options.url, "");
			this._viewer.dataSources.add(this._dataSource);
			this._dataUrl = SceneGIS.defaultValue(_options.url, "");
			this._camera.changed.addEventListener(this._onchanged.bind(this));
			this._coordTransform = new CoordTransform();
			this._validDataRange = true;
			this._lastType = 0;
			this._debugShowEntity = null;
			this._init = false;
			this._dataSource.show = this._visible;
			this.planeView = viewer.scene.planeView;
			this._onchanged();
		}
		get visible() {
			return this._visible;
		}
		set visible(value) {
			this._visible = value;
			this.show = value;
		}
		get show() {
			return this._show;
		}

		set show(value) {
			if (this._visible == false && value == true) {
				return;
			}
			this._show = value;
			this._dataSource.show = value;
		}
		_getZoom2D() {
			let modeFactor = {
				zoom: 16,
				height: 1571.2485798760013,
			};
			const position = this._camera._positionWC;
			const car = SceneGIS.Cartographic.fromCartesian(position);
			const _height = car.height;
			const zoom = modeFactor.zoom - Math.log2(_height / modeFactor.height);
			return zoom;
		}
		// 根据当前级别个 获取数据来进行数据的更新
		_getData(level, polygon) { }
		_computerRange() {
			const width = this._scene.canvas.width;
			const height = this._scene.canvas.height;
			const lt = new SceneGIS.Cartesian2(0, 0);
			const leftTop = this._camera.pickEllipsoid(lt, SceneGIS.Ellipsoid.WGS84);
			if (!leftTop) {
				this._validDataRange = false;
				return;
			}

			const lb = new SceneGIS.Cartesian2(0, height);
			const leftbottom = this._camera.pickEllipsoid(lb, SceneGIS.Ellipsoid.WGS84);
			if (!leftbottom) {
				this._validDataRange = false;
				return;
			}

			const rt = new SceneGIS.Cartesian2(width, 0);
			const rightTop = this._camera.pickEllipsoid(rt, SceneGIS.Ellipsoid.WGS84);
			if (!rightTop) {
				this._validDataRange = false;
				return;
			}
			const rb = new SceneGIS.Cartesian2(width, height);
			const rightBottom = this._camera.pickEllipsoid(
				rb,
				SceneGIS.Ellipsoid.WGS84
			);
			if (!rightBottom) {
				this._validDataRange = false;
				return;
			}
			const elps = SceneGIS.Ellipsoid.WGS84;
			const LT = elps.cartesianToCartographic(leftTop);
			const LB = elps.cartesianToCartographic(leftbottom);
			const RT = elps.cartesianToCartographic(rightTop);
			const RB = elps.cartesianToCartographic(rightBottom);
			const ltLon = SceneGIS.Math.toDegrees(LT.longitude);
			const ltLat = SceneGIS.Math.toDegrees(LT.latitude);
			const lbLon = SceneGIS.Math.toDegrees(LB.longitude);
			const lbLat = SceneGIS.Math.toDegrees(LB.latitude);
			const rtLon = SceneGIS.Math.toDegrees(RT.longitude);
			const rtLat = SceneGIS.Math.toDegrees(RT.latitude);
			const rbLon = SceneGIS.Math.toDegrees(RB.longitude);
			const rbLat = SceneGIS.Math.toDegrees(RB.latitude);
			this._validDataRange = true;
			return [ltLon, ltLat, rtLon, rtLat, rbLon, rbLat, lbLon, lbLat];
		}
		//  相机改变事件
		_onchanged() {
			let zoom = parseInt(this._getZoom2D());
			let type = 10;
			if (zoom > 8 && zoom <= 12) {
				type = 10;
			} else if (zoom > 12 && zoom <= 13) {
				type = 20;
			} else if (zoom > 13 && zoom <= 15) {
				type = 30;
			} else if (zoom > 15 && zoom <= 16) {
				type = 40;
			} else if (zoom > 16 && zoom <= 17) {
				type = 50;
			} else if (zoom > 17 && zoom <= 18) {
				type = 60;
			} else if (zoom > 18 && zoom <= 19) {
				type = 70;
			} else if (zoom > 19 && zoom <= 20) {
				type = 70;
			}
			if (this._requestBylevel && type > 49) {
				type = 50;
			}
			if (this._lastType === type && this._init) {
				return;
			}
			this._lastType = type;
			let bbox = this._computerRange();
			if (!this._validDataRange) {
				return;
			}
			if (this._debugShow) {
				this._debugShowEntity &&
					this._dataSource.entities.remove(this._debugShowEntity);
				this._dataSource.entities.add({
					polygon: {
						hierarchy: new SceneGIS.PolygonHierarchy(
							SceneGIS.Cartesian3.fromDegreesArray(bbox)
						),
						material: SceneGIS.SceneGIS.Color.fromRandom({
							alpha: 0.6,
						}),
					},
				});
			}
			const self = this;
			if (this._requestBylevel) {
				let optionsCatch = {
					url: this._url + "/" + type + ".json",
					headers: {
						"Content-Type": "application/x-www-form-urlencoded;charset=UTF-8",
					},
				};
				SceneGIS.Resource.fetch(optionsCatch).then(function (jsonData) {
					let dataObj = JSON.parse(jsonData);
					let road_condition = dataObj.data;
					self._drawRoad(road_condition);
				});
			} else {
				// let roadRequestData = `bbox=[114.297558,295829,127.391071,35.661384,120.769068,30.744862,120.7504,30.743792]&type=${type}`;
				let optionsCatch = {
					url: this._url,
					data: "",
					headers: {
						"Content-Type": "application/x-www-form-urlencoded;charset=UTF-8",
					},
				};
				let roadRequestData = `bbox=[${bbox}]&type=${type}`;
				// optionsCatch.data = JSON.stringify(roadRequestData);
				optionsCatch.data = roadRequestData;
				let self = this;
				SceneGIS.Resource.post(optionsCatch).then(function (jsonData) {
					let dataObj = JSON.parse(jsonData);
					let road_condition = dataObj.data;
					self._drawRoad(road_condition);
				});
			}
			this._init = true;
			// console.log(zoom);
		}
		_drawRoad(road_condition) {
			if (road_condition) {
				this._dataSource.entities.removeAll();
				let self = this;
				road_condition.forEach((element) => {
					let linePos = element.line;
					let level = element.index;
					element.type;
					let color = level1;
					if (level > 2.0 && level <= 3.0) {
						color = level2;
					} else if (level > 3.0 && level <= 4.0) {
						color = level3;
					} else if (level > 4.0 && level <= 5.0) {
						color = level4;
					}
					let positions = [];
					let _length = 0;
					linePos.forEach((pos, index) => {
						//   let resultPos = this._coordTransform.gcj02towgs84(pos[0], pos[1]);
						//   let carPos = SceneGIS.Cartesian3.fromDegrees(
						//     SceneGIS.Math.toDegrees(resultPos.longitude),
						//     SceneGIS.Math.toDegrees(resultPos.latitude)
						//   );
						let carPos;
						if (self.planeView === true) {
							carPos = new SceneGIS.Cartesian3(pos[0], pos[1], 0);
						} else {
							carPos = SceneGIS.Cartesian3.fromDegrees(pos[0], pos[1]);
						}
						positions.push(carPos);
						if (index > 0) {
							_length += Math.abs(
								SceneGIS.Cartesian3.distance(
									positions[index],
									positions[index - 1]
								)
							);
						}
					});

					let material = color;
					if (this._materialType === "flow") {
						material = new PolylineFlowTailMaterialProperty({
							image: CoreEX.getAssetUrl("img/lineArrow3.png"),
							duration: _length < 2000 ? 2000 : _length,
							// duration: 2000,
							percent: 0.5,
							color: color.withAlpha(0.5),
						});
					}
					this._dataSource.entities.add({
						polyline: {
							// distanceDisplayCondition: new SceneGIS.DistanceDisplayCondition(0.0, 280000),
							// distanceDisplayCondition: new SceneGIS.DistanceDisplayCondition(0.0, showDistance),
							positions: positions,
							width: 6,

							clampToGround: true,
							material: material,
							show: true,
						},
					});
				});
			}
		}
		/**
		 * 销毁
		 * @returns SceneGIS.destroyObject(this)
		 */
		destroy() {
			this._camera.changed.removeEventListener(this._onchanged.bind(this));
			this._dataSource.entities.removeAll();
			this._viewer.dataSources.remove(this._dataSource);
			return SceneGIS.destroyObject(this);
		}
	}

	/** S3M 图层类
	 * @alias S3MLayerEX
	 * @constructor
	 * @param {Viewer} viewer
	 * @param {String} option.id 图层id
	 * @param {SceneGIS.SceneGIS3DTileset.constructor} option.data 图层配置数据
	 * @param {Boolean} option.visible 图层显隐
	 * @param {Object} option.camera 图层相机配置
	 * @param {Number} [option.lodLevel=-1] lod等级,-1时表示不加入lod控制
	 * @param {String} option.symbol tileset titleset的位置和样式
	 * @param {String} option.symbol.transform tileset 变换矩阵 优先级最高
	 * @param {String} option.symbol.hpr tileset 位置和旋转值 优先级次高
	 * @param {String} option.symbol.mheight tileset 调整高度 优先级最低
	 * @param {TileSetEffectType} option.symbol.effect tileset 预置特效，主要为修改名字
	 */
	function S3MLayerEX(viewer, option) {
		CheckEX.instanceOf("viewer", viewer, SceneGIS.Viewer);
		CoreEX.GisBaseLayer.call(this, viewer, option);
		this._data = undefined;
		this._url = undefined;
		this.load(option);
	}

	S3MLayerEX.prototype = Object.create(CoreEX.GisBaseLayer.prototype);
	S3MLayerEX.prototype.constructor = S3MLayerEX;

	Object.defineProperties(S3MLayerEX.prototype, {
		/**
		 * 图层是否打开
		 * @memberof S3MLayerEX.prototype
		 * @type {Boolean}
		 */
		visible: {
			get: function () {
				if (this.data) {
					return this._visible;
				}
				return false;
			},
			set: function (value) {
				this._visible = value;
				this.show = value;

			},
		},
		/**
		 * 图层是否显示
		 * @memberof S3MLayerEX.prototype
		 * @type {Boolean}
		 */
		show: {
			get: function () {
				if (this.data) {
					return this.data.show;
				}
				return false;
			},
			set: function (value) {
				if (this._visible == false && value == true) {
					return;
				}
				if (this.data) {
					if (value) {
						this.data.visibleDistanceMax = Infinity;
					}
					else {
						this.data.visibleDistanceMax = 0;
					}

					//this.data.show = value;
				} else {
					if (value) {
						init$2.bind(this)();//表示首次根本不加载任何数据
					}
				}
			},
		},
		/**
		 * 图层数据
		 * @memberof S3MLayerEX.prototype
		 * @type {SceneGIS3DTileset}
		 * @readonly
		 */
		data: {
			get: function () {
				return SceneGIS.defined(this._data) ? this._data : undefined;
			},
		},
		/**
		 * 获取parameter 图层名称
		 * @memberof S3MLayerEX.prototype
		 *
		 * @type {String}
		 * @readonly
		 */
		name: {
			get: function () {
				return SceneGIS.defined(this.option) ? this.option.name : undefined;
			},
		},
		/**
		 * 获取parameter 图层id
		 * @memberof S3MLayerEX.prototype
		 *
		 * @type {String}
		 * @readonly
		 */
		id: {
			get: function () {
				return SceneGIS.defined(this.option) ? this.option.id : undefined;
			},
		},

	});

	function init$2() {
		let options = this.option.data ? this.option.data : this.option.models;
		if (!SceneGIS.defined(options.uri) && !SceneGIS.defined(options.url)) {
			throw CoreEX.DeveloperError("uri 或者url is required");
		}
		let scene = this.viewer.scene;
		let optionsnew = {
			context: scene._context,
			...options
		};


		let t3dtiles = new SceneGIS.S3MTilesLayer(optionsnew);
		//url: './data/CBD/cbd.scp'//

		this._data = t3dtiles;

		this.viewer.scene.primitives
			.add(t3dtiles)
			.readyPromise.then(function (tileset) {

			});
	}


	/**
	 * 加载tileset 数据
	 * @param {Object} option 参考构造函数的option
	 */
	S3MLayerEX.prototype.load = function (option) {
		SceneGIS.Check.defined("option.id", option.id);
		SceneGIS.Check.typeOf.string("option.layerType", option.layerType);

		if (SceneGIS.defined(option.data)) {
			SceneGIS.Check.typeOf.object("option.data", option.data);
		} else if (SceneGIS.defined(option.models)) {
			SceneGIS.Check.typeOf.object("option.models", option.models);
		} else {
			throw new SceneGIS.DeveloperError(
				`图层${option.id}的option.data or option.models is required`
			);
		}

		let options = option.data ? option.data : option.models;
		if (!SceneGIS.defined(options.uri) && !SceneGIS.defined(options.url)) {
			throw CoreEX.DeveloperError("uri 或者url is required");
		}
		let url = options.uri ? options.uri : options.url;

		this._visible = SceneGIS.defaultValue(option.visible, true);
		option.symbol = SceneGIS.defaultValue(option.symbol, {});
		this.option = option;

		if (this._data && _.isEqual(this._url, url));
		this._url = options.uri ? options.uri : options.url;
		if (this._visible) {
			this.destroy();
			init$2.bind(this)();
		}
	};

	/**
	 *  根据id 获取对应feature
	 * @param {String} idField  要素id 字段:
	 * @param {Object} idValue  要素id 字段值
	 * @return {*}
	 */
	S3MLayerEX.prototype.getFeatureById = function (idField, idValue) {

	};

	/**
	 *  根据id 获取对应feature
	 * @param {String} idField  要素id 字段:
	 * @param {Object} idValue  要素id 字段值
	 * @return {*}
	 */
	S3MLayerEX.prototype.getById = function (idField, idValue) {

		return undefined;
	};


	/**
	 * 销毁图层
	 * @return {boolean} 销毁成功返回true,否则返回false
	 */
	S3MLayerEX.prototype.destroy = function () {
		if (this.viewer)
			this.viewer.scene.primitives.remove(this._data);

	};

	/** ShpLayerEX 图层
	 * @alias ShpLayerEX
	 * @constructor
	 * @param {Viewer} viewer  ScenGIS的Viewer 对象
	 * @param {Object} geojson  geojson数据
	 * @param {Object} option  配置参数
	 */
	function ShpLayerEX(viewer, option = {}) {
		CheckEX.instanceOf("viewer", viewer, SceneGIS.Viewer);
		this._viewer = viewer;
		this._visible = true;
		this._show = true;
		this.option = option;

		this._data = null;
		this._features = new CoreEX.Dictionary(); //这个是所有属性
		this._featureReadyPromise = undefined;
		this._cmd = undefined;

		//高亮
		this.highFeature = undefined;
		this.preM = undefined;

		shp(option.data.url).then(geo => {
			this._geojson = geo;
			this.load(geo, option);
		})
			.catch(error => {
				// 处理读取失败的情况
				console.error(error);
			});

	}

	Object.defineProperties(ShpLayerEX.prototype, {
		/**
		 * 图层是否打开
		 * @memberof ShpLayerEX.prototype
		 * @type {Boolean}
		 */
		visible: {
			get: function () {
				return this._visible;
			},
			set: function (value) {
				this._visible = value;
				this.show = value;
			},
		},
		/**
		 * 图层是否显示
		 * @memberof ShpLayerEX.prototype
		 * @type {Boolean}
		 */
		show: {
			get: function () {
				return this._show;
			},
			set: function (value) {
				if (this._visible == false && value == true) {
					return;
				}
				//在visible为 false 时不起作用
				this._show = value;
				if (!this._data) {
					//mapCharts 对象,热力图等对象需要删除，重建
					if (value) {
						this.option.visible = value;
						this.load(this._geojson, this.option);
					}
					else {
						this.destroy();
					}
				} else {
					this._data.show = value;

				}
			},
		},
		/**
		 * 获取promise 对象
		 *
		 * @memberof ShpLayerEX.prototype
		 *
		 * @type {Promise}
		 * @readonly
		 *
		 * @default undefined
		 */
		featureReadyPromise: {
			get: function () {
				return SceneGIS.defined(this._featureReadyPromise)
					? this._featureReadyPromise
					: undefined;
			},
		},

		/**
		 * 要素数据
		 *
		 * @memberof ShpLayerEX.prototype
		 * @type {CoreEX.Dictionary}
		 * @readonly
		 */

		features: {
			get: function () {
				return SceneGIS.defined(this._features) ? this._features : undefined;
			},
		},
		/**
		 * 获取viewer
		 * @memberof ShpLayerEX.prototype
		 *
		 * @type {viewer}
		 * @readonly
		 */
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			},
		},
	});

	//创建具体要素
	function createOrUpdateFeatures(customEx, geojson, option) {
		var featureCollection = geojson;
		//平面坐标系需要加坐标信息
		if (customEx.viewer.scene.planeView === true) {
			featureCollection.crs = {
				type: "name",
				properties: {
					name: "nanjing:08"
				}
			};
		}
		var symbol = option.symbol;
		let rule = option.symbol.rule;
		var dataSourcePromise = null;

		dataSourcePromise = SceneGIS.GeoJsonDataSource.load(featureCollection, {
			clampToGround: true,
			planeView: customEx.viewer.scene.planeView
		});
		customEx.viewer.dataSources.add(dataSourcePromise);
		return dataSourcePromise.then((source) => {
			if (!source) return new CoreEX.Dictionary();
			customEx._data = source;
			customEx._data.show = customEx._visible;
			customEx._features.removeAll();
			let index_ = 0;
			source.entities.values.forEach((entity) => {
				//在这里实现渲染
				//id 很重要决定了能不能正确找到要素。
				let id_ = entity.properties.id ? entity.properties.id._value : entity.id;
				customEx._features.add(id_, entity);
				// entity.polygon.heightReference=SceneGIS.HeightReference.CLAMP_TO_GROUND
				// entity.polygon.perPositionHeight=false;
				//SceneGIS.Color.fromCssColorString(color[index++]);
				if (rule && !symbol.geojson) {
					//执行渲染规则
					let fun = new Function("node", "index", rule);
					fun(entity, index_);
				}
				index_++;
			});
			return customEx._features;
		});
	}

	/**
	 * 加载geojson数据，或者其他转换过来的额geojson数据，不支持增量更新
	 * @param {Object} geojson geojosn数据
	 * @param {Object} option 配置参数
	 */
	ShpLayerEX.prototype.load = function (geojson, option) {
		if (!SceneGIS.defined(geojson)) return;
		//清除，重新创建，不支持增量更新呢
		this.destroy();

		option.id = SceneGIS.defaultValue(option.id, SceneGIS.createGuid()); //内置图层id 不受约束。

		this.option = SceneGIS.defaultValue(option, {});
		this._visible = SceneGIS.defaultValue(option.visible, true);

		if (!this._visible) {
			return;
		}

		option.symbol = SceneGIS.defaultValue(option.symbol, {});

		if (option.symbol && option.symbol.geojson) {
			//具备特有的符号化对象
			this.autoRadiusConfig = option.symbol.geojson.autoRadiusConfig;
		}
		this._featureReadyPromise = createOrUpdateFeatures(this, geojson, option);

	};

	/**
	 *  图层销毁
	 * @return {*}
	 */
	ShpLayerEX.prototype.destroy = function () {
		var self = this;
		if (this._featureReadyPromise) {
			/**destroy 要保证数据销毁，这里如果不删掉，频繁加载可能会导致内存假泄露。
			 * 一旦假泄露，在Ex图层级别将删除不掉了，使用dataSource 删除将会很难定位数据集。
			 */
			this._featureReadyPromise.then((ds) => {
				self.viewer.dataSources.remove(self._data);
				//self._data.detroy();
			});
		}
		if (this._cmd) {
			this._cmd.remove();
			this._cmd = undefined;
		}
	};

	//更新，内部调用
	ShpLayerEX.prototype.update = function () { };

	ShpLayerEX.prototype.reset = function (option) {
		throw new CoreEX.DeveloperError("不在支持重置");
	};

	/**单个对象添加
	 * @param {Object} data 对象或者对象数据
	 */
	ShpLayerEX.prototype.add = function (option) {
		throw new CoreEX.DeveloperError("不在支持单个对象添加");
	};

	/**
	 * 根据id获取要素
	 * @param {String} id 要素id
	 * @return {CustomEntity|SceneGIS.Entity} 要素
	 */
	ShpLayerEX.prototype.getById = function (id) {
		if (this._cmd) {
			throw new CoreEX.DeveloperError("不在支持对象获取");
		}
		var feature = this._features.get(id);
		return feature;
	};

	/**
	 * 根据id删除要素
	 * @param {String} id 要素id
	 * @return {Boolean} 删除成功返回true,否则返回false
	 */
	ShpLayerEX.prototype.removeById = function (id) {
		if (this._cmd) {
			throw new CoreEX.DeveloperError("不在支持对象删除");
		}
		if (this._data) {
			this._data.entities.removeById(id);
			return this._features.remove(id);
		}
		return false;
	};

	/**
	 * 定位要素
	 * @param {String} id 要素id
	 * @param {Object} option  定位参数
	 * @param {SceneGIS.HeadingPitchRange} option.offset  定位偏移量，默认new SceneGIS.HeadingPitchRange(5, -0.785, 5)
	 * @param {Number} option.maximumHeight  定位最大高度，默认是0
	 */
	ShpLayerEX.prototype.zoomById = function (id, option = {}) {
		if (this._cmd) {
			throw new CoreEX.DeveloperError("不在支持对象定位");
		}
		var feature = this.getById(id);
		if (this._data) {
			this.viewer.flyTo(feature);
		}
	};

	/**
	 * 高亮要素
	 * @param {String} id 要素id
	 * @param {option} option 高亮参数
	 * @param {SceneGIS.Color} [option.color=SceneGIS.Color.RED]  颜色,默认红色
	 */
	ShpLayerEX.prototype.highLightById = function (
		id,
		option = { color: SceneGIS.Color.RED }
	) {
		if (this._cmd) {
			throw new CoreEX.DeveloperError("不在支持对象高亮");
		}
		var feature = this.getById(id);
		if (this._data) {
			if (this.highFeature) {
				//清除原来的高亮
				if (feature[name].color) {
					feature[name].color = this.preM;
				}
				if (feature[name].material) {
					feature[name].material = this.preM;
				}
			}
			feature._propertyNames.forEach((name) => {
				if (feature[name].color) {
					this.preM = feature[name].color;
					feature[name].color = option.color;
				}
				if (feature[name].material) {
					this.preM = feature[name].material;
					feature[name].material = option.color;
				}
				this.highFeature = feature;
			});
		}
	};

	/**
	 * 定位并高亮要素
	 * @param {String} id 要素id
	 * @param {option} option 高亮参数
	 * @param {SceneGIS.Color} [option.color=SceneGIS.Color.RED]  颜色,默认红色
	 * @param {SceneGIS.HeadingPitchRange} option.offset  定位偏移量，默认new SceneGIS.HeadingPitchRange(5, -0.785, 5)
	 * @param {Number} option.maximumHeight  定位最大高度，默认是0
	 */
	ShpLayerEX.prototype.zoomAndHLById = function (
		id,
		option = { color: SceneGIS.Color.RED }
	) {
		this.highLightById(id, option);
		this.zoomById(id, option);
	};

	/**
	 * 删除所有对象
	 * @return {boolean} 销毁成功返回true,否则返回false
	 */
	ShpLayerEX.prototype.removeAll = function () {
		if (this._cmd) {
			throw new CoreEX.DeveloperError("不在支持对象删除，请调用destroy");
		}
		if (this._data) {
			this._ds.entities.removeAll();
			this._features.removeAll();
			return true;
		}
		return false;
	};

	//图层工厂
	var GisLayerFactoryEX = {
		tileset: function (viewer, option) {
			return new TileSetLayerEX(viewer, option);
		},
		glb: function (viewer, option) {
			option.layerType = "graphic";
			console.log("已经不在支持glb图层类型,用graphic代替");
			return new GraphicLayerEX(viewer, option);
			//throw new CoreEX.DeveloperError("已经不在支持glb图层类型,用graphic代替");
			//return new SceneGisGlbLayer(viewer, option);
		},
		glbs: function (viewer, option) {
			return new GlbsLayerEX(viewer, option);
		},
		graphic: function (viewer, option) {
			return new GraphicLayerEX(viewer, option);
		},
		geojson: function (viewer, option) {
			option.layerType = "graphic";
			console.log("已经不在支持geojson图层类型,用graphic代替");
			//throw new CoreEX.DeveloperError("已经不在支持geojson图层类型,用graphic代替");
			return new GraphicLayerEX(viewer, option);
		},
		group: function (viewer, option) {
			return new CoreEX.GisBaseLayer(viewer, option);
		},

		urlTemplateImageryProvider: function (viewer, option) {
			return new ImageryLayerEX(viewer, option);
		},
		webMapTileServiceImageryProvider: function (viewer, option) {
			return new ImageryLayerEX(viewer, option);
		},
		singleTileImageryProvider: function (viewer, option) {
			return new ImageryLayerEX(viewer, option);
		},
		arcGisMapServerImageryProvider: function (viewer, option) {
			return new ImageryLayerEX(viewer, option);
		},
		bingMapsImageryProvider: function (viewer, option) {
			return new ImageryLayerEX(viewer, option);
		},
		openStreetMapImageryProvider: function (viewer, option) {
			return new ImageryLayerEX(viewer, option);
		},
		webMapServiceImageryProvider: function (viewer, option) {
			return new ImageryLayerEX(viewer, option);
		},

		dataSource: function (viewer, option) {
			option.layerType = "graphic";
			console.log("已经不在支持dataSource图层类型,用graphic代替");
			return new GraphicLayerEX(viewer, option);
			//throw new CoreEX.DeveloperError("已经不在支持dataSource图层类型,用graphic代替");
			//return new SceneGisDataSourceLayer(viewer, option);
		},

		custom: function (viewer, option) {
			option.layerType = "graphic";
			console.log("已经不在支持custom图层类型,用graphic代替");
			return new GraphicLayerEX(viewer, option);
			//throw new CoreEX.DeveloperError("已经不在支持custom图层类型,用graphic代替");
			//return new SceneGisCustomLayer(viewer, option);
		},
		table: function (viewer, option) {
			throw new CoreEX.DeveloperError("带扩展table图层类型");
			//return new SceneGisTableLayer(viewer, option);
		},
		scenegisTerrainProvider: function (viewer, option) {
			return new TerrainLayerEX(viewer, option);
		},
		superMapTerrainProvider: function (viewer, option) {
			return new TerrainLayerEX(viewer, option);
		},
		pipe: function (viewer, option) {
			return new PipeLayerEX(viewer, option);
		},
		cartesianCustomTerrainProvider: function (viewer, option) {
			return new TerrainLayerEX(viewer, option);
		},
		cartesianTerrainProvider: function (viewer, option) {
			return new TerrainLayerEX(viewer, option);
		},
		cartesianTileImageryProvider: function (viewer, option) {
			return new ImageryLayerEX(viewer, option);
		},
		cartesianArcGisMapServerImageryProvider: function (viewer, option) {
			return new ImageryLayerEX(viewer, option);
		},
		i3s: function (viewer, option) {
			return new I3SLayerEX(viewer, option)
		},
		s3m: function (viewer, option) {
			return new S3MLayerEX(viewer, option)
		},
		shp: function (viewer, option) {
			return new ShpLayerEX(viewer, option)
		}
	};

	/** 
	* 高级功能，编辑类。动态修改数据，编辑器的前身
	* @class EditorEX
	*/
	class EditorEX {

	}

	let tools = new CoreEX.Dictionary(); //内部工具
	/** 
	* 交互类，交互操作的入口，比如点，线，面的标绘。
	* @class InteractiveEX
	*/
	class InteractiveEX {
		constructor() {

		}
		/**
		 * 
		 * @param {Object} options 配置参数
		 * @param {InteractiveType} options.type 交互类型
		 * @param {Viewer} viewer 
		 * @returns {InteractiveEX} 交互对象
		 */
		static init(options, viewer) {
			let type = options.type;
			let tool = tools.get(type);
			if (tool) {//不允许创建多个工具
				if (tool.clear) {
					tool.clear();
				}
				if (tool.destroy) {
					tool.destroy();
				}
				tools.remove(type);
			}
			switch (type) {
				case "IconPlotEX":
					tool = new IconPlotEX(options, viewer);

					break;
				case "LinePlotEX":
					tool = new LinePlotEX(options, viewer);

					break;
				case "PolyGonPlotEX":
					tool = new PolyGonPlotEX(options, viewer);

					break;
				case "PointPlotEX":
					tool = new PointPlotEX(options, viewer);

					break;
				case "WordPlotEX":
					tool = new WordPlot(options, viewer);

					break;
				case "MilitaryPlotEX":
					tool = new MilitaryPlotEX(options, viewer);

					break;
				default:
					throw new SceneGIS.DeveloperError("交互类型不支持");
			}
			tools.add(type, tool);
			return tool;
		}
		/**
		 * 
		 * @param {InteractiveType} type 交互类型
		 * @returns {InteractiveEX} 交互对象
		 */
		static get(type) {
			return tools.get(type);
		}

	}

	function SceneEX(domId, url = {}, ui = undefined) {
		if (!SceneGIS.defined(domId)) {
			throw CoreEX.DeveloperError("domId is not defined");
		}
		//老版本的错误提示
		if (ui && ui.indexOf && ui.indexOf(".json") > -1) {
			throw CoreEX.DeveloperError(
				"SceneEX 类调整了参数顺序，第二个参数为url参数"
			);
		}
		//#region  private 私有成员
		this._viewer = undefined;
		this._url = undefined;
		this._root = undefined;
		this._scenejson = undefined;
		this._dynamicLayer = []; //动态临时图层
		this._ui = ui;
		this._lod = undefined;
		this._domId = domId;
		this._customEntities = undefined;
		this._baseImageLayer = undefined;

		this._layerList = new CoreEX.Dictionary();

		var self = this;
		VueDialogEX["vue"] = ui;
		//#endregion
		this.load(url);
		//lod 更新机制
		this._preUpdate = function () {
			if (!self.lod) {
				return;
			}
			//
			let scene = self._viewer.scene;
			var dis = 0;

			//球面坐标系
			if (!scene.planeView) {
				var cartographic = SceneGIS.Cartographic.fromCartesian(
					self._viewer.camera.positionWC
				);
				// 将弧度转为度的十进制度表示
				SceneGIS.Math.toDegrees(cartographic.longitude);
				SceneGIS.Math.toDegrees(cartographic.latitude);
				var height = cartographic.height;
				dis = height;
			} else {
				//平面坐标系的高度
				dis = self._viewer.camera.positionWC.z;
			}

			self.lod.update(dis);
		};
	}

	//创建viewer
	function createViewer(sceneEx, options) {
		let optionO = options;
		//平面坐标系的判断，平面坐标系的判断很可能在scenejson场景文件中。
		let viewer;
		let option;
		if (optionO.planeView) {
			SceneGIS.CartesianTilingScheme.define({
				west: -20037549.4, //x
				//south: -19992606.18, //y
				south: -20037549.015772111872,
				//east: 19992604.6, //x
				east: 20037547.435772111872,
				north: 20037547.82, //y
			});

			optionO.terrainProvider = new SceneGIS.CartesianTerrainProvider();//默认不添加地形
			optionO.imageryProvider = new SceneGIS.CartesianTileImageryProvider({
				tilingScheme: new SceneGIS.CartesianTilingScheme(),
				credit: "",
				url: "",
				format: "png",
			});
			option = {
				"name": "cartesianTileImageryProvider",
				"layerType": "cartesianTileImageryProvider",
				"lodLevel": -1,
				"visible": true,
				"camera": "",
				"data": {
					url: 'http://10.10.10.40/server/image/NJ08N/',
					format: 'png'
				},
				"id": "_baseImageLayer_"
			};
		} else {
			optionO.imageryProvider = new SceneGIS.UrlTemplateImageryProvider({
				url: "",
				maximumLevel: 18,
				subdomains: ["t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7"],
				layer: "cia_w",
				style: "default",
				format: "tiles",
				imageBasedLighting: { luminanceAtZenith: 0.8 },
			});

			option = {
				name: "天地图影像",
				layerType: "urlTemplateImageryProvider",
				symbol: {},
				lodLevel: -1,
				visible: true,
				camera: {},
				data: {
					url: "https://{s}.tianditu.gov.cn/DataServer?T=img_w&x={x}&y={y}&l={z}&tk=3be1f8f76d1bb298e931e05db7a8b315",
					maximumLevel: 18,
					subdomains: ["t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7"],
					layer: "cia_w",
					style: "default",
					format: "tiles",
					imageBasedLighting: {
						luminanceAtZenith: 0.8,
					},
				},
				id: "_baseImageLayer_",
			};
		}
		viewer = new SceneGIS.Viewer(sceneEx._domId, optionO);
		if (optionO.planeView) {
			viewer.scene.skyAtmosphere.show = false;
			viewer.scene.globe.maximumScreenSpaceError = 0.002;
		}
		if (option) {
			sceneEx._baseImageLayer = new ImageryLayerEX(viewer, option);
		}
		viewer.scene.globe.depthTestAgainstTerrain = true;
		viewer._czmlDataSource = new SceneGIS.CzmlDataSource("_czmlDataSource_");
		viewer.dataSources.add(viewer._czmlDataSource);

		sceneEx._customEntities = new CustomEntityCollection(viewer);
		viewer._cesiumWidget._creditContainer.style.display = "none";
		const scene = viewer.scene;
		scene.postProcessStages.taa.enabled = true;
		scene._taaProcessStage._brightDiff = 20;
		scene._taaProcessStage._depthDiff = 20;
		scene._taaProcessStage.disableCameraStatic = true;
		sceneEx._viewer = viewer;
		// renderWatermark(viewer);
	}

	//删除viewer
	function destroy(sceneEx) {
		var scene = sceneEx._viewer.scene;
		// 
		sceneEx._viewer.destroy();
		scene.destroy();

		var dom = document.getElementById(sceneEx._domId);
		dom.innerHTML = "";
		//document.body.removeChild(dom);
	}

	function init$1(root) {
		var rootLayer = new CoreEX.GisBaseLayer(this.viewer, root);
		//var dataSetPropName=rootLayer._propertyNames;
		this._root = rootLayer;
		var stack = [];
		stack.push(rootLayer);
		while (stack.length > 0) {
			var layer = stack.pop();
			var children = layer.option.children;
			if (SceneGIS.defined(children)) {
				//广度优先遍历建立节点关系
				var length = children.length;
				for (var i = 0; i < length; ++i) {
					var child = children[i];
					var childlayer = this.addLayer(child, layer);
					stack.push(childlayer);
				}
			}
		}
		//#region 场景根节点定位，后面单独拿出去
		this.home();
		//#endregion

		//启动lod
		this._viewer.scene.preUpdate.addEventListener(this._preUpdate);

		//事件弹窗，只针对CustomEntity 对象
		let handerEvent = new SceneGIS.ScreenSpaceEventHandler(this._viewer.scene.canvas);
		handerEvent.setInputAction((movement) => {
			var pickedObject = this._viewer.scene.pick(movement.position);
			try {
				if (SceneGIS.defined(pickedObject)) {
					var picFea;
					if (pickedObject.id && pickedObject.id instanceof SceneGIS.Entity) {
						picFea = pickedObject.id;
					}
					else if (pickedObject.primitive) {
						picFea = pickedObject.primitive;
					}

					if (SceneGIS.defined(picFea)) {
						let owner = picFea.owner;
						if (owner instanceof CustomEntity) {
							owner._createPopup();
						}
					}
				}
			} catch (error) {

			}

		}, SceneGIS.ScreenSpaceEventType.LEFT_CLICK);
	}

	Object.defineProperties(SceneEX.prototype, {
		/**
		 * 获取promise 对象
		 *
		 * @memberof SceneEX.prototype
		 *
		 * @type {Promise}
		 * @readonly
		 *
		 * @default undefined
		 */
		readyPromise: {
			get: function () {
				return SceneGIS.defined(this._readyPromise)
					? this._readyPromise
					: undefined;
			},
		},
		/**
		 * 获取 三维 viewer
		 *
		 * @memberof SceneEX.prototype
		 *
		 * @type {Viewer}
		 * @readonly
		 *
		 * @default undefined
		 */
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			},
		},
		/**
		 * 获取动态临时图层
		 *
		 * @memberof SceneEX.prototype
		 *
		 * @type {Array<LayerEX>}
		 * @readonly
		 *
		 * @default []
		 */
		dynamicLayer: {
			get: function () {
				return SceneGIS.defined(this._dynamicLayer) ? this._dynamicLayer : [];
			},
		},
		/**
		 * 获取根图层
		 *
		 * @memberof SceneEX.prototype
		 *
		 * @type {Array<LayerEX>}
		 * @readonly
		 *
		 * @default []
		 */
		rootLayer: {
			get: function () {
				return SceneGIS.defined(this._root) ? this._root : undefined;
			},
		},
		/**
		 * lod,重新设置时，暂时必须时lod 对象
		 * @memberof SceneEX.prototype
		 * @type {CoreEx.GisLod}
		 */
		lod: {
			get: function () {
				return SceneGIS.defined(this._lod) ? this._lod : undefined;
			},
			set: function (value) {
				this._lod = value;
			},
		},

		/**
		 * SceneGIS扩展对象
		 * @memberof SceneEX.prototype
		 * @type {CustomEntityCollection}
		 * @readonly
		 */
		customEntities: {
			get: function () {
				return SceneGIS.defined(this._customEntities)
					? this._customEntities
					: undefined;
			},
		},

		/**
		 * SceneGIS 内置对象
		 * @memberof SceneEX.prototype
		 * @type {SceneGIS.EntityCollection}
		 * @readonly
		 */
		entities: {
			get: function () {
				return this._viewer.entities;
			},
		},
	});

	/**
	 * 加载场景文件
	 * @param {String|object} url 场景参数,url或json对象
	 * @example
	 *  var _sceneEx=new SceneEX("app");
	 * _sceneEx.load("./scene.json");
	 * let opt=
	 * {
	 *      "id":"SceneGIS3.0",
	 *      "name": "测试场景",
	 *      "lodUrl": basicSet.lodUrl || undefined,
	 *      "sun": {},
	 *      "moon": {},
	 *      "skyAtmosphere": {},
	 *      "skyBox": {},
	 *      "children": [{
	 *        "id": "root",
	 *        "name": "场景根节点",
	 *        "camera": {
	 *        },
	 *        "children": []
	 *      }]
	 *  }
	 * _sceneEx.load(opt);
	 */
	SceneEX.prototype.load = function (url = {}) {
		this.destroy(); //每次load前必须先销毁
		var self = this;
		//#region 参数设定和赋值
		let optionO = {
			contextOptions: {
				requestWebgl2: true,
			},
			showRenderLoopErrors: false,
			shouldAnimate: true,
			animation: false, // 是否创建动画小器件，左下角仪表
			baseLayerPicker: false, // 是否显示图层选择器
			fullscreenButton: false, // 是否显示全屏按钮
			geocoder: false, // 是否显示geocoder小器件，右上角查询按钮
			homeButton: false, // 是否显示Home按钮
			infoBox: false, // 是否显示信息框
			sceneModePicker: false, // 是否显示3D/2D选择器
			selectionIndicator: false, // 是否显示选取指示器组件
			timeline: false, // 是否显示时间轴
			navigationHelpButton: false, // 是否显示右上角的帮助按钮
			//terrainProvider: new SceneGIS.EllipsoidTerrainProvider(),
			//imageryProvider:new SceneGIS.UrlTemplateImageryProvider({"index":2,"url":"https://{s}.tianditu.gov.cn/DataServer?T=img_w&x={x}&y={y}&l={z}&tk=3be1f8f76d1bb298e931e05db7a8b315","maximumLevel":18,"subdomains":["t0","t1","t2","t3","t4","t5","t6","t7"],"layer":"cia_w","style":"default","format":"tiles","imageBasedLighting":{"luminanceAtZenith":0.8}})
		};
		//#endregion

		if (url instanceof String || typeof url == "string") {
			//是url 地址
			this._url = url;

			this._readyPromise = CoreEX.urlResolve(url, { method: "get" }).then(
				(data) => {
					var lod = undefined;
					data.id = SceneGIS.defaultValue(data.id, "SceneGIS2.0"); //默认是2.0版本，向下兼容
					let rootLayer_ = checkScene(data);

					//继续复制
					//Object.assign(optionO, data.viewerOption);
					this._scenejson = data;
					Object.assign(optionO, data.viewerOption);
					createViewer(this, optionO);
					//用最终的optionO创建viewer
					// let baseLayer = SceneGIS.defaultValue(
					//   data.viewerOption.baseLayer,
					//   true
					// );
					// if (baseLayer == false) {
					//   this._baseImageLayer.visible = false;
					// }

					// if (data.viewerOption) {
					//   for (let key in data.viewerOption) {
					//     if (this._viewer[key]) {
					//       try {
					//         this._viewer[key] = data.viewerOption[key];
					//       } catch (e) {
					//         throw e;
					//       } finally {
					//         this.destroy();
					//       }
					//     }
					//   }
					// }

					if (data.lodUrl) {
						lod = new CoreEX.GisLod(this, { url: data.lodUrl });
						this._lod = lod;
						return lod._readyPromise.then((lod1) => {
							init$1.bind(self)(rootLayer_, lod1);
							return self;
						});
					} else {
						init$1.bind(self)(rootLayer_);
						return self;
					}
				}
			);
		} else {
			//url 约束场景文件
			let sceneid = (url.id = SceneGIS.defaultValue(url.id, "SceneGIS3.0")); //默认3.0版本,保持最新
			if (sceneid == "SceneGIS2.0") {
				if (!SceneGIS.defined(url.layer)) {
					let url_ = {
						id: "SceneGIS2.0",
						name: "测试场景",
						layer: {
							id: "root",
							name: "场景根节点",
							camera: {},
							children: [],
						},
					};
					Object.assign(url_, url);
					this._url = url_;
				} else {
					this._url = url;
				}
			} else if (sceneid == "SceneGIS3.0") {
				if (!SceneGIS.defined(url.children)) {
					let url_ = {
						id: "SceneGIS3.0",
						name: "测试场景",
						children: [
							{
								id: "root",
								name: "场景根节点",
								camera: {},
								children: [],
							},
							{
								id: "setSceneEx",
								name: "设置根节点",
								children: [],
							},
						],
					};
					Object.assign(url_, url);
					this._url = url_;
				} else {
					this._url = url;
				}
			}
			let rootLayer_ = checkScene(this._url);
			var data = self._url;
			//继续复制
			Object.assign(optionO, data.viewerOption);
			this._scenejson = data;
			//用最终的optionO创建viewer
			createViewer(this, optionO);

			var lod = undefined;
			this._readyPromise = new Promise((resolve) => {
				if (data.lodUrl) {
					lod = new CoreEX.GisLod(this, { url: data.lodUrl });
					this._lod = lod;
					lod._readyPromise.then((lod1) => {
						// this._dynamicLayer = new CoreEX.GisBaseLayer(
						//   self.viewer,
						//   data.dynamicLayer
						// );
						init$1.bind(self)(rootLayer_, lod1);
						resolve(self);
					});
				} else {
					// this._dynamicLayer = new CoreEX.GisBaseLayer(
					//   self.viewer,
					//   data.dynamicLayer
					// );
					init$1.bind(self)(rootLayer_);
					resolve(self);
				}
			});
		}
	};

	function checkScene(data) {
		let sceneid = data.id;
		//版本兼容真痛苦
		//约束场景文件
		if (sceneid == "SceneGIS2.0") {
			if (!SceneGIS.defined(data.layer)) {
				throw new CoreEX.DeveloperError("场景文件格式错误,缺少layer节点");
			}
			CheckEX.ValueOf(data.layer, "id", "root");
			return data.layer;
		} else if (sceneid == "SceneGIS3.0") {
			if (!SceneGIS.defined(data.children)) {
				throw new CoreEX.DeveloperError("场景文件格式错误,缺少children节点");
			}
			if (data.children.length != 2) {
				throw new CoreEX.DeveloperError("场景文件格式错误,图层根节点只能2个");
			}
			CheckEX.ValueOf(data.children[0], "id", "root");
			CheckEX.ValueOf(data.children[1], "id", "setSceneEx");
			return data.children[0];
		} else {
			throw new CoreEX.DeveloperError(
				"场景文件id 不正确，只支持SceneGIS2.0和SceneGIS3.0"
			);
		}
	}

	/**
	 * 获取图层
	 * @param {String}  mark  图层id
	 * @returns {LayerEX|undefined} 返回获取的图层或者undefined
	 */
	SceneEX.prototype.getLayer = function (mark) {
		var layer = this._layerList.get(mark);
		return layer;
	};

	/**
	 * 获取图层
	 * @param {String}  mark  图层id
	 * @returns {LayerEX|undefined} 返回获取的图层或者undefined
	 */
	SceneEX.prototype.get = function (mark) {
		this.getLayer(mark);
	};

	/**
	 * 根据对象获取图层，针对静态图层
	 * @param {Object} data
	 * @returns {LayerEX|undefined} 返回获取的图层或者undefined
	 */
	SceneEX.prototype.getLayerByData = function (data) {
		let layer = undefined;
		this._layerList.forEach((key, value) => {
			if (value.data && value.data === data) {
				layer = value;
			}
		});
		return layer;
	};

	/**
	 * 获取图层列表
	 * @returns {Array<LayerEX>}  返回图层列表
	 */
	SceneEX.prototype.getLayerList = function () {
		var layerlist = [];
		layerlist = this._layerList.toArray();
		return layerlist;
	};

	/**
	 * 添加图层
	 * @param {Object}  option  图层配置项
	 * @param {LayerEX}  [parent=root]  父图层,如果不给定,则默认为根图层
	 * @returns {LayerEX}  返回对应的图层
	 * @example
	 * var layer = scene.addLayer({
	 *  name: "test",
	 *  id: "test",
	 *  layerType: "tileset",
	 *  data:{
	 *   cloudId:"34" }
	 *  })
	 */
	SceneEX.prototype.addLayer = function (option, parent) {
		let check = SceneGIS.defaultValue(option.isTemp, false);
		option.id = SceneGIS.defaultValue(option.id, CoreEX.MathEX.createUID());
		SceneGIS.Check.typeOf.string(
			`图层:${option.id}的option.layerType`,
			option.layerType
		);

		if (this._layerList.contain(option.id)) {
			throw new CoreEX.DeveloperError(`图层id:${option.id}重复`);
		}
		let _type = SceneGIS.defaultValue(option.layerType, "group");
		var childlayer = GisLayerFactoryEX[_type](this.viewer, option);

		this._layerList.add(option.id, childlayer);

		if (childlayer.option.hasOwnProperty("lodLevel") && this.lod) {
			this.lod.addData(childlayer, childlayer.option.lodLevel);
		}

		if (check) {
			//临时图层
			this._dynamicLayer.push(childlayer);
			return childlayer;
		}

		parent = SceneGIS.defaultValue(parent, this._root);
		parent.children.push(childlayer);

		//为保证 场景json 的完整性
		if (!check) {
			var options = parent.option.children.find((item) => item.id === option.id);
			if (!SceneGIS.defined(options)) {
				parent.option.children.push(option);
			}
		}

		return childlayer;
	};

	/**
	 * 添加图层,图层添加只能一个一个图层的添加
	 * @param {Object}  option  图层配置项
	 * @param {LayerEX}  [parent=root]  父图层,如果不给定,则默认为根图层
	 * @returns {LayerEX}  返回对应的图层
	 * @example
	 * var layer = scene.add({
	 *  name: "test",
	 *  id: "test",
	 *  layerType: "tileset",
	 *  data:{
	 *   cloudId:"34" }
	 *  })
	 */
	SceneEX.prototype.add = function (option, parent) {
		this.addLayer(option, parent);
	};

	/**
	 * 定位图层
	 * @param {String}  mark  图层id
	 * @param {Object}  option  定位参数
	 * @param {Object}  option.offset  飞行偏移，这是一个对象，有heading，pitch，roll的参数。
	 * @returns {Boolean}  定位成功返回true，失败返回false
	 */
	SceneEX.prototype.zoomLayer = function (mark, option) {
		let layer = this.getLayer(mark);
		if (layer) {
			return zoom_(layer, option, this.viewer);
		}
		return false;
	};

	/**
	 * 定位图层
	 * @param {String}  mark  图层id
	 * @param {Object}  option  定位参数
	 * @param {Object}  option.offset  飞行偏移，这是一个对象，有heading，pitch，roll的参数。
	 * @returns {Boolean}  定位成功返回true，失败返回false
	 */
	SceneEX.prototype.zoom = function (mark, option) {
		this.zoomLayer(mark, option);
	};

	//场景定位
	function zoom_(layer, option, viewer) {
		var layerdata = layer.option;

		var rectangles = layerdata.rectangle;
		var camera = layerdata.camera;
		var provider = layerdata.layerType;

		//各类定位优先级
		if (rectangles) {
			var rectextends = rectangles.split("|");
			var minxy = rectextends[0].split(",");
			var maxxy = rectextends[1].split(",");
			let rectangleDEM = new SceneGIS.Rectangle(
				SceneGIS.Math.toRadians(minxy[0]),
				SceneGIS.Math.toRadians(minxy[1]),
				SceneGIS.Math.toRadians(maxxy[0]),
				SceneGIS.Math.toRadians(maxxy[1])
			);
			viewer.scene.camera.flyTo({ destination: rectangleDEM });
		} else if (camera) {
			if (camera.cartographic) {
				console.log("camera", camera);
				viewer.camera.flyTo({
					destination: SceneGIS.Cartesian3.fromDegrees(
						camera.cartographic[0],
						camera.cartographic[1],
						camera.cartographic[2]
					),
					orientation: {
						heading: camera.cartographic[3],
						pitch: camera.cartographic[4],
						roll: camera.cartographic[5],
					},
					duration: camera.cartographic[6],
				});
			} else if (camera.cartesian3) {
				var camera = camera;
				if (!camera.cartesian3) {
					camera = JSON.parse(camera);
				}
				var p_ = camera.cartesian3;
				viewer.camera.flyTo({
					destination: new SceneGIS.Cartesian3(p_[0], p_[1], p_[2]),
					orientation: {
						heading: p_[3],
						pitch: p_[4],
						roll: p_[5],
					},
					duration: p_[6],
				});
			}
		} else if (provider == "tileset") {
			if (layer.data) {
				var tileset = layer.data;
				if (option && option.offset) {
					viewer.camera.flyToBoundingSphere(tileset.boundingSphere, {
						offset: new SceneGIS.HeadingPitchRange(
							option.offset.heading,
							option.offset.pitch,
							option.offset.range
						),
					});
				} else {
					viewer.flyTo(tileset);
				}
			}
		} else if (provider == "CustomPole"); else if (provider == "scenegisTerrainProvider") {
			var xhr = new XMLHttpRequest();
			xhr.open("GET", layer.data._layers[0].resource._url + "meta.json");
			xhr.send();
			xhr.onreadystatechange = function (e) {
				if (xhr.readyState == 4 && this.status == 200) {
					var data = JSON.parse(this.response);
					var latitude = (data.bounds.south + data.bounds.north) / 2;
					var longitude = (data.bounds.east + data.bounds.west) / 2;
					viewer.camera.flyTo({
						destination: new SceneGIS.Cartesian3.fromDegrees(
							longitude,
							latitude,
							5000
						),
					});
				}
			};
		} else if (provider == "glb") {
			if (SceneGIS.defined(layerdata.models.position)) {
				var longitude = layerdata.models.position.longitude;
				var latitude = layerdata.models.position.latitude;
				var height = layerdata.models.position.height;
				viewer.camera.flyTo({
					destination: new SceneGIS.Cartesian3.fromDegrees(
						longitude,
						latitude,
						height + 500
					),
				});
			} else if (SceneGIS.defined(layerdata.models.modelMatrix)) {
				var ellipsoid = viewer.scene.globe.ellipsoid;
				var result = new SceneGIS.Cartesian3();
				var pos = SceneGIS.Matrix4.getTranslation(layer.data.modelMatrix, result);
				var cart = ellipsoid.cartesianToCartographic(pos);

				var lat = SceneGIS.Math.toDegrees(cart.latitude);
				var lng = SceneGIS.Math.toDegrees(cart.longitude);
				var alt = cart.height;
				viewer.camera.flyTo({
					destination: new SceneGIS.Cartesian3.fromDegrees(lng, lat, alt + 500),
				});
			}
		} else if (provider == "geojson") {
			layer._featureReadyPromise.then((ds) => {
				if (layer._data && layer._data.entities) {
					viewer.flyTo(layer._data.entities);
				}
				if (layer.layer && layer.layer._data && layer.layer._data.entities) {
					viewer.flyTo(layer.layer._data.entities);
				}
			});
		} else if (provider == "graphic") {
			layer._featureReadyPromise.then((ds) => {
				if (layer._data && layer._data.entities) {
					viewer.flyTo(layer._data.entities);
				}
				if (layer.layer && layer.layer._data && layer.layer._data.entities) {
					viewer.flyTo(layer.layer._data.entities);
				}
			});
		}
		else if (provider == "i3s") {

			if (layer.data) {
				let i3sProvider = layer.data;
				const center = SceneGIS.Rectangle.center(i3sProvider.extent);
				center.height = 10000.0;
				viewer.camera.setView({
					destination: SceneGIS.Ellipsoid.WGS84.cartographicToCartesian(center),
				});
			}

		}

		return true;
	}

	/**
	 * 删除图层，如果图层具备子图层，应该先删除子图层，否则删除报错
	 * @param {String}  mark  图层id
	 * @returns {Boolean} 删除成功返回true，失败返回false
	 */
	SceneEX.prototype.removeLayer = function (mark) {
		//删除图层必须遍历，要保证图层树的完整性
		if (mark == "root") {
			//根节点不能删除
			return false;
		}
		var stack = [];
		var rootLayer = this._root;
		stack.push(rootLayer);
		var indexScene = -1;
		var parent = undefined;
		while (stack.length > 0) {
			var layer = stack.pop();
			var children = layer.children;
			if (SceneGIS.defined(children)) {
				//广度优先遍历建立节点关系
				var length = children.length;
				for (var i = 0; i < length; ++i) {
					var child = children[i];
					if (child.id == mark) {
						parent = layer;
						indexScene = i;
						break;
					}
					stack.push(child);
				}
				if (parent) {
					break;
				}
			}
		}
		if (indexScene != -1) {
			let findelayer = parent.children[indexScene];
			if (findelayer.children && findelayer.children.length > 0) {
				throw new SceneGIS.DeveloperError("该图层不是叶子图层，请先删除子图层");
			}
			this._layerList.remove(findelayer.id);
			findelayer.destroy();

			parent.children.splice(indexScene, 1); //删除节点
			parent.option.children.splice(indexScene, 1); //删除场景节点，保证json场景的完整性
			return true;
		}

		var dynamics = this._dynamicLayer;
		var index = -1;
		for (var i = 0; i < dynamics.length; i++) {
			if (dynamics[i].id == mark) {
				index = i;
				break;
			}
		}
		if (index != -1) {
			let findelayer = dynamics[index];
			this._layerList.remove(findelayer.id);
			findelayer.destroy();
			this._dynamicLayer.splice(index, 1); //删除节点
			return true;
		}

		return false;
	};

	/**
	 * 删除图层，如果图层具备子图层，应该先删除子图层，否则删除报错
	 * @param {String}  mark  图层id
	 * @returns {Boolean} 删除成功返回true，失败返回false
	 */
	SceneEX.prototype.remove = function (mark) {
		this.removeLayer(mark);
	};

	/*
	 * 删除动态图层
	 */
	function removeDynamicLayers(sceneEx) {
		var dynamics = sceneEx._dynamicLayer;

		for (var i = 0; i < dynamics.length; i++) {
			sceneEx._layerList.remove(dynamics[i].id);
			dynamics[i].destroy();
		}

		sceneEx._dynamicLayer = []; //删除节点
		return true;
	}

	/**
	 * 删除所有图层
	 * @returns {Boolean} 删除成功返回true，失败返回false
	 */
	SceneEX.prototype.removeAllLayer = function () {
		var stack = [];
		var rootLayer = this._root;
		stack.push(rootLayer);
		while (stack.length > 0) {
			var layer = stack.pop();
			if (SceneGIS.defined(layer)) {
				var children = layer.children;
				if (SceneGIS.defined(children)) {
					//广度优先遍历建立节点关系
					var length = children.length;
					for (var i = 0; i < length; ++i) {
						var child = children[i];
						child.destroy();
						stack.push(child);
					}
				}
			}
		}
		this._root.children.splice(0, this._root.children.length);
		this._root.option.children = [];

		removeDynamicLayers(this);
		this._layerList.removeAll();

		return true;
	};

	/**
	 * 删除所有图层
	 * @returns {Boolean} 删除成功返回true，失败返回false
	 */
	SceneEX.prototype.removeAll = function () {
		this.removeAllLayer();
	};

	/**
	 * 场景初始状态
	 */
	SceneEX.prototype.home = function () {
		var locationP = undefined;
		var camera = this._root.option.camera;
		var p_ = {};
		if (camera) {
			if (camera.cartesian3) {
				p_ = camera.cartesian3;
				locationP = new SceneGIS.Cartesian3(
					camera.cartesian3[0],
					camera.cartesian3[1],
					camera.cartesian3[2]
				);
			} else if (camera.cartographic) {
				p_ = camera.cartographic;
				locationP = SceneGIS.Cartesian3.fromDegrees(
					camera.cartographic[0],
					camera.cartographic[1],
					camera.cartographic[2]
				);
			}
			if (locationP) {
				this.viewer.scene.camera.flyTo({
					destination: locationP,
					orientation: {
						heading: p_[3],
						pitch: p_[4],
						roll: p_[5],
					},
					duration: p_[6],
				});
			}
		}
	};
	/**
	 * 根据笛卡尔数组飞行
	 * @param {Array}  array  [x,y,z,heading,pitch,roll,duration]
	 * @returns {Boolean} 删除成功返回true，失败返回false
	 */
	SceneEX.prototype.flyTo = function (array) {
		var locationP = undefined;
		var p_ = array;
		locationP = new SceneGIS.Cartesian3(
			p_[0],
			p_[1],
			p_[2]
		);
		if (locationP) {
			this.viewer.scene.camera.flyTo({
				destination: locationP,
				orientation: {
					heading: p_[3],
					pitch: p_[4],
					roll: p_[5],
				},
				duration: p_[6],
			});
		}
	};

	/**
	 * 销毁场景
	 */
	SceneEX.prototype.destroy = function () {
		if (this._root) {
			this.removeAllLayer();
		}
		if (this._viewer) {
			this._viewer.scene.preUpdate.removeEventListener(this._preUpdate);
			destroy(this);
		}
		if (this._viewer) {
			let stages = this._viewer.scene.postProcessStages._stages;
			var postProcessStages = this._viewer.scene.postProcessStages;
			let watermaskStage = stages.find((item) => item.name == 'czm_watermark');
			if (postProcessStages.contains(watermaskStage)) {
				postProcessStages.remove(watermaskStage);
			}
		}
	};

	/**
	 * 设置项类型
	 * @readonly
	 * @enum {string}
	 */
	const SetType = {
		/**
		  * 天气设置
		  * @type {string}
		  * @constant
		*/
		"WeatherEX": "WeatherEX",

		/**
		  * 环境贴图
		  * @type {string}
		  * @constant
		*/
		"EnvironmentMapsEX": "EnvironmentMapsEX",


		/**
		  * 抗锯齿
		  * @type {string}
		  * @constant
		*/
		"AAEX": "AAEX",

		/**
		  * 环境遮挡
		  * @type {string}
		  * @constant
		*/
		"AOEX": "AOEX",

		/**
		  * 环境光贴图
		  * @type {string}
		  * @constant
		*/
		"EnvironmentMapsEX": "EnvironmentMapsEX",

		/**
		  * 阴影
		  * @type {string}
		  * @constant
		*/
		"ShadowEX": "ShadowEX",

		/**
		  * 时间设置
		  * @type {string}
		  * @constant
		*/
		"TimeEX": "TimeEX",

		/**
		  * 动态大气
		  * @type {string}
		  * @constant
		*/
		"skyAtmosphereEX": "skyAtmosphereEX",

		/**
		  * 天空盒
		  * @type {string}
		  * @constant
		*/
		"SkyBoxEX": "SkyBoxEX",

		/**
		  * 地下模式
		  * @type {string}
		  * @constant
		*/
		"UndergroundModeEX": "UndergroundModeEX",

		/**
		 * 深度检测
		 * @type {string}
		 * @constant
	   */
		"DepthTestEX": "DepthTestEX",

		/**
		  * 场景色调调整
		  * @type {string}
		  * @constant
		*/
		"SceneColorEX": "SceneColorEX",
	};

	var SetType$1 = Object.freeze(SetType);

	/**
	 * 抗锯齿类型
	 * @readonly
	 * @enum {string}
	 */
	const AAType = {
		/**
		 * 无抗锯齿
		 * @type {string}
		 * @constant
		 */
		NONE: "none",
		/**
		 * FXAA
		 * @type {string}
		 * @constant
		 */
		FXAA: "FXAA",
		/**
		 * TAA
		 * @type {string}
		 * @constant
		 */
		TAA: "TAA"
	};

	var AAType$1 = Object.freeze(AAType);

	var _AAEX = undefined;
	/**
	 * 抗锯齿
	 *
	 * @class AAEX
	 * @constructor
	 * 
	 * @param {Object} options 配置
	 * @param {AAType} [options.type='TAA'] 抗锯齿类型,默认TAA {@link AAType}
	 * @param {Viewer} viewer viewer对象
	 */
	function AAEX(options, viewer) {
		if (_AAEX) {
			return _AAEX;
		}
		options = SceneGIS.defaultValue(options, SceneGIS.defaultValue.EMPTY_OBJECT);
		this.name = "AAEX";
		this._type = SceneGIS.defaultValue(options.type, AAType$1.NONE);
		this._viewer = viewer;
		this._visible = SceneGIS.defaultValue(options.visible, false);
		if (this._visible) {
			this.Set({ type: this._type });
		}
		_AAEX = this;
	}


	Object.defineProperties(AAEX.prototype, {
		/**
		* 获取viewer 对象
		* @memberof AAEX.prototype
		*
		* @type {Viewer}
		* @readonly
		*/
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		},
		/**
		 * 抗锯齿类型
		 * @memberof AAEX.prototype
		 *
		 * @type {String}
		 */
		type: {
			get: function () {
				return SceneGIS.defined(this._type) ? this._type : undefined;
			},
			set: function (val) {
				this._type = val;
				this.Set({ type: this._type });
			}
		},
		/**
		 * 抗锯齿生效
		 * @memberof AAEX.prototype
		 *
		 * @type {Boolean}
		 */
		visible: {
			get: function () {
				return this._visible;
			},
			set: function (val) {
				this._visible = val;
				if (this._visible) {
					this.Set({ type: this._type });
				} else {
					this.stop();
				}
			}
		},


	});

	/**
	 * 设置抗锯齿效果
	 * @param {Objct} option
	 * @param {AAType} [option.type] 抗锯齿类型 {@link AAType}
	 */

	AAEX.prototype.Set = function (option) {
		option = SceneGIS.defaultValue(option, SceneGIS.defaultValue.EMPTY_OBJECT);
		let type = option.type;
		const scene = this._viewer.scene;
		this._type = SceneGIS.defined(type) ? type : this._type;
		if (this._type === AAType$1.FXAA) {
			scene.postProcessStages.taa.enabled = false;
			scene.postProcessStages.fxaa.enabled = true;
		} else if (this._type === AAType$1.TAA) {
			scene.postProcessStages.fxaa.enabled = false;

			scene.postProcessStages.taa.enabled = true;
			scene._taaProcessStage._brightDiff = 20;
			scene._taaProcessStage._depthDiff = 20;
			scene._taaProcessStage.disableCameraStatic = true;
		} else if (this._type === AAType$1.NONE) {
			scene.postProcessStages.fxaa.enabled = false;
			scene.postProcessStages.taa.enabled = false;
		}
	};
	/**
	 * 恢复默认
	 */
	AAEX.prototype.stop = function () {
		const scene = this._viewer.scene;
		scene.postProcessStages.fxaa.enabled = false;
		scene.postProcessStages.taa.enabled = false;
	};

	/**
	 * 销毁操作，销毁内部事件和临时对象
	 */
	AAEX.prototype.destroy = function () {
		this.stop();
	};

	/**
	 * 环境遮挡类型
	 * @readonly
	 * @enum {string}
	 */
	const AOType = {
		/**
		 * 无环境遮挡
		 * @type {string}
		 * @constant
		 */
		NONE: "none",
		/**
		 * 普通AO
		 * @type {string}
		 * @constant
		 */
		AO: "AO",
		/**
		 * HBAO
		 * @type {string}
		 * @constant
		 */
		HBAO: "HBAO"
	};

	var AOType$1 = Object.freeze(AOType);

	var _AOEX = undefined;
	/**
	 * 环境遮挡
	 *
	 * @class AOEX
	 * @constructor
	 * 
	 * @param {Object} options 配置
	 * @param {AOType} [options.type = AOType.NONE] 环境遮挡类型,默认AOType.NONE {@link AOType}
	 * @param {AOType} [options.visible = false] 是否生效，默认为不生效
	 * @param {Number} [options.intensity = 3] AO的强度,只有当type=AOType.AO时才生效
	 * @param {Number} [options.lengthCap = 0.26] AO的长度限制,只有当type=AOType.AO时才生效
	 * @param {Number} [options.stepSize = 3.5] AO的步长,只有当type=AOType.AO时才生效
	 * @param {Number} [options.blurStepSize = 0.86] AO的模糊程度,只有当type=AOType.AO时才生效
	 * @param {Viewer} viewer viewer对象
	 */
	function AOEX(options, viewer) {
		if (_AOEX) {
			return _AOEX;
		}
		options = SceneGIS.defaultValue(options, SceneGIS.defaultValue.EMPTY_OBJECT);
		this.name = "AOEX";
		this._type = SceneGIS.defaultValue(options.type, AOType$1.NONE);
		this._viewer = viewer;
		this._hbao = null;
		this._visible = SceneGIS.defaultValue(options.visible, false);
		//设置默认值
		this._intensity = SceneGIS.defaultValue(options.intensity, 3);
		this._lengthCap = SceneGIS.defaultValue(options.lengthCap, 0.26);
		this._stepSize = SceneGIS.defaultValue(options.stepSize, 3.5);
		this._blurStepSize = SceneGIS.defaultValue(options.blurStepSize, 0.86);
		//检查类型
		CheckEX.typeOf("options.intensity", this._intensity, "number");
		CheckEX.typeOf("options.lengthCap", this._lengthCap, "number");
		CheckEX.typeOf("options.stepSize", this._stepSize, "number");
		CheckEX.typeOf("options.blurStepSize", this._blurStepSize, "number");

		if (this._visible) {
			this.Set({
				type: this._type,
				intensity: this._intensity,
				lengthCap: this._lengthCap,
				stepSize: this._stepSize,
				blurStepSize: this._blurStepSize
			});
		}
		_AOEX = this;
	}


	Object.defineProperties(AOEX.prototype, {
		/**
		* 获取viewer 对象
		* @memberof AOEX.prototype
		*
		* @type {Viewer}
		* @readonly
		*/
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		},
		/**
		 * 环境遮挡类型
		 * @memberof AOEX.prototype
		 *
		 * @type {String}
		 */
		type: {
			get: function () {
				return SceneGIS.defined(this._type) ? this._type : undefined;
			},
			set: function (val) {
				this._type = val;
				this.Set({ type: this._type });
			}
		},
		/**
		 * 环境遮挡生效
		 * @memberof AOEX.prototype
		 *
		 * @type {Boolean}
		 */
		visible: {
			get: function () {
				return this._visible;
			},
			set: function (val) {
				this._visible = val;
				if (this._visible) {
					this.Set({ type: this._type });
				} else {
					this.stop();
				}

			}
		},
		/**
		 * AO的强度，只有type=AO时才生效
		 * @memberof AOEX.prototype
		 *
		 * @type {Number}
		 */
		intensity: {
			get: function () {
				return this._intensity;
			},
			set: function (val) {
				CheckEX.typeOf("intensity", val, "number");
				this._intensity = val;
				this.Set({ type: this._type, intensity: this._intensity });
			}
		},

		/**
		 * AO的长度限制，只有type=AO时才生效
		 * @memberof AOEX.prototype
		 *
		 * @type {Number}
		 */
		lengthCap: {
			get: function () {
				return this._lengthCap;
			},
			set: function (val) {
				CheckEX.typeOf("lengthCap", val, "number");
				this._lengthCap = val;
				this.Set({ type: this._type, lengthCap: this._lengthCap });
			}
		},

		/**
		 * AO的步长，只有type=AO时才生效
		 * @memberof AOEX.prototype
		 *
		 * @type {Number}
		 */
		stepSize: {
			get: function () {
				return this._stepSize;
			},
			set: function (val) {
				CheckEX.typeOf("stepSize", val, "number");
				this._stepSize = val;
				this.Set({ type: this._type, stepSize: this._stepSize });
			}
		},

		/**
		 * AO的模糊程度，只有type=AO时才生效
		 * @memberof AOEX.prototype
		 *
		 * @type {Number}
		 */
		blurStepSize: {
			get: function () {
				return this._blurStepSize;
			},
			set: function (val) {
				CheckEX.typeOf("blurStepSize", val, "number");
				this._blurStepSize = val;
				this.Set({ type: this._type, blurStepSize: this._blurStepSize });
			}
		},


	});

	/**
	 * 设置环境遮挡效果
	 *
	 * @param {Object} [options] AO的配置属性，可为空
	 * @param {String} [options.type='none'] 环境遮挡类型,默认none[1-none,2-AO,3-HBAO]
	 * @param {Number} [options.intensity = 3] AO的强度,只有当type=AOType.AO时才生效
	 * @param {Number} [options.lengthCap = 0.26] AO的长度限制,只有当type=AOType.AO时才生效
	 * @param {Number} [options.stepSize = 3.5] AO的步长,只有当type=AOType.AO时才生效
	 * @param {Number} [options.blurStepSize = 0.86] AO的模糊程度,只有当type=AOType.AO时才生效
	 */

	AOEX.prototype.Set = function (options) {
		var ambientOcclusion = this._viewer.scene.postProcessStages.ambientOcclusion;
		options = SceneGIS.defaultValue(options, SceneGIS.defaultValue.EMPTY_OBJECT);
		let type = options.type;
		this._type = SceneGIS.defined(type) ? type : this._type;
		if (this._type === AOType$1.NONE) {
			ambientOcclusion.enabled = false;
			ambientOcclusion.uniforms.ambientOcclusionOnly = false;
			if (this._hbao) {
				this._hbao.destroy();
				this._hbao = null;
			}
		}
		else if (this._type === AOType$1.AO) {
			if (this._hbao) {
				this._hbao.destroy();
				this._hbao = null;
			}
			this._intensity = SceneGIS.defaultValue(options.intensity, this._intensity);
			this._lengthCap = SceneGIS.defaultValue(options.lengthCap, this._lengthCap);
			this._stepSize = SceneGIS.defaultValue(options.stepSize, this._stepSize);
			this._blurStepSize = SceneGIS.defaultValue(options.blurStepSize, this._blurStepSize);
			console.log("oyyx ");

			ambientOcclusion.enabled = true;
			ambientOcclusion.uniforms.ambientOcclusionOnly = false;
			ambientOcclusion.uniforms.intensity = this._intensity;
			ambientOcclusion.uniforms.lengthCap = this._lengthCap;
			ambientOcclusion.uniforms.stepSize = this._stepSize;
			ambientOcclusion.uniforms.blurStepSize = this._blurStepSize;
			ambientOcclusion.uniforms.bias = 0.1;
		}
		else if (this._type === AOType$1.HBAO) {
			ambientOcclusion.enabled = false;
			ambientOcclusion.uniforms.ambientOcclusionOnly = false;
			if (!this._hbao) this._hbao = new SceneGIS.HBAOPass();
			this._hbao.render();
		}
	};

	AOEX.prototype.stop = function () {
		var ambientOcclusion = this._viewer.scene.postProcessStages.ambientOcclusion;
		ambientOcclusion.enabled = false;
		ambientOcclusion.uniforms.ambientOcclusionOnly = false;
		if (this._hbao) {
			this._hbao.destroy();
			this._hbao = null;
		}
	};

	/**
	 * 销毁操作，销毁内部事件和临时对象
	 */
	AOEX.prototype.destroy = function () {
		this.stop();
	};

	/**
	 * 环境光贴图
	 *
	 * @class EnvironmentMapsEX
	 * @constructor
	 * 
	 * @param {Object} options 配置
	 * @param {String} [options.type] 贴图类型,可选["none","morning","noon","afternoon","night"]
	 * @param {SceneGIS3DTileset} options.tileset 生效的模型id
	 * @param {Viewer} viewer viewer对象
	 */
	function EnvironmentMapsEX(options, viewer) {
		options = SceneGIS.defaultValue(options, SceneGIS.defaultValue.EMPTY_OBJECT);
		this.name = "EnvironmentMapsEX";
		this._type = SceneGIS.defaultValue(options.type, "none");
		let _tileset = SceneGIS.defaultValue(options.tileset, []);
		this._viewer = viewer;
		this.tilesetArray = Array.isArray(_tileset)
			? _tileset
			: [_tileset];
		const tilesetCount = this.tilesetArray.length;
		this._enableThreePbrs = [];
		this._preEnvironmentMaps = [];
		this._preLightIntensitys = [];
		for (let i = 0; i < tilesetCount; i++) {
			let enableThreePbr = SceneGIS.defined(this.tilesetArray[i].imageBasedLighting) ? this.tilesetArray[i].imageBasedLighting.enableThreePbr : false;
			let preEnvironmentMap = SceneGIS.defined(this.tilesetArray[i].imageBasedLighting) ? this.tilesetArray[i].imageBasedLighting.specularEnvironmentMaps : "";
			let preLightIntensity = SceneGIS.defined(this.tilesetArray[i].imageBasedLighting) ? this.tilesetArray[i].imageBasedLighting.ambientLightIntensity : 0;
			this._enableThreePbrs.push(enableThreePbr);
			this._preEnvironmentMaps.push(preEnvironmentMap);
			this._preLightIntensitys.push(preLightIntensity);
		}
	}


	Object.defineProperties(EnvironmentMapsEX.prototype, {
		/**
		* 获取viewer 对象
		* @memberof EnvironmentMapsEX.prototype
		*
		* @type {Viewer}
		* @readonly
		*/
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		},
		/**
		 * 环境贴图类型
		 * @memberof EnvironmentMapsEX.prototype
		 *
		 * @type {String}
		 */
		type: {
			get: function () {
				return SceneGIS.defined(this._type) ? this._type : undefined;
			},
			set: function (val) {
				this._type = val;
			}
		},


	});

	/**
	 * 设置环境光贴图效果
	 *
	 * @param {Object} [options] 配置的属性，可谓空
	 * @param {String} [options.type='none'] 贴图类型,可选["none","morning","noon","afternoon","night"]
	 * @param {SceneGIS3DTileset} [options.tileset] 生效的模型
	 */

	EnvironmentMapsEX.prototype.Set = function (options) {
		options = SceneGIS.defaultValue(options, SceneGIS.defaultValue.EMPTY_OBJECT);
		this._type = SceneGIS.defined(options.type) ? options.type : this._type;
		let _tileset = options.tileset;
		if (SceneGIS.defined(_tileset)) {
			this.tilesetArray = Array.isArray(_tileset)
				? _tileset
				: [_tileset];
		}
		let specularEnvironmentMaps = "", ambientLightIntensity = 9;
		if (this._type === "none") {
			this.stop();
		}
		else {
			if (this._type === "morning" || this._type === "afternoon") {
				specularEnvironmentMaps = CoreEX.getAssetUrl("img/Visualizations-Tatami_Room_3k.hdr");
				ambientLightIntensity = 8;
			}
			else if (this._type === "noon") {
				specularEnvironmentMaps = CoreEX.getAssetUrl("img/HDRI_Hen-Konigsallee_4k.hdr");
				ambientLightIntensity = 12;
			}
			else if (this._type === "night") {
				specularEnvironmentMaps = CoreEX.getAssetUrl("img/BOCO_Studio-City_Water_Dawn_0001_4k.hdr");
				ambientLightIntensity = 5;
			}
			for (let tileset of this.tilesetArray) {
				if (specularEnvironmentMaps === "") {
					tileset.imageBasedLighting = new SceneGIS.ImageBasedLighting({
						enableThreePbr: true,
						ambientLightIntensity: 9
					});
				} else {
					tileset.imageBasedLighting.specularEnvironmentMaps = specularEnvironmentMaps;
					tileset.imageBasedLighting.ambientLightIntensity = ambientLightIntensity;
				}
			}
		}
	};

	EnvironmentMapsEX.prototype.stop = function () {
		for (let i in this.tilesetArray) {
			if (this._preEnvironmentMaps[i] === "") {
				this.tilesetArray[i].imageBasedLighting = new SceneGIS.ImageBasedLighting({
					enableThreePbr: this._enableThreePbrs[i],
					ambientLightIntensity: this._preLightIntensitys[i]
				});
			} else {
				this.tilesetArray[i].imageBasedLighting.specularEnvironmentMaps = this._preEnvironmentMaps[i];
				this.tilesetArray[i].imageBasedLighting.ambientLightIntensity = this._preLightIntensitys[i];
			}
		}
	};

	/**
	 * 销毁操作，销毁内部事件和临时对象
	 */
	EnvironmentMapsEX.prototype.destroy = function () {
		this.stop();
	};

	var _TimeEX = undefined;
	/**
	 * 时间设置
	 *
	 * @class TimeEX
	 * @constructor
	 * 
	 * @param {Object} options 配置
	 * @param {String} [options.time='00:00']时间 格式为00:00-24:00
	 * @param {String} [options.visible=false] false代表时间为当前时间
	 * @param {Viewer} viewer viewer对象
	 */
	function TimeEX(options, viewer) {
		if (_TimeEX) {
			return _TimeEX;
		}
		options = SceneGIS.defaultValue(options, SceneGIS.defaultValue.EMPTY_OBJECT);
		this.name = "TimeEX";
		this._time = SceneGIS.defaultValue(options.time, new Date().toLocaleTimeString());
		this._viewer = viewer;
		this._visible = SceneGIS.defaultValue(options.visible, false);
		if (this._visible) {
			this.Set({ time: this._time });
		} else {
			this.stop();
		}
		_TimeEX = this;
	}


	Object.defineProperties(TimeEX.prototype, {
		/**
		* 获取viewer 对象
		* @memberof TimeEX.prototype
		*
		* @type {Viewer}
		* @readonly
		*/
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		},
		/**
		 * 时间
		 * @memberof TimeEX.prototype
		 *
		 * @type {String}
		 */
		time: {
			get: function () {
				return this._time;
			},
			set: function (val) {
				this._time = val;
				this.Set({ time: this._time });
			}
		},
		/**
		 * 时间生效
		 * @memberof TimeEX.prototype
		 *
		 * @type {Boolean}
		 */
		visible: {
			get: function () {
				return this._visible;
			},
			set: function (val) {
				this._visible = val;
				if (this._visible) {
					this.Set({ time: this._time });
				} else {
					this.stop();
				}

			}
		},


	});

	/**
	 * 设置时间
	 *
	 * @param {Object} [options] AO的配置属性，可为空
	 * @param {String} [options.time='00:00'] 时间，格式为00:00-24:00
	 */

	TimeEX.prototype.Set = function (options) {
		options = SceneGIS.defaultValue(options, SceneGIS.defaultValue.EMPTY_OBJECT);
		let time = options.time;
		this._time = SceneGIS.defined(time) ? time : this._time;
		var date = "October 13, 1975 " + this._time + ":00";
		var jsdate = new Date(date);
		const currentTime = SceneGIS.JulianDate.fromDate(jsdate, new SceneGIS.JulianDate());
		this._viewer.clock.currentTime = currentTime;
	};

	TimeEX.prototype.stop = function () {
		this._viewer.clock.currentTime = SceneGIS.JulianDate.now();
	};

	/**
	 * 销毁操作，销毁内部事件和临时对象
	 */
	TimeEX.prototype.destroy = function () {
		this.stop();
	};

	var _ShadowEX = undefined;
	/**
	 * 阴影
	 *
	 * @class ShadowEX
	 * @constructor
	 * 
	 * @param {Object} options 配置
	 * @param {String} options.time [options.time=当前时间]时间 格式为00:00-24:00
	 * @param {Boolean} options.shadow [options.shadow=false]是否开启阴影
	 * @param {Boolean} options.softShadow [options.softShadow=false]是否开启软阴影
	 * @param {Float} options.darkness [options.darkness=0.3]暗度
	 * @param {Number} options.shadowMap [options.shadowMap=2048]阴影贴图大小
	 * @param {Viewer} viewer viewer对象
	 */
	function ShadowEX(options, viewer) {
		if (_ShadowEX) {
			return _ShadowEX;
		}
		options = SceneGIS.defaultValue(options, SceneGIS.defaultValue.EMPTY_OBJECT);
		this.name = "ShadowEX";
		this._viewer = viewer;
		this._visible = SceneGIS.defaultValue(options.visible, false);
		this._time = SceneGIS.defaultValue(options.time, new Date().toLocaleTimeString());
		this.timeEX = new TimeEX({}, viewer);
		this._shadow = SceneGIS.defaultValue(options.shadow, false);
		this._softShadow = SceneGIS.defaultValue(options.softShadow, false);
		this._darkness = SceneGIS.defaultValue(options.darkness, 0.3);
		this._shadowMap = SceneGIS.defaultValue(options.shadowMap, 2048);
		if (this._visible) {
			this.Set();
		}
		_ShadowEX = this;
	}


	Object.defineProperties(ShadowEX.prototype, {
		/**
		* 获取viewer 对象
		* @memberof ShadowEX.prototype
		*
		* @type {Viewer}
		* @readonly
		*/
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		},
		/**
		 * 阴影生效
		 * @memberof ShadowEX.prototype
		 *
		 * @type {Boolean}
		 */
		visible: {
			get: function () {
				return this._visible;
			},
			set: function (val) {
				this._visible = val;
				if (this._visible) {
					this.Set();
				} else {
					this.stop();
				}

			}
		},
		/**
		 * 开启阴影
		 * @memberof ShadowEX.prototype
		 *
		 * @type {Boolean}
		 */
		shadow: {
			get: function () {
				return this._shadow;
			},
			set: function (val) {
				this._shadow = val;
				this._viewer.shadows = val;
			}
		},
		/**
		 * 开启软阴影
		 * @memberof ShadowEX.prototype
		 *
		 * @type {Boolean}
		 */
		softShadow: {
			get: function () {
				return this._softShadow;
			},
			set: function (val) {
				this._softShadow = val;
				this._viewer.scene.shadowMap.softShadows = val;
			}
		},
		/**
		 * 暗度
		 * @memberof ShadowEX.prototype
		 *
		 * @type {Float}
		 */
		darkness: {
			get: function () {
				return this._darkness;
			},
			set: function (val) {
				this._darkness = val;
				this._viewer.scene.shadowMap.darkness = val;
			}
		},
		/**
		 * 阴影贴图大小
		 * @memberof ShadowEX.prototype
		 *
		 * @type {Number}
		 */
		shadowMap: {
			get: function () {
				return this._shadowMap;
			},
			set: function (val) {
				this._shadowMap = val;
				this._viewer.scene.shadowMap.size = val;
			}
		},
		/**
		 * 时间设置
		 * @memberof ShadowEX.prototype
		 *
		 * @type {Number}
		 */
		time: {
			get: function () {
				return this._time;
			},
			set: function (val) {
				this._time = val;
				this.timeEX.Set({ time: val });
			}
		}
	});

	/**
	 * 设置阴影效果
	 *
	 * @param {Object} [type] 阴影配置
	 */

	ShadowEX.prototype.Set = function (option) {
		option = SceneGIS.defaultValue(option, SceneGIS.defaultValue.EMPTY_OBJECT);
		this._shadow = SceneGIS.defaultValue(option.shadow, this._shadow);
		this._softShadow = SceneGIS.defaultValue(option.softShadow, this._softShadow);
		this._darkness = SceneGIS.defaultValue(option.darkness, this._darkness);
		this._shadowMap = SceneGIS.defaultValue(option.shadowMap, this._shadowMap);

		this._viewer.shadows = this._shadow;
		this._viewer.scene.shadowMap.softShadows = this._softShadow;
		this._viewer.scene.shadowMap.darkness = this._darkness;
		this._viewer.scene.shadowMap.size = this._shadowMap;

		this.timeEX.Set({ time: SceneGIS.defaultValue(option.time, this._time) });
	};

	ShadowEX.prototype.stop = function () {
		this._viewer.shadows = false;
	};

	/**
	 * 销毁操作，销毁内部事件和临时对象
	 */
	ShadowEX.prototype.destroy = function () {
		this.stop();
	};

	/**
	 * 动态大气
	 *
	 * @class skyAtmosphereEX
	 * @constructor
	 * 
	 * @param {Object} options 配置
	 * @param {Boolean} options.visible 是否生效
	 * @param {Viewer} viewer viewer对象
	 */
	function skyAtmosphereEX(options, viewer) {
		options = SceneGIS.defaultValue(options, SceneGIS.defaultValue.EMPTY_OBJECT);
		this.name = "skyAtmosphereEX";
		this._viewer = viewer;
		this._visible = SceneGIS.defaultValue(options.visible, true);
		if (this._visible) {
			this.Set({});
		} else {
			this.stop();
		}
	}


	Object.defineProperties(skyAtmosphereEX.prototype, {
		/**
		* 获取viewer 对象
		* @memberof skyAtmosphereEX.prototype
		*
		* @type {Viewer}
		* @readonly
		*/
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		},
		/**
		 * 动态大气生效
		 * @memberof skyAtmosphereEX.prototype
		 *
		 * @type {Boolean}
		 */
		visible: {
			get: function () {
				return this._visible;
			},
			set: function (val) {
				this._visible = val;
				if (this._visible) {
					this.Set({});
				} else {
					this.stop();
				}

			}
		},


	});

	/**
	 * 设置时间
	 *
	 * @param {Object} [options] 属性，为空
	 */

	skyAtmosphereEX.prototype.Set = function (options) {
		options = SceneGIS.defaultValue(options, SceneGIS.defaultValue.EMPTY_OBJECT);
		this._viewer.scene.skyAtmosphere.dynamic = true;
	};

	skyAtmosphereEX.prototype.stop = function () {
		this._viewer.scene.skyAtmosphere.dynamic = false;
	};

	/**
	 * 销毁操作，销毁内部事件和临时对象
	 */
	skyAtmosphereEX.prototype.destroy = function () {
		this.stop();
	};

	/**
	 * 起雾特效
	 *
	 * @class FogEX
	 * @constructor
	 * 
	 * @param {Object} options 配置
	 * @param {Number} [options.visibility=0.1] 雾的浓度,默认0.1
	 * @param {SceneGIS.Color} [color=SceneGIS.Color(0.8, 0.8, 0.8, 0.5)] 雾的颜色
	 * @param {Viewer} viewer viewer对象
	 */
	function FogEX(options, viewer) {
		options = SceneGIS.defaultValue(options, SceneGIS.defaultValue.EMPTY_OBJECT);
		this.name = "FogEX";
		this.cartesian = undefined;
		this.fognum = 0.9;
		this.visibility = SceneGIS.defaultValue(options.visibility, 0.1);
		this.color = SceneGIS.defaultValue(options.color, new SceneGIS.Color(0.8, 0.8, 0.8, 0.5));
		this.isFog = false;
		this._viewer = viewer;
	}


	Object.defineProperties(FogEX.prototype, {
		/**
		* 获取viewer 对象
		* @memberof FogEX.prototype
		*
		* @type {Viewer}
		* @readonly
		*/
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		},

	});

	/**
	 * 生成起雾特效
	 *
	 * @param {Number} val 控制雾的大小（范围0-1），数值越小雾越浓。
	 */

	FogEX.prototype.Set = function (val) {
		if (val == this.fognum && this.viewer.scene.postProcessStages.length > 0) {
			for (let i = 0; i < this.viewer.scene.postProcessStages.length; i++) {
				if (this.viewer.scene.postProcessStages._activeStages.length > 0) {
					let fog = this.viewer.scene.postProcessStages._activeStages[i];
					if (fog.name == 'czm_fog') {
						this.viewer.scene.postProcessStages.remove(fog);
					}
				}
			}
			return
		} else {
			for (let i = 0; i < this.viewer.scene.postProcessStages.length; i++) {
				if (this.viewer.scene.postProcessStages._activeStages.length > 0) {
					let fog = this.viewer.scene.postProcessStages._activeStages[i];
					if (fog.name == 'czm_fog') {
						this.viewer.scene.postProcessStages.remove(fog);
					}
				}
			}
			this.fognum = val;
			this.visibility = val;
			var FogStage = new SceneGIS.PostProcessStage({
				name: "czm_fog",
				fragmentShader: "  uniform sampler2D colorTexture;\n" +
					"  uniform sampler2D depthTexture;\n" +
					"  uniform float visibility;\n" +
					"  uniform vec4 fogColor;\n" +
					"  varying vec2 v_textureCoordinates;\n" +
					"  void main(void)\n" +
					"  {\n" +
					"      vec4 origcolor=texture2D(colorTexture, v_textureCoordinates);\n" +
					"      vec4 fogcolor=vec4(0.8,0.8,0.8,0.4);\n" +
					"\n" +
					"      float depth = czm_readDepth(depthTexture, v_textureCoordinates);\n" +
					"      vec4 depthcolor=texture2D(depthTexture, v_textureCoordinates);\n" +
					"\n" +
					//"      float f=(depthcolor.r-0.3)/" + val + ";\n" +
					"      float f = visibility * (depthcolor.r - 0.3) / 0.2; \n" +
					"      if(f<0.0) f=0.0;\n" +
					"      else if(f>1.0) f=1.0;\n" +
					"      gl_FragColor = mix(origcolor,fogcolor,f);\n" +
					"   }",
				uniforms: {
					visibility: () => {
						return this.visibility;
					},
					fogColor: () => {
						return this.color;
					}
				}
			});
			this.viewer.scene.postProcessStages.add(FogStage);
			//window.map3D.ui.$store.state.weather = true
		}

		this.isFog = true;
	};

	FogEX.prototype.stop = function () {
		for (let i = 0; i < this.viewer.scene.postProcessStages.length; i++) {
			let rain = this.viewer.scene.postProcessStages._activeStages[i];
			if (rain.name == 'czm_fog') {
				this.viewer.scene.postProcessStages.remove(rain);
			}
		}
		this.isFog = false;
	};

	/**
  * 销毁操作，销毁内部事件和临时对象，右键内部会调用
  * @param {*}
  * @return {*}
  */
	FogEX.prototype.destroy = function () {
		this.stop();
	};

	/**
	 * 天气类型
	 * @readonly
	 * @enum {string}
	 */
	const WeatherType = {
		/**
		 * 晴天
		 * @type {string}
		 * @constant
		 */
		SUN: "sun",
		/**
		 * 雨天
		 * @type {string}
		 * @constant
		*/
		RAIN: "rain",
		/**
		 * 雪天
		 * @type {string}
		 * @constant
		 */
		SNOW: "snow",
		/**
		 * 雾天
		 * @type {string}
		 * @constant
		*/
		FOG: "fog"
	};

	var WeatherType$1 = Object.freeze(WeatherType);

	var _WeatherEX = undefined;
	/**
	 * 天气设置
	 *
	 * @class WeatherEX
	 * @constructor
	 * 
	 * @param {Object} options 配置
	 * @param {WeatherType} [options.type = WeatherType.SUN] 天空盒类型,默认WeatherType.SUN {@link WeatherType}
	 * @param {Float} [options.fognum=0.13] 雾天气时，雾的浓度
	 * @param {Viewer} viewer viewer对象
	 */
	function WeatherEX(options, viewer) {
		if (_WeatherEX) {
			return _WeatherEX;
		}
		options = SceneGIS.defaultValue(options, SceneGIS.defaultValue.EMPTY_OBJECT);
		this.name = "WeatherEX";
		this._type = SceneGIS.defaultValue(options.type, WeatherType$1.SUN);
		this._viewer = viewer;
		this._visible = SceneGIS.defaultValue(options.visible, true);
		this._fognum = SceneGIS.defaultValue(options.fognum, 0.13);
		this.weather = new SceneGIS.WeatherPass({
			Viewer: viewer,
			url: './Assets/Images/tex16.png',
		});
		if (this._visible) {
			this.Set({ type: this._type });
		}
		_WeatherEX = this;
	}


	Object.defineProperties(WeatherEX.prototype, {
		/**
		* 获取viewer 对象
		* @memberof WeatherEX.prototype
		*
		* @type {Viewer}
		* @readonly
		*/
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		},
		/**
		 * 抗锯齿类型
		 * @memberof WeatherEX.prototype
		 *
		 * @type {String}
		 */
		type: {
			get: function () {
				return SceneGIS.defined(this._type) ? this._type : undefined;
			},
			set: function (val) {
				this._type = val;
				this.Set({ type: this._type });
			}
		},
		/**
		 * 天气生效
		 * @memberof WeatherEX.prototype
		 *
		 * @type {Boolean}
		 */
		visible: {
			get: function () {
				return this._visible;
			},
			set: function (val) {
				this._visible = val;
				if (this._visible) {
					this.Set({ type: this._type });
				} else {
					this.stop();
				}

			}
		},
		/**
		 * 雾浓度
		 * @memberof WeatherEX.prototype
		 *
		 * @type {Float}
		 */
		fognum: {
			get: function () {
				return this._fognum;
			},
			set: function (val) {
				this._fognum = val;
				if (this._visible) {
					this.Set({ type: this._type, fognum: this._fognum });
				} else {
					this.stop();
				}
			}
		},
	});

	/**
	 * 天气设置
	 *
	 * @param {Object} [options] 天气的配置属性，可为空
	 * @param {String} [options.type='sun'] 天气类型,默认sun[1-sun,2-rain,3-snow,4-fog]
	 * @param {String} [options.fognum=0.13] 雾天气时雾的浓度
	 */

	WeatherEX.prototype.Set = function (options) {
		options = SceneGIS.defaultValue(options, SceneGIS.defaultValue.EMPTY_OBJECT);
		let type = options.type;
		this._type = SceneGIS.defined(type) ? type : this._type;
		let stages = this._viewer.scene.postProcessStages._stages;
		var postProcessStages = this._viewer.scene.postProcessStages;
		let snowStage = stages.find((item) => item.name == 'czm_snow');
		let rainStage = stages.find((item) => item.name == 'czm_rain');
		let fogStage = stages.find((item) => item.name == 'czm_fog');
		if (postProcessStages.contains(snowStage)) {
			postProcessStages.remove(snowStage);
		}
		if (postProcessStages.contains(rainStage)) {
			postProcessStages.remove(rainStage);
		}
		if (postProcessStages.contains(fogStage)) {
			postProcessStages.remove(fogStage);
		}
		if (this._type === WeatherType$1.SUN) {
			this.weather.switchSun();
		}
		else if (this._type === WeatherType$1.RAIN) {
			this.weather.switchRain();
		}
		else if (this._type === WeatherType$1.SNOW) {
			this.weather.switchSnow();
		}
		else if (this._type === WeatherType$1.FOG) {

			let fog = new FogEX({}, this._viewer);
			this._fognum = SceneGIS.defaultValue(options.fognum, this._fognum);
			fog.Set(this._fognum);
		}
	};

	WeatherEX.prototype.stop = function () {
		let stages = this._viewer.scene.postProcessStages._stages;
		var postProcessStages = this._viewer.scene.postProcessStages;
		let snowStage = stages.find((item) => item.name == 'czm_snow');
		let rainStage = stages.find((item) => item.name == 'czm_rain');
		let fogStage = stages.find((item) => item.name == 'czm_fog');
		if (postProcessStages.contains(snowStage)) {
			postProcessStages.remove(snowStage);
		}
		if (postProcessStages.contains(rainStage)) {
			postProcessStages.remove(rainStage);
		}
		if (postProcessStages.contains(fogStage)) {
			postProcessStages.remove(fogStage);
		}
		this.weather.switchSun();

	};

	/**
	 * 销毁操作，销毁内部事件和临时对象
	 */
	WeatherEX.prototype.destroy = function () {
		this.stop();
	};

	/**
	 * 天空盒类型
	 * @readonly
	 * @enum {string}
	 */
	const SkyBoxType = {
		/**
		 * 清晨
		 * @type {string}
		 * @constant
		 */
		MORNING: "morning",
		/**
		 * 正午
		 * @type {string}
		 * @constant
		 */
		NOON: "noon",
		/**
		 * 傍晚
		 * @type {string}
		 * @constant
		 */
		AFTERNOON: "afternoon",
		/**
		 * 夜晚
		 * @type {string}
		 * @constant
		 */
		NIGHT: "night"
	};

	var SkyBoxType$1 = Object.freeze(SkyBoxType);

	var _SkyBoxEX = undefined;
	/**
	 * 天空盒
	 *
	 * @class SkyBoxEX
	 * @constructor
	 * 
	 * @param {Object} options 配置
	 * @param {Boolean} options.visible 是否生效
	 * @param {SkyBoxType} [options.type = SkyBoxType.NOON] 天空盒类型,默认SkyBoxType.NOON {@link SkyBoxType}
	 * @param {Viewer} viewer viewer对象
	 */
	function SkyBoxEX(options, viewer) {
		if (_SkyBoxEX) {
			return _SkyBoxEX;
		}
		options = SceneGIS.defaultValue(options, SceneGIS.defaultValue.EMPTY_OBJECT);
		this.name = "SkyBoxEX";
		this._viewer = viewer;
		viewer.defaultSkybox = viewer.scene.skyBox;
		this.defaultSkybox = viewer.defaultSkybox;
		this._visible = SceneGIS.defaultValue(options.visible, false);
		this._type = SceneGIS.defaultValue(options.type, SkyBoxType$1.NOON);
		this._EventListener = null;
		this.planeView = viewer.scene.planeView;
		if (this._visible) {
			this.Set({ type: this._type });
		} else {
			this.stop();
		}
		_SkyBoxEX = this;
	}


	Object.defineProperties(SkyBoxEX.prototype, {
		/**
		* 获取viewer 对象
		* @memberof SkyBoxEX.prototype
		*
		* @type {Viewer}
		* @readonly
		*/
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		},
		/**
		 * 天空盒生效
		 * @memberof SkyBoxEX.prototype
		 *
		 * @type {Boolean}
		*/
		visible: {
			get: function () {
				return this._visible;
			},
			set: function (val) {
				this._visible = val;
				if (this._visible) {
					this.Set({});
				} else {
					this.stop();
				}
			}
		},
		/**
		 * 天空盒类型
		 * @memberof SkyBoxEX.prototype
		 *
		 * @type {String}
		*/
		type: {
			get: function () {
				return this._type;
			},
			set: function (val) {
				this._type = val;
				if (this._visible) {
					this.Set({ type: this._type });
				} else {
					this.stop();
				}
			}
		},


	});

	/**
	 * 天空盒
	 *
	 * @param {Object} [options] 天空盒属性，可为空
	 * @param {Object} [options.type] 天空盒类型
	 */

	SkyBoxEX.prototype.Set = function (options) {
		options = SceneGIS.defaultValue(options, SceneGIS.defaultValue.EMPTY_OBJECT);
		this._type = SceneGIS.defaultValue(options.type, this._type);
		if (this._EventListener) this._EventListener();
		var groundSkybox = undefined;
		if (this._type === SkyBoxType$1.NOON) {
			if (this._EventListener) this._EventListener();
			var date = "October 13, 1975 " + "12:00" + ":00";
			var jsdate = new Date(date);
			const currentTime = SceneGIS.JulianDate.fromDate(jsdate, new SceneGIS.JulianDate());
			this._viewer.clock.currentTime = currentTime;
			if (this.planeView != true) {
				this._viewer.scene.skyBox = this.defaultSkybox;
			}
			this._viewer.scene.skyAtmosphere.show = this.planeView === true ? false : true;
		} else if (this._type === SkyBoxType$1.MORNING || this._type === SkyBoxType$1.AFTERNOON) {
			var date = "October 13, 1975 " + "20:00" + ":00";
			var jsdate = new Date(date);
			const currentTime = SceneGIS.JulianDate.fromDate(jsdate, new SceneGIS.JulianDate());
			this._viewer.clock.currentTime = currentTime;
			groundSkybox = new SceneGIS.SkyBox({
				sources: {
					negativeY: CoreEX.getAssetUrl("img/pano_0_180.png"), //前 对
					positiveX: CoreEX.getAssetUrl("img/pano_3_left90.png"), //右 对
					positiveY: CoreEX.getAssetUrl("img/pano_2.png"), //背   对
					negativeX: CoreEX.getAssetUrl("img/pano_1_right90.png"), //左 对
					positiveZ: CoreEX.getAssetUrl("img/pano_4_180.png"), //顶
					negativeZ: CoreEX.getAssetUrl("img/pano_5.png"), //底  对
				},
				alpha: 1,
			});
			this._viewer.scene.skyBoxForPlaneMode = groundSkybox;
			this._viewer.scene.skyAtmosphere.show = false;
		} else if (this._type === SkyBoxType$1.NIGHT) {
			if (this._EventListener) this._EventListener();
			var date = "October 13, 1975 " + "20:00" + ":00";
			var jsdate = new Date(date);
			const currentTime = SceneGIS.JulianDate.fromDate(jsdate, new SceneGIS.JulianDate());
			this._viewer.clock.currentTime = currentTime;
			this._viewer.scene.skyBox = this.defaultSkybox;
			groundSkybox = this.defaultSkybox;
			this._viewer.scene.skyBoxForPlaneMode = groundSkybox;
			this._viewer.scene.skyAtmosphere.show = false;
		}
		//只有球面坐标系才走这段逻辑
		if (this.planeView != true) {
			this._EventListener = this._viewer.scene.preUpdate.addEventListener(() => {
				if (this._type != SkyBoxType$1.NOON) {
					const position = this._viewer.scene.camera.position;
					const cameraHeight = SceneGIS.Cartographic.fromCartesian(position).height;
					if (cameraHeight < 240000) {
						this._viewer.scene.skyAtmosphere.show = false;
						this._viewer.scene.skyBoxForPlaneMode = groundSkybox;
						const alpha = SceneGIS.Math.clamp(
							1 - (cameraHeight / 240000) * (cameraHeight / 240000),
							0,
							1
						);
						groundSkybox.setAlpha(alpha);
					} else {
						this._viewer.scene.skyBox = this.defaultSkybox;
						this._viewer.scene.skyAtmosphere.show = false;
					}
				} else {
					this._viewer.scene.skyBox = this.defaultSkybox;
					this._viewer.scene.skyAtmosphere.show = true;
				}
			});
		}

	};

	SkyBoxEX.prototype.stop = function () {
		if (this._EventListener) this._EventListener();
		if (this.planeView != true) {
			this._viewer.scene.skyBox = this.defaultSkybox;
		} else {
			var date = "October 13, 1975 " + "12:00" + ":00";
			var jsdate = new Date(date);
			const currentTime = SceneGIS.JulianDate.fromDate(jsdate, new SceneGIS.JulianDate());
			this._viewer.clock.currentTime = currentTime;
		}
		this._viewer.scene.skyAtmosphere.show = this.planeView === true ? false : true;
	};

	/**
	 * 销毁操作，销毁内部事件和临时对象
	 */
	SkyBoxEX.prototype.destroy = function () {
		this.stop();
	};

	var _UndergroundModeEX = undefined;
	/**
	 * 地下模式
	 *
	 * @class UndergroundModeEX
	 * @constructor
	 * 
	 * @param {Object} options 配置
	 * @param {Boolean} [options.visible=true] 是否生效,默认false
	 * @param {Float} [options.alpha = 0.6] 地表透明程度,默认0.6
	 * @param {Viewer} viewer viewer对象
	 */
	function UndergroundModeEX(options, viewer) {
		if (_UndergroundModeEX) {
			return _UndergroundModeEX;
		}
		options = SceneGIS.defaultValue(options, SceneGIS.defaultValue.EMPTY_OBJECT);
		this.name = "UndergroundModeEX";
		this._viewer = viewer;
		this._visible = SceneGIS.defaultValue(options.visible, false);
		this._alpha = SceneGIS.defaultValue(options.alpha, 0.6);
		if (this._visible) {
			this.Set({ alpha: this._alpha });
		}
		_UndergroundModeEX = this;
	}


	Object.defineProperties(UndergroundModeEX.prototype, {
		/**
		* 获取viewer 对象
		* @memberof UndergroundModeEX.prototype
		*
		* @type {Viewer}
		* @readonly
		*/
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		},
		/**
		 * 地下模式生效
		 * @memberof UndergroundModeEX.prototype
		 *
		 * @type {Boolean}
		 */
		visible: {
			get: function () {
				return this._visible;
			},
			set: function (val) {
				this._visible = val;
				if (this._visible) {
					this.Set({ alpha: this._alpha });
				} else {
					this.stop();
				}
			}
		},
		/**
		 * 透明度设置
		 * @memberof UndergroundModeEX.prototype
		 *
		 * @type {Float}
		 */
		alpha: {
			get: function () {
				return this._alpha;
			},
			set: function (val) {
				this._alpha = val;
				const globe = this._viewer.scene.globe;
				globe.translucency.frontFaceAlpha = this._alpha;
			}
		},
	});

	/**
	 * 设置地下模式效果
	 * @param {Object} option 配置
	 * @param {Float} option.alpha 地表透明程度
	 */

	UndergroundModeEX.prototype.Set = function (option) {
		option = SceneGIS.defaultValue(option, SceneGIS.defaultValue.EMPTY_OBJECT);
		this._alpha = SceneGIS.defaultValue(option.alpha, this._alpha);
		const scene = this._viewer.scene;
		const globe = scene.globe;
		// 开启地表透明
		globe.translucency.enabled = true;
		globe.translucency.frontFaceAlpha = this._alpha;

		scene.screenSpaceCameraController.inertiaZoom = 0.5;
		scene.screenSpaceCameraController.enableCollisionDetection = false;
	};
	/**
	 * 恢复默认
	 */
	UndergroundModeEX.prototype.stop = function () {
		const scene = this._viewer.scene;
		const globe = scene.globe;
		globe.translucency.enabled = false;
		scene.screenSpaceCameraController.enableCollisionDetection = true;
	};

	/**
	 * 销毁操作，销毁内部事件和临时对象
	 */
	UndergroundModeEX.prototype.destroy = function () {
		this.stop();
	};

	var _DepthTestEX = undefined;
	/**
	 * 深度检测
	 *
	 * @class DepthTestEX
	 * @constructor
	 * 
	 * @param {Object} options 配置
	 * @param {Boolean} [options.visible=true] 是否生效,默认false
	 * @param {Viewer} viewer viewer对象
	 */
	function DepthTestEX(options, viewer) {
		if (_DepthTestEX) {
			return _DepthTestEX;
		}
		options = SceneGIS.defaultValue(options, SceneGIS.defaultValue.EMPTY_OBJECT);
		this.name = "DepthTestEX";
		this._viewer = viewer;
		this._visible = SceneGIS.defaultValue(options.visible, false);
		if (this._visible) {
			this.Set();
		}
		_DepthTestEX = this;
	}


	Object.defineProperties(DepthTestEX.prototype, {
		/**
		* 获取viewer 对象
		* @memberof DepthTestEX.prototype
		*
		* @type {Viewer}
		* @readonly
		*/
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		},
		/**
		 * 地下模式生效
		 * @memberof DepthTestEX.prototype
		 *
		 * @type {Boolean}
		 */
		visible: {
			get: function () {
				return this._visible;
			},
			set: function (val) {
				this._visible = val;
				if (this._visible) {
					this.Set();
				} else {
					this.stop();
				}
			}
		},
	});

	/**
	 * 开启深度检测
	 */

	DepthTestEX.prototype.Set = function () {
		this._viewer.scene.globe.depthTestAgainstTerrain = true;//开启地形深度检测
	};
	/**
	 * 恢复默认
	 */
	DepthTestEX.prototype.stop = function () {
		this._viewer.scene.globe.depthTestAgainstTerrain = false;
	};

	/**
	 * 销毁操作，销毁内部事件和临时对象
	 */
	DepthTestEX.prototype.destroy = function () {
		this.stop();
	};

	var _SceneColorEX = undefined;
	/**
	 * 场景色调调整
	 *
	 * @class SceneColorEX
	 * @constructor
	 * 
	 * @param {Object} options 配置
	 * @param {Float} [options.Hscale = 1.0] 场景色相比例，默认1.0
	 * @param {Float} [options.Sscale = 1.0] 场景饱和度比例，默认1.0
	 * @param {Float} [options.Vscale = 1.0] 场景亮度比例，默认1.0
	 * @param {Boolean} [options.visible = false] 设置是否生效，默认false
	 * @param {Viewer} viewer viewer对象
	 */
	function SceneColorEX(options, viewer) {
		if (_SceneColorEX) {
			return _SceneColorEX;
		}
		this.name = "SceneColorEX";
		this._viewer = viewer;
		options = SceneGIS.defaultValue(options, SceneGIS.defaultValue.EMPTY_OBJECT);
		this._Hscale = SceneGIS.defaultValue(options.Hscale, 1.0);
		this._Sscale = SceneGIS.defaultValue(options.Sscale, 1.0);
		this._Vscale = SceneGIS.defaultValue(options.Vscale, 1.0);
		this._visible = SceneGIS.defaultValue(options.visible, false);
		this.postProcessStageComposite = undefined;
		this.init();
		if (this._visible) {
			this.Set({ Hscale: this._Hscale, Sscale: this._Sscale, Vscale: this._Vscale });
		}
		_SceneColorEX = this;
	}


	Object.defineProperties(SceneColorEX.prototype, {
		/**
		* 获取viewer 对象
		* @memberof SceneColorEX.prototype
		*
		* @type {Viewer}
		* @readonly
		*/
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		},
		/**
		 * 场景色相比例
		 * @memberof SceneColorEX.prototype
		 *
		 * @type {Float}
		 */
		Hscale: {
			get: function () {
				return SceneGIS.defined(this._Hscale) ? this._Hscale : undefined;
			},
			set: function (val) {
				this._Hscale = val;
				this.Set({ Hscale: this._Hscale });
			}
		},
		/**
		 * 场景饱和度比例
		 * @memberof SceneColorEX.prototype
		 *
		 * @type {Float}
		 */
		Sscale: {
			get: function () {
				return SceneGIS.defined(this._Sscale) ? this._Sscale : undefined;
			},
			set: function (val) {
				this._Sscale = val;
				this.Set({ Sscale: this._Sscale });
			}
		},
		/**
		 * 场景亮度比例
		 * @memberof SceneColorEX.prototype
		 *
		 * @type {Float}
		 */
		Vscale: {
			get: function () {
				return SceneGIS.defined(this._Vscale) ? this._Vscale : undefined;
			},
			set: function (val) {
				this._Vscale = val;
				this.Set({ Vscale: this._Vscale });
			}
		},
		/**
		 * 场景色调生效
		 * @memberof SceneColorEX.prototype
		 *
		 * @type {Boolean}
		 */
		visible: {
			get: function () {
				return this._visible;
			},
			set: function (val) {
				this._visible = val;
				if (this._visible) {
					this.Set({ Hscale: this._Hscale, Sscale: this._Sscale, Vscale: this._Vscale });
				} else {
					this.stop();
				}
			}
		},


	});

	SceneColorEX.prototype.init = function () {
		let that = this;
		var ShaderCode = `
      #version 300 es
      uniform sampler2D colorTexture;
      in vec2 v_textureCoordinates;
      uniform float Hscale;
      uniform float Sscale;
      uniform float Vscale;

      layout(location=0) out vec4 czm_fragColor;

      vec3 rgb2hsv(vec3 c) {
        vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
        vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

        float d = q.x - min(q.w, q.y);
        float e = 1.0e-10;
        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
      }
      vec3 hsv2rgb(vec3 c) {
        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
      }

      void main() {
        vec4 color = texture(colorTexture, v_textureCoordinates);//原始图像

        vec3 hsv = rgb2hsv(color.rgb);

        // Adjust HSV values (example: increase saturation)
        hsv.x *= Hscale;
        hsv.y *= Sscale;
        hsv.z *= Vscale;

        // Convert HSV back to RGB
        vec3 rgb = hsv2rgb(hsv);

        czm_fragColor = vec4(rgb, color.a);;
    }`;
		var postProcessStage = new SceneGIS.PostProcessStage({
			fragmentShader: ShaderCode,
			uniforms: {
				Hscale: function () {
					return that._visible === false ? 1.0 : that._Hscale;
				},
				Sscale: function () {
					return that._visible === false ? 1.0 : that._Sscale;
				},
				Vscale: function () {
					return that._visible === false ? 1.0 : that._Vscale;
				}
			}
		});
		that.postProcessStageComposite = new SceneGIS.PostProcessStageComposite({
			stages: [postProcessStage]
		});
		that._viewer.scene.postProcessStages.add(that.postProcessStageComposite);
	};

	/**
	 * 设置场景色调效果
	 * @param {Objct} option
	 * @param {Float} [option.Hscale = 1.0] 场景色相比例，默认1.0
	 * @param {Float} [option.Sscale = 1.0] 场景饱和度比例，默认1.0
	 * @param {Float} [option.Vscale = 1.0] 场景亮度比例，默认1.0
	 */

	SceneColorEX.prototype.Set = function (option) {
		option = SceneGIS.defaultValue(option, SceneGIS.defaultValue.EMPTY_OBJECT);
		this._Hscale = SceneGIS.defined(option.Hscale) ? option.Hscale : this._Hscale;
		this._Sscale = SceneGIS.defined(option.Sscale) ? option.Sscale : this._Sscale;
		this._Vscale = SceneGIS.defined(option.Vscale) ? option.Vscale : this._Vscale;

	};
	/**
	 * 恢复默认
	 */
	SceneColorEX.prototype.stop = function () {
		this._visible = false;
	};

	/**
	 * 销毁操作，销毁内部事件和临时对象
	 */
	SceneColorEX.prototype.destroy = function () {
		this.stop();
		this._viewer.scene.postProcessStages.remove(that.postProcessStageComposite);
	};

	var SetFactoryEX = {
		AAEX: function (options, viewer) {
			return new AAEX(options, viewer);
		},
		AOEX: function (options, viewer) {
			return new AOEX(options, viewer);
		},
		EnvironmentMapsEX: function (options, viewer) {
			return new EnvironmentMapsEX(options, viewer);
		},
		ShadowEX: function (options, viewer) {
			return new ShadowEX(options, viewer);
		},
		TimeEX: function (options, viewer) {
			return new TimeEX(options, viewer);
		},
		skyAtmosphereEX: function (options, viewer) {
			return new skyAtmosphereEX(options, viewer);
		},
		//天气设置里涵盖了FogEX
		WeatherEX: function (options, viewer) {
			return new WeatherEX(options, viewer);
		},
		SkyBoxEX: function (options, viewer) {
			return new SkyBoxEX(options, viewer);
		},
		UndergroundModeEX: function (options, viewer) {
			return new UndergroundModeEX(options, viewer);
		},
		DepthTestEX: function (options, viewer) {
			return new DepthTestEX(options, viewer);
		},
		SceneColorEX: function (options, viewer) {
			return new SceneColorEX(options, viewer);
		},
	};

	/** 
	* 设置类，常用的设置启动入口
	* @class SetEX
	*/
	class SetEX {
		/**
		 * @constructor
		 * @param {Object} options 配置
		 * @param {SetType} options.type 类型 {@link SetType}
		 * @param {Boolean} options.visible 是否生效
		 * @param {SceneGIS.Viewer} viewer 
		 */
		constructor(options, viewer) {
			this._viewer = viewer;
			options = SceneGIS.defaultValue(options, SceneGIS.defaultValue.EMPTY_OBJECT);
			this._type = options.type;
			if (!SceneGIS.defined(options.option)) {
				options.option = {};
			}
			console.log(options.option);
			this._visible = SceneGIS.defaultValue(options.visible, false);
			options.option["visible"] = this._visible;
			this.set = SetFactoryEX[this._type](options.option, this._viewer);
		}

		/**
		 * 销毁资源
		 */
		destroy() {
			if (this.set) {
				this.set.destroy();
				this.set = null;
			}
		}

		/**
		 * 获取类型
		 * @memberof SetEX.prototype
		 *
		 * @type {SetType} options.type 类型 {@link SetType}
		 */
		get type() {
			return this._type;
		}

		/**
		 * 设置类型
		 * @memberof SetEX.prototype
		 *
		 * @type {SetType} options.type 类型 {@link SetType}
		 */
		set type(val) {
			if (this._type != val) {
				this._type = val;
				this.destroy();
				this.set = SetFactoryEX[this._type]({}, this._viewer);
			}
		}

		/**
		 * 获取类型
		 * @memberof SetEX.prototype
		 *
		 * @type {Boolean} options.visible 是否生效
		 */
		get visible() {
			return this._visible;
		}

		/**
		 * 设置类型
		 * @memberof SetEX.prototype
		 *
		 * @type {Boolean} options.visible 是否生效
		 */
		set visible(val) {
			this._visible = val;
			if (this.set) {
				this.set.visible = this._visible;
			}
		}
	}

	/**
	 * 定点观察类
	 * @class StaticObservationEX
	 * @param {Object} options 
	 * @param {Number} options.height 观察的高度
	 * @param {Number} options.speed 观察的速度
	 * @param {Number} options.pitch 观察的俯仰角
	 * @param {SceneGIS.Viewer} viewer 
	 */
	function StaticObservationEX(options, viewer) {
		//设置默认值
		options = defaultValue$4(options, defaultValue$4.EMPTY_OBJECT);
		options.height = defaultValue$4(options.height, 1000);
		options.speed = defaultValue$4(options.speed, 0.5);
		options.pitch = defaultValue$4(options.pitch, 30);
		//检查类型
		CheckEX.instanceOf("viewer", viewer, SceneGIS.Viewer);
		CheckEX.typeOf("options.height", options.height, "number");
		CheckEX.typeOf("options.speed", options.speed, "number");
		CheckEX.typeOf("options.pitch", options.pitch, "number");

		this.name = "StaticObservationEX";
		this.viewer = viewer;
		this.height = parseFloat(options.height);
		this.speed = parseFloat(options.speed);
		this.pitch = parseFloat(options.pitch);
		this.worldPosition;
		this.setIntervalID = undefined;
		this.silhouetteGreen = undefined;
		this.pickedFeature = undefined;
		this.removeCallback = undefined;
		this.isrunning = false;
		this.init();
	}

	function defaultValue$4(a, b) {
		if (a !== undefined && a !== null) {
			return a;
		}
		return b;
	}
	defaultValue$4.EMPTY_OBJECT = Object.freeze({});
	//初始化操作
	/** @private */
	StaticObservationEX.prototype.init = function () {
		if (SceneGIS.PostProcessStageLibrary.isSilhouetteSupported(this.viewer.scene)) {
			this.silhouetteGreen = SceneGIS.PostProcessStageLibrary.createEdgeDetectionStage();
			this.silhouetteGreen.uniforms.color = SceneGIS.Color.LIME;
			this.silhouetteGreen.uniforms.length = 0.01;
			this.silhouetteGreen.selected = [];
			this.viewer.scene.postProcessStages.add(
				SceneGIS.PostProcessStageLibrary.createSilhouetteStage([
					this.silhouetteGreen,
				])
			);
		}
	};
	/**
	 * 开始功能
	 */
	StaticObservationEX.prototype.start = function () {
		this.addEvent();
		this.isrunning = true;
	};

	/**
	 * 暂停功能
	 */
	StaticObservationEX.prototype.stop = function () {
		this.removeEvent();
	};
	//添加事件
	/** @private */
	StaticObservationEX.prototype.addEvent = function () {
		if (this.handle) return;
		this.handle = new SceneGIS.ScreenSpaceEventHandler(this.viewer.canvas);
		this.viewer.scene.globe.depthTestAgainstTerrain = true;//开启地形深度检测
		var that = this;
		//添加事件
		this.handle.setInputAction(function (event) {
			that.LEFT_CLICK(event);
		}, SceneGIS.ScreenSpaceEventType.LEFT_CLICK);
		this.handle.setInputAction(function (event) {
			that.RIGHT_CLICK(event);
		}, SceneGIS.ScreenSpaceEventType.RIGHT_CLICK);
	};

	//获取当前点击三维坐标并旋转
	/** @private */
	StaticObservationEX.prototype.LEFT_CLICK = function (clickEvent) {
		if (this.setIntervalID) {
			clearInterval(this.setIntervalID);
		}
		this.clear();

		if (this.removeCallback) {
			this.removeCallback();  //去除监听事件
		}
		//当前点击的点的位置
		var position = {
			x: clickEvent.position.x,
			y: clickEvent.position.y
		};
		//获得点击的位置
		var pick = this.viewer.scene.pickPosition(position);
		if (pick) {
			var entity = this.viewer.entities.add({
				name: "旋转中心点",
				position: new SceneGIS.Cartesian3(pick.x, pick.y, pick.z),
				point: {
					color: new SceneGIS.Color(0, 0, 0, 0),
					pixelSize: 0
				}
			});
			var initialHeading = 0;
			// 步长
			let step = 0.1;
			var that = this;
			var time = 100 / that.speed;
			that.setIntervalID = setInterval(intervalFn, step * time);
			function intervalFn() {
				var offset = new SceneGIS.HeadingPitchRange(
					SceneGIS.Math.toRadians(initialHeading), // 水平方向的旋转角 0-360度
					-SceneGIS.Math.toRadians(that.pitch),// 垂直平面俯仰角 // 0-90度
					that.height  // 相机距离地球球心的距离
				);
				//if(that.exit === true) return;
				that.viewer.zoomTo(entity, offset);
				initialHeading += step;
				that.viewer.scene.screenSpaceCameraController.enableInputs = false;  //屏蔽屏幕输入事件
			}
			//高亮模型
			//获得点击的模型
			that.pickedFeature = that.viewer.scene.pick(position);
			if (that.pickedFeature) {
				//3Dtile
				if (that.pickedFeature instanceof SceneGIS.SceneGIS3DTileFeature) {
					that.pickedFeature.color = SceneGIS.Color.CYAN;
					const featureName = that.pickedFeature.getProperty("name");
					//获取当前楼的名字
					var buildiingName = featureName.split('_')[0];
					//给整个楼赋颜色
					that.pickedFeature.tileset.style = new SceneGIS.SceneGIS3DTileStyle({
						color: {
							conditions: [
								["regExp('^" + buildiingName + "').test(${feature['name'])}", "color('yellow')"],
							],
						},
						anchorLineColor: {
							conditions: [
								['color("red")'],
								['true', 'color("lime")']
							]
						}
					});
					//边线高亮
					//因为分为多个LOD，不同的LOD就是不同的feature，所以要找到这栋楼所有LOD对应的feature
					//然后再将这些lod给到silhouetteGreen里
					that.removeCallback = that.pickedFeature.tileset.tileVisible.addEventListener(LOD.bind(this));

				}
				else if (that.pickedFeature.primitive instanceof SceneGIS.SceneGIS3DTileset) {
					that.pickedFeature.primitive.style = new SceneGIS.SceneGIS3DTileStyle({
						color: "color('yellow')"
					});
				}

				else {
					//gltf物体
					that.pickedFeature.primitive.color = SceneGIS.Color.YELLOW;
				}
			}
		}
	};

	//获取可见feature的监听事件
	function LOD(tile) {
		var content = tile.content;
		var featuresLength = content.featuresLength;
		for (var i = 0; i < featuresLength; i++) {
			let feature = content.getFeature(i);
			let name = feature.getProperty("name").split('_')[0];
			let buildingName2 = this.pickedFeature.getProperty("name").split('_')[0];  //这里要重新获取一下buildingname，要不然就会变
			if (name === buildingName2) {
				this.silhouetteGreen.selected = [feature];
			}
		}
	}
	//停止飞行
	/** @private */
	StaticObservationEX.prototype.RIGHT_CLICK = function (clickEvent) {
		clearInterval(this.setIntervalID);
		this.viewer.scene.screenSpaceCameraController.enableInputs = true;  //恢复屏幕输入事件
	};

	/**
	 * 清空所有颜色及物体
	 */
	StaticObservationEX.prototype.clear = function () {
		if (this.pickedFeature) {
			//分层的3Dtile
			if (this.pickedFeature instanceof SceneGIS.SceneGIS3DTileFeature) {
				this.pickedFeature.tileset.style = new SceneGIS.SceneGIS3DTileStyle({
					color: "color('white')"
				});
			}
			//普通的3Dtile
			else if (this.pickedFeature.primitive instanceof SceneGIS.SceneGIS3DTileset) {
				this.pickedFeature.primitive.style = new SceneGIS.SceneGIS3DTileStyle({
					color: "color('white')"
				});
			}
			//gltf物体
			else {
				this.pickedFeature.primitive.color = SceneGIS.Color.WHITE;
			}
		}
		const entitys = this.viewer.entities._entities._array;
		let length = entitys.length;
		// 倒叙遍历防止实体减少之后entitys[f]不存在
		for (let f = length - 1; f >= 0; f--) {
			if (entitys[f]._name && (entitys[f]._name === '旋转中心点')) {
				this.viewer.entities.remove(entitys[f]);
			}
		}
		this.silhouetteGreen.selected = [];
	};

	StaticObservationEX.prototype.removeEvent = function () {
		if (this.handle) {
			this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.LEFT_CLICK);
			this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.RIGHT_CLICK);
			this.handle.destroy();
			this.handle = undefined;
		}
	};

	/**
	 * 清空所有颜色，销毁资源
	 */
	StaticObservationEX.prototype.destroy = function () {
		if (this.isrunning === false) return;
		if (this.setIntervalID) {
			clearInterval(this.setIntervalID);
		}
		this.viewer.scene.screenSpaceCameraController.enableInputs = true;  //恢复屏幕输入事件
		this.clear();
		if (this.removeCallback) {
			this.removeCallback();  //去除监听事件
		}
		this.viewer.scene.postProcessStages.removeAll();

		this.removeEvent();
		this.isrunning = false;
	};

	/**
	 * 开挖类，包括道路开挖和地形开挖
	 * @class RoadExcavationEXCore/
	 * @param {Object} options
	 * @param {Number} [options.height=10] 开挖深度
	 * @param {Number} [options.splitNum=50] 分割数目
	 * @param {String} [options.wallImg] 土壤盒子墙壁图案
	 * @param {String} [options.bottomImg] 土壤盒子底部图案
	 * @param {Boolean} [options.isbuildingClip=false] 是否为道路开挖|默认false,为地形开挖
	 * @param {Array} [options.tileset] 道路开挖时的tileset数据
	 * @param {SceneGIS.Viewer} viewer 
	 */
	function RoadExcavationEX(options, viewer) {
		//设置默认值
		options = SceneGIS.defined(options) ? options : {
			height: 10,
			splitNum: 50,
			wallImg: CoreEX.getAssetUrl("img/泥土剖面.png"),
			bottomImg: CoreEX.getAssetUrl("img/泥土底面.png"),
			isbuildingClip: false,
			tileset: null
		};
		//设置默认值
		options.height = SceneGIS.defaultValue(options.height, 10);
		options.splitNum = SceneGIS.defaultValue(options.splitNum, 50);
		options.wallImg = SceneGIS.defaultValue(options.wallImg, CoreEX.getAssetUrl("img/泥土剖面.png"));
		options.bottomImg = SceneGIS.defaultValue(options.bottomImg, CoreEX.getAssetUrl("img/泥土底面.png"));
		options.isbuildingClip = SceneGIS.defaultValue(options.isbuildingClip, false);

		//类型检查
		CheckEX.instanceOf("viewer", viewer, SceneGIS.Viewer);
		CheckEX.typeOf("options.height", options.height, "number");
		CheckEX.typeOf("options.isbuildingClip", options.isbuildingClip, "boolean");

		this.name = "RoadExcavationEX";

		this.options = options;
		this._viewer = viewer;
		this.callback = options.callback || undefined;

		this.positions = [];
		this.polygon = null;
		this.distance = 0;
		this.clippingPlanes = [];

		this.screenPoints = [];
		this.isClockwise = false;
		this.terrainClipPlan = undefined;
		this.viewer.scene.globe.depthTestAgainstTerrain = true;
		this.iswiseRing = undefined;

		this.isrunning = false;
	}

	Object.defineProperties(RoadExcavationEX.prototype, {
		/**
		* 获取 三维 viewer
		* @memberof RoadExcavationEX.prototype
		* @type {Viewer}
		* @readonly
		* @default undefined
		*/
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		}
	});
	/**
	 * 开始功能
	 */
	RoadExcavationEX.prototype.start = function () {
		//之前没有启动过
		if (this.isrunning == false) {
			this._draw = new CommanDrawEX({ callback: callback$6.bind(this) }, this._viewer);
			this._draw.setMode(CommanDrawModeEX$1.POLYGON);
			this._draw.pause = false;
			this.isrunning = true;
		}
		//之前启动过了
		else {
			this._draw.pause = false;
			this.isrunning = true;
		}
	};
	/**
	 * 暂停功能
	 */
	RoadExcavationEX.prototype.stop = function () {
		this._draw.pause = true;
	};

	RoadExcavationEX.prototype.removeEvent = function () {
		this._draw.pause = true;
	};
	function callback$6(data) {
		if (data.eventType && data.eventType === "rightClick") {
			//判断绘制的方向是否是逆时针
			var points = [];
			this.screenPoints = data.screenPoints.concat();
			for (let screenPoint of data.screenPoints) {
				var point = [];
				point.push(screenPoint.x);
				point.push(screenPoint.y);
				points.push(point);
			}
			var clockwiseRing = lineString(points);
			//false为顺时针，切不了，所以得转成逆时针
			this.iswiseRing = booleanClockwise(clockwiseRing);
			this.positions = data.position.concat();
			if (!this.iswiseRing) {
				var temp, temp2;
				for (let i = 0; i < this.positions.length / 2; i++) {
					temp = this.positions[i];
					this.positions[i] = this.positions[this.positions.length - 1 - i];
					this.positions[this.positions.length - 1 - i] = temp;
				}
				for (let i = 0; i < points.length / 2; i++) {
					temp2 = points[i];
					points[i] = points[points.length - 1 - i];
					points[points.length - 1 - i] = temp2;
				}
			}
			try {
				if (this.callback) {
					this.callback(this.positions);
				}
				analysis.bind(this)(points);
			} catch (e) {
				console.log(e);
			}
			finally {
				this._draw.removeAll();
			}
		}
	}
	/**
	 * 改变开挖深度
	 * @param {Number} val 地形开挖深度
	 */
	RoadExcavationEX.prototype.changeDepth = function (val) {
		console.log("地形裁剪深度为:", val);
		this.clear(true);
		this.options.height = val;
		if (val === NaN) return;

		if (this.positions.length < 3) {
			console.log("请先绘制完成开挖范围");
			return;
		}
		var arr = [];
		for (let s = 0; s < this.positions.length; s++) {
			let element = this.positions[s];
			arr.push({ x: element.x, y: element.y, z: element.z });
		}

		var points = [];
		for (let screenPoint of this.screenPoints) {
			var point = [];
			point.push(screenPoint.x);
			point.push(screenPoint.y);
			points.push(point);
		}
		if (!this.iswiseRing) {
			var temp2;
			for (let i = 0; i < points.length / 2; i++) {
				temp2 = points[i];
				points[i] = points[points.length - 1 - i];
				points[points.length - 1 - i] = temp2;
			}
		}

		this.terrainClipPlan = new TerrainClipPlan(this.viewer, this.options);
		this.terrainClipPlan.updateData(arr, points, true);
	};

	/**
	 * 移除开挖
	 */
	RoadExcavationEX.prototype.clear = function (isChange) {
		//this.terrainClipPlan.clear();
		if (this.viewer.scene.globe.clippingPlanes) {
			this.viewer.scene.globe.clippingPlanes.removeAll();
		}
		if (this.terrainClipPlan && this.terrainClipPlan.bottomSurface) {
			this.viewer.scene.primitives.remove(this.terrainClipPlan.bottomSurface);
		}
		if (this.terrainClipPlan && this.terrainClipPlan.wellWall) {
			this.viewer.scene.primitives.remove(this.terrainClipPlan.wellWall);
		}
		if (!SceneGIS.defined(isChange) || !isChange) {
			this.clearBuilding();
		}
	};

	/**
	 * @private
	 * 移除针对建筑物的开挖
	 */
	RoadExcavationEX.prototype.clearBuilding = function () {
		if (this.options.isbuildingClip) {
			for (let clippingPlane of this.clippingPlanes) {
				clippingPlane.removeAll();
			}
			this.clippingPlanes = [];

			this.distance = 0;

			if (this.polygon && this.polygon.polygonEntity) {
				this.viewer.entities.remove(this.polygon.polygonEntity);
			}
			this.polygon = null;
		}
	};
	/**
	 * 销毁资源
	 */
	RoadExcavationEX.prototype.destroy = function () {
		if (this.isrunning === false) return;

		this.distance = 0;

		if (this.polygon && this.polygon.polygonEntity) {
			this.viewer.entities.remove(this.polygon.polygonEntity);
		}

		this.polygon = null;
		this.clear();
		this.positions = [];
		if (this._draw) this._draw.destroy();
		this.isrunning = false;
	};

	function analysis(screenPoints) {
		var that = this;
		if (this.positions.length < 3) {
			console.log("请先绘制完成开挖范围");
			return;
		}
		this.clear();
		var arr = [];
		var polygon = [];
		for (let s = 0; s < this.positions.length; s++) {
			let element = this.positions[s];
			arr.push({ x: element.x, y: element.y, z: element.z });

			//转成经纬度
			var ellipsoid = that.viewer.scene.globe.ellipsoid;
			var cartesian3 = new SceneGIS.Cartesian3(element.x, element.y, element.z);
			var cart = ellipsoid.cartesianToCartographic(cartesian3);
			var lat = SceneGIS.Math.toDegrees(cart.latitude);
			var lng = SceneGIS.Math.toDegrees(cart.longitude);
			polygon.push({ x: lng, y: lat });
		}
		if (this.viewer.scene.planeView === true) {
			polygon = arr.concat([]);
		}
		if (that.options.isbuildingClip === true) {
			for (let tileset of that.options.tileset) {
				let transform = tileset.root.transform;
				//转换矩阵
				let inverseTransform = SceneGIS.Matrix4.inverseTransformation(transform, new SceneGIS.Matrix4());
				// clippingPlane集合
				let clippingPlanes1 = [];
				for (let i = 0; i < polygon.length - 1; i++) {
					let plane = createPlane$1.bind(that)(polygon[i], polygon[i + 1], inverseTransform);
					if (i === polygon.length - 2) {
						let plane = createPlane$1.bind(that)(polygon[i + 1], polygon[0], inverseTransform);
						clippingPlanes1.push(plane);
					}
					clippingPlanes1.push(plane);
				}
				// 创建裁剪平面
				let clippingPlane = new SceneGIS.ClippingPlaneCollection({
					//一组ClippingPlane对象，用于选择性地禁用每个平面外部的渲染。
					planes: clippingPlanes1,
					//应用于裁剪对象的边缘的高光的宽度（以像素为单位）
					edgeWidth: 1.0,
				});
				this.clippingPlanes.push(clippingPlane);
			}
			for (let i in that.options.tileset) {
				this.options.tileset[i].clippingPlanes = this.clippingPlanes[i];
			}
		}

		this.terrainClipPlan = new TerrainClipPlan(this.viewer, this.options);
		this.terrainClipPlan.updateData(arr, screenPoints, false);
	}

	function createPlane$1(p1, p2, inverseTransform) {
		let that = this;
		// 将仅包含经纬度信息的p1,p2，转换为相应坐标系的cartesian3对象
		let p1C3 = getOriginCoordinateSystemPoint.bind(that)(p1, inverseTransform);
		let p2C3 = getOriginCoordinateSystemPoint.bind(that)(p2, inverseTransform);
		// 定义一个垂直向上的向量up
		let up = new SceneGIS.Cartesian3(0, 0, 10);
		//  right 实际上就是由p1指向p2的向量 （这里是p2--》p1）
		let right = SceneGIS.Cartesian3.subtract(p2C3, p1C3, new SceneGIS.Cartesian3());
		// 计算normal， right叉乘up，得到平面法向量（垂直于两个向量），这个法向量指向right的右侧
		let normal = SceneGIS.Cartesian3.cross(right, up, new SceneGIS.Cartesian3());
		normal = SceneGIS.Cartesian3.normalize(normal, normal);

		//由于已经获得了法向量和过平面的一点，因此可以直接构造Plane,并进一步构造ClippingPlane
		let planeTmp = SceneGIS.Plane.fromPointNormal(p1C3, normal);
		return SceneGIS.ClippingPlane.fromPlane(planeTmp)
	}

	function getOriginCoordinateSystemPoint(point, inverseTransform) {
		let val;
		if (this.viewer.scene.planeView === true) {
			val = new SceneGIS.Cartesian3(point.x, point.y);
		}
		else {
			val = SceneGIS.Cartesian3.fromDegrees(point.x, point.y);
		}
		return SceneGIS.Matrix4.multiplyByPoint(
			inverseTransform, val, new SceneGIS.Cartesian3(0, 0, 0))
	}

	/**
	 * 建筑剖切类
	 * @class BuildingClipEX
	 * @param {Object} options 配置
	 * @param {String} [options.type="vertical"]  剖切方向,默认"vertical"-纵向剖切。"horizon"-横向剖切
	 * @param {String} [options.BuildingType="tileset"]  模型类型,默认"tileset"。另外一个类型是"glb"
	 * @param {Array} options.tilesets  需要剖切的模型数组
	 * @param {SceneGIS.Viewer} viewer 
	 */
	function BuildingClipEX(options, viewer) {
		CheckEX.instanceOf("viewer", viewer, SceneGIS.Viewer);
		this.viewer = viewer;
		this.tilesets = [];
		this.gltfs = [];
		this.clippingPlanes = [];
		this.plane;
		this.planeEntity;
		this.origin = [];
		this.size = 0;
		this.distance = [];
		this.rootTransform = [];
		this.createHandle;
		this.moveHandle;
		this.clipLinePositions = [];
		this.selectedPlane;
		this.Axis;
		this.planeCenter;
		this.toWorld;
		this.position;
		this.rotation;
		//平面坐标系下旋转矩阵
		this.Protation;
		this.toModel;
		this.originDistance = [];
		this.type = "";
		this.BuildingType = "";
		//设置默认值
		options = SceneGIS.defaultValue(options, SceneGIS.defaultValue.EMPTY_OBJECT);
		options.type = SceneGIS.defaultValue(options.type, "vertical");
		options.BuildingType = SceneGIS.defaultValue(options.BuildingType, "tileset");
		options.tilesets = SceneGIS.defaultValue(options.tilesets, []);
		//检查类型
		CheckEX.typeOf("options.type", options.type, "string");
		CheckEX.typeOf("options.BuildingType", options.BuildingType, "string");
		CheckEX.instanceOf("options.tilesets", options.tilesets, Array);
		this.options = options;
		this.isrunning = false;
	}

	/**
	 * 开始功能
	 */
	BuildingClipEX.prototype.start = function () {
		this.startFunc(this.options.tilesets, this.options.type, this.options.BuildingType);
		this.isrunning = true;
	};

	/**
	 * 暂停功能
	 */
	BuildingClipEX.prototype.stop = function () {
		this.removeEvent();
	};

	/**
	 * @private
	 * 开始建筑剖切功能
	 * @param {Array} tilesets tileset或者是glb 数据数组
	 * @param {String} type 剖切类型:"vertical"-纵向剖切; "horizon"-横向剖切
	 */
	BuildingClipEX.prototype.startFunc = function (tilesets, type, BuildingType) {
		this.type = type;
		for (var item of tilesets) {
			if (BuildingType == "tileset") {
				this.tilesets.push(item);
				if (item.root.boundingSphere.radius > this.size) {
					this.size = item.root.boundingSphere.radius;
				}
			}
			if (BuildingType == "glb") {
				this.gltfs.push(item);
				if (item.boundingSphere.radius > this.size) {
					this.size = item.boundingSphere.radius;
				}
			}
		}

		if (this.tilesets.length == 0 && this.gltfs.length == 0) {
			return;
		}

		var rootTransform;
		if (this.tilesets.length > 0) {
			for (let tileset of this.tilesets) {
				rootTransform = tileset.root.transform;
				let origin = SceneGIS.Matrix4.multiplyByPoint(rootTransform, new SceneGIS.Cartesian3(0, 0, 0), new SceneGIS.Cartesian3);
				if (SceneGIS.Matrix4.getMatrix3(rootTransform, new SceneGIS.Matrix3).equals(SceneGIS.Matrix3.IDENTITY)) {
					origin = tileset.root.boundingSphere.center;
					rootTransform = SceneGIS.Transforms.eastNorthUpToFixedFrame(origin);
				}
				this.origin.push(origin);
				this.rootTransform.push(rootTransform);
			}

		} else {
			for (let gltf of this.gltfs) {
				rootTransform = gltf.modelMatrix;
				let origin = SceneGIS.Matrix4.multiplyByPoint(rootTransform, new SceneGIS.Cartesian3(0, 0, 0), new SceneGIS.Cartesian3);
				this.origin.push(origin);
				this.rootTransform.push(rootTransform);
			}

		}
		this.createHandle = new SceneGIS.ScreenSpaceEventHandler(this.viewer.canvas);
		this.moveHandle = new SceneGIS.ScreenSpaceEventHandler(this.viewer.canvas);
		this.bindEvent();
	};
	/**
	 * 针对纵向切割，切割面旋转功能
	 * @param {float} val 旋转值(角度表达)
	 */
	BuildingClipEX.prototype.rotate = function (val) {
		val = parseFloat(val);
		var radian = SceneGIS.Math.toRadians(val);
		if (this.type == 'vertical') {
			this.rotation = SceneGIS.Matrix4.fromRotationTranslation(SceneGIS.Matrix3.fromRotationZ(radian));
			if (this.viewer.scene.planeView === true) {
				this.Protation = SceneGIS.Matrix4.fromRotationTranslation(SceneGIS.Matrix3.fromRotationY(SceneGIS.Math.toRadians(val + 44)));
			}
			for (let i in this.tilesets) {
				this.tilesets[i].clippingPlanes.modelMatrix = this.rotation;
			}
			for (let i in this.gltfs) {
				this.gltfs[i].clippingPlanes.modelMatrix = this.rotation;
			}
			//旋转后要重新计算distance  ??
			var length = this.tilesets.length || this.gltfs.length;
			for (let i = 0; i < length; i++) {
				var currentNormal = undefined;
				if (this.tilesets.length > 0) {
					currentNormal = SceneGIS.Matrix4.multiplyByPointAsVector(this.tilesets[i].clippingPlanes.modelMatrix, new SceneGIS.Cartesian3(1, 0, 0), new SceneGIS.Cartesian3);
				} else if (this.gltfs.length > 0) {
					currentNormal = SceneGIS.Matrix4.multiplyByPointAsVector(this.gltfs[i].clippingPlanes.modelMatrix, new SceneGIS.Cartesian3(1, 0, 0), new SceneGIS.Cartesian3);
				}
				var worldNormal = SceneGIS.Matrix4.multiplyByPointAsVector(this.toWorld, currentNormal, new SceneGIS.Cartesian3);
				var planeCenterToModelCenter = new SceneGIS.Cartesian3(this.planeCenter.x - this.position.x, this.planeCenter.y - this.position.y, this.planeCenter.z - this.position.z);
				this.distance[i] = -SceneGIS.Cartesian3.dot(planeCenterToModelCenter, worldNormal);

				var vectorCentorToP1 = new SceneGIS.Cartesian3(
					this.clipLinePositions[0].x - this.origin[i].x,
					this.clipLinePositions[0].y - this.origin[i].y,
					this.clipLinePositions[0].z - this.origin[i].z
				);
				var dot = SceneGIS.Cartesian3.dot(worldNormal, vectorCentorToP1);
				let distance = Math.abs(dot);
				if (dot > 0) {
					this.originDistance[i] = distance;
				} else {
					this.originDistance[i] = -distance;
				}
			}
		}
	};

	/**
	 * 移除切割面
	 */
	BuildingClipEX.prototype.clear = function () {
		for (let clippingPlane of this.clippingPlanes) {
			clippingPlane.removeAll();
		}
		this.clipLinePositions = [];
		this.viewer.entities.remove(this.planeEntity);
		this.viewer.entities.remove(this.Axis);
	};

	BuildingClipEX.prototype.removeEvent = function () {
		if (this.createHandle) this.createHandle.destroy();
		if (this.moveHandle) this.moveHandle.destroy();
	};

	/**
	 * 销毁资源
	 */
	BuildingClipEX.prototype.destroy = function () {
		if (this.isrunning === false) return;
		this.clear();
		this.removeEvent();
		this.isrunning = false;
	};
	/** @private */
	BuildingClipEX.prototype.bindEvent = function () {
		this.createHandle.setInputAction(addClipLinePositions.bind(this), SceneGIS.ScreenSpaceEventType.LEFT_CLICK);
		this.moveHandle.setInputAction(function (event) {
			var position = {
				x: event.position.x,
				y: event.position.y
			};
			var pickedObject = this.viewer.scene.pick(position);
			if (
				SceneGIS.defined(pickedObject) &&
				SceneGIS.defined(pickedObject.id)
			) {
				if (pickedObject.id.id == this.Axis.id || pickedObject.id.id == this.planeEntity.id) {
					this.selectedPlane = true;
					this.viewer.scene.screenSpaceCameraController.enableInputs = false;
				}
			}
		}.bind(this), SceneGIS.ScreenSpaceEventType.LEFT_DOWN);

		this.moveHandle.setInputAction(function () {
			this.selectedPlane = false;
			this.viewer.scene.screenSpaceCameraController.enableInputs = true;
		}.bind(this), SceneGIS.ScreenSpaceEventType.LEFT_UP);

		this.moveHandle.setInputAction(movePlane.bind(this), SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
	};

	function addClipLinePositions(event) {
		var position = {
			x: event.position.x,
			y: event.position.y
		};
		var pick = this.viewer.scene.pickPosition(position);
		console.log("pick", pick);
		if (pick) {
			var earthPosition = new SceneGIS.Cartesian3(pick.x, pick.y, pick.z);
			this.clipLinePositions.push(earthPosition);
			createPlane.bind(this)();
		}
	}

	function createPlane() {
		const planeView = this.viewer.scene.planeView;
		this.createHandle.removeInputAction(SceneGIS.ScreenSpaceEventType.LEFT_CLICK);
		this.position = this.clipLinePositions[0];
		this.planeCenter = this.position;
		if (planeView === true) {
			this.toWorld = SceneGIS.Matrix4.fromTranslation(this.position);
		} else {
			this.toWorld = SceneGIS.Transforms.eastNorthUpToFixedFrame(this.position);
		}
		this.toModel = SceneGIS.Matrix4.inverse(this.toWorld, new SceneGIS.Matrix4);
		if (this.type == 'vertical') {
			this.rotation = SceneGIS.Matrix4.fromRotationTranslation(SceneGIS.Matrix3.fromRotationZ(SceneGIS.Math.toRadians(0)));
			this.Protation = SceneGIS.Matrix4.fromRotationTranslation(SceneGIS.Matrix3.fromRotationY(SceneGIS.Math.toRadians(44)));
			let normal = new SceneGIS.Cartesian3(1, 0, 0);

			var length = this.tilesets.length || this.gltfs.length;
			for (let i = 0; i < length; i++) {
				let distance = 0;
				this.plane = new SceneGIS.Plane(normal, distance);
				this.distance.push(distance);
				var vectorCentorToP1 = new SceneGIS.Cartesian3(
					this.clipLinePositions[0].x - this.origin[i].x,
					this.clipLinePositions[0].y - this.origin[i].y,
					this.clipLinePositions[0].z - this.origin[i].z
				);
				let originDistance = SceneGIS.Matrix4.multiplyByPointAsVector(this.toModel, vectorCentorToP1, new SceneGIS.Cartesian3).x;
				this.originDistance.push(originDistance);

				let clipPlane = new SceneGIS.ClippingPlane(normal, 0);
				var clippingPlane = new SceneGIS.ClippingPlaneCollection({
					planes: [
						clipPlane
					],
					edgeWidth: 1.0
				});
				this.clippingPlanes.push(clippingPlane);
			}
			for (let i in this.tilesets) {
				this.tilesets[i].clippingPlanes = this.clippingPlanes[i];
			}
			for (let i in this.gltfs) {
				this.gltfs[i].clippingPlanes = this.clippingPlanes[i];
			}
			//添加面
			var that = this;
			this.planeEntity = that.viewer.entities.add({
				position: new SceneGIS.CallbackProperty(function () {
					return that.planeCenter;
				}, false),
				name: "plane",
				plane: {
					material: new SceneGIS.ImageMaterialProperty({
						image: CoreEX.getAssetUrl("img/clipPlane.png"),
						repeat: new SceneGIS.Cartesian2(5, 5),
						transparent: true
					}),
					plane: new SceneGIS.CallbackProperty(function () {
						for (var i in that.clippingPlanes) {
							that.clippingPlanes[i]._planes[0].distance = that.distance[i] - that.originDistance[i];
						}
						if (that.viewer.scene.planeView == true) {
							SceneGIS.Matrix4.multiplyByPointAsVector(that.Protation, normal, that.plane.normal);
						} else {
							SceneGIS.Matrix4.multiplyByPointAsVector(that.rotation, normal, that.plane.normal);
						}
						return that.plane;
					}, false),
					dimensions: new SceneGIS.Cartesian2(
						Math.min(this.size, 80),
						Math.min(this.size, 80)
					),
				}
			});

			//添加轴
			var radius = -100;
			//this.xAxisPositions = [this.position.clone(), SceneGIS.Matrix4.multiplyByPoint(this.matrix, new SceneGIS.Cartesian3(this.radius, 0, 0), new SceneGIS.Cartesian3())];//绘制X轴的点坐标
			this.Axis = this.viewer.entities.add({
				id: "move_zAxis",
				name: "zAxis",
				polyline: {
					positions: new SceneGIS.CallbackProperty(function () {
						var modelWorldNormal = undefined;
						if (that.tilesets.length > 0) {
							modelWorldNormal = SceneGIS.Matrix4.multiplyByPointAsVector(that.tilesets[0].clippingPlanes.modelMatrix, normal, new SceneGIS.Cartesian3());
						} else if (that.gltfs.length > 0) {
							modelWorldNormal = SceneGIS.Matrix4.multiplyByPointAsVector(that.gltfs[0].clippingPlanes.modelMatrix, normal, new SceneGIS.Cartesian3());
						}
						modelWorldNormal = SceneGIS.Matrix4.multiplyByPointAsVector(that.toWorld, modelWorldNormal, new SceneGIS.Cartesian3);
						//箭头起点
						var position0 = that.planeCenter.clone();
						//箭头终点
						var position1 = SceneGIS.Cartesian3.add(that.planeCenter.clone(),
							SceneGIS.Cartesian3.multiplyByScalar(modelWorldNormal, radius, new SceneGIS.Cartesian3),
							new SceneGIS.Cartesian3());
						var Positions = [
							position0,
							position1
						];
						return Positions;
					}, false),
					width: 15,
					arcType: SceneGIS.ArcType.NONE,
					material: new SceneGIS.PolylineArrowMaterialProperty(
						SceneGIS.Color.RED
					),
					depthTest: false
				},
			});
		}
		else if (this.type == 'horizon') {
			//转成经纬度
			var ellipsoid = this.viewer.scene.globe.ellipsoid;
			var cartesian3 = new SceneGIS.Cartesian3(this.clipLinePositions[0].x, this.clipLinePositions[0].y, this.clipLinePositions[0].z);
			var cart = ellipsoid.cartesianToCartographic(cartesian3);
			let distance;
			let normal;
			if (planeView === true) {
				distance = cartesian3.z;
				normal = new SceneGIS.Cartesian3(0.0, -1.0, 0.0);
			} else {
				distance = cart.height;
				normal = new SceneGIS.Cartesian3(0.0, 0.0, -1.0);
			}

			var length = this.tilesets.length || this.gltfs.length;
			for (let i = 0; i < length; i++) {
				this.distance.push(distance);
			}
			var originDistance = this.distance[0];
			//this.clipPlane = new SceneGIS.ClippingPlane(new SceneGIS.Cartesian3(0.0, 0.0, -1.0), this.distance);
			this.plane = new SceneGIS.Plane(normal, this.distance[0]);
			var length = this.tilesets.length || this.gltfs.length;
			for (let i = 0; i < length; i++) {
				let clipPlane = new SceneGIS.ClippingPlane(new SceneGIS.Cartesian3(0.0, 0.0, -1.0), this.distance[0]);
				var clippingPlane = new SceneGIS.ClippingPlaneCollection({
					planes: [
						clipPlane
					],
					edgeWidth: 1.0
				});
				this.clippingPlanes.push(clippingPlane);
			}
			for (let i in this.tilesets) {
				this.tilesets[i].clippingPlanes = this.clippingPlanes[i];
			}
			for (let i in this.gltfs) {
				this.gltfs[i].clippingPlanes = this.clippingPlanes[i];
			}

			//添加面
			var that = this;
			this.planeEntity = this.viewer.entities.add({
				id: SceneGIS.createGuid(),
				position: this.clipLinePositions[0],
				plane: {
					dimensions: new SceneGIS.Cartesian2(
						Math.min(this.size, 50),
						Math.min(this.size, 100)
					),
					material: new SceneGIS.ImageMaterialProperty({
						image: CoreEX.getAssetUrl("img/clipPlane.png"),
						repeat: new SceneGIS.Cartesian2(5, 5),
						transparent: true
					}),
					plane: new SceneGIS.CallbackProperty(
						function () {
							//更新clipPlane
							for (var clipPlane of that.clippingPlanes) {
								clipPlane._planes[0].distance = that.distance[0];
							}
							that.plane.distance = that.distance[0] - originDistance;
							return that.plane;
						},
						false
					),
				},
			});
			//添加轴
			var radius = -100;
			//this.xAxisPositions = [this.position.clone(), SceneGIS.Matrix4.multiplyByPoint(this.matrix, new SceneGIS.Cartesian3(this.radius, 0, 0), new SceneGIS.Cartesian3())];//绘制X轴的点坐标
			this.Axis = this.viewer.entities.add({
				id: "move_zAxis",
				name: "zAxis",
				polyline: {
					positions: new SceneGIS.CallbackProperty(function () {
						var distance = -1 * (that.distance[0] - originDistance);
						var modelWorldNormal;
						if (planeView === true) {
							modelWorldNormal = new SceneGIS.Cartesian3(0.0, 0.0, -1.0);
						} else {
							modelWorldNormal = SceneGIS.Matrix4.multiplyByPointAsVector(that.rootTransform[0], new SceneGIS.Cartesian3(0.0, 0.0, -1.0), new SceneGIS.Cartesian3);
						}
						//箭头起点
						var position0 = SceneGIS.Cartesian3.add(that.clipLinePositions[0].clone(),
							SceneGIS.Cartesian3.multiplyByScalar(modelWorldNormal, distance, new SceneGIS.Cartesian3),
							new SceneGIS.Cartesian3());
						//箭头终点
						var position1 = SceneGIS.Cartesian3.add(SceneGIS.Cartesian3.add(that.clipLinePositions[0].clone(),
							SceneGIS.Cartesian3.multiplyByScalar(modelWorldNormal, distance, new SceneGIS.Cartesian3),
							new SceneGIS.Cartesian3()),
							SceneGIS.Cartesian3.multiplyByScalar(modelWorldNormal, radius, new SceneGIS.Cartesian3),
							new SceneGIS.Cartesian3());
						var Positions = [
							position0,
							position1
						];
						return Positions;
					}, false),
					width: 15,
					arcType: SceneGIS.ArcType.NONE,
					material: new SceneGIS.PolylineArrowMaterialProperty(
						SceneGIS.Color.RED
					),
					depthTest: false
				},
			});
		}

	}

	function movePlane(e) {
		const planeView = this.viewer.scene.planeView;
		if (this.selectedPlane) {
			var screenVector = undefined;
			if (this.type == 'vertical') {
				screenVector = new SceneGIS.Cartesian3(e.endPosition.x - e.startPosition.x, -(e.endPosition.y - e.startPosition.y), 0);
			} else if (this.type == 'horizon') {
				this.viewer.scene.globe.depthTestAgainstTerrain = false;
				screenVector = new SceneGIS.Cartesian3(0, 0, e.startPosition.y - e.endPosition.y);//平面向量
			}
			screenVector = SceneGIS.Matrix4.multiplyByPointAsVector(this.viewer.camera.inverseViewMatrix, screenVector, screenVector);
			screenVector = SceneGIS.Matrix4.multiplyByPointAsVector(this.toModel, screenVector, screenVector);
			var primitiveInCamera = new SceneGIS.Matrix4.multiplyByPoint(this.viewer.camera.viewMatrix, this.position, new SceneGIS.Cartesian3());
			var width = -primitiveInCamera.z * Math.tan(this.viewer.camera.frustum.fov / 2) * 2;
			var factor = width / this.viewer.canvas.width;

			var dis, worldNormal, modelWorldNormal;
			if (planeView === true) {
				//平面坐标系基于模型剖切面的法向量做移动
				if (this.tilesets.length > 0) {
					modelWorldNormal = SceneGIS.Matrix4.multiplyByPointAsVector(this.tilesets[0].clippingPlanes.modelMatrix, new SceneGIS.Cartesian3(1, 0, 0), new SceneGIS.Cartesian3());
				} else if (this.gltfs.length > 0) {
					modelWorldNormal = SceneGIS.Matrix4.multiplyByPointAsVector(this.gltfs[0].clippingPlanes.modelMatrix, new SceneGIS.Cartesian3(1, 0, 0), new SceneGIS.Cartesian3());
				}
				modelWorldNormal = SceneGIS.Matrix4.multiplyByPointAsVector(this.toWorld, modelWorldNormal, new SceneGIS.Cartesian3);
				dis = SceneGIS.Cartesian3.dot(screenVector, modelWorldNormal) * factor;
				worldNormal = SceneGIS.Matrix4.multiplyByPointAsVector(this.toWorld, modelWorldNormal, new SceneGIS.Cartesian3);
			} else {
				//球面坐标系基于plane的法向量做移动
				dis = SceneGIS.Cartesian3.dot(screenVector, this.plane.normal) * factor;
				worldNormal = SceneGIS.Matrix4.multiplyByPointAsVector(this.toWorld, this.plane.normal, new SceneGIS.Cartesian3);
			}
			var length = this.tilesets.length || this.gltfs.length;
			for (let i = 0; i < length; i++) {
				this.distance[i] += -dis;
			}
			if (this.type == 'vertical') {
				if (planeView === true) {
					this.planeCenter = new SceneGIS.Cartesian3(this.planeCenter.x + modelWorldNormal.x * dis, this.planeCenter.y + modelWorldNormal.y * dis, this.planeCenter.z);
				} else {
					this.planeCenter = new SceneGIS.Cartesian3(this.planeCenter.x + worldNormal.x * dis, this.planeCenter.y + worldNormal.y * dis, this.planeCenter.z + worldNormal.z * dis);
				}
			} else {
				this.planeCenter = new SceneGIS.Cartesian3(this.planeCenter.x, this.planeCenter.y, this.planeCenter.z + worldNormal.y * dis);
			}
		}
	}

	/**
	 * 飞行线路类
	 * @class FlyEX
	 * @param {Object} options 
	 * @param {Function} options.callback 回调函数
	 * @param {Object} options.callback.position 位置:{lng:经度,lat:纬度,alt:高度}
	 * @param {Object} options.callback.camera 保存的相机视口参数 {destination:笛卡尔坐标,orientation:{heading,pitch,roll}}
	 * @param {Object} options.callback.isViewChange 当前选点是否更改了视口
	 * @param {SceneGIS.Viewer} viewer 
	 */
	function FlyEX(options, viewer) {
		options = defaultValue$3(options, defaultValue$3.EMPTY_OBJECT);
		//检查
		CheckEX.instanceOf("viewer", viewer, SceneGIS.Viewer);
		this.name = "FlyEX";
		this._viewer = viewer;
		//#region 飞行参数
		this.isflying = false;
		this.Exection = undefined;
		//保存相机模型的信息
		this.cameraEntitys = [];
		this.floatingPoints = [];
		this.drawLines = [];
		this.Aircraft = undefined;
		//SceneGIS 事件
		viewer.scene.globe.depthTestAgainstTerrain = true;//开启地形深度检测
		this.cartesian = undefined;
		this.positions = [];
		this.pickModel = undefined;
		//保存路线的回调函数
		this.callback = options.callback;
		this.addEvent();
		//保存cesium相机的旋转信息
		this.cameraviews = [];
		//保存cesium相机的位置信息
		this.camerapositions = [];
		//当前视口是否保存的标志
		this.saveflag = false;

		//坐标轴编辑
		this.control = undefined;
		this.originMatrix = undefined;

		//气泡
		// this._billboards = undefined;
		// this._billboard = undefined;
		//关键帧的回调函数
		this.triggerCallbacks = [];
		this.triggerStopTimes = [];

		this.planeView = viewer.scene.planeView;
		//所有的点位信息
		this.cameras = [];
		//跟随配置
		this.followCarType = "";
		this.followHeading = 0;
		this.followPitch = 0;
		this.followRange = 0;
	}

	function defaultValue$3(a, b) {
		if (a !== undefined && a !== null) {
			return a;
		}
		return b;
	}
	defaultValue$3.EMPTY_OBJECT = Object.freeze({});

	Object.defineProperties(FlyEX.prototype, {
		/**
		* 获取viewer 对象
		* @memberof FlyEX.prototype
		*
		* @type {SceneGIS.Viewer}
		* @readonly
		*/
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		},
	});

	/** @private */
	FlyEX.prototype.addEvent = function () {
		if (this.handle) return;
		this.handle = new SceneGIS.ScreenSpaceEventHandler(this.viewer.canvas);
		var that = this;
		//添加事件
		this.handle.setInputAction(function (event) {
			that.RIGHT_CLICK(event);
		}, SceneGIS.ScreenSpaceEventType.RIGHT_CLICK);

		this.handle.setInputAction(function (event) {
			that.LEFT_DOUBLE_CLICK(event);
		}, SceneGIS.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);

	};
	/** @private */
	FlyEX.prototype.removeEvent = function () {
		if (!this.handle) return;
		this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.RIGHT_CLICK);
		this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
		this.handle = undefined;
	};
	/** @private */
	FlyEX.prototype.LEFT_DOUBLE_CLICK = function (clickEvent) {
		for (let floatingPoint of this.floatingPoints) {
			floatingPoint.show = false;
		}
		for (let drawLine of this.drawLines) {
			drawLine.polyline.show = false;
		}
		//  提示用户保存上一个视口的修改
		if (this.pickModel && this.saveflag === false
			&& this.originMatrix
			&& this.pickModel.primitive.modelMatrix
			&& !this.pickModel.primitive.modelMatrix.equals(this.originMatrix)) {
			alert("之前的视口修改未保存，请选择保存或恢复");
			return;
		}
		this.saveflag = false;

		//当前点击的点的位置
		var position = {
			x: clickEvent.position.x,
			y: clickEvent.position.y
		};
		var pick = this.viewer.scene.pickPosition(position);
		//获得点击的模型
		this.pickModel = this.viewer.scene.pick(position);
		if (this.pickModel && pick) {
			if (this.pickModel.id && this.pickModel.id.indexOf("相机") > -1) {
				var index = this.cameraEntitys.findIndex((item) => item.id === this.pickModel.id);
				//当前点的headingpitchroll值
				this.cameraviews[index];
				//当前点的世界坐标
				var cameraposition = this.camerapositions[index];
				//回调，显示当前的经纬度
				if (this.callback && typeof this.callback === 'function') {
					if (this.planeView === true) {
						this.callback({ index: index, position: cameraposition, isViewChange: true });
					} else {
						var pos = transformCartesianToWGS84$1(this.viewer, cameraposition);
						this.callback({ index: index, position: pos, isViewChange: true });
					}

				}            //编辑轴同步
				if (!this.control) {
					this.control = new SceneGIS.TransformControls(this.viewer);
					this.control.setMode(1);
					this.viewer.scene.primitives.add(this.control);
				}
				this.control.attach(this.pickModel.primitive);
				if (this.pickModel.primitive) {
					this.originMatrix = SceneGIS.Matrix4.clone(
						this.pickModel.primitive.modelMatrix,
						new SceneGIS.Matrix4()
					);
				}
			}
		}
	};

	/**
	 * 选择飞行路线点
	 * @param {Number} addIndex 当前选点索引
	 * @returns {Object} camera 当前选点的视口信息，包括:{destination:世界坐标,orientation(弧度值):{heading,pitch,roll}}
	 */
	FlyEX.prototype.select = function (addIndex) {
		var camera = {
			destination: undefined,
			orientation: {
				heading: 0,
				pitch: 0,
				roll: 0
			}
		};
		camera.destination = this.viewer.camera.position.clone();
		camera.orientation.heading = this.viewer.camera.heading;
		camera.orientation.pitch = this.viewer.camera.pitch;
		camera.orientation.roll = this.viewer.camera.roll;
		this.addModel(camera, addIndex);
		return camera;
	};

	/**
	 * 注入关键帧的触发事件或暂停时间
	 * @param {Function} func 触发事件方法
	 * @param {Number} time 暂停时间
	 * @param {Number} index 关键帧索引
	 */
	FlyEX.prototype.addTriggeredEvent = function (func, time, index) {
		//长度不够先扩展
		if (this.triggerCallbacks.length < (index + 1)) {
			this.triggerCallbacks.length = index + 1;
		}
		if (this.triggerStopTimes.length < (index + 1)) {
			this.triggerStopTimes.length = index + 1;
		}

		if (SceneGIS.defined(func) && typeof func === 'function') {
			this.triggerCallbacks[index] = func;
		}
		if (SceneGIS.defined(time)) {
			this.triggerStopTimes[index] = time;
		}
		console.log("this.triggerCallbacks:", this.triggerCallbacks, " this.triggerStopTimes:", this.triggerStopTimes);
	};

	/** @private */
	//圆弧插值的触发事件函数
	FlyEX.prototype.triggeredEvent = function (keyIndex, speed, index) {
		let self = this;
		if (SceneGIS.defined(this.triggerStopTimes[keyIndex]) && SceneGIS.defined(this.triggerCallbacks[keyIndex])) {
			index += 3;
			if (typeof this.triggerCallbacks[keyIndex] === 'function') {
				this.triggerCallbacks[keyIndex]();
			} setTimeout(function () {
				setClock$1(1 / speed, self.viewer);
				self.viewer.clock.onTick.addEventListener(self.Exection);
			}, this.triggerStopTimes[keyIndex] * 1000);
		}
		//只定义了暂停事件
		else if (SceneGIS.defined(this.triggerStopTimes[keyIndex])) {
			index += 3;
			setTimeout(function () {
				setClock$1(1 / speed, self.viewer);
				self.viewer.clock.onTick.addEventListener(self.Exection);
			}, this.triggerStopTimes[keyIndex] * 1000);
		}
		else if (SceneGIS.defined(this.triggerCallbacks[keyIndex])) {
			index += 3;
			if (typeof this.triggerCallbacks[keyIndex] === 'function') {
				this.triggerCallbacks[keyIndex]();
			} setClock$1(1 / speed, this.viewer);
			this.viewer.clock.onTick.addEventListener(this.Exection);
		}
		return index;
	};

	FlyEX.prototype.removeTriggeredEvent = function () {
		this.triggerCallbacks = [];
		this.triggerStopTimes = [];
	};


	/** @private */
	//保存当前选点位置和角度的修改
	FlyEX.prototype.save = function (index) {
		//点击保存，则标志位置为true
		this.saveflag = true;
		let originPos = this.viewer.camera.position.clone();
		let orientation = {
			heading: this.viewer.camera.heading,
			pitch: this.viewer.camera.pitch,
			roll: this.viewer.camera.roll,
		};
		var modelMatrix = undefined;
		if (this.pickModel && this.pickModel.primitive) {
			modelMatrix = SceneGIS.Matrix4.clone(
				this.pickModel.primitive.modelMatrix,
				new SceneGIS.Matrix4()
			);
		}
		if (modelMatrix) {
			//拿到位置的世界坐标
			let WSposition = SceneGIS.Matrix4.getTranslation(modelMatrix, new SceneGIS.Cartesian3());
			//拿到旋转矩阵
			var upNormal = new SceneGIS.Cartesian3(0, 0, 1);
			var up = SceneGIS.Matrix4.multiplyByPointAsVector(modelMatrix, upNormal, new SceneGIS.Cartesian3());
			SceneGIS.Cartesian3.normalize(up, up);
			var directionNormal = new SceneGIS.Cartesian3(1, 0, 0);
			var direction = SceneGIS.Matrix4.multiplyByPointAsVector(modelMatrix, directionNormal, new SceneGIS.Cartesian3());
			SceneGIS.Cartesian3.normalize(direction, direction);

			this.camerapositions[index] = WSposition;
			this.floatingPoints[index].position = WSposition.clone();

			this.viewer.camera.setView({
				destination: WSposition,
				orientation: {
					direction: direction,
					up: up
				}
			});

			let cameraview = {
				heading: this.viewer.camera.heading,
				pitch: this.viewer.camera.pitch,
				roll: this.viewer.camera.roll
			};
			this.cameraviews[index] = cameraview;

			if (this.callback && typeof this.callback === 'function') {
				var camera = {
					destination: undefined,
					orientation: {
						heading: 0,
						pitch: 0,
						roll: 0
					}
				};
				camera.destination = WSposition;
				camera.orientation.heading = this.viewer.camera.heading;
				camera.orientation.pitch = this.viewer.camera.pitch;
				camera.orientation.roll = this.viewer.camera.roll;
				this.callback({ index: index, camera: camera });
				this.cameras[index] = camera;
			}
		}
		this.viewer.camera.setView({
			destination: originPos,
			orientation: orientation
		});
	};

	/**
	 * 切换至调整选点位置功能
	 */
	FlyEX.prototype.transform = function () {
		if (this.pickModel && !this.control) {
			this.control = new SceneGIS.TransformControls(this.viewer);
			this.control.setMode(1);
			this.viewer.scene.primitives.add(this.control);
			this.control.attach(this.pickModel.primitive);
		}
	};
	/**
	 * 切换至调整选点旋转值功能
	 */
	FlyEX.prototype.rotate = function () {
		if (this.control && this.control != null) {
			this.viewer.scene.primitives.remove(this.control);
		}
		this.control = null;
		if (this.pickModel) {
			let modelMatrix = SceneGIS.Matrix4.clone(
				this.pickModel.primitive.modelMatrix,
				new SceneGIS.Matrix4()
			);
			var index = this.cameraEntitys.findIndex((item) => item.id === this.pickModel.id);
			var pos = SceneGIS.Matrix4.getTranslation(modelMatrix, new SceneGIS.Cartesian3());
			//当前点的headingpitchroll值
			var cameraview = this.cameraviews[index];
			//当前点的世界坐标
			var cameraposition = pos;
			//镜头同步
			this.viewer.camera.flyTo({
				destination: cameraposition,
				orientation: cameraview,
			});
		}
	};
	/**
	 * 更新当前选点的位置和角度
	 * @param {Object} options 
	 * @param {Number} [options.rotatex] 绕 X 轴旋转的角度,在模式'rotatex'下使用
	 * @param {Number} [options.rotatey] 绕 Y 轴旋转的角度,在模式'rotatey'下使用
	 * @param {Number} [options.rotatez] 绕 Z 轴旋转的角度,在模式'rotatez'下使用
	 * @param {String} type 模式:'rotatex' | 'rotatey' | 'rotatez'
	 * @param {Number} index 当前点的索引
	 */
	FlyEX.prototype.update = function (options, type, index) {
		var m1 = undefined;
		var rootTransform = this.pickModel.primitive.modelMatrix;
		var cameraposition = SceneGIS.Matrix4.getTranslation(rootTransform, new SceneGIS.Cartesian3());

		if (type === "rotatex") {
			m1 = SceneGIS.Matrix3.fromRotationX(SceneGIS.Math.toRadians(Number(options.rotatex)));
			rootTransform = this.pickModel.primitive.modelMatrix;
			rootTransform = SceneGIS.Matrix4.multiplyByMatrix3(rootTransform, m1, rootTransform);

			var upNormal = new SceneGIS.Cartesian3(0, 0, 1);
			var up = SceneGIS.Matrix4.multiplyByPointAsVector(rootTransform, upNormal, new SceneGIS.Cartesian3());
			SceneGIS.Cartesian3.normalize(up, up);
			var directionNormal = new SceneGIS.Cartesian3(1, 0, 0);
			var direction = SceneGIS.Matrix4.multiplyByPointAsVector(rootTransform, directionNormal, new SceneGIS.Cartesian3());
			SceneGIS.Cartesian3.normalize(direction, direction);

			this.viewer.camera.setView({
				destination: cameraposition,
				orientation: {
					direction: direction,
					up: up
				}
			});

			let cameraview = {
				heading: this.viewer.camera.heading,
				pitch: this.viewer.camera.pitch,
				roll: this.viewer.camera.roll
			};
			this.cameraviews[index] = cameraview;
		} else if (type === "rotatey") {
			m1 = SceneGIS.Matrix3.fromRotationY(SceneGIS.Math.toRadians(Number(options.rotatey)));
			rootTransform = this.pickModel.primitive.modelMatrix;
			rootTransform = SceneGIS.Matrix4.multiplyByMatrix3(rootTransform, m1, rootTransform);

			var upNormal = new SceneGIS.Cartesian3(0, 0, 1);
			var up = SceneGIS.Matrix4.multiplyByPointAsVector(rootTransform, upNormal, new SceneGIS.Cartesian3());
			SceneGIS.Cartesian3.normalize(up, up);
			var directionNormal = new SceneGIS.Cartesian3(1, 0, 0);
			var direction = SceneGIS.Matrix4.multiplyByPointAsVector(rootTransform, directionNormal, new SceneGIS.Cartesian3());
			SceneGIS.Cartesian3.normalize(direction, direction);
			this.viewer.camera.setView({
				destination: cameraposition,
				orientation: {
					direction: direction,
					up: up
				}
			});
			let cameraview = {
				heading: this.viewer.camera.heading,
				pitch: this.viewer.camera.pitch,
				roll: this.viewer.camera.roll
			};
			this.cameraviews[index] = cameraview;
		} else if (type === "rotatez") {
			m1 = SceneGIS.Matrix3.fromRotationZ(SceneGIS.Math.toRadians(Number(options.rotatez)));
			rootTransform = this.pickModel.primitive.modelMatrix;
			SceneGIS.Matrix4.multiplyByMatrix3(rootTransform, m1, rootTransform);

			var upNormal = new SceneGIS.Cartesian3(0, 0, 1);
			var up = SceneGIS.Matrix4.multiplyByPointAsVector(rootTransform, upNormal, new SceneGIS.Cartesian3());
			SceneGIS.Cartesian3.normalize(up, up);
			var directionNormal = new SceneGIS.Cartesian3(1, 0, 0);
			var direction = SceneGIS.Matrix4.multiplyByPointAsVector(rootTransform, directionNormal, new SceneGIS.Cartesian3());
			SceneGIS.Cartesian3.normalize(direction, direction);
			this.viewer.camera.setView({
				destination: cameraposition,
				orientation: {
					direction: direction,
					up: up
				}
			});
			let cameraview = {
				heading: this.viewer.camera.heading,
				pitch: this.viewer.camera.pitch,
				roll: this.viewer.camera.roll
			};
			this.cameraviews[index] = cameraview;
		}
		if (this.callback && typeof this.callback === 'function') {
			var camera = {
				destination: undefined,
				orientation: {
					heading: 0,
					pitch: 0,
					roll: 0
				}
			};
			camera.destination = this.viewer.camera.position.clone();
			camera.orientation.heading = this.viewer.camera.heading;
			camera.orientation.pitch = this.viewer.camera.pitch;
			camera.orientation.roll = this.viewer.camera.roll;
			this.callback({ index: index, camera: camera });
		}
	};
	/**
	 * 退出选点的调整
	 * @param {Number} index 当前点的索引
	 */
	FlyEX.prototype.exitAdjust = function (index) {
		this.save(index);
		for (let floatingPoint of this.floatingPoints) {
			floatingPoint.show = true;
		}
		if (this.control && this.control != null) {
			this.viewer.scene.primitives.remove(this.control);
		}
		this.control = null;
	};

	/** @private */
	FlyEX.prototype.RIGHT_CLICK = function (e) {
		debugger
		if (this.isflying) {
			this.exitFly();
		}
		this.isflying = false;
	};

	/**
	 * 暂停飞行
	 */
	FlyEX.prototype.exitFly = function () {
		if (this.Exection && typeof (this.Exection) == 'function') {
			this.viewer.clock.onTick.removeEventListener(this.Exection);
		}
		for (let floatingPoint of this.floatingPoints) {
			floatingPoint.show = true;
		}
		for (let cameraEntity of this.cameraEntitys) {
			cameraEntity.show = true;
		}
		if (this.drawLines.length > 0) {
			for (let drawLine of this.drawLines) {
				drawLine.polyline.show = true;
			}
		}
		this.isflying = false;
		this.viewer.trackedEntity = undefined;
	};

	/**
	 * 继续飞行
	 */
	FlyEX.prototype.goon = function (isAircraft) {
		if (this.followType === "fixfollow") {
			this.viewer.trackedEntity = this.Aircraft;
			this.Aircraft._heading = this.followHeading;
			this.Aircraft._pitch = this.followPitch;
			this.Aircraft._range = this.followRange;
		}
		if (this.Exection && typeof (this.Exection) == 'function') {
			this.viewer.clock.onTick.addEventListener(this.Exection);
		}
		for (let cameraEntity of this.cameraEntitys) {
			cameraEntity.show = false;
		}
		if (!isAircraft) {
			for (let floatingPoint of this.floatingPoints) {
				floatingPoint.show = false;
			}
			if (this.drawLines.length > 0) {
				for (let drawLine of this.drawLines) {
					drawLine.polyline.show = false;
				}
			}
		}
		this.isflying = true;
	};
	/**
	 * 销毁资源
	 */
	FlyEX.prototype.destroy = function () {
		this.isflying = false;
		if (this.Exection && typeof (this.Exection) == 'function') {
			this.viewer.clock.onTick.removeEventListener(this.Exection);
		}
		const entitys = this.viewer.entities._entities._array;
		let length = entitys.length;
		// 倒叙遍历防止实体减少之后entitys[f]不存在
		for (let f = length - 1; f >= 0; f--) {
			if (entitys[f]._name && (entitys[f]._name === '飞行路线' || entitys[f]._name === '飞行路线点')) {
				this.viewer.entities.remove(entitys[f]);
			}
		}
		for (let cameraEntity of this.cameraEntitys) {
			this.viewer.scene.primitives.remove(cameraEntity);
		}
		if (this.control && this.control != null) {
			this.viewer.scene.primitives.remove(this.control);
		}
		this.control = null;
		this.removeAircraftModel();
		// if(this._billboards) {
		//     this.viewer.scene.primitives.remove(this._billboards)
		//     this._billboards = undefined;
		// }
		this.removeEvent();
		this.removeTriggeredEvent();
		this.followType = "";
	};
	/**
	 * 清除路线
	 */
	FlyEX.prototype.clearRoute = function () {
		const entitys = this.viewer.entities._entities._array;
		let length = entitys.length;
		// 倒叙遍历防止实体减少之后entitys[f]不存在
		for (let f = length - 1; f >= 0; f--) {
			if (entitys[f]._name && (entitys[f]._name === '飞行路线')) {
				this.viewer.entities.remove(entitys[f]);
			}
		}
		//隐藏模型
		for (let floatingPoint of this.floatingPoints) {
			floatingPoint.show = false;
		}
		for (let cameraEntity of this.cameraEntitys) {
			cameraEntity.show = false;
		}
	};

	//modelHelper.VCesViewer的时钟设置
	function setClock$1(time, viewer) {
		//const { modelHelper.VCesViewer } = this;
		const startTime = SceneGIS.JulianDate.fromDate(new Date());
		const stopTime = SceneGIS.JulianDate.addSeconds(startTime, time, new SceneGIS.JulianDate());
		viewer.clock.startTime = startTime.clone();  // 开始时间
		viewer.clock.stopTime = stopTime.clone();     // 结速时间
		viewer.clock.currentTime = startTime.clone(); // 当前时间
		viewer.clock.clockRange = SceneGIS.ClockRange.CLAMPED; // 行为方式-达到终止时间后停止
		viewer.clock.clockStep = SceneGIS.ClockStep.SYSTEM_CLOCK; // 时钟设置为当前系统时间; 忽略所有其他设置。
	}

	/** @private */
	FlyEX.prototype.getBSRPoints = function (cameras3ds, length) {
		let points = [];
		for (let cameras3d of cameras3ds) {
			var point = [];
			point.push(cameras3d.x);
			point.push(cameras3d.y);
			point.push(cameras3d.z);
			points.push(point);
		}
		let arr = getBSR(points, length);
		arr.push([cameras3ds[cameras3ds.length - 1].x, cameras3ds[cameras3ds.length - 1].y, cameras3ds[cameras3ds.length - 1].z]);
		return arr
	};

	// 生成贝塞尔曲线
	function getBSR(points, length) {
		var ps = [];
		for (let point of points) {
			var p = {
				x: 0,
				y: 0,
				z: 0
			};
			p.x = point[0];
			p.y = point[1];
			p.z = point[2];
			ps.push(p);
		}
		let guijipoints = CreateBezierPoints(ps, length);
		return guijipoints
	}

	// 贝赛尔曲线算法
	function CreateBezierPoints(anchorpoints, pointsAmount) {
		var points = [];
		for (var i = 0; i < pointsAmount; i++) {
			var point = MultiPointBezier(anchorpoints, i / pointsAmount);
			points.push([point.x, point.y, point.z]);
		}
		return points;
	}
	function MultiPointBezier(points, t) {
		var len = points.length;
		var x = 0, y = 0, z = 0;
		var erxiangshi = function (start, end) {
			var cs = 1, bcs = 1;
			while (end > 0) {
				cs *= start;
				bcs *= end;
				start--;
				end--;
			}
			return (cs / bcs);
		};
		for (var i = 0; i < len; i++) {
			var point = points[i];
			x += point.x * Math.pow((1 - t), (len - 1 - i)) * Math.pow(t, i) * (erxiangshi(len - 1, i));
			y += point.y * Math.pow((1 - t), (len - 1 - i)) * Math.pow(t, i) * (erxiangshi(len - 1, i));
			z += point.z * Math.pow((1 - t), (len - 1 - i)) * Math.pow(t, i) * (erxiangshi(len - 1, i));
		}
		return { x: x, y: y, z: z };
	}

	//样本插值算法
	function Cardinalspline(points, tension, numOfSeg) {
		// console.log("numOfSeg",numOfSeg);
		tension = tension ? tension : 0.5;
		if (!numOfSeg) {
			var num = 25;
			numOfSeg = [];
			for (let k = 0; k < points.length / 3 - 1; k++) {
				numOfSeg.push(num);
			}
		}
		var pts, // for cloning point array
			l = points.length,
			rPos = 0,
			res = [],
			caches = [],
			cachePtrs = [];
		for (let k in numOfSeg) {
			var cache = [];
			cache[0] = 1;
			cache[1] = 0;
			cache[2] = 0;
			cache[3] = 0;
			caches.push(cache);
			var cachePtr = 4;
			cachePtrs.push(cachePtr);
		}

		pts = points.slice(0);
		pts.unshift(points[2]);
		pts.unshift(points[1]);                                        // copy 1. point and insert at beginning
		pts.unshift(points[0]);
		pts.push(points[l - 3], points[l - 2], points[l - 1]);        // duplicate end-points

		for (let j = 0; j < numOfSeg.length; j++) {
			for (let i = 1; i < numOfSeg[j]; i++) {
				var st = i / numOfSeg[j],
					st2 = st * st,
					st3 = st2 * st,
					st23 = st3 * 2,
					st32 = st2 * 3;

				caches[j][cachePtrs[j]++] = st23 - st32 + 1;        // c1
				caches[j][cachePtrs[j]++] = st32 - st23;                // c2
				caches[j][cachePtrs[j]++] = st3 - 2 * st2 + st;        // c3
				caches[j][cachePtrs[j]++] = st3 - st2;                        // c4
			}
			caches[j][cachePtrs[j]] = 0;
			caches[j][++cachePtrs[j]] = 1;
		}

		parse(pts, caches, l);
		function parse(pts, caches, l) {
			for (var i = 3, t; i < l; i += 3) {

				var pt1 = pts[i],
					pt2 = pts[i + 1],
					pt3 = pts[i + 2],
					pt4 = pts[i + 3],
					pt5 = pts[i + 4],
					pt6 = pts[i + 5],

					t1x = (pt4 - pts[i - 3]) * tension,
					t1y = (pt5 - pts[i - 2]) * tension,
					t1z = (pt6 - pts[i - 1]) * tension,
					t2x = (pts[i + 6] - pt1) * tension,
					t2y = (pts[i + 7] - pt2) * tension,
					t2z = (pts[i + 8] - pt3) * tension;

				for (t = 0; t < numOfSeg[Math.floor(i / 3) - 1]; t++) {

					var c = t << 2, //t * 4;

						c1 = caches[Math.floor(i / 3) - 1][c],
						c2 = caches[Math.floor(i / 3) - 1][c + 1],
						c3 = caches[Math.floor(i / 3) - 1][c + 2],
						c4 = caches[Math.floor(i / 3) - 1][c + 3];

					res[rPos++] = c1 * pt1 + c2 * pt4 + c3 * t1x + c4 * t2x;
					res[rPos++] = c1 * pt2 + c2 * pt5 + c3 * t1y + c4 * t2y;
					res[rPos++] = c1 * pt3 + c2 * pt6 + c3 * t1z + c4 * t2z;
				}
			}
		}
		l = points.length - 3;
		res[rPos++] = points[l];
		res[rPos++] = points[l + 1];
		res[rPos] = points[l + 2];
		return res;
	}

	/**
	 * 
	 * @param {Object} camera 添加的飞机模型位置及姿态
	 * @param {Object} camera.destination 世界坐标
	 * @param {Object} camera.orientation 方向(弧度值) {heading,pitch,roll}
	 */
	FlyEX.prototype.addAircraftModel = function (camera) {
		if (!camera) return

		//add Aircraft model
		const position = camera.destination;
		const heading = SceneGIS.Math.toRadians(SceneGIS.Math.toDegrees(camera.orientation.heading) - 90);
		const pitch = camera.orientation.pitch;
		const roll = camera.orientation.roll;
		const hpr = new SceneGIS.HeadingPitchRoll(heading, pitch, roll);
		const orientation = SceneGIS.Transforms.headingPitchRollQuaternion(
			position,
			hpr
		);
		this.Aircraft = this.viewer.entities.add({
			name: "汽车",
			position: position,
			orientation: orientation,
			model: {
				uri: CoreEX.getAssetUrl("glb/Car.glb"),
			}
		});
		this.Aircraft.model.scale = 1;
		console.log("oyyx this.Aircraft:", this.Aircraft);

		//添加气泡
		// let wgsPos;
		// if(this.planeView === true){
		//     wgsPos = JSON.parse(JSON.stringify(position));
		// }
		// else{
		//     wgsPos = transformCartesianToWGS84(this.viewer,position);
		//     wgsPos.alt += 20;
		//     wgsPos = transformWGS84ToCartesian(wgsPos);
		// }

		// if(!this._billboards) this._billboards = this.viewer.scene.primitives.add(new SceneGIS.BillboardCollection());
		// this._billboard = this._billboards.add({
		//     position: wgsPos,
		//     image: CoreEX.getAssetUrl("img/气泡.png"),
		//     scaleByDistance:new SceneGIS.NearFarScalar(200, 1, 10000, 0),
		//     pixelOffset:new SceneGIS.Cartesian2(0.0, -10.0),
		//     pixelOffsetScaleByDistance:new SceneGIS.NearFarScalar(200, 0.01, 8000, 2.5),
		//     distanceDisplayCondition:new SceneGIS.DistanceDisplayCondition(0,6000)
		// });
	};
	/**
	 * 去除飞行模型
	 */
	FlyEX.prototype.removeAircraftModel = function () {
		if (this.Aircraft) {
			this.viewer.entities.remove(this.Aircraft);
		}
		this.Aircraft = undefined;
		// if(this._billboard) {
		//     this._billboards.remove(this._billboard);
		//     this._billboard = undefined;
		// }
	};
	/**
	 * 去除指定点的模型（包括相机和点）
	 * @param {Number} index 索引
	 */
	FlyEX.prototype.deleteModel = function (index) {
		this.viewer.scene.primitives.remove(this.cameraEntitys[index]);
		this.viewer.entities.remove(this.floatingPoints[index]);
		if (this.control && this.control != null) {
			this.viewer.scene.primitives.remove(this.control);
		}
		this.control = null;
		this.pickModel = null;
	};
	/**
	 * 还原选点处模型的位置和角度
	 * @param {Number} index 当前选点的索引
	 * @param {Boolean} [isAxisShow=true] 编辑轴是否显示了
	 */
	FlyEX.prototype.resetModel = function (index, isAxisShow = true) {
		if (!isAxisShow) {
			if (this.control && this.control != null) {
				this.viewer.scene.primitives.remove(this.control);
			}
			this.control = null;
		}
		//还原了，也算是保存的一种方式，标志位置为true
		this.saveflag = true;
		this.cameraEntitys[index].modelMatrix = SceneGIS.clone(this.originMatrix);
		var pos = SceneGIS.Matrix4.getTranslation(this.originMatrix, new SceneGIS.Cartesian3());
		this.floatingPoints[index].position = pos.clone();
	};

	/**
	 * 在选择的点位上添加相机模型
	 * @param {Object} camera 选点的位置及方向
	 * @param {Object} camera.destination 世界坐标
	 * @param {Object} camera.orientation 方向(弧度值){heading,pitch,roll}
	 * @param {Number} index 选点的索引
	 */
	FlyEX.prototype.addModel = function (camera, index) {

		//存放视口旋转信息
		this.cameraviews.push(camera.orientation);
		//存放视口位置信息
		this.camerapositions.push(camera.destination);

		//add camera model
		const position = camera.destination;
		var floatingPoint = this.viewer.entities.add({
			name: '飞行路线点',
			position: position,
			point: {
				color: SceneGIS.Color.SKYBLUE,
				pixelSize: 10,
				outlineColor: SceneGIS.Color.YELLOW,
				outlineWidth: 3,
				//   disableDepthTestDistance: Number.POSITIVE_INFINITY,
			},
		});
		this.floatingPoints.push(floatingPoint);

		const heading = SceneGIS.Math.toRadians(SceneGIS.Math.toDegrees(camera.orientation.heading) - 90);
		const pitch = camera.orientation.pitch;
		const roll = camera.orientation.roll;

		//计算平移矩阵
		var transformM;
		if (this.planeView === true) {
			transformM = SceneGIS.Matrix4.fromTranslation(position, new SceneGIS.Matrix4());
		} else {
			transformM = SceneGIS.Transforms.eastNorthUpToFixedFrame(position);
		}
		//计算旋转矩阵
		var headingPitchRoll = new SceneGIS.HeadingPitchRoll(heading, pitch, roll);
		var rotate = SceneGIS.Matrix3.fromHeadingPitchRoll(headingPitchRoll, new SceneGIS.Matrix3());
		var rotateM = SceneGIS.Matrix4.fromRotationTranslation(rotate);
		//计算缩放矩阵
		var scaleM = SceneGIS.Matrix4.fromScale(new SceneGIS.Cartesian3(20, 20, 20));
		//计算最后的矩阵
		var m1 = SceneGIS.Matrix4.multiply(transformM, rotateM, new SceneGIS.Matrix4());
		var matrix = SceneGIS.Matrix4.multiply(m1, scaleM, new SceneGIS.Matrix4());
		var cameraEntity = this.viewer.scene.primitives.add(SceneGIS.Model.fromGltf({
			id: "相机" + index.toString(),
			url: CoreEX.getAssetUrl("glb/UE4Camera.glb"),
			modelMatrix: matrix,
		}));
		//存放相机model信息（矩阵）
		this.cameraEntitys.push(cameraEntity);
	};

	/**
	 * 绘制曲线
	 * @param {Object} camera 选点的位置及方向
	 * @param {Object} camera.destination 世界坐标
	 * @param {Object} camera.orientation 方向(弧度值){heading,pitch,roll}
	 * @param {Object} options
	 * @param {String} options.interpWays 插值方式:'直接插值' | '贝塞尔插值' | '圆弧插值'
	 * @param {Number} [options.tension] 圆弧程度，插值方式为'圆弧插值'时使用
	 */
	FlyEX.prototype.draw = function (cameras, options) {
		if (cameras.length < 2) return;
		this.cameras = cameras;
		if (options.interpWays === "直接插值") {
			this.drawLines = [];
			for (let j = 0; j < cameras.length - 1; j++) {
				var info = computeposition(cameras, j, 5);
				var positionsArr = [];
				for (let newCamera of info.newCameras) {
					positionsArr.push(newCamera.destination);
				}
				var drawLine = this.viewer.entities.add({
					name: '飞行路线',
					polyline: {
						positions: positionsArr,
						show: true,
						material: new SceneGIS.PolylineArrowMaterialProperty(
							SceneGIS.Color.SKYBLUE
						),
						width: 10,
						arcType: SceneGIS.ArcType.NONE,
						clampToGround: false,
						depthTest: false
					}
				});
				this.drawLines.push(drawLine);
			}
		} else if (options.interpWays === "贝塞尔插值") {
			this.drawLines = [];
			var cameras3ds = [];
			for (let camera of cameras) {
				var cameras3d = {
					x: 0,
					y: 0,
					z: 0
				};
				cameras3d.x = camera.destination.x;
				cameras3d.y = camera.destination.y;
				cameras3d.z = camera.destination.z;
				cameras3ds.push(cameras3d);
			}
			var arr = this.getBSRPoints(cameras3ds, 100);
			var linearr = [];
			for (let i in arr) {
				for (let j in arr[i]) {
					linearr.push(arr[i][j]);
				}
			}
			var drawLine = this.viewer.entities.add(
				{
					name: '飞行路线',
					polyline: {
						positions: SceneGIS.Cartesian3.unpackArray(linearr),
						show: true,
						material: new SceneGIS.PolylineArrowMaterialProperty(
							SceneGIS.Color.SKYBLUE
						),
						width: 10,
						arcType: SceneGIS.ArcType.NONE,
						clampToGround: false,
						depthTest: false
					},
				}
			);
			this.drawLines.push(drawLine);
		} else if (options.interpWays === "圆弧插值") {
			this.drawLines = [];
			var positionsArr = [];
			for (let camera of cameras) {
				positionsArr.push(camera.destination.x);
				positionsArr.push(camera.destination.y);
				positionsArr.push(camera.destination.z);
			}
			var cardinalarr = Cardinalspline(positionsArr, options.tension);
			//将坐标划分为10组
			let num = Math.ceil(cardinalarr.length / 3 / 10);
			let i = 0;
			while (i < num) {
				let arr;
				if (i == 0) {
					arr = cardinalarr.slice(0, (i + 1) * 30);
				} else if (i == (num - 1)) {
					arr = cardinalarr.slice(i * 30);
				} else {
					arr = cardinalarr.slice(i * 30, (i + 1) * 30);
				}
				var drawLine = this.viewer.entities.add(
					{
						name: '飞行路线',
						polyline: {
							positions: SceneGIS.Cartesian3.unpackArray(arr.slice(0)),
							show: true,
							material: new SceneGIS.PolylineArrowMaterialProperty(
								SceneGIS.Color.SKYBLUE
							),
							width: 10,
							arcType: SceneGIS.ArcType.NONE,
							clampToGround: false,
							depthTest: false
						},
					}
				);
				this.drawLines.push(drawLine);
				i++;
			}
		}
		//显示模型
		for (let floatingPoint of this.floatingPoints) {
			floatingPoint.show = true;
		}
		for (let cameraEntity of this.cameraEntitys) {
			cameraEntity.show = true;
		}
	};

	/**
	 * 开始飞行
	 * @param {Object} camera 选点的位置及方向
	 * @param {Object} camera.destination 世界坐标
	 * @param {Object} camera.orientation 方向(弧度值){heading,pitch,roll}
	 * @param {Object} options
	 * @param {String} [options.interpWays='圆弧插值'] 插值方式:'直接插值' |'贝塞尔插值' | '圆弧插值'
	 * @param {Array} options.times 飞行时间('直接插值'和'圆弧插值':每两点设置时间 | '贝塞尔插值':设置总时间)
	 * @param {Number} [options.tension] 圆弧程度，插值方式为'圆弧插值'时使用
	 * @param {String} [options.observeWays="camera"] 飞行方式: "car"-车载轨迹回放 | "camera"-相机视口飞行
	 * @param {Object} [options.observeOption] 车载轨迹回放时的配置项
	 * @param {String} [options.observeOption.followCarType = "fixfollow"] 车载轨迹回放方式:"allfollow"-全程跟随车，观察角度也跟着车的角度变化而变化
	 *                                                                                     "fixfollow"[默认]:跟随车，但是固定观察角度
	 *                                                                                     "nofollow":不跟随车，由用户自由变换视角
	 *                                                                                     "nocar":第一人称在车上,看不见车,此时heading pitch range无效
	 * @param {Float} [options.observeOption.heading = 0] 观察航向角，默认0
	 * @param {Float} [options.observeOption.pitch = pi/4] 观察俯仰角，"allfollow"默认pi/10，"fixfollow"默认pi/4
	 * @param {Number} [options.observeOption.range = 1000] 观察距离，"allfollow"默认1000，"fixfollow"默认100
	 */
	FlyEX.prototype.start = function (cameras, options) {
		//设置默认值
		options.interpWays = SceneGIS.defaultValue(options.interpWays, '圆弧插值');
		options.observeWays = SceneGIS.defaultValue(options.observeWays, "camera");
		if (options.observeWays === "car") {
			options.observeOption = SceneGIS.defaultValue(options.observeOption, {});
			options.observeOption.followCarType = SceneGIS.defaultValue(options.observeOption.followCarType, "fixfollow");
			options.observeOption.heading = SceneGIS.defaultValue(options.observeOption.heading, 0);
			if (options.observeOption.followCarType === "allfollow") {
				options.observeOption.pitch = SceneGIS.defaultValue(options.observeOption.pitch, SceneGIS.Math.pi / 10);
				options.observeOption.range = SceneGIS.defaultValue(options.observeOption.range, 100);
			} else if (options.observeOption.followCarType === "fixfollow") {
				options.observeOption.pitch = SceneGIS.defaultValue(options.observeOption.pitch, SceneGIS.Math.pi / 4);
				options.observeOption.range = SceneGIS.defaultValue(options.observeOption.range, 1000);
			} else if (options.observeOption.followCarType === "nocar") {
				options.observeOption.pitch = -SceneGIS.Math.PI / 100.0;
				options.observeOption.range = -100;
				options.observeOption.heading = 0;
			}
			this.followType = options.observeOption.followCarType;
			this.followHeading = options.observeOption.heading;
			this.followPitch = options.observeOption.pitch;
			this.followRange = options.observeOption.range;
		}
		//检查格式
		CheckEX.typeOf("options.interpWays", options.interpWays, "string");
		CheckEX.instanceOf("options.times", options.times, Array);
		CheckEX.typeOf("options.observeWays", options.observeWays, "string");
		var zeroTimeindex = options.times.findIndex((item) => item === 0);
		if (zeroTimeindex != -1) {
			return
		}
		if (this.isflying === true) return;
		this.isflying = true;
		//添加点击事件，避免之前destroy后右键无反应
		this.addEvent();
		//保存当前点位信息
		this.cameras = cameras;
		//隐藏相机、编辑轴、车子
		for (let cameraEntity of this.cameraEntitys) {
			cameraEntity.show = false;
		}
		if (this.control && this.control != null) {
			this.viewer.scene.primitives.remove(this.control);
		}
		this.control = null;
		this.removeAircraftModel();

		//车载轨迹回放
		if (options.observeWays === "car") {
			//在初始点位添加车子
			if (!this.Aircraft) this.addAircraftModel(cameras[0]);
			//锁定相机追踪
			if (this.followType !== "nofollow") {
				this.viewer.trackedEntity = this.Aircraft;
				this.Aircraft._heading = this.followHeading;
				this.Aircraft._pitch = this.followPitch;
				this.Aircraft._range = this.followRange;
			}

			//第一人称以外的显示路径
			if (this.followType !== "nocar") {
				for (let floatingPoint of this.floatingPoints) {
					floatingPoint.show = true;
				}
				if (this.drawLines.length > 0) {
					for (let drawLine of this.drawLines) {
						drawLine.polyline.show = true;
					}
				}
			} else {
				for (let floatingPoint of this.floatingPoints) {
					floatingPoint.show = false;
				}
				if (this.drawLines.length > 0) {
					for (let drawLine of this.drawLines) {
						drawLine.polyline.show = false;
					}
				}
			}
		}
		//相机飞行
		else {
			this.viewer.trackedEntity = undefined;
			//隐藏路径
			for (let floatingPoint of this.floatingPoints) {
				floatingPoint.show = false;
			}
			if (this.drawLines.length > 0) {
				for (let drawLine of this.drawLines) {
					drawLine.polyline.show = false;
				}
			}
		}
		var speed = 0;
		if (options.interpWays === "直接插值") {
			let j = 0;
			var info = computeposition(cameras, j, options.times[j]);
			speed = info.speed;
			setClock$1(1 / speed, this.viewer);
			var self = this;
			var index = 0;
			this.Exection = function TimeExecution() {
				//相机视角观察
				if (options.observeWays === "camera") {
					self.viewer.scene.camera.setView(info.newCameras[index]);
				}
				//飞机视角观察
				else if (options.observeWays === "car") {
					if (self.planeView === true) {
						let position = info.newCameras[index].destination;
						let nextpos;
						if (index <= info.newCameras.length - 2) {
							nextpos = info.newCameras[index + 1].destination;
						} else {
							nextpos = new SceneGIS.Cartesian3(0, 0, 0);
						}
						//位置
						let airposition = new SceneGIS.Cartesian3(position.x, position.y, position.z);
						//角度
						const direction = new SceneGIS.Cartesian3(position.x - nextpos.x, position.y - nextpos.y, position.z - nextpos.z);
						SceneGIS.Cartesian3.normalize(direction, direction);
						const right = SceneGIS.Cartesian3.cross(direction, SceneGIS.Cartesian3.UNIT_Z, new SceneGIS.Cartesian3());
						const rotate = new SceneGIS.Matrix3(right.x, direction.x, 0, right.y, direction.y, 0, right.z, direction.z, 1);
						const qua = SceneGIS.Quaternion.fromRotationMatrix(rotate);
						self.Aircraft.position = airposition;
						if (nextpos.x != 0) {
							self.Aircraft.orientation = qua;
						}
						if (self.followType === "fixfollow") {
							//在平面坐标系必须这样，要不然似乎地形会抬高
							self.viewer.trackedEntity = undefined;
							self.viewer.trackedEntity = self.Aircraft;
						}
						//观察视角变化
						else if (self.followType === "allfollow") {
							const hpr = SceneGIS.HeadingPitchRoll.fromQuaternion(qua);
							self.viewer.trackedEntity = undefined;
							if (nextpos.x != 0) {
								self.viewer.trackedEntity = self.Aircraft;
								self.Aircraft._heading = SceneGIS.Math.toRadians(SceneGIS.Math.toDegrees(hpr.heading) - 180);
							}
						} else if (self.followType === "nocar") {
							self.viewer.trackedEntity = undefined;
							self.Aircraft.show = false;
							let direction = new SceneGIS.Cartesian3(nextpos.x - position.x, nextpos.y - position.y, nextpos.z - position.z);
							let up = SceneGIS.Cartesian3.normalize(SceneGIS.Cartesian3.UNIT_Z, new SceneGIS.Cartesian3());
							let right = SceneGIS.Cartesian3.cross(direction, up, new SceneGIS.Cartesian3());
							SceneGIS.Cartesian3.cross(right, direction, up);
							if (nextpos.x != 0) {
								viewer.camera.setView({
									destination: airposition,
									orientation: {
										direction: direction,
										up: up
									}
								});
							}
						}
						// if(self._billboard)
						//     self._billboard.position = new SceneGIS.Cartesian3(airposition.x, airposition.y, airposition.z+20);
					} else {
						let position = JSON.parse(JSON.stringify(info.newCameras[index].destination));
						let pos1 = transformCartesianToWGS84$1(self.viewer, position);
						let pos2;
						if (index < info.newCameras.length - 2) {
							pos2 = transformCartesianToWGS84$1(self.viewer, info.newCameras[index + 1].destination.clone());
						}
						else {
							pos2 = JSON.parse(JSON.stringify(pos1));
						}
						const heading = SceneGIS.Math.toRadians(getheading(pos1.lat, pos1.lng, pos2.lat, pos2.lng) - 180);

						// let heading = SceneGIS.Math.toRadians(SceneGIS.Math.toDegrees(info.newCameras[index].orientation.heading)-90);
						let pitch = 0;
						let roll = 0;
						let hpr = new SceneGIS.HeadingPitchRoll(heading, pitch, roll);
						let orientation = SceneGIS.Transforms.headingPitchRollQuaternion(
							position,
							hpr
						);
						self.Aircraft.position = position;
						if (index < info.newCameras.length - 2) {
							self.Aircraft.orientation = orientation;
						}
						//观察视角变化
						if (self.followType === "allfollow") {
							const heading2 = SceneGIS.Math.toRadians(getheading(pos2.lat, pos2.lng, pos1.lat, pos1.lng) - 180 + self.followHeading);
							self.viewer.trackedEntity = undefined;
							self.viewer.trackedEntity = self.Aircraft;
							if (index < info.newCameras.length - 2) {
								self.Aircraft._heading = heading2;
							}
						} else if (self.followType === "nocar") {
							self.viewer.trackedEntity = undefined;
							self.Aircraft.show = false;
							let direction = new SceneGIS.Cartesian3(info.newCameras[index + 1].destination.x - info.newCameras[index].destination.x,
								info.newCameras[index + 1].destination.y - info.newCameras[index].destination.y,
								info.newCameras[index + 1].destination.z - info.newCameras[index].destination.z);
							let up = SceneGIS.Cartesian3.normalize(position, new SceneGIS.Cartesian3());
							let right = SceneGIS.Cartesian3.cross(direction, up, new SceneGIS.Cartesian3());
							SceneGIS.Cartesian3.cross(right, direction, up);
							viewer.camera.setView({
								destination: position,
								orientation: {
									direction: direction,
									up: up
								}
							});
						}
						// if(self._billboard)
						//     self._billboard.position = SceneGIS.Cartesian3.fromDegrees(pos1.lng, pos1.lat, pos1.alt+20);
					}
				}
				if (SceneGIS.JulianDate.compare(self.viewer.clock.currentTime, self.viewer.clock.stopTime) >= 0) {
					self.viewer.clock.onTick.removeEventListener(self.Exection);
					//点与点之间
					if (index < info.newCameras.length - 1) {
						index++;
						setClock$1(1 / speed, self.viewer);
						self.viewer.clock.onTick.addEventListener(self.Exection);
					}                //换到下一段了
					if (index === info.newCameras.length - 1 && j < cameras.length - 2) {
						self.viewer.clock.onTick.removeEventListener(self.Exection);
						j++;
						//定义了暂停和事件
						if (SceneGIS.defined(self.triggerStopTimes[j]) && SceneGIS.defined(self.triggerCallbacks[j])) {
							if (typeof self.triggerCallbacks[j] === 'function') {
								self.triggerCallbacks[j]();
							} setTimeout(function () {
								info = computeposition(cameras, j, options.times[j]);
								speed = info.speed;
								index = 0;
								setClock$1(1 / speed, self.viewer);
								self.viewer.clock.onTick.addEventListener(self.Exection);
							}, self.triggerStopTimes[j] * 1000);
						}
						//只定义了暂停
						else if (SceneGIS.defined(self.triggerStopTimes[j])) {
							setTimeout(function () {
								info = computeposition(cameras, j, options.times[j]);
								speed = info.speed;
								index = 0;
								setClock$1(1 / speed, self.viewer);
								self.viewer.clock.onTick.addEventListener(self.Exection);
							}, self.triggerStopTimes[j] * 1000);
						}
						//只定义了事件
						else if (SceneGIS.defined(self.triggerCallbacks[j])) {
							if (typeof self.triggerCallbacks[j] === 'function') {
								self.triggerCallbacks[j]();
							} info = computeposition(cameras, j, options.times[j]);
							speed = info.speed;
							index = 0;
							setClock$1(1 / speed, self.viewer);
							self.viewer.clock.onTick.addEventListener(self.Exection);
						}
						//什么都没定义
						else {
							info = computeposition(cameras, j, options.times[j]);
							speed = info.speed;
							index = 0;
							setClock$1(1 / speed, self.viewer);
							self.viewer.clock.onTick.addEventListener(self.Exection);
						}
					}
					//最后一帧显示相机
					if (index === info.newCameras.length - 1 && j == cameras.length - 2) {
						if (SceneGIS.defined(self.triggerCallbacks[j + 1])) {
							if (typeof self.triggerCallbacks[j + 1] === 'function') {
								self.triggerCallbacks[j + 1]();
							}
						}
						for (let floatingPoint of self.floatingPoints) {
							floatingPoint.show = true;
						}
						for (let cameraEntity of self.cameraEntitys) {
							cameraEntity.show = false;
						}
						if (self.drawLines.length > 0) {
							for (let drawLine of self.drawLines) {
								drawLine.polyline.show = true;
							}
						}
						self.isflying = false;
						self.viewer.trackedEntity = undefined;
					}
				}
			};
			this.viewer.clock.onTick.addEventListener(this.Exection);
		} else if (options.interpWays === "贝塞尔插值") {
			//计算得到当前需要运行的总时间
			var duration = 0;
			speed = 60;  //原理上应该是40，但是有系统误差，所以*1.5经验值消除误差
			duration = options.times[0] * 40;
			//角度插值
			var orientations = [];
			var adjustAngles = [];
			//角度首先得调整一下，要不然会360°旋转
			for (let i = 1; i < cameras.length; i++) {
				var startHeading = adjustAngleForLERP(cameras[i].orientation.heading, cameras[i - 1].orientation.heading);
				var startRoll = adjustAngleForLERP(cameras[i].orientation.roll, cameras[i - 1].orientation.roll);
				let diffHeading = startHeading - cameras[i].orientation.heading;
				let diffRoll = startRoll - cameras[i].orientation.roll;
				cameras[i].orientation.heading = cameras[i].orientation.heading + diffHeading;
				cameras[i].orientation.roll = cameras[i].orientation.roll + diffRoll;
				var adjustAngle = {
					heading: 0,
					pitch: 0,
					roll: 0,
				};
				adjustAngle.heading = startHeading;
				adjustAngle.pitch = cameras[i].orientation.pitch;
				adjustAngle.roll = startRoll;
				adjustAngles.push(adjustAngle);
			}
			adjustAngles.unshift(cameras[0].orientation);

			for (let camera of adjustAngles) {
				var orient = {
					x: 0,
					y: 0,
					z: 0
				};
				orient.x = camera.heading;
				orient.y = camera.pitch;
				orient.z = camera.roll;
				orientations.push(orient);
			}
			//角度的贝塞尔拟合
			var orientarr = this.getBSRPoints(orientations, duration);

			//位置插值
			var cameras3ds = [];
			for (let camera of cameras) {
				var cameras3d = {
					x: 0,
					y: 0,
					z: 0
				};
				cameras3d.x = camera.destination.x;
				cameras3d.y = camera.destination.y;
				cameras3d.z = camera.destination.z;
				cameras3ds.push(cameras3d);
			}
			var arr = this.getBSRPoints(cameras3ds, duration);

			setClock$1(1 / speed, this.viewer);
			var self = this;
			var index = 0;
			var position = { x: 0, y: 0, z: 0 };
			var nextpos = { x: 0, y: 0, z: 0 };
			var orientation = { heading: 0, pitch: 0, roll: 0 };
			this.Exection = function TimeExecution() {
				position.x = arr[index][0];
				position.y = arr[index][1];
				position.z = arr[index][2];
				nextpos.x = arr[index + 1][0];
				nextpos.y = arr[index + 1][1];
				nextpos.z = arr[index + 1][2];
				orientation.heading = orientarr[index][0];
				orientation.pitch = orientarr[index][1];
				orientation.roll = orientarr[index][2];
				if (options.observeWays === "camera") {
					self.viewer.scene.camera.setView({
						destination: position,
						orientation: orientation,
						observeCamera: true
					});
				}
				//车载轨迹回放
				else if (options.observeWays === "car") {
					if (self.planeView === true) {
						//位置
						let airposition = new SceneGIS.Cartesian3(position.x, position.y, position.z);
						//角度
						const direction = new SceneGIS.Cartesian3(position.x - nextpos.x, position.y - nextpos.y, position.z - nextpos.z);
						SceneGIS.Cartesian3.normalize(direction, direction);
						const right = SceneGIS.Cartesian3.cross(direction, SceneGIS.Cartesian3.UNIT_Z, new SceneGIS.Cartesian3());
						const rotate = new SceneGIS.Matrix3(right.x, direction.x, 0, right.y, direction.y, 0, right.z, direction.z, 1);
						const qua = SceneGIS.Quaternion.fromRotationMatrix(rotate);
						self.Aircraft.position = airposition;
						self.Aircraft.orientation = qua;
						if (self.followType === "fixfollow") {
							//在平面坐标系必须这样，要不然似乎地形会抬高
							self.viewer.trackedEntity = undefined;
							self.viewer.trackedEntity = self.Aircraft;
						}
						//观察视角变化
						else if (self.followType === "allfollow") {
							const hpr = SceneGIS.HeadingPitchRoll.fromQuaternion(qua);
							self.viewer.trackedEntity = undefined;
							self.viewer.trackedEntity = self.Aircraft;
							self.Aircraft._heading = SceneGIS.Math.toRadians(SceneGIS.Math.toDegrees(hpr.heading) - 180);
						} else if (self.followType === "nocar") {
							self.viewer.trackedEntity = undefined;
							self.Aircraft.show = false;
							let direction = new SceneGIS.Cartesian3(nextpos.x - position.x, nextpos.y - position.y, nextpos.z - position.z);
							let up = SceneGIS.Cartesian3.normalize(SceneGIS.Cartesian3.UNIT_Z, new SceneGIS.Cartesian3());
							let right = SceneGIS.Cartesian3.cross(direction, up, new SceneGIS.Cartesian3());
							SceneGIS.Cartesian3.cross(right, direction, up);
							viewer.camera.setView({
								destination: airposition,
								orientation: {
									direction: direction,
									up: up
								}
							});
						}
						// if(self._billboard)
						//     self._billboard.position = new SceneGIS.Cartesian3(airposition.x, airposition.y, airposition.z+20);
					} else {
						let airposition = JSON.parse(JSON.stringify(position));
						let airposition2 = JSON.parse(JSON.stringify(nextpos));
						let pos1 = transformCartesianToWGS84$1(self.viewer, airposition);
						let pos2 = transformCartesianToWGS84$1(self.viewer, airposition2);
						const heading = SceneGIS.Math.toRadians(getheading(pos1.lat, pos1.lng, pos2.lat, pos2.lng) - 180);
						let pitch = 0;
						let roll = 0;
						let hpr = new SceneGIS.HeadingPitchRoll(heading, pitch, roll);
						let airorientation = SceneGIS.Transforms.headingPitchRollQuaternion(
							airposition,
							hpr
						);
						self.Aircraft.position = airposition;
						self.Aircraft.orientation = airorientation;
						//观察视角变化
						if (self.followType === "allfollow") {
							const heading2 = SceneGIS.Math.toRadians(getheading(pos2.lat, pos2.lng, pos1.lat, pos1.lng) - 180 + self.followHeading);
							self.viewer.trackedEntity = undefined;
							self.viewer.trackedEntity = self.Aircraft;
							self.Aircraft._heading = heading2;
						} else if (self.followType === "nocar") {
							self.viewer.trackedEntity = undefined;
							self.Aircraft.show = false;
							let direction = new SceneGIS.Cartesian3(nextpos.x - position.x, nextpos.y - position.y, nextpos.z - position.z);
							let up = SceneGIS.Cartesian3.normalize(position, new SceneGIS.Cartesian3());
							let right = SceneGIS.Cartesian3.cross(direction, up, new SceneGIS.Cartesian3());
							SceneGIS.Cartesian3.cross(right, direction, up);
							viewer.camera.setView({
								destination: airposition,
								orientation: {
									direction: direction,
									up: up
								}
							});
						}
						// if(self._billboard)
						//     self._billboard.position = SceneGIS.Cartesian3.fromDegrees(pos1.lng, pos1.lat, pos1.alt+20);
					}
				}
				if (SceneGIS.JulianDate.compare(self.viewer.clock.currentTime, self.viewer.clock.stopTime) >= 0) {
					self.viewer.clock.onTick.removeEventListener(self.Exection);
					if (index < arr.length - 2) {
						index++;
						setClock$1(1 / speed, self.viewer);
						self.viewer.clock.onTick.addEventListener(self.Exection);
					}
					//最后一帧显示相机
					else {
						for (let floatingPoint of self.floatingPoints) {
							floatingPoint.show = true;
						}
						for (let cameraEntity of self.cameraEntitys) {
							cameraEntity.show = false;
						}
						if (self.drawLines.length > 0) {
							for (let drawLine of self.drawLines) {
								drawLine.polyline.show = true;
							}
						}
						self.isflying = false;
						self.viewer.trackedEntity = undefined;
					}
				}
			};
			this.viewer.clock.onTick.addEventListener(this.Exection);
		} else if (options.interpWays === "圆弧插值") {
			//计算得到当前需要间隔数duration(time = speed*duration。默认speed = 40，所以duration = time/speed。圆弧插值每两个点之间为一段duration，所以总的要/cameras.length-1)
			let durations = [];
			let keyframes = [0];
			let totalTimes = 0;
			speed = 45;  //原理上应该是30，但是有系统误差，所以*1.5经验值消除误差
			for (let time of options.times) {
				let duration = time * 30;
				durations.push(parseInt(duration));
				totalTimes += parseInt(duration);
				keyframes.push(totalTimes * 3); //关键帧
			}

			//位置插值
			var positionsArr = [];
			for (let camera of cameras) {
				positionsArr.push(camera.destination.x);
				positionsArr.push(camera.destination.y);
				positionsArr.push(camera.destination.z);
			}
			var cardinalarr = Cardinalspline(positionsArr, options.tension, durations);

			//角度插值
			var orientations = [], adjustAngles1 = [];
			//首先先调整角度值
			for (let i = 1; i < cameras.length; i++) {
				var startHeading = adjustAngleForLERP(cameras[i].orientation.heading, cameras[i - 1].orientation.heading);
				var startRoll = adjustAngleForLERP(cameras[i].orientation.roll, cameras[i - 1].orientation.roll);
				let diffHeading = startHeading - cameras[i].orientation.heading;
				let diffRoll = startRoll - cameras[i].orientation.roll;
				cameras[i].orientation.heading = cameras[i].orientation.heading + diffHeading;
				cameras[i].orientation.roll = cameras[i].orientation.roll + diffRoll;

				adjustAngles1.push(startHeading);
				adjustAngles1.push(cameras[i].orientation.pitch);
				adjustAngles1.push(startRoll);
			}
			adjustAngles1.unshift(cameras[0].orientation.roll);
			adjustAngles1.unshift(cameras[0].orientation.pitch);
			adjustAngles1.unshift(cameras[0].orientation.heading);

			//角度的样本插值拟合
			var cardinalAngleArr = Cardinalspline(adjustAngles1, options.tension, durations);

			setClock$1(1 / speed, this.viewer);
			var self = this;
			var index = 0;
			var position = { x: 0, y: 0, z: 0 };
			var nextpos = { x: 0, y: 0, z: 0 };
			var orientation = { heading: 0, pitch: 0, roll: 0 };
			this.Exection = function TimeExecution() {
				position.x = cardinalarr[index];
				position.y = cardinalarr[index + 1];
				position.z = cardinalarr[index + 2];
				if (index === cardinalarr.length - 3) {
					nextpos.x = 0;
					nextpos.y = 0;
					nextpos.z = 0;
				} else {
					nextpos.x = cardinalarr[index + 3];
					nextpos.y = cardinalarr[index + 4];
					nextpos.z = cardinalarr[index + 5];
				}
				orientation.heading = cardinalAngleArr[index];
				orientation.pitch = cardinalAngleArr[index + 1];
				orientation.roll = cardinalAngleArr[index + 2];
				if (options.observeWays === "camera") {
					self.viewer.scene.camera.setView({
						destination: position,
						orientation: orientation,
						observeCamera: true
					});
				}
				//车载轨迹回放
				else if (options.observeWays === "car") {
					if (self.planeView === true) {
						if (nextpos.x != 0) {
							//位置
							let airposition = new SceneGIS.Cartesian3(position.x, position.y, position.z);
							//角度
							const direction = new SceneGIS.Cartesian3(position.x - nextpos.x, position.y - nextpos.y, position.z - nextpos.z);
							SceneGIS.Cartesian3.normalize(direction, direction);
							const right = SceneGIS.Cartesian3.cross(direction, SceneGIS.Cartesian3.UNIT_Z, new SceneGIS.Cartesian3());
							const rotate = new SceneGIS.Matrix3(right.x, direction.x, 0, right.y, direction.y, 0, right.z, direction.z, 1);
							const qua = SceneGIS.Quaternion.fromRotationMatrix(rotate);
							self.Aircraft.position = airposition;
							self.Aircraft.orientation = qua;
							if (self.followType === "fixfollow") {
								//在平面坐标系必须这样，要不然似乎地形会抬高
								self.viewer.trackedEntity = undefined;
								self.viewer.trackedEntity = self.Aircraft;
							}
							//观察视角变化
							else if (self.followType === "allfollow") {
								const hpr = SceneGIS.HeadingPitchRoll.fromQuaternion(qua);
								self.viewer.trackedEntity = undefined;
								self.viewer.trackedEntity = self.Aircraft;
								self.Aircraft._heading = SceneGIS.Math.toRadians(SceneGIS.Math.toDegrees(hpr.heading) - 180);
							} else if (self.followType === "nocar") {
								self.viewer.trackedEntity = undefined;
								self.Aircraft.show = false;
								let direction = new SceneGIS.Cartesian3(nextpos.x - position.x, nextpos.y - position.y, nextpos.z - position.z);
								let up = SceneGIS.Cartesian3.normalize(SceneGIS.Cartesian3.UNIT_Z, new SceneGIS.Cartesian3());
								let right = SceneGIS.Cartesian3.cross(direction, up, new SceneGIS.Cartesian3());
								SceneGIS.Cartesian3.cross(right, direction, up);
								viewer.camera.setView({
									destination: airposition,
									orientation: {
										direction: direction,
										up: up
									}
								});
							}
							// if(self._billboard)
							//     self._billboard.position = new SceneGIS.Cartesian3(airposition.x, airposition.y, airposition.z+20);
						} else {
							//位置
							let airposition = new SceneGIS.Cartesian3(position.x, position.y, position.z);
							self.Aircraft.position = airposition;
							self.viewer.trackedEntity = undefined;
							// if(self._billboard)
							//     self._billboard.position = new SceneGIS.Cartesian3(airposition.x, airposition.y, airposition.z+20);
						}
					} else {
						if (nextpos.x != 0) {
							let airposition = JSON.parse(JSON.stringify(position));
							let airposition2 = JSON.parse(JSON.stringify(nextpos));
							let pos1 = transformCartesianToWGS84$1(self.viewer, airposition);
							let pos2 = transformCartesianToWGS84$1(self.viewer, airposition2);
							const heading = SceneGIS.Math.toRadians(getheading(pos1.lat, pos1.lng, pos2.lat, pos2.lng) - 180);
							// let heading = SceneGIS.Math.toRadians(SceneGIS.Math.toDegrees(orientation.heading)-90);
							let pitch = 0;
							let roll = 0;
							let hpr = new SceneGIS.HeadingPitchRoll(heading, pitch, roll);
							let airorientation = SceneGIS.Transforms.headingPitchRollQuaternion(
								airposition,
								hpr
							);
							self.Aircraft.position = airposition;
							self.Aircraft.orientation = airorientation;
							//观察视角变化
							if (self.followType === "allfollow") {
								const heading2 = SceneGIS.Math.toRadians(getheading(pos2.lat, pos2.lng, pos1.lat, pos1.lng) - 180 + self.followHeading);
								self.viewer.trackedEntity = undefined;
								self.viewer.trackedEntity = self.Aircraft;
								self.Aircraft._heading = heading2;
							} else if (self.followType === "nocar") {
								self.viewer.trackedEntity = undefined;
								self.Aircraft.show = false;
								let direction = new SceneGIS.Cartesian3(nextpos.x - position.x, nextpos.y - position.y, nextpos.z - position.z);
								let up = SceneGIS.Cartesian3.normalize(position, new SceneGIS.Cartesian3());
								let right = SceneGIS.Cartesian3.cross(direction, up, new SceneGIS.Cartesian3());
								SceneGIS.Cartesian3.cross(right, direction, up);
								viewer.camera.setView({
									destination: airposition,
									orientation: {
										direction: direction,
										up: up
									}
								});
							}
							// if(self._billboard)
							//     self._billboard.position = SceneGIS.Cartesian3.fromDegrees(pos1.lng, pos1.lat, pos1.alt+20);
						}
						else {
							let airposition = JSON.parse(JSON.stringify(position));
							transformCartesianToWGS84$1(self.viewer, airposition);
							self.Aircraft.position = airposition;
							self.viewer.trackedEntity = undefined;
							// if(self._billboard)
							//     self._billboard.position = SceneGIS.Cartesian3.fromDegrees(pos1.lng, pos1.lat, pos1.alt+20);
						}
					}
				}
				if (SceneGIS.JulianDate.compare(self.viewer.clock.currentTime, self.viewer.clock.stopTime) >= 0) {
					self.viewer.clock.onTick.removeEventListener(self.Exection);
					if (index < cardinalarr.length - 3) {
						let keyIndex = keyframes.findIndex((item) => item === index);
						if (keyIndex == -1 || (!SceneGIS.defined(self.triggerStopTimes[keyIndex]) && !SceneGIS.defined(self.triggerCallbacks[keyIndex]))) {
							index += 3;
							setClock$1(1 / speed, self.viewer);
							self.viewer.clock.onTick.addEventListener(self.Exection);
						}
						//即当前帧为关键帧，且定义了function或暂停
						else {
							let tempIndex = self.triggeredEvent(keyIndex, speed, index);
							index = tempIndex;
						}
					}
					//最后一帧显示相机
					else {
						//最后一帧为关键帧，且定义了function
						let keyIndex = keyframes.findIndex((item) => item === index);
						if (keyIndex != -1 && SceneGIS.defined(self.triggerCallbacks[keyIndex])) {
							if (typeof self.triggerCallbacks[keyIndex] === 'function') {
								self.triggerCallbacks[keyIndex]();
							}
						}

						if (options.observeWays === "camera") {
							self.viewer.scene.camera.setView({
								destination: cameras[cameras.length - 1].destination,
								orientation: cameras[cameras.length - 1].orientation,
								observeCamera: true
							});
						}
						for (let floatingPoint of self.floatingPoints) {
							floatingPoint.show = true;
						}
						for (let cameraEntity of self.cameraEntitys) {
							cameraEntity.show = false;
						}
						if (self.drawLines.length > 0) {
							for (let drawLine of self.drawLines) {
								drawLine.polyline.show = true;
							}
						}
						self.isflying = false;
					}
				}
			};
			this.viewer.clock.onTick.addEventListener(this.Exection);
		}
	};

	function computeposition(cameras, j, time) {
		var speed = 45;  //原理上应该是30，但是有系统误差，所以*1.5经验值消除误差
		var duration = time * 30;

		var spline = new SceneGIS.CatmullRomSpline({
			times: [0.0, duration],
			points: [cameras[j].destination, cameras[j + 1].destination]
		});

		var newCamera;
		var startHeading = adjustAngleForLERP(cameras[j].orientation.heading, cameras[j + 1].orientation.heading);
		var startRoll = adjustAngleForLERP(cameras[j].orientation.roll, cameras[j + 1].orientation.roll);

		var deltHeading = (cameras[j + 1].orientation.heading - startHeading) / duration;
		var deltPitch = (cameras[j + 1].orientation.pitch - cameras[j].orientation.pitch) / duration;
		var deltRoll = (cameras[j + 1].orientation.roll - startRoll) / duration;

		var newCameras = [];

		for (var k = 0; k < duration; k++) {
			var newDestination = spline.evaluate(k);
			var newHeading = cameras[j].orientation.heading + deltHeading * (k + 1);
			var newPitch = cameras[j].orientation.pitch + deltPitch * (k + 1);
			var newRoll = cameras[j].orientation.roll + deltRoll * (k + 1);
			newCamera = {
				destination: newDestination,
				orientation: {
					heading: newHeading,
					pitch: newPitch,
					roll: newRoll
				},
				observeCamera: true
			};
			newCameras.push(newCamera);
		}
		if (j === cameras.length - 2) {
			newCameras.push({
				destination: cameras[j + 1].destination,
				orientation: cameras[j + 1].orientation
			});
		}
		var info = {
			newCameras: newCameras,
			speed: speed
		};
		return info;
	}

	function adjustAngleForLERP(startAngle, endAngle) {
		if (
			SceneGIS.Math.equalsEpsilon(
				startAngle,
				SceneGIS.Math.TWO_PI,
				SceneGIS.Math.EPSILON11
			)
		) {
			startAngle = 0.0;
		}

		if (endAngle > startAngle + Math.PI) {
			startAngle += SceneGIS.Math.TWO_PI;
		} else if (endAngle < startAngle - Math.PI) {
			startAngle -= SceneGIS.Math.TWO_PI;
		}

		return startAngle;
	}

	/*
	 * 坐标转换 笛卡尔转84
	 * 
	 * @param {Object} Cartesian3 三维位置坐标
	 * 
	 * @return {Object} {lng,lat,alt} 地理坐标
	 */
	function transformCartesianToWGS84$1(viewer, cartesian) {
		if (viewer && cartesian) {
			var ellipsoid = SceneGIS.Ellipsoid.WGS84;
			var cartographic = ellipsoid.cartesianToCartographic(cartesian);
			return {
				lng: SceneGIS.Math.toDegrees(cartographic.longitude),
				lat: SceneGIS.Math.toDegrees(cartographic.latitude),
				alt: cartographic.height
			}
		}
	}

	//计算偏航角
	function getheading(startLat, startlon, destLat, destlon) {
		startLat = SceneGIS.Math.toRadians(startLat);
		startlon = SceneGIS.Math.toRadians(startlon);
		destLat = SceneGIS.Math.toRadians(destLat);
		destlon = SceneGIS.Math.toRadians(destlon);

		let y = Math.sin(destlon - startlon) * Math.cos(destLat);
		let x = Math.cos(startLat) * Math.sin(destLat) - Math.sin(startLat) * Math.cos(destLat) * Math.cos(destlon - startlon);
		let brng = Math.atan2(y, x);
		let brngDgr = SceneGIS.Math.toDegrees(brng);

		return (brngDgr + 360) % 360;
	}

	/**
	 * 键盘控制相机漫游
	 * @class KeyboardCameraControlEX
	 * @param {SceneGIS.Viewer} viewer 
	 */
	function KeyboardCameraControlEX(viewer) {
		CheckEX.instanceOf("viewer", viewer, SceneGIS.Viewer);
		this._viewer = viewer;
		this._startMousePosition;
		this._mousePosition;
		this._rate = 1;
		this._x;
		this._y;
		this._flags = {
			looking: false,
			moveForward: false,
			moveBackward: false,
			moveUp: false,
			moveDown: false,
			moveLeft: false,
			moveRight: false,
			shift: false,
			control: false
		};

		this.keyUpBind = keyUp.bind(this);
		this.keyDownBind = keyDown.bind(this);
		this.mouseMoveBind = mouseMove$3.bind(this);
		this.onPointerLockChangeBind = onPointerLockChange.bind(this);

		this._updateCameraRemove;
		this._updatePositionRemove;

		this.isrunning = false;
	}

	Object.defineProperties(KeyboardCameraControlEX.prototype, {
		/**
		 * 控制速度,作为速度的倍率，0则静止
		 * @memberof KeyboardCameraControlEX.prototype
		 * @type {number}
		 */
		speedControl: {
			get: function () {
				return this._rate;
			},
			set: function (e) {
				this._rate = e;
			}
		}
	});

	function getFlagForKeyCode(keyCode) {
		switch (keyCode) {
			case 'W'.charCodeAt(0):
				return 'moveForward';
			case 'S'.charCodeAt(0):
				return 'moveBackward';
			case 'Q'.charCodeAt(0):
				return 'moveUp';
			case 'E'.charCodeAt(0):
				return 'moveDown';
			case 'D'.charCodeAt(0):
				return 'moveRight';
			case 'A'.charCodeAt(0):
				return 'moveLeft';
			default:
				return undefined;
		}
	}

	function keyDown(e) {
		let flagName = getFlagForKeyCode(e.keyCode);
		if (typeof flagName !== 'undefined') {
			this._flags[flagName] = true;
		}

		if (e.ctrlKey) {
			document.exitPointerLock();
			this._flags.control = true;
		}
		if (e.shiftKey) {
			e.preventDefault();
			this._flags.shift = true;
		}
	}

	function keyUp(e) {
		let flagName = getFlagForKeyCode(e.keyCode);
		if (typeof flagName !== 'undefined') {
			this._flags[flagName] = false;
		}

		if (e.key == "Control") {
			this._viewer.canvas.requestPointerLock();
			this._flags.control = false;
		}
		if (e.key == "Shift") {
			e.preventDefault();
			this._flags.shift = false;
		}
	}

	function mouseMove$3(movement) {
		this._flags.looking = true;
		this._x = movement.movementX;
		this._y = movement.movementY;
	}

	function updateCamera$1() {
		let camera = this._viewer.camera;
		let canvas = this._viewer.canvas;
		const planeView = this._viewer.scene.planeView;
		if (this._flags.looking) {
			let width = canvas.clientWidth;
			let height = canvas.clientHeight;
			let x_norm = this._x / width;
			let y_norm = -this._y / height;
			if (planeView) {
				camera.look(SceneGIS.Cartesian3.UNIT_Z, x_norm);
			} else {
				camera.look(camera.position, x_norm);
			}
			camera.lookUp(y_norm);
			this._flags.looking = false;
		}
	}

	function updatePosition() {
		let camera = this._viewer.camera;
		const planeView = this._viewer.scene.planeView;
		let height;
		if (planeView === true) {
			height = camera.position.z;
		} else {
			height = SceneGIS.Cartographic.fromCartesian(camera.position).height;
		}
		let moveRate = SceneGIS.Math.clamp(height > 1 ? Math.pow(height, 0.5) : height / 2, 0.2, 10000.0) * this._rate;
		if (this._flags.moveForward) {
			let directionBackward = new SceneGIS.Cartesian3();
			let normal;
			if (planeView === true) {
				normal = new SceneGIS.Cartesian3(0, 0, 1);
			} else {
				normal = camera.position.clone();
			}
			SceneGIS.Cartesian3.cross(camera.rightWC, normal, directionBackward);
			SceneGIS.Cartesian3.normalize(directionBackward.clone(), directionBackward);
			let directionForward = new SceneGIS.Cartesian3(-directionBackward.x, -directionBackward.y, -directionBackward.z);
			let position1 = camera.position.clone();
			if (!this._flags.shift) {
				let ray0 = new SceneGIS.Ray(position1, directionForward);
				let result0 = this._viewer.scene.pickFromRay(ray0);
				if (result0) {
					let distance = SceneGIS.Cartesian3.distance(position1, result0.position);
					if (distance < moveRate) {
						return;
					}
				}
			}
			console.log("oyyx directionForward:", directionForward);
			camera.move(directionForward, moveRate);
			return;
		}
		if (this._flags.moveBackward) {
			let directionBackward = new SceneGIS.Cartesian3();
			let normal;
			if (planeView === true) {
				normal = new SceneGIS.Cartesian3(0, 0, 1);
			} else {
				normal = camera.position.clone();
			}
			SceneGIS.Cartesian3.cross(camera.rightWC, normal, directionBackward);
			SceneGIS.Cartesian3.normalize(directionBackward.clone(), directionBackward);
			let position1 = camera.position.clone();
			if (!this._flags.shift) {
				let ray0 = new SceneGIS.Ray(position1, directionBackward);
				let result0 = this._viewer.scene.pickFromRay(ray0);
				if (result0) {
					let distance = SceneGIS.Cartesian3.distance(position1, result0.position);
					if (distance < moveRate) {
						return;
					}
				}
			}
			camera.move(directionBackward, moveRate);
			return;
		}
		if (this._flags.moveUp) {
			let directionUp = new SceneGIS.Cartesian3();
			if (planeView) {
				directionUp = SceneGIS.Cartesian3.UNIT_Z;
			} else {
				SceneGIS.Cartesian3.normalize(camera.position, directionUp);
			}
			let position1 = camera.position.clone();
			if (!this._flags.shift) {
				let ray0 = new SceneGIS.Ray(position1, directionUp);
				let result0 = this._viewer.scene.pickFromRay(ray0);
				if (result0) {
					let distance = SceneGIS.Cartesian3.distance(position1, result0.position);
					if (distance < moveRate) {
						return;
					}
				}
			}
			camera.move(directionUp, moveRate);
			return;
		}
		if (this._flags.moveDown) {
			let directionDown = new SceneGIS.Cartesian3();
			if (planeView) {
				directionDown.z = -1;
			} else {
				SceneGIS.Cartesian3.normalize(new SceneGIS.Cartesian3(-camera.position.x, -camera.position.y, -camera.position.z), directionDown);
			}
			let position1 = camera.position.clone();
			if (!this._flags.shift) {
				let ray0 = new SceneGIS.Ray(position1, directionDown);
				let result0 = this._viewer.scene.pickFromRay(ray0);
				if (result0) {
					let distance = SceneGIS.Cartesian3.distance(position1, result0.position);
					if (distance < moveRate) {
						return;
					}
				}
			}
			camera.move(directionDown, moveRate);
			if (!planeView) {
				if (SceneGIS.Cartographic.fromCartesian(camera.position).height < 0) {
					camera.move(directionDown, -moveRate);
				}
			}
			return;
		}
		if (this._flags.moveLeft) {
			let position1 = camera.position.clone();
			let directionLeft = new SceneGIS.Cartesian3();
			SceneGIS.Cartesian3.normalize(new SceneGIS.Cartesian3(-camera.rightWC.x, -camera.rightWC.y, -camera.rightWC.z), directionLeft);
			if (!this._flags.shift) {
				let ray0 = new SceneGIS.Ray(position1, directionLeft);
				let result0 = this._viewer.scene.pickFromRay(ray0);
				if (result0) {
					let distance = SceneGIS.Cartesian3.distance(position1, result0.position);
					if (distance < moveRate) {
						return;
					}
				}
			}
			camera.move(directionLeft, moveRate);
			return;
		}
		if (this._flags.moveRight) {
			let position1 = camera.position.clone();
			if (!this._flags.shift) {
				let ray0 = new SceneGIS.Ray(position1, camera.rightWC);
				let result0 = this._viewer.scene.pickFromRay(ray0);
				if (result0) {
					let distance = SceneGIS.Cartesian3.distance(position1, result0.position);
					if (distance < moveRate) {
						return;
					}
				}
			}
			camera.move(camera.rightWC, moveRate);
			return;
		}
	}

	/**
	 * 启用控制
	 */
	KeyboardCameraControlEX.prototype.start = function () {
		this.isrunning = true;
		this._viewer.canvas.requestPointerLock();
		//固定相机
		let cameraPosition = this._viewer.camera.position.clone();
		let directionUp = new SceneGIS.Cartesian3();
		SceneGIS.Cartesian3.normalize(this._viewer.camera.position, directionUp);
		let directionDown = new SceneGIS.Cartesian3(-directionUp.x, -directionUp.y, -directionUp.z);
		let ray = new SceneGIS.Ray(cameraPosition, directionDown);
		let result = this._viewer.scene.pickFromRay(ray);
		if (result) {
			let newPosition = new SceneGIS.Cartesian3(
				result.position.x + directionUp.x * 1.7,
				result.position.y + directionUp.y * 1.7,
				result.position.z + directionUp.z * 1.7
			);
			this._viewer.camera.flyTo({
				destination: newPosition,
				orientation: {
					heading: this._viewer.camera.heading, // east, default value is 0.0 (north)
					pitch: this._viewer.camera.pitch,    // default value (looking down)
					roll: this._viewer.camera.roll
				}
			});
		}
		document.addEventListener('keydown', this.keyDownBind, false);
		document.addEventListener('keyup', this.keyUpBind, false);
		document.addEventListener('mousemove', this.mouseMoveBind, false);

		document.addEventListener('pointerlockchange', this.onPointerLockChangeBind);
	};

	function onPointerLockChange() {
		if (document.pointerLockElement == this._viewer.canvas) {
			let scene = this._viewer.scene;
			let canvas = this._viewer.canvas;
			canvas.setAttribute('tabindex', '0'); // needed to put focus on the canvas
			canvas.onclick = function () {
				canvas.focus();
			};

			scene.screenSpaceCameraController.enableRotate = false;
			scene.screenSpaceCameraController.enableTranslate = false;
			scene.screenSpaceCameraController.enableZoom = false;
			scene.screenSpaceCameraController.enableTilt = false;
			scene.screenSpaceCameraController.enableLook = false;

			this._updateCameraRemove = scene.preUpdate.addEventListener(updateCamera$1.bind(this));
			this._updatePositionRemove = scene.preUpdate.addEventListener(updatePosition.bind(this));
		} else {
			let scene = this._viewer.scene;
			scene.screenSpaceCameraController.enableRotate = true;
			scene.screenSpaceCameraController.enableTranslate = true;
			scene.screenSpaceCameraController.enableZoom = true;
			scene.screenSpaceCameraController.enableTilt = true;
			scene.screenSpaceCameraController.enableLook = true;

			if (this._updateCameraRemove) {
				this._updateCameraRemove();
			}
			if (this._updatePositionRemove) {
				this._updatePositionRemove();
			}

			if (!this._flags.control) {
				//按下esc时也移除方法
				document.removeEventListener('keydown', this.keyDownBind, false);
				document.removeEventListener('keyup', this.keyUpBind, false);
				document.removeEventListener('mousemove', this.mouseMoveBind, false);
			}
		}
	}

	/**
	 * 停止控制
	 */
	KeyboardCameraControlEX.prototype.stop = function () {
		this.removeEvent();
	};

	/**
	 * @private
	 * 停止控制
	 */
	KeyboardCameraControlEX.prototype.removeEvent = function () {
		//只有按住control能够执行，所以去掉document.exitPointerLock();
		document.removeEventListener('keydown', this.keyDownBind, false);
		document.removeEventListener('keyup', this.keyUpBind, false);
		document.removeEventListener('mousemove', this.mouseMoveBind, false);
	};

	KeyboardCameraControlEX.prototype.clear = function () {
		throw new SceneGIS.DeveloperError('error');
	};

	/**
	 * 释放资源
	 */
	KeyboardCameraControlEX.prototype.destroy = function () {
		this.isrunning = false;
		this.removeEvent();
		document.removeEventListener('pointerlockchange', this.onPointerLockChangeBind);
	};

	/**
	 * 压平工具类
	 * @alias FlatTilesetEX
	 * @constructor
	 * @param {Object} options 
	 * @param {Viewer} viewer 
	 */
	function FlatTilesetEX(options, viewer) {
		CheckEX.instanceOf("options.tileset", options.tileset, SceneGIS.SceneGIS3DTileset);

		this._viewer = viewer;

		this._tileset = options.tileset;
		this._flatPolygons = new SceneGIS.FlatPolygonCollection();

		this._draw = new CommanDrawEX({
			callback: callback$5.bind(this),
			drawCompletePoints: false,
			drawComplete: false
		}, this._viewer);
		this._draw.setMode(CommanDrawModeEX$1.POLYGON);
		this._draw.pause = true;

		this._depthTestAgainstTerrain = this._viewer.scene.globe.depthTestAgainstTerrain;
		this._viewer.scene.globe.depthTestAgainstTerrain = true;
		this.isrunning = false;
	}

	function callback$5(data) {
		if (data.eventType == "leftClick") {
			return;
		}
		let positions = [];
		for (let position of data.position) {
			positions.push(position);
		}
		positions.push(data.position[0]);

		let polygon = new SceneGIS.PolygonGeometry({
			polygonHierarchy: new SceneGIS.PolygonHierarchy(
				positions
			)
		});
		this._flatPolygons.add(polygon);
		if (!this._tileset.flatPolygons) {
			this._tileset.flatPolygons = this._flatPolygons;
		}
		this.stop();
	}

	FlatTilesetEX.prototype.start = function () {
		this._draw.pause = false;
		this.isrunning = true;
	};

	FlatTilesetEX.prototype.stop = function () {
		this._draw.pause = true;
		this.isrunning = false;
	};

	FlatTilesetEX.prototype.clear = function () {
		if (this._tileset.flatPolygons) {
			this._tileset.flatPolygons.removeAll();
		}
	};

	FlatTilesetEX.prototype.destroy = function () {
		this.clear();
		this._draw.destroy();
		this._viewer.scene.globe.depthTestAgainstTerrain = this._depthTestAgainstTerrain;
		this.isrunning = false;
	};

	/**
	 * 视点管理类
	 * @class ViewManageEX
	 * @param {SceneGIS.Viewer} viewer 
	 */
	function ViewManageEX(viewer) {
		this.name = "ViewManageEX";
		this._viewer = viewer;
	}

	Object.defineProperties(ViewManageEX.prototype, {
		/**
		* 获取 三维 viewer
		*
		* @memberof ViewManageEX.prototype
		*
		* @type {Viewer}
		* @readonly
		*
		* @default undefined
		*/

		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		}

	});

	/**
	 * 添加视点
	 * @param {String} name 视点名称
	 * @return {Object} paramater {viewname:视点名称,x:世界坐标x,y:世界坐标y,z:世界坐标z,heading:偏航角,pitch:俯仰角,roll:翻滚角}
	 */
	ViewManageEX.prototype.add = function (name) {

		var camera = this.viewer.camera;
		var paramater = {
			viewname: name,
			x: camera.positionWC.x,
			y: camera.positionWC.y,
			z: camera.positionWC.z,
			heading: camera.heading,
			pitch: camera.pitch,
			roll: camera.roll
		};
		return paramater;

	};

	/**
	 * 定位世界坐标视点点位
	 * @param {Number} x 世界坐标x
	 * @param {Number} y 世界坐标y
	 * @param {Number} z 世界坐标z
	 * @param {Number} [heading=0] 偏航角,默认为0
	 * @param {Number} [pitch=0] 俯仰角,默认为0
	 * @param {Number} [roll=0] 翻滚角,默认为0
	 */
	ViewManageEX.prototype.location_xyz = function (x, y, z, heading, pitch, roll) {
		var camera = this.viewer.scene.camera;
		camera.setView({
			destination: new SceneGIS.Cartesian3(x, y, z),
			orientation: {       //设置视角
				heading: SceneGIS.defaultValue(heading, 0), // east, default value is 0.0 (north)左右摆头
				pitch: SceneGIS.defaultValue(pitch, 0),    // default value (looking down)上下抬头 -90俯视 0平视 90仰视(默认俯视)
				roll: SceneGIS.defaultValue(roll, 0),                            // default value
			}
		});
	};

	/**
	 * 定位经纬度视点点位
	 * @param {Number} longitude 经度
	 * @param {Number} latitude 纬度
	 * @param {Number} height 高度
	 * @param {Number} [heading=0] 偏航角,默认为0
	 * @param {Number} [pitch=0] 俯仰角,默认为0
	 * @param {Number} [roll=0] 翻滚角,默认为0
	 */
	ViewManageEX.prototype.location = function (longitude, latitude, height, heading, pitch, roll) {
		var camera = this.viewer.scene.camera;
		camera.setView({
			destination: SceneGIS.Cartesian3.fromDegrees(longitude, latitude, height),
			orientation: {       //设置视角
				heading: SceneGIS.defaultValue(heading, 0), // east, default value is 0.0 (north)左右摆头
				pitch: SceneGIS.defaultValue(pitch, 0),    // default value (looking down)上下抬头 -90俯视 0平视 90仰视(默认俯视)
				roll: SceneGIS.defaultValue(roll, 0),     // default value
			}
		});
	};

	/**
	 * 坐标转换 笛卡尔转84
	 * @param {Object} paramater {Cartesian3,heading,pitch,roll} 三维位置坐标及方向
	 * @returns {Object} {lat,lng,alt,heading,pitch,roll} 地理坐标
	 */
	ViewManageEX.prototype.revert = function (paramater) {
		var ellipsoid = this.viewer.scene.globe.ellipsoid;
		var cartesian3 = new SceneGIS.Cartesian3(paramater.x, paramater.y, paramater.z);
		var cart = ellipsoid.cartesianToCartographic(cartesian3);

		var lat = SceneGIS.Math.toDegrees(cart.latitude);
		var lng = SceneGIS.Math.toDegrees(cart.longitude);
		var alt = cart.height;
		var position = {
			lat: lat,
			lng: lng,
			alt: alt,
			heading: paramater.heading,
			pitch: paramater.pitch,
			roll: paramater.roll
		};
		return position;
	};

	/**
	 * 资源销毁
	 */
	ViewManageEX.prototype.destroy = function () {

		_sceneGisViewManage = undefined;
	};

	/**
	 * 空间距离测量类
	 * @class MeasureDistanceEX
	 * @param {Object} options
	 * @param {function} options.callback 回调函数
	 * @param {SceneGIS.Viewer} viewer 
	 */
	function MeasureDistanceEX(options, viewer) {
		this.name = "MeasureDistanceEX";
		this.cartesian = undefined;
		this.positions = [];
		this.poly = null;
		//存储结果的数组（会有很多distance）
		this.distances = [];
		this.distance = 0;
		this.floatingPoint = null;
		this._viewer = viewer;
		viewer.scene.globe.depthTestAgainstTerrain = true;//开启地形深度检测
		this.handle = null;
		this._completeColor = SceneGIS.Color.GREEN.withAlpha(0.5);
		//功能开启后是否在测量
		this._draw = true;
		this.callback = options.callback ? options.callback : undefined;
		//功能是否开启
		this.isrunning = false;
		//鼠标点
		this._tempPoint = undefined;
		this._tempPosition = new SceneGIS.Cartesian3(0, 0, 0);
	}
	Object.freeze({});

	Object.defineProperties(MeasureDistanceEX.prototype, {
		/**
		* 获取viewer 对象
		* @memberof MeasureDistanceEX.prototype
		*
		* @type {Viewer}
		* @readonly
		*/
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		},

	});

	/**
	 * 开始功能
	 */
	MeasureDistanceEX.prototype.start = function () {
		//添加事件
		this.addEvent();
		this.isrunning = true;
	};
	/**
	 *  清除当前实体
	 */
	MeasureDistanceEX.prototype.clear = function () {
		const entitys = this.viewer.entities._entities._array;
		let length = entitys.length;
		// 倒叙遍历防止实体减少之后entitys[f]不存在
		for (let f = length - 1; f >= 0; f--) {
			if (entitys[f]._name && ((entitys[f]._name.indexOf("直线") != -1) || (entitys[f]._name.indexOf("多边形") != -1))) {
				this.viewer.entities.remove(entitys[f]);
			}
		}
		this.distances = [];

		// this.viewer.entities.removeAll()
	};
	/** @private */
	MeasureDistanceEX.prototype.addEvent = function () {

		if (this.handle) return;
		this.handle = new SceneGIS.ScreenSpaceEventHandler(this.viewer.canvas);
		var that = this;
		//添加事件
		this.handle.setInputAction(function (event) {
			that.LEFT_CLICK(event);
		}, SceneGIS.ScreenSpaceEventType.LEFT_CLICK);
		this.handle.setInputAction(function (event) {
			that.RIGHT_CLICK(event);
		}, SceneGIS.ScreenSpaceEventType.RIGHT_CLICK);

		this.handle.setInputAction(function (event) {
			that.MOUSE_MOVE(event);
		}, SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);

		let self = this;
		this._tempPoint = this._viewer.entities.add({
			name: "多边形",
			position: new SceneGIS.CallbackProperty(function () {
				return self._tempPosition;
			}, false),
			point: {
				show: new SceneGIS.CallbackProperty(function () {
					return self._draw;
				}, false),
				pixelSize: 10,
				outlineColor: SceneGIS.Color.YELLOW,
				outlineWidth: 3
			}
		});

	};
	/** @private */
	MeasureDistanceEX.prototype.removeEvent = function () {
		if (!this.handle) return;
		this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.LEFT_CLICK);
		this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.RIGHT_CLICK);
		this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
		this.handle = undefined;
		if (this._tempPoint) {
			this._viewer.entities.remove(this._tempPoint);
		}
	};

	/**
	 * 销毁操作，销毁内部事件和临时对象
	 */

	MeasureDistanceEX.prototype.destroy = function () {
		if (this.isrunning === false) return;
		this.clear();
		this.removeEvent();
		this.isrunning = false;

	};

	/**
	 * 暂停绘制
	 */
	MeasureDistanceEX.prototype.stop = function () {
		this.removeEvent();
	};

	/** @private */
	MeasureDistanceEX.prototype.LEFT_CLICK = function (e) {
		//上轮测量结束，开启下一段测量
		if (this._draw === false) {
			let that = this;
			this.handle.setInputAction(function (event) {
				that.MOUSE_MOVE(event);
			}, SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
			this._draw = true;
		}
		this.cartesian = this.viewer.scene.pickPosition(e.position);
		if (this.cartesian == undefined) {
			return;
		}

		if (this.positions.length == 0) {
			this.positions.push(this.cartesian.clone());
		}
		this.positions.push(this.cartesian.clone());
		this.floatingPoint = this.viewer.entities.add({
			name: '空间直线距离',
			position: this.positions[this.positions.length - 1],
			point: {
				pixelSize: 10,
				outlineColor: this._completeColor,
				outlineWidth: 3,
				disableDepthTestDistance: Number.POSITIVE_INFINITY,
			}
		});
		//偶数个点，说明已经有一条线了
		if (this.positions.length > 2) {
			this.distances.push(this.distance);
			let textDistance = "长" + this.distance + "米";
			var pos = this.positions[0].clone();
			pos.x = (this.positions[this.positions.length - 2].x + this.positions[this.positions.length - 3].x) / 2;
			pos.y = (this.positions[this.positions.length - 2].y + this.positions[this.positions.length - 3].y) / 2;
			pos.z = (this.positions[this.positions.length - 2].z + this.positions[this.positions.length - 3].z) / 2;
			this.viewer.entities.add({
				name: '空间直线距离文本',
				position: pos,
				label: {
					text: textDistance,
					font: '18px sans-serif',
					fillColor: SceneGIS.Color.GOLD,
					style: SceneGIS.LabelStyle.FILL_AND_OUTLINE,
					outlineWidth: 2,
					verticalOrigin: SceneGIS.VerticalOrigin.CENTER,
					pixelOffset: new SceneGIS.Cartesian2(0, -20),
					eyeOffset: new SceneGIS.Cartesian3(0, 0, -10),
					disableDepthTestDistance: Number.POSITIVE_INFINITY,
				}
			});
		}
	};
	/** @private */
	MeasureDistanceEX.prototype.RIGHT_CLICK = function (e) {
		if (this._draw === false) {
			return;
		}
		if (this.callback) {
			this.callback(this.distances);
		}
		this.positions.pop(); //最后一个点无效
		this._draw = false;
		this.positions = [];
		this.poly = null;
		this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
	};

	let PolyLinePrimitive$2 = (function () {
		function _(positions, viewer) {
			this.viewer = viewer;
			this.options = {
				name: '直线',
				polyline: {
					show: true,
					positions: [],
					depthTest: false,
					width: 3,
					clampToGround: false,
					material: SceneGIS.Color.YELLOW,
				},
			};
			this.positions = positions;
			this._init();
		}

		_.prototype._init = function () {
			let _self = this;
			let _update = function () {
				return _self.positions;
			};
			//实时更新polyline.positions
			this.options.polyline.positions = new SceneGIS.CallbackProperty(_update, false);
			this.viewer.entities.add(this.options);
		};

		return _;
	})();

	/** @private */
	MeasureDistanceEX.prototype.MOUSE_MOVE = function (e) {
		if (this._draw === false) {
			return;
		}
		this.cartesian = this.viewer.scene.pickPosition(e.endPosition);
		if (this.cartesian) {
			this._tempPosition = this.cartesian;
			//cartesian = viewer.scene.camera.pickEllipsoid(movement.endPosition, viewer.scene.globe.ellipsoid);
			if (this.cartesian != undefined) {
				//在三维场景中添加点
				if (this.positions.length >= 2) {
					if (!SceneGIS.defined(this.poly)) {
						this.poly = new PolyLinePrimitive$2(this.positions, this.viewer);
					} else {
						this.positions.pop();
						// cartesian.y += (1 + Math.random());
						this.positions.push(this.cartesian);
					}
					this.distance = getSpaceDistance(this.positions, this.viewer);
				}
			}
		}
	};

	//空间两点距离计算函数
	function getSpaceDistance(positions, viewer) {
		const planeView = viewer.scene.planeView;
		let distance = 0;
		let predistance = 0;
		if (planeView === true) {
			for (let i = 0; i < positions.length - 1; i++) {
				let point1 = positions[i];
				let point2 = positions[i + 1];
				//根据世界坐标算出距离
				let s0 = Math.sqrt(Math.pow((point1.x - point2.x), 2) + Math.pow((point1.y - point2.y), 2));
				let s = Math.sqrt(Math.pow(s0, 2) + Math.pow((point1.z - point2.z), 2));
				distance = distance + s;
				if (i < positions.length - 2) {
					predistance = predistance + s;
				}
			}
		} else {
			for (let i = 0; i < positions.length - 1; i++) {
				let point1cartographic = SceneGIS.Cartographic.fromCartesian(positions[i]);
				let point2cartographic = SceneGIS.Cartographic.fromCartesian(positions[i + 1]);
				/**根据经纬度计算出距离**/
				let geodesic = new SceneGIS.EllipsoidGeodesic();
				geodesic.setEndPoints(point1cartographic, point2cartographic);
				let s = geodesic.surfaceDistance;
				//console.log(Math.sqrt(Math.pow(distance, 2) + Math.pow(endheight, 2)));
				//返回两点之间的距离
				s = window.Math.sqrt(window.Math.pow(s, 2) + window.Math.pow(point2cartographic.height - point1cartographic.height, 2));
				distance = distance + s;
				if (i < positions.length - 2) {
					predistance = predistance + s;
				}
			}
		}
		return Math.abs((distance - predistance).toFixed(2));
	}

	/**
	 * 水平距离测量类
	 * @class MeasureHDistanceEX
	 * @param {Object} options
	 * @param {function} options.callback 回调函数
	 * @param {SceneGIS.Viewer} viewer 
	 */
	function MeasureHDistanceEX(options, viewer) {
		this.cartesian = undefined;
		this.positions = [];
		this.poly = null;
		//存储的结果
		this.distance = 0;
		this.distances = [];
		this._height = 0;
		this.floatingPoint = null;
		this._viewer = viewer;
		viewer.scene.globe.depthTestAgainstTerrain = true;//开启地形深度检测
		this.handle = null;
		this.pointPositions = [];
		this._completeColor = SceneGIS.Color.GREEN.withAlpha(0.5);
		//功能开启后是否绘制
		this._draw = true;
		this.callback = options.callback ? options.callback : undefined;
		//功能是否开启
		this.isrunning = false;
		//鼠标点
		this._tempPoint = undefined;
		this._tempPosition = new SceneGIS.Cartesian3(0, 0, 0);

	}
	Object.freeze({});

	Object.defineProperties(MeasureHDistanceEX.prototype, {
		/**
	   * 获取viewer 对象
	   * @memberof MeasureHDistanceEX.prototype
	   *
	   * @type {Viewer}
	   * @readonly
	   */

		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		}

	});
	/**
	 * 开始功能
	 */
	MeasureHDistanceEX.prototype.start = function () {
		//添加事件
		this.addEvent();
		this.isrunning = true;
	};

	/**
	 * @private
	 */
	MeasureHDistanceEX.prototype.addEvent = function () {

		if (this.handle) return;
		this.handle = new SceneGIS.ScreenSpaceEventHandler(this.viewer.canvas);
		var that = this;
		//添加事件
		this.handle.setInputAction(function (event) {
			that.LEFT_CLICK(event);
		}, SceneGIS.ScreenSpaceEventType.LEFT_CLICK);
		this.handle.setInputAction(function (event) {
			that.RIGHT_CLICK(event);
		}, SceneGIS.ScreenSpaceEventType.RIGHT_CLICK);

		this.handle.setInputAction(function (event) {
			that.MOUSE_MOVE(event);
		}, SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);

		let self = this;
		this._tempPoint = this._viewer.entities.add({
			name: "多边形",
			position: new SceneGIS.CallbackProperty(function () {
				return self._tempPosition;
			}, false),
			point: {
				show: new SceneGIS.CallbackProperty(function () {
					return self._draw;
				}, false),
				pixelSize: 10,
				outlineColor: SceneGIS.Color.YELLOW,
				outlineWidth: 3
			}
		});
	};

	/**
	 * @private
	 */
	MeasureHDistanceEX.prototype.removeEvent = function () {
		if (!this.handle) return;
		this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.LEFT_CLICK);
		this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.RIGHT_CLICK);
		this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
		this.handle = undefined;
		if (this._tempPoint) {
			this._viewer.entities.remove(this._tempPoint);
		}
	};

	/**
	 * 销毁操作，销毁内部事件和临时对象
	 */

	MeasureHDistanceEX.prototype.destroy = function () {
		if (this.isrunning === false) return;
		this.clear();
		this.removeEvent();
		this.isrunning = false;
	};

	/**
	 * 暂停功能
	 */
	MeasureHDistanceEX.prototype.stop = function () {
		this.removeEvent();
	};

	/**
	 *  清除当前实体
	 */
	MeasureHDistanceEX.prototype.clear = function () {
		const entitys = this.viewer.entities._entities._array;
		let length = entitys.length;
		// 倒叙遍历防止实体减少之后entitys[f]不存在
		for (let f = length - 1; f >= 0; f--) {
			if (entitys[f]._name && ((entitys[f]._name.indexOf("直线") != -1) || (entitys[f]._name.indexOf("多边形") != -1))) {
				this.viewer.entities.remove(entitys[f]);
			}
		}
		this.distances = [];
		// this.viewer.entities.removeAll()
	};
	/** @private */
	MeasureHDistanceEX.prototype.LEFT_CLICK = function (e) {
		const planeView = this.viewer.scene.planeView;
		//上一次测量结束，开始新一段的测量
		if (this._draw === false) {
			let that = this;
			this.handle.setInputAction(function (event) {
				that.MOUSE_MOVE(event);
			}, SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
			this._draw = true;
		}

		this.cartesian = this.viewer.scene.pickPosition(e.position);
		if (this.cartesian == undefined) {
			return;
		}

		//在三维场景中添加点
		if (this.positions.length == 0) {
			if (planeView === true) {
				this._height = this.cartesian.z;
			} else {
				let cartographic_1 = SceneGIS.Cartographic.fromCartesian(this.cartesian);
				this._height = cartographic_1.height;
			}
			this.positions.push(this.cartesian.clone());
		}
		this.positions.push(this.cartesian.clone());

		this.floatingPoint = this.viewer.entities.add({
			name: '空间水平直线距离',
			position: this.positions[this.positions.length - 1],
			point: {
				pixelSize: 10,
				outlineColor: this._completeColor,
				outlineWidth: 3,
				disableDepthTestDistance: Number.POSITIVE_INFINITY,
			},
		});
		this.pointPositions.push(this.positions[this.positions.length - 1]);

		if (this.positions.length > 2) {
			this.distances.push(this.distance);
			let textDistance = "水平" + this.distance + "米";
			var pos = this.positions[0].clone();
			pos.x = (this.positions[this.positions.length - 2].x + this.positions[this.positions.length - 3].x) / 2;
			pos.y = (this.positions[this.positions.length - 2].y + this.positions[this.positions.length - 3].y) / 2;
			pos.z = (this.positions[this.positions.length - 2].z + this.positions[this.positions.length - 3].z) / 2;
			this.viewer.entities.add({
				name: '空间水平直线距离文本',
				position: pos,
				label: {
					text: textDistance,
					font: '18px sans-serif',
					fillColor: SceneGIS.Color.GOLD,
					style: SceneGIS.LabelStyle.FILL_AND_OUTLINE,
					outlineWidth: 2,
					verticalOrigin: SceneGIS.VerticalOrigin.CENTER,
					pixelOffset: new SceneGIS.Cartesian2(0, -20),
					eyeOffset: new SceneGIS.Cartesian3(0, 0, -10),
					disableDepthTestDistance: Number.POSITIVE_INFINITY,
				}
			});
			this.RIGHT_CLICK();
		}
	};
	/** @private */
	MeasureHDistanceEX.prototype.RIGHT_CLICK = function (e) {
		if (this._draw === false) {
			return;
		}
		if (this.positions.length > 2) {
			//加垂直线
			var positions = [];
			positions.push(this.pointPositions[this.pointPositions.length - 1]);
			positions.push(this.positions[this.positions.length - 2]);
			this.viewer.entities.add({
				name: '水平直线',  //其实是垂直线
				polyline: {
					show: true,
					positions: positions,
					material: SceneGIS.Color.CHARTREUSE,
					width: 3,
					clampToGround: false,
					depthTest: false
				}
			});
			//加点
			let pointoptions = {
				name: '空间水平直线距离',
				position: this.positions[this.positions.length - 2],
				point: {
					pixelSize: 10,
					outlineColor: this._completeColor,
					outlineWidth: 3,
					disableDepthTestDistance: Number.POSITIVE_INFINITY,
				},
			};
			this.viewer.entities.add(pointoptions);
			//加文本
			var VDistance = getVDistance$1(positions, this.viewer);
			if (VDistance > 0.01) {
				let VDistanceText = "垂直" + VDistance + "米";
				var pos = positions[0].clone();
				pos.x = (positions[0].x + positions[1].x) / 2;
				pos.y = (positions[0].y + positions[1].y) / 2;
				pos.z = (positions[0].z + positions[1].z) / 2;
				this.viewer.entities.add({
					name: '空间水平直线距离文本',
					position: pos,
					label: {
						text: VDistanceText,
						font: '18px sans-serif',
						fillColor: SceneGIS.Color.GOLD,
						style: SceneGIS.LabelStyle.FILL_AND_OUTLINE,
						outlineWidth: 2,
						verticalOrigin: SceneGIS.VerticalOrigin.CENTER,
						pixelOffset: new SceneGIS.Cartesian2(0, -20),
						eyeOffset: new SceneGIS.Cartesian3(0, 0, -10),
						disableDepthTestDistance: Number.POSITIVE_INFINITY,
					}
				});
			}
			if (this.callback) {
				this.callback(this.distances);
			}
		}
		this.positions.pop(); //最后一个点无效

		//该段测量结束
		this._draw = false;
		this.positions = [];
		this.poly = null;
		this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
	};

	let PolyLinePrimitive$1 = (function () {
		function _(positions, viewer) {

			this.viewer = viewer;
			this.options = {
				name: '水平直线',
				polyline: {
					show: true,
					positions: [],
					material: SceneGIS.Color.YELLOW,
					width: 3,
					clampToGround: false,
					depthTest: false
				}
			};
			this.positions = positions;
			this._init();
		}

		_.prototype._init = function () {
			let _self = this;
			let _update = function () {
				return _self.positions;
			};
			//实时更新polyline.positions
			this.options.polyline.positions = new SceneGIS.CallbackProperty(_update, false);
			this.viewer.entities.add(this.options);
		};

		return _;
	})();
	/** @private */
	MeasureHDistanceEX.prototype.MOUSE_MOVE = function (e) {
		if (this._draw === false) {
			return;
		}
		const planeView = this.viewer.scene.planeView;
		this.cartesian = this.viewer.scene.pickPosition(e.endPosition);
		//cartesian = viewer.scene.camera.pickEllipsoid(movement.endPosition, viewer.scene.globe.ellipsoid);
		if (this.cartesian) {
			this._tempPosition = this.cartesian;
			if (planeView === true) {
				this.cartesian.z = this._height;
			} else {
				let cartographic_1 = SceneGIS.Cartographic.fromCartesian(this.cartesian);
				var lon = SceneGIS.Math.toDegrees(cartographic_1.longitude);
				var lat = SceneGIS.Math.toDegrees(cartographic_1.latitude);
				this.cartesian = new SceneGIS.Cartesian3.fromDegrees(lon, lat, this._height);
			}
			if (this.cartesian != undefined) {
				if (this.positions.length >= 2) {
					if (!SceneGIS.defined(this.poly)) {
						this.poly = new PolyLinePrimitive$1(this.positions, this.viewer);
					} else {
						this.positions.pop();
						// cartesian.y += (1 + Math.random());
						this.positions.push(this.cartesian.clone());
					}
					this.distance = getHDistance$1(this.positions, this.viewer);//水平距离
				}
			}
		}
	};


	//垂直距离计算函数
	function getVDistance$1(positions, viewer) {
		const planeView = viewer.scene.planeView;
		let distance = 0;
		if (planeView === true) {
			let point1 = positions[positions.length - 2];
			let point2 = positions[positions.length - 1];
			distance = point2.z - point1.z;
		} else {
			let point1cartographic = SceneGIS.Cartographic.fromCartesian(positions[positions.length - 2]);
			let point2cartographic = SceneGIS.Cartographic.fromCartesian(positions[positions.length - 1]);
			/**根据经纬度计算出距离**/
			let geodesic = new SceneGIS.EllipsoidGeodesic();
			geodesic.setEndPoints(point1cartographic, point2cartographic);
			distance = point2cartographic.height - point1cartographic.height;
		}
		return Math.abs(distance.toFixed(2));
	}
	//水平距离计算函数
	function getHDistance$1(positions, viewer) {
		const planeView = viewer.scene.planeView;
		let distance = 0;
		if (planeView === true) {
			for (let i = 0; i < positions.length - 1; i++) {
				let point1 = positions[i];
				let point2 = positions[i + 1];
				//根据世界坐标算出距离
				let s = Math.sqrt(Math.pow((point1.x - point2.x), 2) + Math.pow((point1.y - point2.y), 2));
				distance = distance + s;
			}
		} else {
			for (let i = 0; i < positions.length - 1; i++) {

				let point1cartographic = SceneGIS.Cartographic.fromCartesian(positions[i]);
				let point2cartographic = SceneGIS.Cartographic.fromCartesian(positions[i + 1]);
				/**根据经纬度计算出距离**/
				let geodesic = new SceneGIS.EllipsoidGeodesic();
				geodesic.setEndPoints(point1cartographic, point2cartographic);
				let s = geodesic.surfaceDistance;
				distance = distance + s;
			}
		}
		return Math.abs(distance.toFixed(2));
	}

	/**
	 * 垂直距离测量类
	 *
	 * @class MeasureVDistanceEX
	 * @param {Object} options
	 * @param {function} options.callback 回调函数
	 * @param {SceneGIS.Viewer} viewer viewer对象
	 */

	function MeasureVDistanceEX(options, viewer) {
		this.name = "MeasureVDistanceEX";
		this.cartesian = undefined;
		this.positions = [];
		this.poly = null;
		//结果
		this.distance = 0;
		this.distances = [];
		this.floatingPoint = null;
		viewer.scene.globe.depthTestAgainstTerrain = true;//开启地形深度检测
		this._lon = 0;
		this._lat = 0;
		this.pointPositions = [];
		this._completeColor = SceneGIS.Color.GREEN.withAlpha(0.5);
		this._viewer = viewer;
		//开启功能后，是否绘制
		this._draw = true;
		this.callback = options.callback ? options.callback : undefined;
		this.isrunning = false;
		//鼠标点
		this._tempPoint = undefined;
		this._tempPosition = new SceneGIS.Cartesian3(0, 0, 0);
	}
	Object.freeze({});

	Object.defineProperties(MeasureVDistanceEX.prototype, {
		/**
		* 获取viewer 对象
		* @memberof MeasureVDistanceEX.prototype
		*
		* @type {Viewer}
		* @readonly
		*/

		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		}

	});
	/**
	 * 开始功能
	 */
	MeasureVDistanceEX.prototype.start = function () {
		//添加事件
		this.addEvent();
		this.isrunning = true;
	};
	/** @private */
	MeasureVDistanceEX.prototype.addEvent = function () {

		if (this.handle) return;
		this.handle = new SceneGIS.ScreenSpaceEventHandler(this.viewer.canvas);
		var that = this;
		//添加事件
		this.handle.setInputAction(function (event) {
			that.LEFT_CLICK(event);
		}, SceneGIS.ScreenSpaceEventType.LEFT_CLICK);
		this.handle.setInputAction(function (event) {
			that.RIGHT_CLICK(event);
		}, SceneGIS.ScreenSpaceEventType.RIGHT_CLICK);

		this.handle.setInputAction(function (event) {
			that.MOUSE_MOVE(event);
		}, SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);

		let self = this;
		this._tempPoint = this._viewer.entities.add({
			name: "多边形",
			position: new SceneGIS.CallbackProperty(function () {
				return self._tempPosition;
			}, false),
			point: {
				show: new SceneGIS.CallbackProperty(function () {
					return self._draw;
				}, false),
				pixelSize: 10,
				outlineColor: SceneGIS.Color.YELLOW,
				outlineWidth: 3
			}
		});

	};
	/** @private */
	MeasureVDistanceEX.prototype.removeEvent = function () {
		if (!this.handle) return;
		this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.LEFT_CLICK);
		this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.RIGHT_CLICK);
		this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
		this.handle = undefined;
		if (this._tempPoint) {
			this._viewer.entities.remove(this._tempPoint);
		}
	};

	/**
	 * 销毁操作，销毁内部事件和临时对象
	 */
	MeasureVDistanceEX.prototype.destroy = function () {
		if (this.isrunning === false) return;
		this.clear();
		this.removeEvent();
		this.isrunning = false;
	};

	/**
	 * 暂停功能
	 */
	MeasureVDistanceEX.prototype.stop = function () {
		this.removeEvent();
	};

	/**
	 *  清除当前实体
	 */
	MeasureVDistanceEX.prototype.clear = function () {
		const entitys = this.viewer.entities._entities._array;
		let length = entitys.length;
		// 倒叙遍历防止实体减少之后entitys[f]不存在
		for (let f = length - 1; f >= 0; f--) {
			if (entitys[f]._name && ((entitys[f]._name.indexOf("直线") != -1) || (entitys[f]._name.indexOf("多边形") != -1))) {
				this.viewer.entities.remove(entitys[f]);
			}
		}
		this.distances = [];
		// this.viewer.entities.removeAll()
	};
	/** @private */
	MeasureVDistanceEX.prototype.LEFT_CLICK = function (e) {
		const planeView = this.viewer.scene.planeView;
		if (this._draw === false) {
			let that = this;
			this.handle.setInputAction(function (event) {
				that.MOUSE_MOVE(event);
			}, SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
			this._draw = true;
		}

		this.cartesian = this.viewer.scene.pickPosition(e.position);
		if (this.cartesian == undefined) {
			return;
		}

		//在三维场景中添加点                                                                                             
		if (this.positions.length == 0) {
			if (planeView === true) {
				this._lon = this.cartesian.x;
				this._lat = this.cartesian.y;
			} else {
				let cartographic_1 = SceneGIS.Cartographic.fromCartesian(this.cartesian);
				this._lon = SceneGIS.Math.toDegrees(cartographic_1.longitude);
				this._lat = SceneGIS.Math.toDegrees(cartographic_1.latitude);
			}
			this.positions.push(this.cartesian.clone());
		}
		this.positions.push(this.cartesian.clone());

		this.floatingPoint = this.viewer.entities.add({
			name: '空间垂直直线距离',
			position: this.positions[this.positions.length - 1],
			point: {
				pixelSize: 10,
				outlineColor: this._completeColor,
				outlineWidth: 3,
				disableDepthTestDistance: Number.POSITIVE_INFINITY,
			},
		});
		this.pointPositions.push(this.positions[this.positions.length - 1]);
		if (this.positions.length > 2) {
			this.distances.push(this.distance);
			let textDistance = "垂直" + this.distance + "米";
			var pos = this.positions[0].clone();
			pos.x = (this.positions[this.positions.length - 2].x + this.positions[this.positions.length - 3].x) / 2;
			pos.y = (this.positions[this.positions.length - 2].y + this.positions[this.positions.length - 3].y) / 2;
			pos.z = (this.positions[this.positions.length - 2].z + this.positions[this.positions.length - 3].z) / 2;
			this.viewer.entities.add({
				name: '空间垂直直线距离文本',
				position: pos,
				label: {
					text: textDistance,
					font: '18px sans-serif',
					fillColor: SceneGIS.Color.GOLD,
					style: SceneGIS.LabelStyle.FILL_AND_OUTLINE,
					outlineWidth: 2,
					verticalOrigin: SceneGIS.VerticalOrigin.CENTER,
					pixelOffset: new SceneGIS.Cartesian2(0, -20),
					eyeOffset: new SceneGIS.Cartesian3(0, 0, -10),
					disableDepthTestDistance: Number.POSITIVE_INFINITY,
				}
			});
			this.RIGHT_CLICK();
		}

	};
	/** @private */
	MeasureVDistanceEX.prototype.RIGHT_CLICK = function (e) {
		if (this._draw === false) {
			return;
		}
		if (this.positions.length > 2) {
			//加水平线
			var positions = [];
			positions.push(this.pointPositions[this.pointPositions.length - 1]);
			positions.push(this.positions[this.positions.length - 2]);
			this.viewer.entities.add({
				name: '垂直直线',  //其实是水平线
				polyline: {
					show: true,
					positions: positions,
					material: SceneGIS.Color.CHARTREUSE,
					width: 3,
					clampToGround: false,
					depthTest: false
				}
			});
			//加点
			let pointoptions = {
				name: '空间垂直直线距离',
				position: this.positions[this.positions.length - 2],
				point: {
					pixelSize: 10,
					outlineColor: this._completeColor,
					outlineWidth: 3,
					disableDepthTestDistance: Number.POSITIVE_INFINITY,
				},
			};
			this.viewer.entities.add(pointoptions);
			//加文本
			var HDistance = getHDistance(positions, this.viewer);
			if (HDistance > 0.01) {
				let HDistanceText = "水平" + HDistance + "米";
				var pos = positions[0].clone();
				pos.x = (positions[0].x + positions[1].x) / 2;
				pos.y = (positions[0].y + positions[1].y) / 2;
				pos.z = (positions[0].z + positions[1].z) / 2;
				this.viewer.entities.add({
					name: '空间垂直直线距离文本',
					position: pos,
					label: {
						text: HDistanceText,
						font: '18px sans-serif',
						fillColor: SceneGIS.Color.GOLD,
						style: SceneGIS.LabelStyle.FILL_AND_OUTLINE,
						outlineWidth: 2,
						verticalOrigin: SceneGIS.VerticalOrigin.CENTER,
						pixelOffset: new SceneGIS.Cartesian2(0, -20),
						eyeOffset: new SceneGIS.Cartesian3(0, 0, -10),
					}
				});
			}
			if (this.callback) {
				this.callback(this.distances);
			}
		}
		this.positions.pop(); //最后一个点无效
		this._draw = false;
		this.positions = [];
		this.poly = null;
		this.handle.removeInputAction(SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
	};

	let PolyLinePrimitive = (function () {
		function _(positions, viewer) {
			this.viewer = viewer;
			this.options = {
				name: '垂直直线',
				polyline: {
					show: true,
					positions: [],
					material: SceneGIS.Color.YELLOW,
					width: 3,
					clampToGround: false,
					depthTest: false
				}
			};
			this.positions = positions;
			this._init();
		}

		_.prototype._init = function () {
			let _self = this;
			let _update = function () {
				return _self.positions;
			};
			//实时更新polyline.positions
			this.options.polyline.positions = new SceneGIS.CallbackProperty(_update, false);
			this.viewer.entities.add(this.options);
		};

		return _;
	})();
	/** @private */
	MeasureVDistanceEX.prototype.MOUSE_MOVE = function (e) {
		if (this._draw === false) {
			return;
		}
		const planeView = this.viewer.scene.planeView;
		this.cartesian = this.viewer.scene.pickPosition(e.endPosition);
		if (this.cartesian) {
			this._tempPosition = this.cartesian;
			if (planeView === true) {
				this.cartesian.x = this._lon;
				this.cartesian.y = this._lat;
			} else {
				let cartographic_1 = SceneGIS.Cartographic.fromCartesian(this.cartesian);
				var h_ = cartographic_1.height;
				this.cartesian = new SceneGIS.Cartesian3.fromDegrees(this._lon, this._lat, h_);
			}
			if (this.cartesian != undefined) {
				if (this.positions.length >= 2) {
					if (!SceneGIS.defined(this.poly)) {
						this.poly = new PolyLinePrimitive(this.positions, this.viewer);
					} else {
						this.positions.pop();
						this.positions.push(this.cartesian.clone());
					}
					this.distance = getVDistance(this.positions, this.viewer);//垂直距离  
				}
			}
		}
	};


	//垂直距离计算函数
	function getVDistance(positions, viewer) {
		const planeView = viewer.scene.planeView;
		let distance = 0;
		if (planeView === true) {
			let point1 = positions[positions.length - 2];
			let point2 = positions[positions.length - 1];
			distance = point2.z - point1.z;
		} else {
			let point1cartographic = SceneGIS.Cartographic.fromCartesian(positions[positions.length - 2]);
			let point2cartographic = SceneGIS.Cartographic.fromCartesian(positions[positions.length - 1]);
			/**根据经纬度计算出距离**/
			let geodesic = new SceneGIS.EllipsoidGeodesic();
			geodesic.setEndPoints(point1cartographic, point2cartographic);
			distance = point2cartographic.height - point1cartographic.height;
		}
		return Math.abs(distance.toFixed(2));
	}
	//水平距离计算函数
	function getHDistance(positions, viewer) {
		const planeView = viewer.scene.planeView;
		let distance = 0;
		if (planeView === true) {
			for (let i = 0; i < positions.length - 1; i++) {
				let point1 = positions[i];
				let point2 = positions[i + 1];
				//根据世界坐标算出距离
				let s = Math.sqrt(Math.pow((point1.x - point2.x), 2) + Math.pow((point1.y - point2.y), 2));
				distance = distance + s;
			}
		} else {
			for (let i = 0; i < positions.length - 1; i++) {

				let point1cartographic = SceneGIS.Cartographic.fromCartesian(positions[i]);
				let point2cartographic = SceneGIS.Cartographic.fromCartesian(positions[i + 1]);
				/**根据经纬度计算出距离**/
				let geodesic = new SceneGIS.EllipsoidGeodesic();
				geodesic.setEndPoints(point1cartographic, point2cartographic);
				let s = geodesic.surfaceDistance;
				distance = distance + s;
			}
		}
		return Math.abs(distance.toFixed(2));
	}

	/**
	 * 面积测量类
	 * @class MeasureAreaEX
	 * @param {Object} options
	 * @param {Number} [options.type=1] 面积测量方式:1-投影面积 | 2-地表面积 | 3-空间面积,默认为1
	 * @param {function} options.callback 回调函数
	 * @param {SceneGIS.Viewer} viewer viewer对象
	 */

	/* global Cesium */
	function MeasureAreaEX(options, viewer) {
		CheckEX.instanceOf("viewer", viewer, SceneGIS.Viewer);
		this._viewer = viewer;
		this._scene = viewer.scene;
		this.type = SceneGIS.defaultValue(options.type, 1);
		CheckEX.typeOf("options.type", options.type, "number");

		this._pause = true;
		this.areanum = undefined;
		viewer.scene.globe.depthTestAgainstTerrain = true;//开启地形深度检测

		this._tempPoint = undefined;
		this._tempPolygon = undefined;

		this._tempPosition = new SceneGIS.Cartesian3(0, 0, 0);
		this._tempPositions = [];
		this._tempPoints = [];
		this._positions = [];
		this.screenPoints = []; //屏幕坐标

		this._handle = new SceneGIS.ScreenSpaceEventHandler(this._scene.canvas);
		this._mouseMove = mouseMoveArea.bind(this);
		this._leftClick = leftClickArea.bind(this);
		this._rightClick = rightClickArea.bind(this);

		this._destroyed = false;
		this.isrunning = false;
		this.callback = options.callback ? options.callback : undefined;
	}

	/**
	 * 开始功能
	 */
	MeasureAreaEX.prototype.start = function () {
		addEvent(this);
		this._pause = false;
		this.isrunning = true;
	};

	function addEvent(MeasureAreaEX) {
		MeasureAreaEX._handle.setInputAction(MeasureAreaEX._mouseMove, SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
		MeasureAreaEX._handle.setInputAction(MeasureAreaEX._leftClick, SceneGIS.ScreenSpaceEventType.LEFT_CLICK);
		MeasureAreaEX._handle.setInputAction(MeasureAreaEX._rightClick, SceneGIS.ScreenSpaceEventType.RIGHT_CLICK);
		MeasureAreaEX._tempPoint = MeasureAreaEX._viewer.entities.add({
			name: "多边形",
			position: new SceneGIS.CallbackProperty(function () {
				return MeasureAreaEX._tempPosition;
			}, false),
			point: {
				show: new SceneGIS.CallbackProperty(function () {
					return !MeasureAreaEX._pause;
				}, false),
				pixelSize: 10,
				// heightReference:SceneGIS.HeightReference.CLAMP_TO_GROUND,
				outlineColor: SceneGIS.Color.YELLOW,
				outlineWidth: 3
			}
		});
	}

	function mouseMoveArea(movement) {
		if (this._pause) {
			return;
		}
		const position = this._scene.pickPosition(movement.endPosition);
		if (SceneGIS.defined(position)) {
			this._tempPosition = position;
			if (this._tempPositions.length !== 0) {
				this._tempPositions[this._tempPositions.length - 1] = position;
			}
		}
	}

	function leftClickArea(mouse) {
		if (this._pause) {
			return;
		}
		const position = this._scene.pickPosition(mouse.position);
		if (!position) {
			return;
		}

		this._tempPositions.pop();
		this._tempPositions.push(position.clone());
		this._positions.push(position.clone());
		this.screenPoints.push(mouse.position.clone());
		const point = this._viewer.entities.add({
			name: '多边形面积',
			position: position,
			point: {
				pixelSize: 10,
				outlineColor: SceneGIS.Color.GREEN,
				outlineWidth: 3
			}
		});
		this._tempPositions.push(position);
		//一般点数组的长度比面数组长1
		this._drawing = true;
		if (!this._tempPolygon && this._tempPositions.length === 3) {
			const that = this;
			this._tempPolygon = this._viewer.entities.add({
				name: '多边形',
				polygon: {
					hierarchy: new SceneGIS.CallbackProperty(function () {
						const res = new SceneGIS.PolygonHierarchy(that._tempPositions);
						return res;
					}, false),
					perPositionHeight: that.type === 3 ? true : false,
					material: SceneGIS.Color.YELLOW.withAlpha(0.5),
				}
			});
		}
		this._tempPoints.push(point);
	}

	function rightClickArea() {
		if (this._pause) {
			return;
		}

		if (this._tempPolygon) {

			this._tempPolygon = undefined;
			if (this._tempPositions.length > 3) {
				this._tempPositions.pop();

				//计算面积
				if (this.type == 1) {
					this.areanum = this.computeArea();
				} else if (this.type == 2) {
					this.areanum = this.calculateSurfaceArea(this.screenPoints);
				} else if (this.type == 3) {
					this.areanum = this.calculateSpaceArea();
				}
				console.log("this.areanum:", this.areanum);
				let textArea = "";
				if (this.areanum < 1000000) {
					textArea = "共" + (this.areanum).toFixed(2) + "平方米";
				} else {
					textArea = "共" + (this.areanum / 1000000.0).toFixed(4) + "平方公里";
				}
				//回调
				if (this.callback) {
					this.callback(this.areanum);
				}
				//添加结果文本，并且将文本放在正中间
				let cartos = transformCartesianArrayToWGS84Array(this._viewer, this._positions);
				let pos = JSON.parse(JSON.stringify(cartos[0]));
				var length = cartos.length;
				for (let i = 1; i < length; i++) {
					pos.lng += cartos[i].lng;
					pos.lat += cartos[i].lat;
				}
				pos.lng = pos.lng / (length);
				pos.lat = pos.lat / (length);
				this._viewer.entities.add({
					name: '多边形面积',
					position: SceneGIS.Cartesian3.fromDegrees(pos.lng, pos.lat, pos.alt + 1),
					label: {
						text: textArea,
						font: '18px sans-serif',
						fillColor: SceneGIS.Color.GOLD,
						style: SceneGIS.LabelStyle.FILL_AND_OUTLINE,
						outlineWidth: 2,
						verticalOrigin: SceneGIS.VerticalOrigin.CENTER,
						disableDepthTestDistance: Number.POSITIVE_INFINITY,
					}
				});

				this._positions = [];
				this._pause = true;
			} else {
				this._tempPositions = [];
				this._positions = [];
			}
		} else {
			this._tempPositions = [];
			this._positions = [];
		}
		this._drawing = false;
	}

	/**
	 * @private
	 * 计算投影面积
	 * @returns {double} result 投影面积结果
	 */
	MeasureAreaEX.prototype.computeArea = function () {
		return getArea(this._positions, this._viewer);
	};

	function getArea(positions, viewer) {
		let result = 0;
		if (positions) {
			positions.push(positions[0]);
			//平面坐标系的计算方式
			if (viewer.scene.planeView === true) {
				let h = 0;
				for (let i = 1; i < positions.length; i++) {
					let oel = positions[i - 1];
					let el = positions[i];
					h += oel.x * el.y - el.x * oel.y;
				}
				result = Math.abs(h);
				return result / 2;
			}
			//球面坐标系的计算方式
			const arr = [];
			const cartos = transformCartesianArrayToWGS84Array(viewer, positions);
			for (let i = 0; i < cartos.length; i++) {
				const point = [];
				point.push(cartos[i].lng);
				point.push(cartos[i].lat);
				arr.push(point);
			}
			const polygon$1 = polygon([arr]);
			result = area(polygon$1);
			return result;
		}
	}

	/**
	 * @private
	 * 计算空间面积
	 * @returns {double} result 空间面积结果
	 */
	MeasureAreaEX.prototype.calculateSpaceArea = function () {
		let result = 0;
		for (let i = 1; i < this._positions.length - 1; i++) {
			var threeposition = [];
			threeposition.push(this._positions[0]);
			threeposition.push(this._positions[i]);
			threeposition.push(this._positions[i + 1]);
			result += this.computeArea3D(threeposition);
		}
		return result;
	};

	/**
	 * @private
	 * 计算地表面积
	 * @param {Array} screenPoints 屏幕坐标
	 * @returns {double} result 地表面积结果
	 */
	MeasureAreaEX.prototype.calculateSurfaceArea = function (screenPoints) {
		let that = this;
		let result = 0;
		const bounds = getBounds(screenPoints);
		var points = randomPoint(50, { bbox: [bounds[0], bounds[1], bounds[2], bounds[3]] });
		var mainPoly = Cartesian2turfPolygon(screenPoints);
		var voronoiPolygons = voronoi(points, { bbox: [bounds[0], bounds[1], bounds[2], bounds[3]] });
		//遍历每一个多边形
		voronoiPolygons.features.forEach(element => {
			const intersectPoints = intersect(mainPoly, element.geometry); //计算当前小多边形和原多边形的交集
			//将二维数据转为三维
			var threeposition = [];
			for (var cart of intersectPoints) {
				var cartesianModel = getCatesian3FromPX(that._viewer, cart);
				threeposition.push(cartesianModel);
			}
			result += this.computeArea3D(threeposition);
		});
		return result;
	};

	function getCatesian3FromPX(viewer, px) {

		if (viewer && px) {
			let cartesian = viewer.scene.pickPosition(px);
			if (cartesian) {
				return cartesian;
			}
			return false;
		}

	}

	/**
	 * @private
	 * 单个多边形的表面积计算
	 * @param {Array} PolygonPoints 多边形点坐标
	 * @returns {double} 单个多边形面积结果
	 */
	MeasureAreaEX.prototype.computeArea3D = function (PolygonPoints) {
		let Area = 0.0;
		let Length = PolygonPoints.length;
		if (Length < 3) {
			return Area;
		}

		// 求解常量
		let Point1 = PolygonPoints[0], Point2 = PolygonPoints[1], Point3 = PolygonPoints[2];
		let P1X = Point1.x, P1Y = Point1.y, P1Z = Point1.z;
		let P2X = Point2.x, P2Y = Point2.y, P2Z = Point2.z;
		let P3X = Point3.x, P3Y = Point3.y, P3Z = Point3.z;

		let a = Math.pow(((P2Y - P1Y) * (P3Z - P1Z) - (P3Y - P1Y) * (P2Z - P1Z)), 2) +
			Math.pow(((P3X - P1X) * (P2Z - P1Z) - (P2X - P1X) * (P3Z - P1Z)), 2) +
			Math.pow(((P2X - P1X) * (P3Y - P1Y) - (P3X - P1X) * (P2Y - P1Y)), 2);
		let cosnx = ((Point2.y - Point1.y) * (Point3.z - Point1.z) - (Point3.y - Point1.y) * (Point2.z - Point1.z)) / Math.pow(a, 0.5);
		let cosny = ((Point3.x - Point1.x) * (Point2.z - Point1.z) - (Point2.x - Point1.x) * (Point3.z - Point1.z)) / Math.pow(a, 0.5);
		let cosnz = ((Point2.x - Point1.x) * (Point3.y - Point1.y) - (Point3.x - Point1.x) * (Point2.y - Point1.y)) / Math.pow(a, 0.5);

		// 迭代计算面积
		let CurPoint, NextPoint;
		for (let i = 0; i < Length; ++i) {
			CurPoint = PolygonPoints[i];
			NextPoint = PolygonPoints[(i + 1) % Length];
			Area += cosnz * (CurPoint.x * NextPoint.y - NextPoint.x * CurPoint.y)
				+ cosnx * (CurPoint.y * NextPoint.z - NextPoint.y * CurPoint.z)
				+ cosny * (CurPoint.z * NextPoint.x - NextPoint.z * CurPoint.x);
		}
		return Math.abs(0.5 * Area);
	};

	function getBounds(points) {
		let bounds = [];
		let left = Number.MAX_VALUE;
		let right = Number.MIN_VALUE;
		let top = Number.MAX_VALUE;
		let bottom = Number.MIN_VALUE;
		points.forEach(element => {
			left = Math.min(left, element.x);
			right = Math.max(right, element.x);
			top = Math.min(top, element.y);
			bottom = Math.max(bottom, element.y);
		});
		bounds.push(left);
		bounds.push(top);
		bounds.push(right);
		bounds.push(bottom);
		return bounds;
	}

	function Cartesian2turfPolygon(positions) {
		var coordinates = [];
		coordinates[0] = [];
		positions.forEach(element => {
			coordinates[0].push([element.x, element.y]);
		});
		coordinates[0].push([positions[0].x, positions[0].y]);
		const polygon$1 = polygon(coordinates);
		return polygon$1.geometry;
	}

	function intersect(poly1, poly2) {
		var intersection = intersect$1(poly1, poly2);
		if (intersection && intersection.geometry !== undefined) {
			return turfPloygon2CartesianArr(intersection.geometry);
		} else {
			return [];
		}
	}

	function turfPloygon2CartesianArr(geometry) {
		var arr = [];
		for (var i in geometry.coordinates[0]) {
			var cart = new SceneGIS.Cartesian2();
			cart.x = geometry.coordinates[0][i][0];
			cart.y = geometry.coordinates[0][i][1];
			arr.push(cart);
		}
		return arr;
	}

	/**
	 * @private
	 */
	MeasureAreaEX.prototype.removeEvent = function () {
		this._handle.removeInputAction(SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
		this._handle.removeInputAction(SceneGIS.ScreenSpaceEventType.LEFT_CLICK);
		this._handle.removeInputAction(SceneGIS.ScreenSpaceEventType.RIGHT_CLICK);
	};

	/**
	 * 清除当前实体
	 */
	MeasureAreaEX.prototype.clear = function () {
		this._tempPositions = [];
		this._positions = [];

		const entitys = this._viewer.entities._entities._array;
		let length = entitys.length;
		// 倒叙遍历防止实体减少之后entitys[f]不存在
		for (let f = length - 1; f >= 0; f--) {
			if (entitys[f]._name && ((entitys[f]._name.indexOf("多边形") != -1) || (entitys[f]._name.indexOf("直线") != -1))) {
				this._viewer.entities.remove(entitys[f]);
			}
		}
	};

	/**
	 *  暂停绘制
	 */
	MeasureAreaEX.prototype.stop = function () {
		this.removeEvent();
	};

	/**
	 * 销毁操作，销毁内部事件和临时对象
	 */
	MeasureAreaEX.prototype.destroy = function () {
		if (this._destroyed) {
			return;
		}
		if (this._drawing) {
			this._rightClick();//结束创建图形
		}
		this.clear();
		this.removeEvent();
		if (this._tempPoint) {
			this._viewer.entities.remove(this._tempPoint);
		}
		this._tempPositions = [];

		this._destroyed = true;
		this.isrunning = false;
	};

	function transformCartesianToWGS84(viewer, cartesian) {
		if (viewer && cartesian) {
			var ellipsoid = SceneGIS.Ellipsoid.WGS84;
			var cartographic = ellipsoid.cartesianToCartographic(cartesian);
			return {
				lng: SceneGIS.Math.toDegrees(cartographic.longitude),
				lat: SceneGIS.Math.toDegrees(cartographic.latitude),
				alt: cartographic.height
			}
		}
	}

	function transformCartesianArrayToWGS84Array(viewer, cartesianArr) {
		let cartos = [];
		for (let cartesian of cartesianArr) {
			let carto = transformCartesianToWGS84(viewer, cartesian);
			cartos.push(carto);
		}
		return cartos;
	}

	/**
	 * 影像卷帘
	 * @class ImagerySplitEX
	 * @param {Object} options 
	 * @param {String} [options.type="horizon"] 卷帘方向，默认"horizon"-横向卷帘。"vertical"-纵向卷帘
	 * @param {String} [options.divId="slider"] 滑条div的id，默认"slider"
	 * @param {Array} options.imagerys 进行卷帘的影像图层，需为数组形式传入,索引 0 为左卷帘或上卷帘，索引 1 为右卷帘或下卷帘
	 * @param {SceneGIS.Viewer} viewer 
	 */
	function ImagerySplitEX(options, viewer) {
		//默认值
		options = SceneGIS.defaultValue(options, SceneGIS.defaultValue.EMPTY_OBJECT);
		options.type = SceneGIS.defaultValue(options.type, "horizon");
		options.divId = SceneGIS.defaultValue(options.divId, "slider");
		options.imagerys = SceneGIS.defaultValue(options.imagerys, []);
		//检查类型
		CheckEX.instanceOf("viewer", viewer, SceneGIS.Viewer);
		CheckEX.typeOf("options.type", options.type, "string");
		CheckEX.typeOf("options.divId", options.divId, "string");
		CheckEX.instanceOf("options.imagerys", options.imagerys, Array);

		this._type = options.type;
		this._divId = options.divId;
		this._imagerys = options.imagerys;

		this._viewer = viewer;
		this.slider = document.getElementById(options.divId);
		this.handler = new SceneGIS.ScreenSpaceEventHandler(this.slider);
		if (options.imagerys.length > 1 && options.imagerys[0].data) {
			this.leftLayer = options.imagerys[0].data;
			this.rightLayer = options.imagerys[1].data;
		}
		this.moveActive = false;
		this.isrunning = false;
	}

	Object.defineProperties(ImagerySplitEX.prototype, {
		/**
		 * 获取viewer 对象
		 * @memberof ImagerySplitEX.prototype
		 *
		 * @type {SceneGIS.Viewer}
		 * @readonly
		 */
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		},

		/**
		 * 卷帘方向
		 * @memberof ImagerySplitEX.prototype
		 *
		 * @type {String}
		 */
		type: {
			get: function () {
				return SceneGIS.defined(this._type) ? this._type : undefined;
			},
			set: function (val) {
				this._type = val;
			}
		},

		/**
		 * 滑条div的id
		 * @memberof ImagerySplitEX.prototype
		 *
		 * @type {String}
		 */
		divId: {
			get: function () {
				return SceneGIS.defined(this._divId) ? this._divId : undefined;
			},
			set: function (val) {
				this._divId = val;
				if (this.slider) {
					this.slider.style.visibility = "hidden";
					//为了在start()中handler重建
					this.destroy();
				}
			}
		},

		/**
		 * 进行卷帘的影像图层
		 * @memberof ImagerySplitEX.prototype
		 * @readonly
		 * @type {Array}
		 */
		imagerys: {
			get: function () {
				return SceneGIS.defined(this._imagerys) ? this._imagerys : undefined;
			}
		},
	});

	/**
	 * 开始功能
	 */
	ImagerySplitEX.prototype.start = function () {
		if (this.isrunning == false) {
			this.isrunning = true;
			this.startFunc();
			this.handler.setInputAction(function () { this.moveActive = true; }.bind(this), SceneGIS.ScreenSpaceEventType.LEFT_DOWN);
			this.handler.setInputAction(function () { this.moveActive = true; }.bind(this), SceneGIS.ScreenSpaceEventType.PINCH_START);
			this.handler.setInputAction(move.bind(this), SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
			this.handler.setInputAction(move.bind(this), SceneGIS.ScreenSpaceEventType.PINCH_MOVE);
			this.handler.setInputAction(function () { this.moveActive = false; }.bind(this), SceneGIS.ScreenSpaceEventType.LEFT_UP);
			this.handler.setInputAction(function () { this.moveActive = false; }.bind(this), SceneGIS.ScreenSpaceEventType.PINCH_END);
		} else {
			this.startFunc();
		}

	};

	/** @private */
	ImagerySplitEX.prototype.startFunc = function () {
		//重新获取一下slider
		this.slider = document.getElementById(this._divId);
		this.handler = new SceneGIS.ScreenSpaceEventHandler(this.slider);
		this.slider.style.visibility = "visible";
		//横向卷帘
		if (this.type === "horizon") {
			if (this.leftLayer) {
				this.leftLayer.splitDirection = SceneGIS.SplitDirection.LEFT;
			}
			if (this.rightLayer) {
				this.rightLayer.splitDirection = SceneGIS.SplitDirection.RIGHT;
			}
			viewer.scene.splitType = "width";
			viewer.scene.splitPosition = this.slider.offsetLeft / this.slider.parentElement.offsetWidth;
		}
		else if (this.type === "vertical") {
			if (this.leftLayer) {
				this.leftLayer.splitDirection = SceneGIS.SplitDirection.TOP;
			}
			if (this.rightLayer) {
				this.rightLayer.splitDirection = SceneGIS.SplitDirection.DOWN;
			}
			viewer.scene.splitType = "height";
			viewer.scene.splitPosition = 1.0 - this.slider.offsetTop / this.slider.parentElement.offsetHeight;
		}
	};

	function move(movement) {
		if (!this.moveActive) {
			return;
		}
		if (this.type === "horizon") {
			var relativeOffset = movement.endPosition.x;
			var splitPosition = (this.slider.offsetLeft + relativeOffset) / this.slider.parentElement.offsetWidth;
			this.slider.style.left = `${100.0 * splitPosition}%`;
			viewer.scene.splitPosition = splitPosition;
		}
		else {
			var relativeOffset = movement.endPosition.y;
			var splitPosition = (this.slider.offsetTop + relativeOffset) / this.slider.parentElement.offsetHeight;
			this.slider.style.top = `${100.0 * splitPosition}%`;
			viewer.scene.splitPosition = 1.0 - splitPosition;
		}
	}
	/**
	 * 暂停功能
	 */
	ImagerySplitEX.prototype.stop = function () {
		this.removeEvent();
	};

	/**@private */
	ImagerySplitEX.prototype.removeEvent = function () {
		this.handler.removeInputAction(SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
		this.handler.removeInputAction(SceneGIS.ScreenSpaceEventType.LEFT_DOWN);
		this.handler.removeInputAction(SceneGIS.ScreenSpaceEventType.PINCH_START);
		this.handler.removeInputAction(SceneGIS.ScreenSpaceEventType.PINCH_MOVE);
		this.handler.removeInputAction(SceneGIS.ScreenSpaceEventType.LEFT_UP);
		this.handler.removeInputAction(SceneGIS.ScreenSpaceEventType.PINCH_END);
		this.moveActive = false;
	};

	/**
	 * 清除
	 */
	ImagerySplitEX.prototype.clear = function () {
		this.slider.style.visibility = "hidden";
		if (this.leftLayer) {
			this.leftLayer.splitDirection = SceneGIS.SplitDirection.NONE;
		}
		if (this.rightLayer) {
			this.rightLayer.splitDirection = SceneGIS.SplitDirection.NONE;
		}
	};
	/**
	 * 销毁
	 */
	ImagerySplitEX.prototype.destroy = function () {
		if (this.isrunning === false) return;
		this.stop();
		this.clear();
		this.isrunning = false;
	};

	/**
	 * 缓冲区分析
	 * @class BufferAnalysisEX
	 * @param {Object} options 
	 * @param {number} [options.bufferDistance=10] 缓冲区距离，默认10，单位米
	 * @param {SceneGIS.Color} [options.color=SceneGIS.Color.DARKORANGE.withAlpha(0.5)] 缓冲区颜色，默认SceneGIS.Color.DARKORANGE.withAlpha(0.5)
	 * @param {SceneGIS.Viewer} viewer 
	 */
	function BufferAnalysisEX(options, viewer) {
		//检查
		CheckEX.instanceOf("viewer", viewer, SceneGIS.Viewer);
		CheckEX.typeOf("options.bufferDistance", options.bufferDistance, "number");
		CheckEX.instanceOf("options.color", options.color, SceneGIS.Color);

		this._viewer = viewer;

		this._bufferDistance = SceneGIS.defaultValue(options.bufferDistance, 10);
		this._bufferColor = SceneGIS.defaultValue(options.color, SceneGIS.Color.DARKORANGE.withAlpha(0.5));
		this._drawItems = [];
		this._callback = options.callback;

		this._depthTestAgainstTerrain = this._viewer.scene.globe.depthTestAgainstTerrain;
		this._viewer.scene.globe.depthTestAgainstTerrain = true;
		this.planeView = viewer.scene.planeView;
		this.isrunning = false;
	}

	Object.defineProperties(BufferAnalysisEX.prototype, {
		/**
		 * 缓冲区距离
		 * @memberof BufferAnalysisEX.prototype
		 * @type {number}
		 */
		bufferDistance: {
			get: function () {
				return this._bufferDistance;
			},
			set: function (val) {
				if (isNumber(val)) {
					this._bufferDistance = val;
				}
			}
		},
		/**
		 * 缓冲区颜色
		 * @memberof BufferAnalysisEX.prototype
		 * @type {SceneGIS.Color}
		 */
		bufferColor: {
			get: function () {
				return this._bufferColor;
			},
			set: function (e) {
				CheckEX.instanceOf("bufferColor", e, SceneGIS.Color);
				this._bufferColor = e;
			}
		}
	});
	/**
	 * 开始功能
	 */
	BufferAnalysisEX.prototype.start = function () {
		if (this.isrunning == false) {
			this._draw = new CommanDrawEX({ callback: callback$4.bind(this) }, this._viewer);
			this._draw.setMode(CommanDrawModeEX$1.LINE);
			this._draw.pause = false;
			this.isrunning = true;
		} else {
			this._draw.pause = false;
		}

	};
	/**
	 * 暂停功能
	 */
	BufferAnalysisEX.prototype.stop = function () {
		this.removeEvent();
	};
	/**@private */
	BufferAnalysisEX.prototype.removeEvent = function () {
		this._draw.pause = true;
	};

	function callback$4(data) {
		if (data.eventType) {
			switch (data.type) {
				case CommanDrawModeEX$1.POINT:
					{
						let cartographic, longitude, latitude;
						let buffered;
						//add by oyyx begin
						//获取buffered的数据
						if (this.planeView === true) {
							buffered = new SceneGIS.CircleGeometry({
								center: data.position,
								radius: this._bufferDistance,
								planeView: true
							});
							SceneGIS.CircleGeometry.createGeometry(buffered);
						}
						//add by oyyx end
						else {
							cartographic = SceneGIS.Cartographic.fromCartesian(data.position);
							longitude = SceneGIS.Math.toDegrees(cartographic.longitude);
							latitude = SceneGIS.Math.toDegrees(cartographic.latitude);
							let turfPoint = point([longitude, latitude]);
							buffered = buffer(turfPoint, this._bufferDistance, { units: 'meters' });
						}
						let pointBuffer = this._viewer.entities.add({
							position: data.position,
							ellipse: {
								semiMajorAxis: this._bufferDistance,
								semiMinorAxis: this._bufferDistance,
								material: this._bufferColor
							}
						});
						let item = {
							entity: pointBuffer,
							commanDrawData: data,
							geometry: buffered.geometry || buffered._ellipseGeometry
						};
						this._drawItems.push(item);
						if (this._callback) {
							this._callback(item);
						}
						break;
					}
				case CommanDrawModeEX$1.LINE:
					{
						if (data.eventType === "rightClick") {
							let positions = [];
							for (let position of data.position) {
								let cartographic, longitude, latitude;
								if (this.planeView === true) {
									break;
								} else {
									cartographic = SceneGIS.Cartographic.fromCartesian(position);
									longitude = SceneGIS.Math.toDegrees(cartographic.longitude);
									latitude = SceneGIS.Math.toDegrees(cartographic.latitude);
									positions.push([longitude, latitude]);
								}
							}
							let cesiumPositions = [], buffered, bufferedPositions;
							//add by oyyx begin
							if (this.planeView === true) {
								buffered = new SceneGIS.CorridorGeometry({
									vertexFormat: SceneGIS.VertexFormat.POSITION_ONLY,
									positions: data.position,
									width: this._bufferDistance,
									planeView: this.planeView
								});
								//为了拿到corridor的顶点信息
								SceneGIS.CorridorGeometry.createGeometry(buffered);
								bufferedPositions = buffered._totalPositions;
								for (let i in bufferedPositions) {
									cesiumPositions.push(bufferedPositions[i]);
								}
							}
							//add by oyyx end
							else {
								let trufPolyline = lineString(positions);
								buffered = buffer(trufPolyline, this._bufferDistance, { units: 'meters' });
								bufferedPositions = buffered.geometry.coordinates[0];
								for (let position of bufferedPositions) {
									cesiumPositions.push(position[0]);
									cesiumPositions.push(position[1]);
								}
							}
							let lineBuffer = this._viewer.entities.add({
								polygon: {
									hierarchy: this.planeView === true ? new SceneGIS.PolygonHierarchy(SceneGIS.Cartesian3.unpackArray(cesiumPositions))
										: new SceneGIS.PolygonHierarchy(SceneGIS.Cartesian3.fromDegreesArray(cesiumPositions)),
									material: this._bufferColor,
								}
							});
							let item = {
								entity: lineBuffer,
								commanDrawData: data,
								//fixed by oyyx
								geometry: buffered.geometry || buffered
							};
							this._drawItems.push(item);
							if (this._callback) {
								this._callback(item);
							}
						}
						break;
					}
				case CommanDrawModeEX$1.POLYGON:
					{
						if (data.eventType === "rightClick") {
							let positions = [];
							let buffered, bufferedPositions;
							let cesiumPositions = [];
							if (this.planeView === true) {
								positions = data.position.concat();
								positions.push(positions[0]);
								buffered = new SceneGIS.CorridorGeometry({
									vertexFormat: SceneGIS.VertexFormat.POSITION_ONLY,
									positions: positions,
									width: this._bufferDistance,
									planeView: this.planeView
								});
								//为了拿到corridor的顶点信息
								SceneGIS.CorridorGeometry.createGeometry(buffered);
								bufferedPositions = buffered._totalPositions;
								for (let i in bufferedPositions) {
									cesiumPositions.push(bufferedPositions[i]);
								}
								console.log("oyyx cesiumPositions:", cesiumPositions);
								let tmpCesiumPositions = cesiumPositions.concat();
								for (let i = 0; i < tmpCesiumPositions.length - 2; i += 3) {
									let point = { x: tmpCesiumPositions[i], y: tmpCesiumPositions[i + 1] };
									let vertices = data.position.concat();
									if (isPointInsideQuad(point, vertices) === true) {
										cesiumPositions.splice(i, 3);
									}
								}
							} else {
								for (let position of data.position) {
									let cartographic = SceneGIS.Cartographic.fromCartesian(position);
									let longitude = SceneGIS.Math.toDegrees(cartographic.longitude);
									let latitude = SceneGIS.Math.toDegrees(cartographic.latitude);
									positions.push([longitude, latitude]);
								}
								positions.push(positions[0]);

								let trufPolygon = polygon([positions]);
								buffered = buffer(trufPolygon, this._bufferDistance, { units: 'meters' });
								bufferedPositions = buffered.geometry.coordinates[0];
								for (let position of bufferedPositions) {
									cesiumPositions.push(position[0]);
									cesiumPositions.push(position[1]);
								}
							}

							let polygonBuffer = this._viewer.entities.add({
								polygon: {
									hierarchy: this.planeView === true ? new SceneGIS.PolygonHierarchy(SceneGIS.Cartesian3.unpackArray(cesiumPositions))
										: new SceneGIS.PolygonHierarchy(SceneGIS.Cartesian3.fromDegreesArray(cesiumPositions)),
									material: this._bufferColor,
								}
							});

							let item = {
								entity: polygonBuffer,
								commanDrawData: data,
								geometry: buffered.geometry
							};
							this._drawItems.push(item);
							if (this._callback) {
								this._callback(item);
							}
						}
						break;
					}
			}
		}
	}

	function isPointInsideQuad(point, polygon) {
		var x = point.x, y = point.y;
		var inside = false;
		for (var i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
			var xi = polygon[i].x, yi = polygon[i].y;
			var xj = polygon[j].x, yj = polygon[j].y;
			var intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
			if (intersect) inside = !inside;
		}
		return inside;
	}

	/**
	 * 清除
	 */
	BufferAnalysisEX.prototype.clear = function () {
		for (let item of this._drawItems) {
			if (item.entity) {
				this._viewer.entities.remove(item.entity);
			} else if (item.primitive) {
				this._viewer.scene.primitives.remove(item.primitive);
			}
		}
		this._draw.removeAll();
	};

	/**
	 * 设置模式
	 * @param {CommanDrawMode} mode 模式，参见CommanDrawMode
	 */
	BufferAnalysisEX.prototype.setMode = function (mode) {
		this._draw.setMode(mode);//buffer的setModel又调用Draw的setMode
	};

	/**
	 * 销毁
	 */
	BufferAnalysisEX.prototype.destroy = function () {
		if (this.isrunning === false) return
		this._viewer.scene.globe.depthTestAgainstTerrain = this._depthTestAgainstTerrain;
		this.clear();
		this._draw.destroy();
		this.isrunning = false;
	};

	/**
	 * 通视分析
	 * @class VisibilityAnalysisEX
	 * @constructor
	 * @param {Object} options
	 * @param {SceneGIS.Color} [options.visibleColor=SceneGIS.Color.GREEN] 可见的颜色
	 * @param {SceneGIS.Color} [options.invisibleColor=SceneGIS.Color.RED] 不可见的颜色
	 * @param {SceneGIS.Viewer} viewer 
	 */
	function VisibilityAnalysisEX(options, viewer) {
		//设置默认值
		options = SceneGIS.defaultValue(options, SceneGIS.defaultValue.EMPTY_OBJECT);
		options.visibleColor = SceneGIS.defaultValue(options.visibleColor, SceneGIS.Color.GREEN);
		options.invisibleColor = SceneGIS.defaultValue(options.invisibleColor, SceneGIS.Color.RED);
		//类型检查
		CheckEX.instanceOf("options.visibleColor", options.visibleColor, SceneGIS.Color);
		CheckEX.instanceOf("options.invisibleColor", options.invisibleColor, SceneGIS.Color);
		this._viewer = viewer;
		this._dataSource = new SceneGIS.CustomDataSource("visiblityEntitys");
		viewer.dataSources.add(this._dataSource);
		this._drawItems = [];

		this._visibleColor = SceneGIS.Color.GREEN;
		this._invisibleColor = SceneGIS.Color.RED;
		if (options.visibleColor) {
			this.visibleColor = options.visibleColor;
		}
		if (options.invisibleColor) {
			this.invisibleColor = options.invisibleColor;
		}

		this._depthTestAgainstTerrain = this._viewer.scene.globe.depthTestAgainstTerrain;
		this._viewer.scene.globe.depthTestAgainstTerrain = true;
		this.isrunning = false;
	}

	Object.defineProperties(VisibilityAnalysisEX.prototype, {
		/**
		 * 可见的颜色
		 * @memberof VisibilityAnalysisEX.prototype
		 * @type {SceneGIS.Color}
		 */
		visibleColor: {
			get: function () {
				return this._visibleColor;
			},
			set: function (e) {
				this._visibleColor = e;
			}
		},
		/**
		 * 不可见的颜色
		 * @memberof VisibilityAnalysisEX.prototype
		 * @type {SceneGIS.Color}
		 */
		invisibleColor: {
			get: function () {
				return this._invisibleColor;
			},
			set: function (e) {
				this._invisibleColor = e;
			}
		}
	});

	function callback$3(data) {
		this.visibleTest(data.position[0], data.position[1]);
	}
	/**
	 * 开始功能
	 */
	VisibilityAnalysisEX.prototype.start = function () {
		if (this.isrunning == false) {
			this._draw = new CommanDrawEX({
				ground: false,
				drawComplete: false,
				callback: callback$3.bind(this)
			}, this._viewer);
			this._draw.setMode(CommanDrawModeEX$1.STRAIGHTLINE);
			this._draw.pause = false;
			this.isrunning = true;
		} else {
			this._draw.pause = false;
		}

	};
	/**
	 * 暂停功能
	 */
	VisibilityAnalysisEX.prototype.stop = function () {
		this.removeEvent();
	};
	/**@private */
	VisibilityAnalysisEX.prototype.removeEvent = function () {
		this._draw.pause = true;
	};

	/**
	 * 测试两点之间的可见性
	 * @param {SceneGIS.Cartesian3} startPoint 
	 * @param {SceneGIS.Cartesian3} endPoint 
	 * @private
	 */
	VisibilityAnalysisEX.prototype.visibleTest = function (startPoint, endPoint) {
		this.addLabel(startPoint, endPoint);
		let direction = new SceneGIS.Cartesian3(endPoint.x - startPoint.x, endPoint.y - startPoint.y, endPoint.z - startPoint.z);
		SceneGIS.Cartesian3.normalize(direction, direction);
		let ray = new SceneGIS.Ray(startPoint, direction);
		var result = this._viewer.scene.pickFromRay(ray);
		if (result && result.position) {
			let distanceToCross = SceneGIS.Cartesian3.distance(startPoint, result.position);
			let lineLength = SceneGIS.Cartesian3.distance(startPoint, endPoint);
			if (distanceToCross > lineLength) {
				this.visible(startPoint, endPoint);
			} else {
				let middlePoint = SceneGIS.Cartesian3.lerp(startPoint, endPoint, distanceToCross / lineLength, new SceneGIS.Cartesian3);
				this.invisible(startPoint, middlePoint, endPoint);
			}
		} else {
			this.visible(startPoint, endPoint);
		}
	};

	/**
	 * 添加文字注记
	 * @param {SceneGIS.Cartesian3} startPoint 
	 * @param {SceneGIS.Cartesian3} endPoint 
	 * @private
	 */
	VisibilityAnalysisEX.prototype.addLabel = function (startPoint, endPoint) {
		const planeView = this._viewer.scene.planeView;
		let startCartographic = SceneGIS.Cartographic.fromCartesian(startPoint);
		let endCartographic = SceneGIS.Cartographic.fromCartesian(endPoint);
		this._dataSource.entities.add({
			position: startPoint,
			label: {
				text: planeView === true ? `x: ${startPoint.x}\ny: ${startPoint.y}\nz: ${startPoint.z}` :
					`经度:${SceneGIS.Math.toDegrees(startCartographic.longitude).toFixed(3)}\n纬度:${SceneGIS.Math.toDegrees(startCartographic.latitude).toFixed(3)}\n高度:${startCartographic.height.toFixed(3)}`,
				font: '14px 微软雅黑',
				showBackground: true,
				horizontalOrigin: SceneGIS.HorizontalOrigin.LEFT,
				verticalOrigin: SceneGIS.VerticalOrigin.BOTTOM,
				disableDepthTestDistance: 10000
			}
		});

		this._dataSource.entities.add({
			position: endPoint,
			label: {
				text: planeView === true ? `x:${endPoint.x}\ny:${endPoint.y}\z:${endPoint.z}` :
					`经度:${SceneGIS.Math.toDegrees(endCartographic.longitude).toFixed(3)}\n纬度:${SceneGIS.Math.toDegrees(endCartographic.latitude).toFixed(3)}\n高度:${endCartographic.height.toFixed(3)}`,
				font: '14px 微软雅黑',
				showBackground: true,
				horizontalOrigin: SceneGIS.HorizontalOrigin.LEFT,
				verticalOrigin: SceneGIS.VerticalOrigin.BOTTOM,
				disableDepthTestDistance: 10000
			}
		});
	};

	/**
	 * 绘制可见的结果
	 * @param {SceneGIS.Cartesian3} startPoint 
	 * @param {SceneGIS.Cartesian3} endPoint 
	 * @private
	 */
	VisibilityAnalysisEX.prototype.visible = function (startPoint, endPoint) {
		this._dataSource.entities.add({
			polyline: {
				positions: [startPoint, endPoint],
				width: 3,
				material: this._visibleColor
			}
		});
	};

	/**
	 * 绘制包含不可见段的结果
	 * @param {SceneGIS.Cartesian3} startPoint 
	 * @param {SceneGIS.Cartesian3} middlePoint 
	 * @param {SceneGIS.Cartesian3} endPoint 
	 * @private
	 */
	VisibilityAnalysisEX.prototype.invisible = function (startPoint, middlePoint, endPoint) {
		this._dataSource.entities.add({
			polyline: {
				positions: [startPoint, middlePoint],
				width: 3,
				material: this._visibleColor
			}
		});
		this._dataSource.entities.add({
			polyline: {
				positions: [middlePoint, endPoint],
				width: 3,
				material: this._invisibleColor
			}
		});
	};

	/**
	 * 清除图形
	 */
	VisibilityAnalysisEX.prototype.clear = function () {
		this._dataSource.entities.removeAll();
		this._draw.removeAll();
	};

	/**
	 * 释放资源
	 */
	VisibilityAnalysisEX.prototype.destroy = function () {
		this._viewer.scene.globe.depthTestAgainstTerrain = this._depthTestAgainstTerrain;
		this.clear();
		this._viewer.dataSources.remove(this._dataSource, true);
		this._draw.destroy();
		this.isrunning = false;
	};

	// import CoreEX.getAssetUrl from "./Core/CoreEX.getAssetUrl.js";

	/**
	 * 可视域分析
	 * @alias VisibleAreaAnalysisEX
	 * @constructor
	 * @param {Object} options 
	 * @param {Number} [options.near=1] 最近分析距离
	 * @param {Number} [options.far=500] 最远分析距离
	 * @param {Number} [options.horizontalFov=60] 水平视场角
	 * @param {Number} [options.verticalFov=30] 垂直视场角
	 * @param {Boolean} [options.hasLine=false] 是否创建辅助线
	 * @param {SceneGIS.Viewer} viewer 
	 */
	function VisibleAreaAnalysisEX(options, viewer) {
		CheckEX.typeOf("options.near", options.near, 'number');
		CheckEX.typeOf("options.far", options.far, 'number');
		CheckEX.typeOf("options.horizontalFov", options.horizontalFov, 'number');
		CheckEX.typeOf("options.verticalFov", options.verticalFov, 'number');
		CheckEX.typeOf("options.hasLine", options.hasLine, 'boolean');
		this._viewer = viewer;
		this._handle = new SceneGIS.ScreenSpaceEventHandler(viewer.scene.canvas);
		this._tempPoint = null;
		this._tempPosition = new SceneGIS.Cartesian3(0, 0, 0);
		this._tempEntity = null;
		this._depthCameraPosition = undefined;
		this._pause = true;
		this._readyTempEntity = false;
		this._projects = [];//存储视域分析实例
		this._entities = [];
		this.cameraEntities = new SceneGIS.CustomDataSource("cameraEntities");
		viewer.dataSources.add(this.cameraEntities);
		this._destroyed = false;

		this._near = SceneGIS.defined(options.near) ? options.near : 1;
		this._far = SceneGIS.defined(options.far) ? options.far : 500;
		this._fovx = SceneGIS.defined(options.horizontalFov) ? options.horizontalFov : 60;
		this._fovy = SceneGIS.defined(options.verticalFov) ? options.verticalFov : 30;
		this._hasLine = SceneGIS.defined(options.hasLine) ? options.hasLine : false;
		this.hasCameraEntity = SceneGIS.defined(options.hasCameraEntity) ? options.hasCameraEntity : false;

		this._callback = options.callback instanceof Function ? options.callback : undefined;
		this._depthTestAgainstTerrain = this._viewer.scene.globe.depthTestAgainstTerrain;
		this._viewer.scene.globe.depthTestAgainstTerrain = true;
		this.isrunning = false;
	}

	Object.defineProperties(VisibleAreaAnalysisEX.prototype, {
		/**
		 * 最近分析距离
		 * @memberof VisibleAreaAnalysisEX.prototype
		 * @type {Number}
		 */
		near: {
			get: function () {
				return this._near;
			},
			set: function (val) {
				this._near = val;
			}
		},
		/**
		 * 最远分析距离
		 * @memberof VisibleAreaAnalysisEX.prototype
		 * @type {Number}
		 */
		far: {
			get: function () {
				return this._far;
			},
			set: function (val) {
				this._far = val;
			}
		},
		/**
		 * 水平视场角
		 * @memberof VisibleAreaAnalysisEX.prototype
		 * @type {Number}
		 */
		horizontalFov: {
			get: function () {
				return this._fovx;
			},
			set: function (val) {
				this._fovx = val;
			}
		},
		/**
		 * 垂直视场角
		 * @memberof VisibleAreaAnalysisEX.prototype
		 * @type {Number}
		 */
		verticalFov: {
			get: function () {
				return this._fovy;
			},
			set: function (val) {
				this._fovy = val;
			}
		},
		/**
		 * 是否绘制辅助线
		 * @memberof VisibleAreaAnalysisEX.prototype
		 * @type {Boolean}
		 */
		hasLine: {
			get: function () {
				return this._hasLine;
			},
			set: function (val) {
				this._hasLine = val;
			}
		},
		/**
		 * 是否暂停分析
		 * @memberof VisibleAreaAnalysisEX.prototype
		 * @type {Boolean}
		 */
		pause: {
			get: function () {
				return this._pause;
			},
			set: function (val) {
				this._pause = val;
			}
		}
	});
	/**
	 * 开始功能
	 */
	VisibleAreaAnalysisEX.prototype.start = function () {
		bindEvent$1.bind(this)();
		this.isrunning = true;
		this._pause = false;
	};
	/**
	 * 暂停功能
	 */
	VisibleAreaAnalysisEX.prototype.stop = function () {
		this.removeEvent();
	};
	/**@private */
	VisibleAreaAnalysisEX.prototype.removeEvent = function () {
		unbindEvent$1.bind(this)();
		this.pause = true;
	};

	function bindEvent$1() {
		this._handle.setInputAction(mouseMove$2.bind(this), SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
		this._handle.setInputAction(leftClick$1.bind(this), SceneGIS.ScreenSpaceEventType.LEFT_CLICK);
		this._handle.setInputAction(rightClick$1.bind(this), SceneGIS.ScreenSpaceEventType.RIGHT_CLICK);
		let that = this;
		this._tempPoint = this._viewer.entities.add({
			position: new SceneGIS.CallbackProperty(function () {
				return that._tempPosition;
			}, false),
			point: {
				show: new SceneGIS.CallbackProperty(function () {
					return !that._pause;
				}, false),
				pixelSize: 10,
				outlineColor: SceneGIS.Color.YELLOW,
				outlineWidth: 3
			}
		});
	}

	function mouseMove$2(movement) {
		if (this._pause) {
			return;
		}
		let position = this._viewer.scene.pickPosition(movement.endPosition);
		if (SceneGIS.defined(position)) {
			const planeView = this._viewer.scene.planeView;
			this._tempPosition = position;
			if (this._readyTempEntity) {
				this._readyTempEntity = false;
				let that = this;
				this._tempEntity = this._viewer.entities.add({
					position: this._depthCameraPosition,
					orientation: new SceneGIS.CallbackProperty(function () {
						let direction = new SceneGIS.Cartesian3(
							that._tempPosition.x - that._depthCameraPosition.x,
							that._tempPosition.y - that._depthCameraPosition.y,
							that._tempPosition.z - that._depthCameraPosition.z);
						SceneGIS.Cartesian3.normalize(direction, direction);
						let up;
						if (planeView === true) {
							up = new SceneGIS.Cartesian3(0, 0, 1);
						} else {
							up = SceneGIS.Cartesian3.normalize(that._depthCameraPosition, new SceneGIS.Cartesian3);
						}
						let right = SceneGIS.Cartesian3.cross(direction, up, new SceneGIS.Cartesian3);
						SceneGIS.Cartesian3.normalize(right, right);
						SceneGIS.Cartesian3.cross(right, direction, up);
						SceneGIS.Cartesian3.normalize(up, up);
						let viewMatrix = SceneGIS.Matrix4.computeView(that._depthCameraPosition, direction, up, right, new SceneGIS.Matrix4);
						let inverseViewMatrix = SceneGIS.Matrix4.inverse(viewMatrix, new SceneGIS.Matrix4);
						const mat3 = SceneGIS.Matrix4.getMatrix3(inverseViewMatrix, new SceneGIS.Matrix3()); //获取旋转矩阵，也是以深度相机为原点，以视线负方向为z轴、以上方向为y轴的坐标系
						const rotate = SceneGIS.Matrix3.fromRotationX(-SceneGIS.Math.PI_OVER_TWO); //绕x轴顺时针旋转90度的旋转矩阵
						const rotated = SceneGIS.Matrix3.multiply(mat3, rotate, new SceneGIS.Matrix3()); //得到以视线方向为y轴，上方向为z轴的坐标系
						return SceneGIS.Quaternion.fromRotationMatrix(rotated, new SceneGIS.Quaternion())
					}, false),
					ellipsoid: {
						radii: new SceneGIS.Cartesian3(this._far, this._far, this._far), //外径
						innerRadii: new SceneGIS.Cartesian3(this._near, this._near, this._near), //内径
						minimumClock: SceneGIS.Math.PI_OVER_TWO - this._fovx * SceneGIS.Math.RADIANS_PER_DEGREE * 0.5, //水平方向，以x轴方向为起点，绕z轴顺时针方向
						maximumClock: SceneGIS.Math.PI_OVER_TWO + this._fovx * SceneGIS.Math.RADIANS_PER_DEGREE * 0.5,
						minimumCone: SceneGIS.Math.PI_OVER_TWO - this._fovy * SceneGIS.Math.RADIANS_PER_DEGREE * 0.5, //垂直方向，以z轴方向为起点，绕x轴顺时针方向
						maximumCone: SceneGIS.Math.PI_OVER_TWO + this._fovy * SceneGIS.Math.RADIANS_PER_DEGREE * 0.5,
						fill: false, //不填充
						outline: true, //绘制边线
						outlineColor: SceneGIS.Color.YELLOW,
						stackPartitions: 4,
						slicePartitions: 4,
					},
				});
			}
		}
	}

	function leftClick$1(mouse) {
		if (this._pause) {
			return;
		}
		let position = this._viewer.scene.pickPosition(mouse.position);
		if (!this._tempEntity) {
			this._readyTempEntity = true;
			this._depthCameraPosition = position;
		} else {
			const planeView = this._viewer.scene.planeView;
			//有两个点就完成
			this._viewer.entities.remove(this._tempEntity);
			this._tempEntity = null;
			//重置条件
			this._pause = true;
			//调用视域分析功能
			let direction = new SceneGIS.Cartesian3(
				this._tempPosition.x - this._depthCameraPosition.x,
				this._tempPosition.y - this._depthCameraPosition.y,
				this._tempPosition.z - this._depthCameraPosition.z);
			SceneGIS.Cartesian3.normalize(direction, direction);
			let up;
			if (planeView === true) {
				up = new SceneGIS.Cartesian3(0, 0, 1);
			} else {
				up = SceneGIS.Cartesian3.normalize(this._depthCameraPosition, new SceneGIS.Cartesian3);
			}
			let right = SceneGIS.Cartesian3.cross(direction, up, new SceneGIS.Cartesian3);
			SceneGIS.Cartesian3.normalize(right, right);
			SceneGIS.Cartesian3.cross(right, direction, up);
			SceneGIS.Cartesian3.normalize(up, up);
			let project = new SceneGIS.Visible(this._viewer, {
				position: this._depthCameraPosition,
				diretion: direction,
				up: up,
				verticalFov: this._fovy,
				horizontalFov: this._fovx,
				near: this.near,
				far: this.far,
				hasLine: this.hasLine
			});
			project.apply();
			this._projects.push(project);
			if (this.hasCameraEntity) {
				this.addCameraEntity(project);
			}

			if (this._callback) {
				this._callback(project);
			}
		}
	}

	function rightClick$1() {
		if (this._pause) {
			return;
		}

		if (this._tempEntity) {
			this._viewer.entities.remove(this._tempEntity);
			this._tempEntity = null;
		}
	}

	function unbindEvent$1() {
		this._handle.removeInputAction(SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
		this._handle.removeInputAction(SceneGIS.ScreenSpaceEventType.LEFT_CLICK);
		this._handle.removeInputAction(SceneGIS.ScreenSpaceEventType.RIGHT_CLICK);
	}
	/**@private */
	VisibleAreaAnalysisEX.prototype.addCameraEntity = function (project) {
		let depthCamera = project.depthCamera;
		this.cameraEntities.entities.add({
			position: new SceneGIS.CallbackProperty(function () {
				return depthCamera.position;
			}, false),
			orientation: new SceneGIS.CallbackProperty(function () {
				let hpr = new SceneGIS.HeadingPitchRoll(depthCamera.heading - Math.PI / 2, depthCamera.pitch, depthCamera.roll);
				return SceneGIS.Transforms.headingPitchRollQuaternion(depthCamera.position, hpr);
			}, false),
			model: {
				uri: CoreEX.getAssetUrl('glb/UE4Camera.glb'),
				scale: 10
			}
		});
		this._entities.push(cameraEntity);
	};

	/**
	 * @private
	 * 从场景相机创建可视域分析
	 */
	VisibleAreaAnalysisEX.prototype.fromScene = function () {
		const camera = this._viewer.camera;
		let project = new SceneGIS.Visible(this._viewer, {
			position: camera.position.clone(),
			diretion: camera.direction.clone(),
			up: camera.up.clone(),
			verticalFov: this._fovy,
			horizontalFov: this._fovx,
			near: this.near,
			far: this.far,
			hasLine: this.hasLine
		});
		project.apply();
		this._projects.push(project);
		if (this.hasCameraEntity) {
			this.addCameraEntity(project);
		}
		if (this._callback) {
			this._callback(project);
		}
	};

	/**
	 * 清除
	 */
	VisibleAreaAnalysisEX.prototype.clear = function () {
		rightClick$1.bind(this)();
		for (let project of this._projects) {
			project.destroy();
		}
		this._projects = [];
		this.cameraEntities.entities.removeAll();
		this._entities = [];
	};

	/**
	 * 移除分析案例
	 * @param {number} index 序号
	 */
	VisibleAreaAnalysisEX.prototype.removeCase = function (index) {
		if (index < this._projects.length) {
			let project = this._projects[index];
			project.destroy();
			this._projects.splice(index, 1);
			if (this.addCameraEntity) {
				let entity = this._entities[index];
				this.cameraEntities.entities.remove(entity);
				this._entities.splice(index, 1);
			}
			return true;
		}
		return false;
	};

	/**
	 * 销毁
	 */
	VisibleAreaAnalysisEX.prototype.destroy = function () {
		if (this._destroyed) {
			return;
		}
		this.clear();
		unbindEvent$1.bind(this)();
		if (this._tempPoint) {
			this._viewer.entities.remove(this._tempPoint);
		}
		this._viewer.dataSources.remove(this.cameraEntities, true);
		this._viewer.scene.globe.depthTestAgainstTerrain = this._depthTestAgainstTerrain;
		this._destroyed = true;
		this.isrunning = false;
	};

	/**
	 * 天际线分析类
	 * @class SkylineEX
	 * @param {Object} options 
	 * @param {Boolean} [options.isFixed=false] 相机位置是否锁定
	 * @param {SceneGIS.Viewer} viewer 
	 */
	function SkylineEX(options, viewer) {
		options = defaultValue$2(options, defaultValue$2.EMPTY_OBJECT);
		options.isFixed = defaultValue$2(options.isFixed, false);
		viewer.scene.globe.depthTestAgainstTerrain = true;//开启地形深度检测
		this._show = false;
		this._viewer = viewer;
		this.isFixed = options.isFixed;
		this._flags = {
			looking: false,
		};
		this._x;
		this._y;
		this.moveHandle = undefined;
		this.postProccessStageDraw = undefined;
		this.isrunning = false;

	}

	function defaultValue$2(a, b) {
		if (a !== undefined && a !== null) {
			return a;
		}
		return b;
	}
	defaultValue$2.EMPTY_OBJECT = Object.freeze({});

	Object.defineProperties(SkylineEX.prototype, {
		/**
		* 获取 三维 viewer
		*
		* @memberof SkylineEX.prototype
		*
		* @type {Viewer}
		* @readonly
		*
		* @default undefined
		*/

		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		}

	});
	/**
	 * 开始功能
	 */
	SkylineEX.prototype.start = function () {
		this.bindEvent();
		this.add();
		this.isrunning = true;
	};
	/** @private */
	SkylineEX.prototype.bindEvent = function () {
		this.moveHandle = new SceneGIS.ScreenSpaceEventHandler(this.viewer.canvas);
		this.moveHandle.setInputAction(function (event) {
			this._flags.looking = true;
		}.bind(this), SceneGIS.ScreenSpaceEventType.LEFT_DOWN);

		this.moveHandle.setInputAction(function (event) {
			this._flags.looking = false;
		}.bind(this), SceneGIS.ScreenSpaceEventType.LEFT_UP);

		this.moveHandle.setInputAction(mouseMove$1.bind(this), SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
	};

	function mouseMove$1(movement) {
		this._x = movement.endPosition.x - movement.startPosition.x;
		this._y = movement.endPosition.y - movement.startPosition.y;
	}
	/**@private */
	function updateCamera() {
		let camera = this._viewer.camera;
		let canvas = this._viewer.canvas;
		if (this._flags.looking) {
			let width = canvas.clientWidth;
			let height = canvas.clientHeight;
			let x_norm = this._x / width;
			let y_norm = -this._y / height;
			camera.lookRight(x_norm);
			camera.lookUp(y_norm);
		}
	}
	/**
	 * @private
	 * 天际线的开启和关闭
	 */
	SkylineEX.prototype.add = function () {
		var collection = this.viewer.scene.postProcessStages;
		for (var c1 = 0; c1 < collection.length; c1++) {
			var c = collection.get(c1);
			if (c.name == 'czm_skyline' || c.name == "czm_skylinetemp") {
				collection.remove(c);

			}
		}
		if (this._show) { this._show = false; return; }
		var edgeDetection = SceneGIS.PostProcessStageLibrary.createEdgeDetectionStage();

		var postProccessStage = new SceneGIS.PostProcessStage({
			name: 'czm_skylinetemp',
			fragmentShader: 'uniform sampler2D colorTexture;' +
				'uniform sampler2D depthTexture;' +

				'varying vec2 v_textureCoordinates;' +

				'void main(void)' +
				'{' +
				'float depth = czm_readDepth(depthTexture, v_textureCoordinates);' +
				'vec4 color = texture2D(colorTexture, v_textureCoordinates);' +
				'if(depth<1.0 - 0.000001){' +
				'gl_FragColor = color;' +
				'}' +
				'else{' +
				'gl_FragColor = vec4(1.0,0.0,0.0,1.0);' +
				'}' +
				'}'
		});

		this.postProccessStageDraw = new SceneGIS.PostProcessStage({
			name: 'czm_drawline',
			fragmentShader: 'uniform sampler2D redTexture;' +
				'uniform sampler2D silhouetteTexture;' +
				'varying vec2 v_textureCoordinates;' +
				'void main(void)' +
				'{' +
				'vec4 color = vec4(0.227, 0.613, 0.875, 1.);' +
				'vec4 silhouetteColor = texture2D(silhouetteTexture, v_textureCoordinates);' +
				'vec4 redcolor=texture2D(redTexture, v_textureCoordinates);' +
				'if(redcolor.r == 1.0){' +
				'gl_FragColor = mix(color, vec4(1.0,0.0,0.0,1.0), silhouetteColor.a);' +
				'}' +
				'else{' +
				'gl_FragColor = color;' +
				'}' +
				'}',
			uniforms: {
				redTexture: postProccessStage.name,
				silhouetteTexture: edgeDetection.name
			}
		});

		var postProccessStage1 = new SceneGIS.PostProcessStage({
			name: 'czm_skylinetemp1',
			fragmentShader: 'uniform sampler2D colorTexture;' +
				'uniform sampler2D skylineTexture;' +
				'varying vec2 v_textureCoordinates;' +
				'void main(void)' +
				'{' +
				'vec4 skyline=texture2D(skylineTexture, v_textureCoordinates);' +
				'vec4 color = texture2D(colorTexture, v_textureCoordinates);' +
				'if(skyline.r == 1.0){' +
				'gl_FragColor = mix(color, skyline, skyline.a);' +
				'}' +
				'else{' +
				'gl_FragColor = color;' +
				'}' +
				'}',
			uniforms: {
				skylineTexture: this.postProccessStageDraw.name,
				silhouetteTexture: edgeDetection.name
			}
		});

		var postProccessStage = new SceneGIS.PostProcessStageComposite({
			name: 'czm_skyline',
			stages: [edgeDetection, postProccessStage, this.postProccessStageDraw, postProccessStage1],
			inputPreviousStageTexture: false,
			uniforms: edgeDetection.uniforms
		});

		collection.add(postProccessStage);
		this._show = true;
	};

	/**
	 * 天际线图下载
	 */
	SkylineEX.prototype.download = function () {
		let skylineCapture = new SceneGIS.textureCapture({
			postProccessStage: this.postProccessStageDraw,
			viewer: this.viewer,
		});
		skylineCapture.getCapture();
	};

	/**
	 * 是否锁定相机位置
	 * @param {Boolean} val true-锁定 | false-不锁定
	 */
	SkylineEX.prototype.fixedPosition = function (val) {
		const scene = this.viewer.scene;
		scene.screenSpaceCameraController.enableRotate = !val;
		scene.screenSpaceCameraController.enableTranslate = !val;
		scene.screenSpaceCameraController.enableZoom = !val;
		scene.screenSpaceCameraController.enableTilt = !val;
		scene.screenSpaceCameraController.enableLook = !val;
		if (val) {
			if (!this._updateCameraRemove)
				this._updateCameraRemove = scene.preUpdate.addEventListener(updateCamera.bind(this));
		} else {
			if (this._updateCameraRemove) {
				this._updateCameraRemove();
				this._updateCameraRemove = undefined;
			}
		}
	};

	/**
	 * 关闭天际线
	 */
	SkylineEX.prototype.clear = function () {
		var collection = this.viewer.scene.postProcessStages;
		for (var c1 = 0; c1 < collection.length; c1++) {
			var c = collection.get(c1);
			if (c.name == 'czm_skyline' || c.name == "czm_skylinetemp") {
				collection.remove(c);
			}
		}
		this._show = false;
	};

	SkylineEX.prototype.stop = function () {
		throw new SceneGIS.DeveloperError('error');
	};
	/**
	 * 资源销毁
	 */
	SkylineEX.prototype.destroy = function () {
		if (this.isrunning === false) return
		var collection = this.viewer.scene.postProcessStages;
		for (var c1 = 0; c1 < collection.length; c1++) {
			var c = collection.get(c1);
			if (c.name == 'czm_skyline' || c.name == "czm_skylinetemp") {
				collection.remove(c);
			}
		}
		this._show = false;

		const scene = this.viewer.scene;
		scene.screenSpaceCameraController.enableRotate = true;
		scene.screenSpaceCameraController.enableTranslate = true;
		scene.screenSpaceCameraController.enableZoom = true;
		scene.screenSpaceCameraController.enableTilt = true;
		scene.screenSpaceCameraController.enableLook = true;
		if (this._updateCameraRemove) {
			this._updateCameraRemove();
			this._updateCameraRemove = undefined;
		}
		this.removeEvent();
		this.isrunning = false;
	};
	/** @private */
	SkylineEX.prototype.removeEvent = function () {
		if (!this.moveHandle) return;
		this.moveHandle.removeInputAction(SceneGIS.ScreenSpaceEventType.LEFT_DOWN);
		this.moveHandle.removeInputAction(SceneGIS.ScreenSpaceEventType.LEFT_UP);
		this.moveHandle.removeInputAction(SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
		this.moveHandle = undefined;
	};

	/**
	 * 坡度坡向等高线类
	 * @class SlopeAspectEX
	 * @param {SceneGIS.Viewer} viewer 
	 */
	function SlopeAspectEX(viewer) {
		this.name = "SlopeAspectEX";
		this._viewer = viewer;
		this.enableLighting = viewer.scene.globe.enableLighting;
		viewer.scene.globe.enableLighting = true;
		this.contourUniforms = {};
		this.shadingUniforms = {};
		this.minHeight = 0.0; // approximate dead sea elevation
		this.maxHeight = 700.0; // approximate everest elevation
		this.contourSpacing = 5.0,
			this.contourWidth = 1.0,
			this.contourColor = SceneGIS.Color.RED.clone();
	}

	Object.defineProperties(SlopeAspectEX.prototype, {
		/**
		* 获取viewer 对象
		* @memberof SlopeAspectEX.prototype
		*
		* @type {Viewer}
		* @readonly
		*/
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		},

	});

	function getElevationContourMaterial() {
		// Creates a composite material with both elevation shading and contour lines
		return new SceneGIS.Material({
			fabric: {
				type: "ElevationColorContour",
				materials: {
					contourMaterial: {
						type: "ElevationContour",
					},
					elevationRampMaterial: {
						type: "ElevationRamp",
					},
				},
				components: {
					diffuse:
						"contourMaterial.alpha == 0.0 ? elevationRampMaterial.diffuse : contourMaterial.diffuse",
					alpha:
						"max(contourMaterial.alpha, elevationRampMaterial.alpha)",
				},
			},
			translucent: false,
		});
	}

	function getSlopeContourMaterial() {
		// Creates a composite material with both slope shading and contour lines
		return new SceneGIS.Material({
			fabric: {
				type: "SlopeColorContour",
				materials: {
					contourMaterial: {
						type: "ElevationContour",
					},
					slopeRampMaterial: {
						type: "SlopeRamp",
					},
				},
				components: {
					diffuse:
						"contourMaterial.alpha == 0.0 ? slopeRampMaterial.diffuse : contourMaterial.diffuse",
					alpha: "max(contourMaterial.alpha, slopeRampMaterial.alpha)",
				},
			},
			translucent: false,
		});
	}

	function getAspectContourMaterial() {
		// Creates a composite material with both aspect shading and contour lines
		return new SceneGIS.Material({
			fabric: {
				type: "AspectColorContour",
				materials: {
					contourMaterial: {
						type: "ElevationContour",
					},
					aspectRampMaterial: {
						type: "AspectRamp",
					},
				},
				components: {
					diffuse:
						"contourMaterial.alpha == 0.0 ? aspectRampMaterial.diffuse : contourMaterial.diffuse",
					alpha: "max(contourMaterial.alpha, aspectRampMaterial.alpha)",
				},
			},
			translucent: false,
		});
	}

	const elevationRamp = [1.0, 0.54, 0.37, 0.15, 0.1, 0.045, 0.0];
	const slopeRamp = [0.0, 0.29, 0.5, Math.sqrt(2) / 2, 0.87, 0.91, 1.0];
	const aspectRamp = [0.0, 0.2, 0.4, 0.6, 0.8, 0.9, 1.0];
	function getColorRamp(selectedShading) {
		const ramp = document.createElement("canvas");
		ramp.width = 100;
		ramp.height = 1;
		const ctx = ramp.getContext("2d");

		let values;
		if (selectedShading === "elevation") {
			values = elevationRamp;
		} else if (selectedShading === "slope") {
			values = slopeRamp;
		} else if (selectedShading === "aspect") {
			values = aspectRamp;
		}

		const grd = ctx.createLinearGradient(0, 0, 100, 0);
		grd.addColorStop(values[0], "#000000"); //black
		grd.addColorStop(values[1], "#2747E0"); //blue
		grd.addColorStop(values[2], "#D33B7D"); //pink
		grd.addColorStop(values[3], "#D33038"); //red
		grd.addColorStop(values[4], "#FF9742"); //orange
		grd.addColorStop(values[5], "#ffd700"); //yellow
		grd.addColorStop(values[6], "#ffffff"); //white

		ctx.fillStyle = grd;
		ctx.fillRect(0, 0, 100, 1);

		return ramp;
	}

	/**
	 * 开始渲染
	 * @param {String} type 图类型:"None"|"elevation"|"slope"|"aspect"
	 * @param {Boolean} enableContour 是否开启等高线
	 */
	SlopeAspectEX.prototype.start = function (type, enableContour) {
		type = SceneGIS.defaultValue(type, "elevation");
		enableContour = SceneGIS.defaultValue(enableContour, false);
		const hasContour = enableContour;
		const selectedShading = type;
		const globe = this.viewer.scene.globe;
		let material;
		if (hasContour) {
			if (selectedShading === "elevation") {
				material = getElevationContourMaterial();
				this.shadingUniforms =
					material.materials.elevationRampMaterial.uniforms;
				this.shadingUniforms.minimumHeight = this.minHeight;
				this.shadingUniforms.maximumHeight = this.maxHeight;
				this.contourUniforms = material.materials.contourMaterial.uniforms;
			} else if (selectedShading === "slope") {
				material = getSlopeContourMaterial();
				this.shadingUniforms = material.materials.slopeRampMaterial.uniforms;
				this.contourUniforms = material.materials.contourMaterial.uniforms;
			} else if (selectedShading === "aspect") {
				material = getAspectContourMaterial();
				this.shadingUniforms = material.materials.aspectRampMaterial.uniforms;
				this.contourUniforms = material.materials.contourMaterial.uniforms;
			} else {
				material = SceneGIS.Material.fromType("ElevationContour");
				this.contourUniforms = material.uniforms;
			}
			this.contourUniforms.width = this.contourWidth;
			this.contourUniforms.spacing = this.contourSpacing;
			this.contourUniforms.color = this.contourColor;
		} else if (selectedShading === "elevation") {
			material = SceneGIS.Material.fromType("ElevationRamp");
			this.shadingUniforms = material.uniforms;
			this.shadingUniforms.minimumHeight = this.minHeight;
			this.shadingUniforms.maximumHeight = this.maxHeight;
		} else if (selectedShading === "slope") {
			material = SceneGIS.Material.fromType("SlopeRamp");
			this.shadingUniforms = material.uniforms;
		} else if (selectedShading === "aspect") {
			material = SceneGIS.Material.fromType("AspectRamp");
			this.shadingUniforms = material.uniforms;
		}
		if (selectedShading !== "None") {
			this.shadingUniforms.image = getColorRamp(selectedShading);
		}

		globe.material = material;
	};

	SlopeAspectEX.prototype.stop = function () {
		throw new SceneGIS.DeveloperError('error');
	};
	/**
	 * 修改等高线步进值
	 * @param {Number} val 等高线步进值
	 */
	SlopeAspectEX.prototype.changeSpacing = function (val) {
		this.contourUniforms.spacing = val;
	};
	/**
	 * 修改等高线线宽(px)
	 * @param {Number} val 等高线线宽
	 */
	SlopeAspectEX.prototype.changeWidth = function (val) {
		this.contourUniforms.width = val;
	};
	/**
	 * 修改最高高度
	 * @param {Number} val 最高高度
	 */
	SlopeAspectEX.prototype.changeMax = function (val) {
		this.shadingUniforms.maximumHeight = val;
	};
	/**
	 * 修改最低高度
	 * @param {Number} val 最低高度
	 */
	SlopeAspectEX.prototype.changeMin = function (val) {
		this.shadingUniforms.minimumHeight = val;
	};
	/**
	 * 计算当前屏幕的最大高程值
	 * @param {SceneGIS.ScenegisTerrainProvider} terrainProvider 
	 */
	SlopeAspectEX.prototype.compute = function (terrainProvider) {
		var positions = this.viewer.camera.computeViewRectangle();
		var west = SceneGIS.Math.toDegrees(positions.west);
		var east = SceneGIS.Math.toDegrees(positions.east);
		var south = SceneGIS.Math.toDegrees(positions.south);
		var north = SceneGIS.Math.toDegrees(positions.north);
		var distance = east - west;
		positions = [
			{
				"longitude": west,
				"latitude": south
			},
			{
				"longitude": west,
				"latitude": north
			},
			{
				"longitude": east,
				"latitude": north
			},
			{
				"longitude": east,
				"latitude": south
			},
		];
		this.getHight(terrainProvider, positions, distance);
	};
	/** @private */
	SlopeAspectEX.prototype.getHight = function (terrainProvider, positions, distance) {
		const that = this;
		const tempPoints = [];
		for (let i = 0; i < positions.length; i++) {
			var lat = positions[i].latitude;
			var lng = positions[i].longitude;
			tempPoints.push([lng, lat]);
		}
		var dis = distance / 0.00001;
		var line = turf.lineString(tempPoints);
		var bbox = turf.bbox(line);
		var cellSide = dis / 100000;
		var options = { units: 'kilometers' };
		var grid = turf.pointGrid(bbox, cellSide, options);
		const tempArray = [];
		grid.features.forEach(f => {
			tempArray.push(SceneGIS.Cartographic.fromDegrees(f.geometry.coordinates[0], f.geometry.coordinates[1]));
		});
		var promise = SceneGIS.sampleTerrainMostDetailed(terrainProvider, tempArray);
		if (promise) {
			Promise.resolve(promise).then(function (updatedPositions) {
				var max = 0;
				for (let i = 0; i < updatedPositions.length; i++) {
					if (updatedPositions[i].height) {
						max = max > updatedPositions[i].height ? max : updatedPositions[i].height;
					}
				}
				that.maximumHeight = max;
				return max;
			});
		}
	};

	/**清除 */
	SlopeAspectEX.prototype.clear = function () {
		this.start('None');
		this.viewer.scene.globe.enableLighting = this.enableLighting;
	};

	/**销毁 */
	SlopeAspectEX.prototype.destroy = function () {
		this.start('None');
		this.viewer.scene.globe.enableLighting = this.enableLighting;
	};

	/**
	 * 淹没分析类
	 * @class YmAnalysisEX
	 * @param {SceneGIS.Viewer} viewer 
	 */
	function YmAnalysisEX(viewer) {
		this.name = "YmAnalysisEX";
		this._viewer = viewer;
		this.interval = '';
		this.clearinterval = '';
		this.minsmgd = 0;
		this.maxsmgd = 200;
		this.szjg = 0.1;
		this.ymsd = 60;
		this.isdraw = true;
		this.positions = [];
		this.ymarr = [];
		this.cartesian = '';
		this.waterHeight = 0;
		this.polygon = null;
		this.watergeomask = null;
		this.reflector = null;
		this.water = null;
		this.stopflag = false;
		this.removecallback = undefined;
		viewer.scene.globe.depthTestAgainstTerrain = true;//开启地形深度检测
		//添加事件
		this.isrunning = false;
		// this.addEvent();
	}


	Object.defineProperties(YmAnalysisEX.prototype, {
		/**
		* 获取viewer 对象
		* @memberof YmAnalysisEX.prototype
		*
		* @type {Viewer}
		* @readonly
		*/
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		},

	});
	/**
	 * 开始功能
	 */
	YmAnalysisEX.prototype.start = function () {
		if (this.isrunning == false) {
			this._draw = new CommanDrawEX({ callback: callback$2.bind(this) }, this._viewer);
			this._draw.setMode(CommanDrawModeEX$1.POLYGON);
			this._draw.pause = false;
			this.isrunning = true;
		} else {
			this._draw.pause = false;
		}

	};
	/**@private */
	YmAnalysisEX.prototype.removeEvent = function () {
		this._draw.pause = true;
	};

	function callback$2(data) {
		if (data.eventType && data.eventType === "rightClick") {
			this.positions = data.position.concat();
			if (this.viewer.scene.planeView === true) {
				for (let point of this.positions) {
					this.ymarr.push(point.x);
					this.ymarr.push(point.y);
					this.ymarr.push(point.z);
				}
			} else {
				for (let point of data.WGSPoints) {
					this.ymarr.push(point.lng);
					this.ymarr.push(point.lat);
					this.ymarr.push(point.alt);
				}
				console.log("oyyx this.ymarr:", this.ymarr);
			}
			if (this.positions.length < 3 && this.isdraw) {
				alert('请至少绘制三个点');
				this.ymarr = [];
				this.positions = [];
				this.polygon = null;
				return
			} else {
				this.AddFlood(this.ymarr, this.minsmgd, this.maxsmgd, this.szjg, 361 - this.ymsd);
				this.positions = [];
				this.polygon = null;
				this.isdraw = false;
				console.log("finally");
				this._draw.pause = true;
				this._draw.removeAll();
			}
		}
	}

	/**
	 * @private
	 * 开始绘制淹没范围
	 */
	YmAnalysisEX.prototype.click = function () {
		clearInterval(this.interval);
		clearInterval(this.clearinterval);
		this.isdraw = true;
	};
	/**
	 * 暂停淹没
	 */
	YmAnalysisEX.prototype.stop = function () {
		clearInterval(this.interval);
		clearInterval(this.clearinterval);
		this.stopflag = true;
		this.removeEvent();
	};
	/**
	 * 继续淹没
	 */
	YmAnalysisEX.prototype.go = function (minsmgd, maxsmgd, szjg, ymsd) {
		var ymarr = [];
		var harr = [];
		for (var i = 0; i < this.ymarr.length; i++) {
			if ((i + 1) % 3 == 0) {
				harr.push(this.ymarr[i]); // 高度数组 排序拿到最低点
				if (this.viewer.scene.planeView == true) {
					ymarr.push(0);
				}
			} else {
				ymarr.push(this.ymarr[i]); // 经纬度数组
			}
		}
		var that = this;
		clearInterval(this.interval);
		clearInterval(this.clearinterval);
		this.interval = setInterval(() => {
			that.waterHeight += Number(szjg);
			for (let s = 0; s < this._viewer.entities.values.length; s++) {
				var entityobj = this._viewer.entities.values[s];
				if (entityobj._name == '淹没') {
					this._viewer.entities.remove(entityobj);
				}
			}
			that.water.waterHeight = that.waterHeight;
			that.reflector.height = that.waterHeight;
		}, ymsd);
		// 水面高度到达指定位置后停止淹没
		this.clearinterval = setInterval(() => {
			if (that.waterHeight >= maxsmgd) {
				clearInterval(this.interval);
				clearInterval(this.clearinterval);
			}
		}, 1000);
		this.stopflag = false;

	};

	/** @private */
	YmAnalysisEX.prototype.AddFlood = function (ymlist, minsmgd, maxsmgd, szjg, ymsd) { // ymarr:淹没地点数组,minsmgd:最小高度, maxsmgd:最大高度, szjg:上涨间隔, ymsd:淹没速度
		var ymarr = [];
		var harr = [];
		const planeView = this.viewer.scene.planeView;
		console.log(ymlist);
		for (var i = 0; i < ymlist.length; i++) {
			if ((i + 1) % 3 == 0) {
				harr.push(ymlist[i]); // 高度数组 排序拿到最低点
				if (planeView === true) {
					ymarr.push(0);
				}
			} else {
				ymarr.push(ymlist[i]); // 经纬度数组(在平面坐标系下是世界坐标数组)
			}
		}
		var f = function (a, b) {  //排序函数
			return (a - b);  //返回比较参数
		};
		var minheight = harr.sort(f);

		this.waterHeight = Number(minsmgd + minheight[0]); // 当前淹没高度

		const scene = this.viewer.scene;
		console.log("oyyx ymarr:", ymarr);
		// 生成淹没效果
		const polygon = new SceneGIS.PolygonGeometry({
			polygonHierarchy: planeView === true ? new SceneGIS.PolygonHierarchy(SceneGIS.Cartesian3.unpackArray(ymarr))
				: new SceneGIS.PolygonHierarchy(SceneGIS.Cartesian3.fromDegreesArray(ymarr)),
			planeView: planeView
		});
		let geomask = new SceneGIS.geojsonMask(
			{
				scene: scene,
				polygon: polygon
			}
		);
		this.reflector = new SceneGIS.Reflector({
			scene: scene,
		});
		this.water = new SceneGIS.WaterFilter(scene, this.reflector, geomask);
		scene.primitives.add(this.reflector);
		scene.primitives.add(this.water);

		this.removecallback = scene.preUpdate.addEventListener(() => {
			this.water.center = this.reflector._reflectPositionWC;
		});
		this.watergeomask = this.viewer.scene.primitives.add(geomask);


		var that = this;
		this.interval = setInterval(() => {
			that.waterHeight += Number(szjg);
			for (let s = 0; s < this._viewer.entities.values.length; s++) {
				var entityobj = this._viewer.entities.values[s];
				if (entityobj._name == '淹没') {
					this._viewer.entities.remove(entityobj);
				}
			}

			that.water.waterHeight = that.waterHeight;
			that.reflector.height = that.waterHeight;
		}, ymsd);
		// 水面高度到达指定位置后停止淹没
		this.clearinterval = setInterval(() => {
			if (that.waterHeight >= maxsmgd) {
				clearInterval(this.interval);
				clearInterval(this.clearinterval);
			}
		}, 1000);
	};

	/**
	 * 改变淹没参数
	 * @param {Number} minsmgd 淹没起始高度：（相对于绘制区域最低海拔，单位米）
	 * @param {Number} maxsmgd 淹没最大高度：（单位米）
	 * @param {Number} szjg 上涨间隔：表示每一次上涨的高度（单位米）
	 * @param {Number} ymsd 淹没速度：表示每一次上涨的时间（单位毫秒）
	 */
	YmAnalysisEX.prototype.ChangeSJ = function (minsmgd, maxsmgd, szjg, ymsd) {
		this.minsmgd = Number(minsmgd);
		this.maxsmgd = Number(maxsmgd);
		this.szjg = Number(szjg);
		this.ymsd = Number(ymsd);
		console.log("change minsmgd:", this.minsmgd, " maxsmgd:", this.maxsmgd, " ymsd:", this.ymsd);
	};

	/**
	 * 清除分析结果
	 */
	YmAnalysisEX.prototype.clear = function () {
		if (this.interval) {
			clearInterval(this.interval);
		}
		if (this.clearinterval) {
			clearInterval(this.clearinterval);
		}
		for (let s = this._viewer.entities.values.length - 1; s >= 0; s--) {
			var entityobj = this._viewer.entities.values[s];
			if (entityobj._name == '淹没') {
				this._viewer.entities.remove(entityobj);
			}
		}
		if (this.removecallback && typeof (this.removecallback) === "function") {
			this.removecallback();
		}
		this.viewer.scene.primitives.remove(this.watergeomask);
		this.viewer.scene.primitives.remove(this.water);
		this.viewer.scene.primitives.remove(this.reflector);
		this.watergeomask = this.water = this.reflector = undefined;
	};

	/**
	 * 销毁操作，销毁内部事件和临时对象
	 */
	YmAnalysisEX.prototype.destroy = function () {
		if (this.isrunning === false) return;
		if (this.interval) {
			clearInterval(this.interval);
		}
		if (this.clearinterval) {
			clearInterval(this.clearinterval);
		}
		this._viewer.entities.removeAll();
		if (this.removecallback && typeof (this.removecallback) === "function") {
			this.removecallback();
		}
		this.viewer.scene.primitives.remove(this.watergeomask);
		this.viewer.scene.primitives.remove(this.water);
		this.viewer.scene.primitives.remove(this.reflector);
		this.watergeomask = this.water = this.reflector = undefined;
		this.ymarr = [];
		this.positions = [];
		this.polygon = null;
		this.isdraw = false;
		this._draw.destroy();
		this.isrunning = false;
	};

	/**
	 * 方量分析类
	 * @class VolumeAnalysisEX
	 * @param {Object} options 
	 * @param {Number} [options.baseHeight=0] 基础高度
	 * @param {Number} [options.factor=0] 网格密度, 范围:0-1,越大越密
	 * @param {Number} [options.callback] 回调函数，参数为{totalCutVolume:挖方体积,totalFillVolume:填方体积,maxHeight:最大高程,minHeight:最小高程}
	 * @param {SceneGIS.Viewer} viewer 
	 */
	function VolumeAnalysisEX(options, viewer) {
		//设置默认值
		options = defaultValue$1(options, defaultValue$1.EMPTY_OBJECT);
		options.baseHeight = defaultValue$1(options.baseHeight, 0);
		options.factor = defaultValue$1(options.factor, 0);
		//检查类型
		CheckEX.instanceOf("viewer", viewer, SceneGIS.Viewer);
		CheckEX.typeOf("options.baseHeight", options.baseHeight, "number");
		CheckEX.typeOf("options.factor", options.factor, "number");

		this.name = "VolumeAnalysisEX";

		this._viewer = viewer;
		this._scene = viewer.scene;
		this._factor = options.factor;
		this.baseHeight = options.baseHeight;
		this._drawEntities = new SceneGIS.CustomDataSource('drawVolumeData' + SceneGIS.createGuid());

		viewer.scene.globe.depthTestAgainstTerrain = true;//开启地形深度检测
		this.cartesian = undefined;
		this.positions = [];
		this.polygon = undefined;
		this.callback = options.callback;
		//添加事件
		this.isrunning = false;
		// this.addEvent();
		this.planeView = this.viewer.scene.planeView;
	}

	function defaultValue$1(a, b) {
		if (a !== undefined && a !== null) {
			return a;
		}
		return b;
	}
	defaultValue$1.EMPTY_OBJECT = Object.freeze({});

	Object.defineProperties(VolumeAnalysisEX.prototype, {
		/**
		* 获取viewer 对象
		* @memberof VolumeAnalysisEX.prototype
		*
		* @type {Viewer}
		* @readonly
		*/
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		},

	});

	/**
	 * 开始功能
	 */
	VolumeAnalysisEX.prototype.start = function () {
		if (this.isrunning == false) {
			this._draw = new CommanDrawEX({ callback: callback$1.bind(this) }, this._viewer);
			this._draw.setMode(CommanDrawModeEX$1.POLYGON);
			this._draw.pause = false;
			this.isrunning = true;
		} else {
			this._draw.pause = false;
		}
	};

	/**
	 * 暂停功能
	 */
	VolumeAnalysisEX.prototype.stop = function () {
		this.removeEvent();
	};
	/**@private */
	VolumeAnalysisEX.prototype.removeEvent = function () {
		this._draw.pause = true;
	};

	function callback$1(data) {
		if (data.eventType && data.eventType === "rightClick") {
			this.positions = data.position.concat();
			if (this.positions.length < 3) {
				alert('请至少绘制三个点');
				this.positions = [];
				this.polygon = null;
				return
			} else {
				this.drawResult(this.positions);
			}
			for (let s = this.viewer.entities.values.length - 1; s >= 0; s--) {
				var entityobj = this._viewer.entities.values[s];
				if (entityobj._name == '方量') {
					this._viewer.entities.remove(entityobj);
				}
			}
			this.positionsArray = [];
			this.positions = [];
			this.polygon = null;
			this._draw.removeAll();
			//   this.removeEvent();
		}
	}

	function computeAreaOfTriangle(pos1, pos2, pos3) {
		let a = SceneGIS.Cartesian3.distance(pos1, pos2);
		let b = SceneGIS.Cartesian3.distance(pos2, pos3);
		let c = SceneGIS.Cartesian3.distance(pos3, pos1);

		let S = (a + b + c) / 2;

		return Math.sqrt(S * (S - a) * (S - b) * (S - c));
	}

	function computeCentroidOfPolygon(positions, planeView) {
		let x = [];
		let y = [];

		for (let i = 0; i < positions.length; i++) {
			let cartographic = planeView === true ? new SceneGIS.Cartographic(positions[i].x, positions[i].y, positions[i].z)
				: SceneGIS.Cartographic.fromCartesian(positions[i]);

			x.push(cartographic.longitude);
			y.push(cartographic.latitude);
		}

		let x0 = 0.0, y0 = 0.0, x1 = 0.0, y1 = 0.0;
		let signedArea = 0.0;
		let a = 0.0;
		let centroidx = 0.0, centroidy = 0.0;

		for (let i = 0; i < positions.length; i++) {
			x0 = x[i];
			y0 = y[i];

			if (i == positions.length - 1) {
				x1 = x[0];
				y1 = y[0];
			} else {
				x1 = x[i + 1];
				y1 = y[i + 1];
			}

			a = x0 * y1 - x1 * y0;
			signedArea += a;
			centroidx += (x0 + x1) * a;
			centroidy += (y0 + y1) * a;
		}

		signedArea *= 0.5;
		centroidx /= (6.0 * signedArea);
		centroidy /= (6.0 * signedArea);

		return new SceneGIS.Cartographic(centroidx, centroidy);
	}
	/** @private */
	VolumeAnalysisEX.prototype.computeCutVolume = function (_positions) {
		let modeChangeFactor = {
			zoom: 16,
			height: 1571.2485798760013,
		};

		const position = this._scene.camera._positionWC;
		const car = this.planeView === true ? new SceneGIS.Cartographic(position.x, position.y, position.z)
			: SceneGIS.Cartographic.fromCartesian(position);
		const _height = car.height;
		const level = modeChangeFactor.zoom - SceneGIS.Math.log2(_height / modeChangeFactor.height);
		let granularity = Math.PI / Math.pow(2, parseInt(level + this._factor + 2.5)); // 原始是2的17次方
		console.log("oyyx granularity:", granularity);

		let polygonGeometry = new SceneGIS.PolygonGeometry.fromPositions({
			positions: _positions,
			vertexFormat: SceneGIS.PerInstanceColorAppearance.FLAT_VERTEX_FORMAT,
			granularity: granularity,
			planeView: this.planeView
		});

		//polygon subdivision
		let geom = new SceneGIS.PolygonGeometry.createGeometry(polygonGeometry);
		console.log("oyyx geom:", geom);

		let totalCutVolume = 0;
		let totalFillVolume = 0;
		let maxHeight = 0;
		let minHeight = Number.MAX_VALUE;

		let i0, i1, i2;
		let height1, height2, height3;
		let p1, p2, p3;
		let cartesian;
		let cartographic;
		let bottomArea;

		let triangleArray = [];
		for (let i = 0; i < geom.indices.length; i += 3) {
			if (SceneGIS.JulianDate.compare(SceneGIS.JulianDate.fromDate(new Date()), this.viewer.clock.stopTime) >= 0) {
				console.log("超时");
				return null;
			}
			i0 = geom.indices[i];
			i1 = geom.indices[i + 1];
			i2 = geom.indices[i + 2];

			cartesian = new SceneGIS.Cartesian3(geom.attributes.position.values[i0 * 3], geom.attributes.position.values[i0 * 3 + 1], geom.attributes.position.values[i0 * 3 + 2]);
			cartographic = this.planeView === true ? new SceneGIS.Cartographic(cartesian.x, cartesian.y, cartesian.z)
				: SceneGIS.Cartographic.fromCartesian(cartesian);
			//获取当前点位的高程
			height1 = this._scene.sampleHeight(cartographic);
			p1 = this.planeView === true ? new SceneGIS.Cartesian3(cartographic.longitude, cartographic.latitude, height1 + 0.2)
				: SceneGIS.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, height1 + 0.2);
			if (maxHeight < height1) {
				maxHeight = height1;
			}
			if (minHeight > height1) {
				minHeight = height1;
			}

			cartesian = new SceneGIS.Cartesian3(geom.attributes.position.values[i1 * 3], geom.attributes.position.values[i1 * 3 + 1], geom.attributes.position.values[i1 * 3 + 2]);
			cartographic = this.planeView === true ? new SceneGIS.Cartographic(cartesian.x, cartesian.y, cartesian.z)
				: SceneGIS.Cartographic.fromCartesian(cartesian);
			height2 = this._scene.sampleHeight(cartographic);
			p2 = this.planeView === true ? new SceneGIS.Cartesian3(cartographic.longitude, cartographic.latitude, height2 + 0.2)
				: SceneGIS.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, height2 + 0.2);
			if (maxHeight < height2) {
				maxHeight = height2;
			}
			if (minHeight > height2) {
				minHeight = height2;
			}

			cartesian = new SceneGIS.Cartesian3(geom.attributes.position.values[i2 * 3], geom.attributes.position.values[i2 * 3 + 1], geom.attributes.position.values[i2 * 3 + 2]);
			cartographic = this.planeView === true ? new SceneGIS.Cartographic(cartesian.x, cartesian.y, cartesian.z)
				: SceneGIS.Cartographic.fromCartesian(cartesian);
			height3 = this._scene.sampleHeight(cartographic);
			p3 = this.planeView === true ? new SceneGIS.Cartesian3(cartographic.longitude, cartographic.latitude, height3 + 0.2)
				: SceneGIS.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, height3 + 0.2);
			if (maxHeight < height3) {
				maxHeight = height3;
			}
			if (minHeight > height3) {
				minHeight = height3;
			}

			bottomArea = computeAreaOfTriangle(p1, p2, p3);
			let deltaHeight = height1 + height2 + height3 - this.baseHeight * 3;
			let area = bottomArea * deltaHeight / 3;
			if (deltaHeight > 0) {
				totalCutVolume += area;
			} else {
				totalFillVolume += -area;
			}
			triangleArray.push({
				area: area,
				points: { p1: p1, p2: p2, p3: p3 }
			});
		}
		let positions = [];
		let planeView = this.planeView;
		_positions.forEach(pos => {
			let cartographic = planeView === true ? new SceneGIS.Cartographic(pos.x, pos.y, pos.z)
				: SceneGIS.Cartographic.fromCartesian(pos);
			let height = this._scene.sampleHeight(cartographic);
			let p = planeView === true ? new SceneGIS.Cartesian3(cartographic.longitude, cartographic.latitude, height + 0.2)
				: SceneGIS.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, height + 0.2);
			positions.push(p);
		});

		let result = {
			maxHeight: maxHeight,
			minHeight: minHeight,
			totalCutVolume: totalCutVolume,
			totalFillVolume: totalFillVolume,
			triangleArray: triangleArray,
			subGeom: geom,
			positions: positions,
		};
		console.log("oyyx result:", result);
		return result;

	};
	/**
	 * 修改参数
	 * @param {Object} options 
	 * @param {Number} options.baseHeight 基础高度
	 * @param {Number} options.factor 网格密度, 范围:0-1,越大越密
	 */
	VolumeAnalysisEX.prototype.changeVal = function (options) {
		this.baseHeight = options.baseHeight;
		this._factor = options.factor;
	};

	function setClock(time, viewer) {
		//const { modelHelper.VCesViewer } = this;
		const startTime = SceneGIS.JulianDate.fromDate(new Date());
		const stopTime = SceneGIS.JulianDate.addSeconds(startTime, time, new SceneGIS.JulianDate());
		viewer.clock.startTime = startTime.clone();  // 开始时间
		viewer.clock.stopTime = stopTime.clone();     // 结速时间
		viewer.clock.currentTime = startTime.clone(); // 当前时间
		viewer.clock.clockRange = SceneGIS.ClockRange.CLAMPED; // 行为方式-达到终止时间后停止
		viewer.clock.clockStep = SceneGIS.ClockStep.SYSTEM_CLOCK; // 时钟设置为当前系统时间; 忽略所有其他设置。
	}

	/** @private */
	VolumeAnalysisEX.prototype.drawResult = function (_positions) {
		let result = {
			totalCutVolume: -1,
			totalFillVolume: -1,
			maxHeight: -1,
			minHeight: -1
		};
		if (this.callback && typeof this.callback === 'function') {
			this.callback(result);
		} setClock(10, this.viewer);
		result = this.computeCutVolume(_positions);
		console.log("oyyx result.triangleArray:", result.triangleArray);
		if (result != null) {
			result.triangleArray.forEach(item => {
				let triangleColor;
				if (item.area > 0) {
					triangleColor = SceneGIS.Color.fromCssColorString('#cc3322').withAlpha(0.6);
				} else {
					triangleColor = SceneGIS.Color.fromCssColorString('#22cc33').withAlpha(0.6);
				}

				this.viewer.entities.add({
					name: "结果",
					polyline: {
						positions: [item.points.p1, item.points.p2, item.points.p3, item.points.p1],
						width: 1,
						material: SceneGIS.Color.YELLOW.withAlpha(0.8),
						clampToGround: true,
					},
					polygon: {
						hierarchy: [item.points.p1, item.points.p2, item.points.p3, item.points.p1],
						material: triangleColor,
					}
				});
				Object.keys(item.points).forEach(key => {
					this.viewer.entities.add({
						name: "结果",
						position: item.points[key],
						point: {
							pixelSize: 4,
							color: SceneGIS.Color.YELLOW.withAlpha(0.8),
							outline: false
						},
					});
				});
			});
			// 绘制结果
			let centroid = computeCentroidOfPolygon(_positions, this.planeView);
			let that = this;
			this._prevEntity = this.viewer.entities.add({
				name: "结果",
				position: that.planeView === true ? new SceneGIS.Cartesian3(centroid.longitude, centroid.latitude, result.maxHeight + 100)
					: SceneGIS.Cartesian3.fromRadians(centroid.longitude, centroid.latitude, result.maxHeight + 100),
				polygon: {
					hierarchy: {
						positions: _positions
					},
					extrudedHeight: result.maxHeight,
					closeTop: false,
					closeBottom: false,
					material: SceneGIS.Color.RED.withAlpha(0.5),
					outline: true,
					outlineColor: SceneGIS.Color.WHITE,
					outlineWidth: 2
				}
			});
		}
		if (this.callback && typeof this.callback === 'function') {
			this.callback(result);
		}
	};

	/**
	 * 清除方量分析结果
	 * 
	 */
	VolumeAnalysisEX.prototype.clear = function () {
		this._option = undefined;
		for (let s = this.viewer.entities.values.length - 1; s >= 0; s--) {
			var entityobj = this._viewer.entities.values[s];
			if (entityobj._name == '结果') {
				this.viewer.entities.remove(entityobj);
			}
		}
		// this.removeEvent();
	};
	/**
	 * 停止功能
	 */
	VolumeAnalysisEX.prototype.destroy = function () {
		if (this.isrunning === false) return;
		this.clear();
		this._draw.destroy();
		this.isrunning = false;
	};

	/**
	 * 控高分析
	 * @class LimitHeightEX
	 * @param {Object} options 
	 * @param {Number} [options.targetHeight=50] 限高面高度,默认50
	 * @param {SceneGIS.Viewer} viewer 
	 */
	function LimitHeightEX(options, viewer) {
		//设置默认值
		options = defaultValue(options, defaultValue.EMPTY_OBJECT);
		options.targetHeight = defaultValue(options.targetHeight, 50);
		this.name = "LimitHeightEX";
		//检查类型
		CheckEX.instanceOf("viewer", viewer, SceneGIS.Viewer);
		CheckEX.typeOf("options.targetHeight", options.targetHeight, "number");

		this._viewer = viewer;
		this._entities = viewer.entities;
		this._primitives = viewer.scene.primitives;
		this.labelEntity = undefined;
		this.polygonEntity = undefined;
		this.polygonEntitys = [];
		this.polygonPrimitive = undefined;
		this.polygonprimitives = [];
		this._option = undefined;

		viewer.scene.globe.depthTestAgainstTerrain = true;//开启地形深度检测
		this.targetHeight = options.targetHeight;
		this.cartesian = undefined;
		this.positions = [];
		this.positionsArray = [];
		this.wallPositionsArray = [];
		this.wallPositionsUpdate = [];
		this.polygon = undefined;
		//添加事件
		this.isrunning = false;
		// this.addEvent();

		this.planeView = viewer.scene.planeView;


	}

	function defaultValue(a, b) {
		if (a !== undefined && a !== null) {
			return a;
		}
		return b;
	}
	defaultValue.EMPTY_OBJECT = Object.freeze({});


	Object.defineProperties(LimitHeightEX.prototype, {
		/**
		* 获取viewer 对象
		* @memberof LimitHeightEX.prototype
		*
		* @type {SceneGIS.Viewer}
		* @readonly
		*/
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		},

	});
	/**
	 * 开始功能
	 */
	LimitHeightEX.prototype.start = function () {
		if (this.isrunning == false) {
			this._draw = new CommanDrawEX({ callback: callback.bind(this) }, this._viewer);
			this._draw.setMode(CommanDrawModeEX$1.POLYGON);
			this._draw.pause = false;
			this.isrunning = true;
		} else {
			this._draw.pause = false;
		}
	};
	/**
	 * 暂停功能
	 */
	LimitHeightEX.prototype.stop = function () {
		this.removeEvent();
	};
	/**@private */
	LimitHeightEX.prototype.removeEvent = function () {
		this._draw.pause = true;
	};

	function callback(data) {
		if (data.eventType && data.eventType === "rightClick") {
			this.positions = data.position.concat();
			if (this.planeView === true) {
				this.wallPositionsArray = data.position.concat();
				for (let point of data.position) {
					let position = {
						x: 0,
						y: 0,
						z: 0
					};
					position.x = point.x;
					position.y = point.y;
					this.positionsArray.push(position);
				}
			} else {
				this.wallPositionsArray = data.WGSPoints.concat();
				for (let point of data.WGSPoints) {
					let position = {
						lng: 0,
						lat: 0
					};
					position.lng = point.lng;
					position.lat = point.lat;
					this.positionsArray.push(position);
				}
			}
			console.log("this.wallPositionsArray:", this.wallPositionsArray, " this.positionsArray:", this.positionsArray);
			if (this.positions.length < 3) {
				alert('请至少绘制三个点');
				this.positions = [];
				this.polygon = null;
				return
			} else {
				var positionsArray = [];
				for (let data of this.positionsArray) {
					for (let i in data) {
						if (data.hasOwnProperty(i)) {
							positionsArray.push(data[i]);
						}
					}
				}
				this.create({
					polygonOption: {
						positionsArray: positionsArray,
						height: this.targetHeight,
						material: SceneGIS.Color.WHITE.withAlpha(0.5),
						show: true,
					}
				});
			}
			for (let s = this.viewer.entities.values.length - 1; s >= 0; s--) {
				var entityobj = this._viewer.entities.values[s];
				if (entityobj._name == '控高') {
					this._viewer.entities.remove(entityobj);
				}
			}
			this.positionsArray = [];
			this.wallPositionsArray = [];
			this.positions = [];
			this.polygon = null;
			this._draw.removeAll();
			//   this.removeEvent();
		}
	}
	/**
	 * 更新限高分析结果
	 *
	 * @param {Number} [height=50.0] 限高面高度
	 */
	LimitHeightEX.prototype.update = function (height) {
		this._updatePolygonEntityHeight(height);
		this._updatePolygonPrimitiveHeight(height);
	};

	/** @private */
	LimitHeightEX.prototype._updatePolygonEntityHeight = function (height) {
		if (SceneGIS.defined(this.polygonEntity) && SceneGIS.defined(height)) {
			this.polygonEntity.polygon.height = height;

			var length = this.wallPositionsUpdate.length;
			for (let i = 0; i < length; i++) {
				if ((i + 1) % 3 === 0 && i != 0) {
					this.wallPositionsUpdate.splice(i, 1, height);
				}
			}
			if (this.planeView === true) {
				this.polygonEntity.wall.positions = SceneGIS.Cartesian3.unpackArray(this.wallPositionsUpdate);
			} else {
				this.polygonEntity.wall.positions = SceneGIS.Cartesian3.fromDegreesArrayHeights(this.wallPositionsUpdate);
			}

		}
	};

	/** @private */
	LimitHeightEX.prototype.create = function (option) {
		this._option = defaultValue(option, defaultValue.EMPTY_OBJECT);
		if (SceneGIS.defined(this._option.polygonOption)) {
			this._createPolygonEntity(this._option.polygonOption);
			this._createPolygonPrimitive(this._option.polygonOption);
		}
	};
	/** @private */
	LimitHeightEX.prototype._createPolygonEntity = function (polygonOption) {
		if (!(SceneGIS.defined(polygonOption.positionsArray) && SceneGIS.defined(polygonOption.height))) {
			console.error("请检查限高分析中polygon的positionsArray或height是否符合输入要求！");
			return;
		}
		this.wallPositionsUpdate = [];
		for (let data of this.wallPositionsArray) {
			for (let i in data) {
				if (data.hasOwnProperty(i)) {
					this.wallPositionsUpdate.push(data[i]);
				}
			}
		}
		var length = this.wallPositionsUpdate.length;
		for (let i = 0; i < length; i++) {
			if ((i + 1) % 3 === 0 && i != 0) {
				this.wallPositionsUpdate.splice(i, 1, polygonOption.height);
			}
		}
		this.wallPositionsUpdate.push(this.wallPositionsUpdate[0]);
		this.wallPositionsUpdate.push(this.wallPositionsUpdate[1]);
		this.wallPositionsUpdate.push(this.wallPositionsUpdate[2]);
		let that = this;
		this.polygonEntity = this._entities.add({
			polygon: {
				hierarchy: that.planeView === true ? SceneGIS.Cartesian3.unpackArray(polygonOption.positionsArray)
					: SceneGIS.Cartesian3.fromDegreesArray(polygonOption.positionsArray),
				height: polygonOption.height,
				perPositionHeight: false,
				material: defaultValue(polygonOption.material, SceneGIS.Color.YELLOW.withAlpha(0.3)),
				outline: false,
				outlineColor: SceneGIS.Color.WHITE,
				show: true
			},
			wall: {
				positions: that.planeView === true ? SceneGIS.Cartesian3.unpackArray(this.wallPositionsUpdate)
					: SceneGIS.Cartesian3.fromDegreesArrayHeights(this.wallPositionsUpdate),
				material: defaultValue(polygonOption.material, SceneGIS.Color.YELLOW.withAlpha(0.3)),
				outline: defaultValue(polygonOption.outline, false),
				outlineColor: defaultValue(polygonOption.outlineColor, SceneGIS.Color.WHITE),
				show: defaultValue(polygonOption.show, true)
			},
		});
		this.polygonEntitys.push(this.polygonEntity);
	};
	/** @private */
	LimitHeightEX.prototype._createPolygonPrimitive = function (polygonOption) {
		const positionsArray = polygonOption.positionsArray;
		const height = polygonOption.height;
		const markColor = defaultValue(polygonOption.markColor, SceneGIS.Color.RED.withAlpha(0.3));
		if (!(SceneGIS.defined(positionsArray) && SceneGIS.defined(height))) {
			console.error("请检查限高分析中polygon的positionsArray或height是否符合输入要求！");
			return;
		}
		let that = this;
		const geometryInstance = new SceneGIS.GeometryInstance({
			geometry: new SceneGIS.PolygonGeometry({
				polygonHierarchy: that.planeView === true ? new SceneGIS.PolygonHierarchy(SceneGIS.Cartesian3.unpackArray(positionsArray))
					: new SceneGIS.PolygonHierarchy(SceneGIS.Cartesian3.fromDegreesArray(positionsArray)),
				height: height,
				extrudedHeight: 10000
			}),
			attributes: {
				color: SceneGIS.ColorGeometryInstanceAttribute.fromColor(markColor)
			}
		});
		const appearance = new SceneGIS.PerInstanceColorAppearance({
			flat: true
		});
		this.polygonPrimitive = this.viewer.scene.primitives.add(new SceneGIS.ClassificationPrimitive({
			geometryInstances: [geometryInstance],
			appearance: appearance,
			classificationType: SceneGIS.ClassificationType.CESIUM_3D_TILE
		}));
		this.polygonprimitives.push(this.polygonPrimitive);
	};

	/** @private */
	LimitHeightEX.prototype._updatePolygonPrimitiveHeight = function (height) {
		if (SceneGIS.defined(this.polygonPrimitive) && SceneGIS.defined(height)) {
			let surface, offset;
			if (this.planeView === true) {
				let cartesian = this.polygonPrimitive._primitive._boundingSpheres[0].center;
				surface = new SceneGIS.Cartesian3(cartesian.x, cartesian.y, this.targetHeight);
				offset = new SceneGIS.Cartesian3(cartesian.x, cartesian.y, height);
			} else {
				let cartographic = SceneGIS.Cartographic.fromCartesian(this.polygonPrimitive._primitive._boundingSpheres[0].center); //弧度
				surface = SceneGIS.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, this.targetHeight);
				offset = SceneGIS.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, height);
			}
			let translation = SceneGIS.Cartesian3.subtract(offset, surface, new SceneGIS.Cartesian3());
			this.polygonPrimitive._primitive.modelMatrix = SceneGIS.Matrix4.fromTranslation(translation);
		}
	};

	/**
	 * 清除限高分析结果
	 */
	LimitHeightEX.prototype.clear = function () {
		console.log("清除");
		this._clearPolygonEntity();
		this._clearPolygonPrimitive();
		this._option = undefined;
	};
	/**
	 * 停止分析
	 */
	LimitHeightEX.prototype.destroy = function () {
		if (this.isrunning === false) return;
		this._clearPolygonEntity();
		this._clearPolygonPrimitive();
		this._option = undefined;
		this._draw.destroy();
		this.isrunning = false;
	};
	/** @private */
	LimitHeightEX.prototype._clearPolygonEntity = function () {
		for (let polygonEntity of this.polygonEntitys) {
			if (polygonEntity && this._entities.contains(polygonEntity)) {
				this._entities.remove(polygonEntity);
				this.polygonEntity = undefined;
			}
		}
	};
	/** @private */
	LimitHeightEX.prototype._clearPolygonPrimitive = function () {
		for (let polygonPrimitive of this.polygonprimitives) {
			if (polygonPrimitive && this._primitives.contains(polygonPrimitive)) {
				this._primitives.remove(polygonPrimitive);
				this.polygonPrimitive = undefined;
			}
		}
	};

	var ToolFactoryEX = {
		StaticObservationEX: function (options, viewer) {
			return new StaticObservationEX(options, viewer);
		},
		RoadExcavationEX: function (options, viewer) {
			return new RoadExcavationEX(options, viewer);
		},
		BuildingClipEX: function (options, viewer) {
			return new BuildingClipEX(options, viewer);
		},
		FlyEX: function (options, viewer) {
			return new FlyEX(options, viewer);
		},
		KeyboardCameraControlEX: function (options, viewer) {
			return new KeyboardCameraControlEX(viewer);
		},
		FlatTilesetEX: function (options, viewer) {
			return new FlatTilesetEX(options, viewer);
		},
		ViewManageEX: function (options, viewer) {
			return new ViewManageEX(viewer);
		},
		MeasureDistanceEX: function (options, viewer) {
			return new MeasureDistanceEX(options, viewer);
		},
		MeasureHDistanceEX: function (options, viewer) {
			return new MeasureHDistanceEX(options, viewer);
		},
		MeasureVDistanceEX: function (options, viewer) {
			return new MeasureVDistanceEX(options, viewer);
		},
		MeasureAreaEX: function (options, viewer) {
			return new MeasureAreaEX(options, viewer);
		},
		ImagerySplitEX: function (options, viewer) {
			return new ImagerySplitEX(options, viewer);
		},
		BufferAnalysisEX: function (options, viewer) {
			return new BufferAnalysisEX(options, viewer);
		},
		VisibilityAnalysisEX: function (options, viewer) {
			return new VisibilityAnalysisEX(options, viewer);
		},
		VisibleAreaAnalysisEX: function (options, viewer) {
			return new VisibleAreaAnalysisEX(options, viewer);
		},
		SkylineEX: function (options, viewer) {
			return new SkylineEX(options, viewer);
		},
		SlopeAspectEX: function (options, viewer) {
			return new SlopeAspectEX(viewer);
		},
		YmAnalysisEX: function (options, viewer) {
			return new YmAnalysisEX(viewer);
		},
		VolumeAnalysisEX: function (options, viewer) {
			return new VolumeAnalysisEX(options, viewer);
		},
		LimitHeightEX: function (options, viewer) {
			return new LimitHeightEX(options, viewer);
		},
	};

	/**
	 * 功能工具类型
	 * @readonly
	 * @enum {String}
	 */
	var ToolsType = {
		/**
		 * 定点观察
		 * @type {String}
		 */
		"StaticObservationEX": "StaticObservationEX",
		/**
		 * 地形开挖
		 * @type {String}
		 */
		"RoadExcavationEX": "RoadExcavationEX",
		/**
		 * 道路开挖
		 * @type {String}
		 */
		"RoadExcavationEX": "RoadExcavationEX",
		/**
		 * 建筑剖切
		 * @type {String}
		 */
		"BuildingClipEX": "BuildingClipEX",
		/**
		 * 飞行路线
		 * @type {String}
		 */
		"FlyEX": "FlyEX",
		/**
		 * 键盘交互
		 * @type {String}
		 */
		"KeyboardCameraControlEX": "KeyboardCameraControlEX",
		/**
		 * 倾斜压平
		 * @type {String}
		 */
		"FlatTilesetEX": "FlatTilesetEX",
		/**
		* 视点管理
		* @type {String}
		*/
		"ViewManageEX": "ViewManageEX",
		/**
		 * 空间测量
		 * @type {String}
		 */
		"MeasureDistanceEX": "MeasureDistanceEX",
		/**
		 * 水平测量
		 * @type {String}
		 */
		"MeasureHDistanceEX": "MeasureHDistanceEX",
		/**
		 * 垂直测量
		 * @type {String}
		 */
		"MeasureVDistanceEX": "MeasureVDistanceEX",
		/**
		 * 投影面积测量
		 * @type {String}
		 */
		"MeasureAreaEX": "MeasureAreaEX",
		/**
		 * 地表面积测量
		 * @type {String}
		 */
		"MeasureAreaEX": "MeasureAreaEX",
		/**
		 * 影像卷帘
		 * @type {String}
		 */
		"ImagerySplitEX": "ImagerySplitEX",
		/**
		 * 缓冲分析
		 * @type {String}
		 */
		"BufferAnalysisEX": "BufferAnalysisEX",
		/**
		 * 通视分析
		 * @type {String}
		 */
		"VisibilityAnalysisEX": "VisibilityAnalysisEX",
		/**
		 * 视域分析
		 * @type {String}
		 */
		"VisibleAreaAnalysisEX": "VisibleAreaAnalysisEX",
		/**
		 * 天际线分析
		 * @type {String}
		 */
		"SkylineEX": "SkylineEX",
		/**
		 * 等高线分析
		 * @type {String}
		 */
		"SlopeAspectEX": "SlopeAspectEX",
		/**
		 * 坡度坡向分析
		 * @type {String}
		 */
		"SlopeAspectEX": "SlopeAspectEX",
		/**
		 * 淹没分析
		 * @type {String}
		 */
		"YmAnalysisEX": "YmAnalysisEX",
		/**
		 * 方量分析
		 * @type {String}
		 */
		"VolumeAnalysisEX": "VolumeAnalysisEX",
		/**
		 * 控高分析
		 * @type {String}
		 */
		"LimitHeightEX": "LimitHeightEX",
	};
	var ToolsType$1 = Object.freeze(ToolsType);

	var _toolsEX = undefined;
	/**
	 *  ToolsEX
	 * @class ToolsEX
	 * @constructor
	 * @param {Object} options 
	 * @param {ToolsType} options.type 功能类型 {@link ToolsType}
	 * @param {Object} options.option 不同功能的配置，详情见各功能类的说明
	 * @param {SceneGIS.Viewer} viewer 
	 */
	function ToolsEX(options, viewer) {
		if (_toolsEX) {
			if (_toolsEX.tool) {
				//当上一个功能还在running的时候，就把他的监听事件取消
				if (_toolsEX.tool.isrunning === true)
					_toolsEX.tool.removeEvent();
			}
		}
		this.options = options.option;
		this._type = options.type;
		this.name = "ToolsEX";
		this._viewer = viewer;
		this.tool = null;
		_toolsEX = this;
		init.bind(this)();
	}

	//初始化功能
	function init() {
		this.tool = ToolFactoryEX[this.type](this.options, this.viewer);
	}

	Object.defineProperties(ToolsEX.prototype, {
		/**
		* 获取viewer 对象
		* @memberof ToolsEX.prototype
		*
		* @type {Viewer}
		* @readonly
		*/
		viewer: {
			get: function () {
				return SceneGIS.defined(this._viewer) ? this._viewer : undefined;
			}
		},
		/**
		 * 工具类型
		 * @memberof ToolsEX.prototype
		 *
		 * @type {String}
		 */
		type: {
			get: function () {
				return SceneGIS.defined(this._type) ? this._type : undefined;
			},
			set: function (val) {
				if (this._type != val) {
					this._type = val;
					this.changeTool({ type: val });
				}

			}
		},
	});
	/**
	 * 更改功能
	 * @param {Object} options
	 * @param {String} options.type 功能类型
	 * @param {Object} options.option 不同功能的配置，详情见各功能类的说明
	 */
	ToolsEX.prototype.changeTool = function (options) {
		this.options = options.option;
		this.type = options.type;
		if (this.tool) this.tool.destroy();
		this.tool = ToolFactoryEX[this.type](this.options, this.viewer);
	};

	/**
	 * 销毁资源
	 */
	ToolsEX.prototype.destroy = function () {
		if (this.tool) this.tool.destroy();
	};

	class Map23DEX {
		constructor(ui, scene3D, map2D) {
			this._ui = ui;
			this.currentTool = undefined;
			this.uiButton = undefined;
			this.renderId_ = undefined;
			this._map = map2D;
			this._scene3D = scene3D;
			this._viewMode = "2D";
			this._scene = scene3D ? scene3D.viewer.scene : undefined;
			this.camera_ = undefined;

			if (this._scene && this._map) {
				this.init();
			}

			this.treeData3D = {};
			this.treeData2D = {};
			this.treeData2D.root = {};//mapconfig.layers;
			this.treeData2D.checkedList = [];

		}

		//地图的二三维模式
		get viewMode() {
			return this._viewMode;
		}
		set viewMode(value) {
			this._viewMode = value;
		}

		//#region 属性
		get ui() {
			return this._ui;
		}

		set ui(value) {
			this._ui = value;
		}

		get map2D() {
			return this._map2D;
		};

		set map2D(value) {
			this._map = value;
			if (this._map && this._scene3D) {//重新绑定
				this.init();
			}

		}

		get scene3D() {
			return this._scene3D;
		};

		set scene3D(value) {
			this._scene3D = value;

			if (this._map && this._scene3D) {//重新绑定
				this.init();
			}

		}

		createCamera() {
			this.camera_ = new CameraEX(this._scene, this._map);
			var self = this;
			this._scene.camera.percentageChanged = 0;
			this._scene.camera.changed.addEventListener(() => {
				if (self.viewMode == "3D") {
					self.camera_.updateView(self._scene);
				}

			});
			this._map.on("extent-change", (evt) => {
				console.info(evt);
				evt.extent;
				evt.levelChange;
				// ... Do something ...
				if (self.viewMode == "2D") {
					self.camera_.readFromView();
				}
			});
		}

		init() {
			this.createCamera();
		}
		//#endregion
		activeCommand(name, option, callback) {
			if (this._viewMode == "3D") {
				return this.scene3D.activeCommand(name, option, callback);
			}
			if (this._viewMode == "2D") {
				return this.map2D.activeCommand(name, option, callback);
			}
		}

		getLayer(id) {
			if (this._viewMode == "3D") {
				var layer = this.scene3D.getLayer(id);
				return layer;
			}

			if (this._viewMode == "2D") {
				var layer = this.map2D.getLayer(id);
				return layer;
			}

			return null;
		}

		createLayer(id) {
			if (this._viewMode == "3D") {
				var layer = this.scene3D.createLayer(id);
				return layer;
			}

			if (this._viewMode == "2D") {
				var layer = this.map2D.createLayer(id);
				return layer;
			}

			return null;
		}

	}

	/**
	 * 可视域分析
	 * @alias VideoFusionEX
	 * @constructor
	 * @param {Object} options 
	 * @param {Number} [options.near=1] 最近分析距离
	 * @param {Number} [options.far=500] 最远分析距离
	 * @param {Number} [options.horizontalFov=60] 水平视场角
	 * @param {Number} [options.verticalFov=30] 垂直视场角
	 * @param {Boolean} [options.hasLine=false] 是否创建辅助线
	 * @param {SceneGIS.Viewer} viewer 
	 */
	function VideoFusionEX(options, viewer) {
		CheckEX.typeOf("options.near", options.near, 'number');
		CheckEX.typeOf("options.far", options.far, 'number');
		CheckEX.typeOf("options.horizontalFov", options.horizontalFov, 'number');
		CheckEX.typeOf("options.verticalFov", options.verticalFov, 'number');
		CheckEX.typeOf("options.hasLine", options.hasLine, 'boolean');
		this._viewer = viewer;
		this._handle = new SceneGIS.ScreenSpaceEventHandler(viewer.scene.canvas);
		this._tempPoint = null;
		this._tempPosition = new SceneGIS.Cartesian3(0, 0, 0);
		this._tempEntity = null;
		this._depthCameraPosition = undefined;
		this._pause = true;
		this._readyTempEntity = false;
		this._projects = [];//存储实例
		this._videoUrl = SceneGIS.defined(options.videoUrl) ? options.videoUrl : "";
		this._videoTpye = SceneGIS.defined(options.videoTpye) ? options.videoTpye : "";
		this._players = [];//视频实例
		this._entities = [];
		this.cameraEntities = new SceneGIS.CustomDataSource("cameraEntities");
		viewer.dataSources.add(this.cameraEntities);
		this._destroyed = false;

		this._near = SceneGIS.defined(options.near) ? options.near : 1;
		this._far = SceneGIS.defined(options.far) ? options.far : 500;
		this._fovx = SceneGIS.defined(options.horizontalFov) ? options.horizontalFov : 60;
		this._fovy = SceneGIS.defined(options.verticalFov) ? options.verticalFov : 30;
		this._hasLine = SceneGIS.defined(options.hasLine) ? options.hasLine : false;
		this.hasCameraEntity = SceneGIS.defined(options.hasCameraEntity) ? options.hasCameraEntity : false;

		this._callback = options.callback instanceof Function ? options.callback : undefined;
		this._depthTestAgainstTerrain = this._viewer.scene.globe.depthTestAgainstTerrain;
		this._viewer.scene.globe.depthTestAgainstTerrain = true;
		this.isrunning = false;
	}

	Object.defineProperties(VideoFusionEX.prototype, {
		/**
		 * 最近分析距离
		 * @memberof VideoFusionEX.prototype
		 * @type {Number}
		 */
		near: {
			get: function () {
				return this._near;
			},
			set: function (val) {
				this._near = val;
			}
		},
		/**
		 * 最远分析距离
		 * @memberof VideoFusionEX.prototype
		 * @type {Number}
		 */
		far: {
			get: function () {
				return this._far;
			},
			set: function (val) {
				this._far = val;
			}
		},
		/**
		 * 水平视场角
		 * @memberof VideoFusionEX.prototype
		 * @type {Number}
		 */
		horizontalFov: {
			get: function () {
				return this._fovx;
			},
			set: function (val) {
				this._fovx = val;
			}
		},
		/**
		 * 垂直视场角
		 * @memberof VideoFusionEX.prototype
		 * @type {Number}
		 */
		verticalFov: {
			get: function () {
				return this._fovy;
			},
			set: function (val) {
				this._fovy = val;
			}
		},
		/**
		 * 是否绘制辅助线
		 * @memberof VideoFusionEX.prototype
		 * @type {Boolean}
		 */
		hasLine: {
			get: function () {
				return this._hasLine;
			},
			set: function (val) {
				this._hasLine = val;
			}
		},
		/**
		 * 是否暂停分析
		 * @memberof VideoFusionEX.prototype
		 * @type {Boolean}
		 */
		pause: {
			get: function () {
				return this._pause;
			},
			set: function (val) {
				this._pause = val;
			}
		},
		/**
		 * 当前视频地址
		 * @memberof VideoFusionEX.prototype
		 * @type {String}
		 */
		videoUrl: {
			get: function () {
				return this._videoUrl;
			},
			set: function (val) {
				this._videoUrl = val;
			}
		},
		/**
		 * 当前视频类型
		 * @memberof VideoFusionEX.prototype
		 * @type {String}
		 */
		videoTpye: {
			get: function () {
				return this._videoTpye;
			},
			set: function (val) {
				this._videoTpye = val;
			}
		}
	});
	/**
	 * 开始功能
	 */
	VideoFusionEX.prototype.start = function () {
		bindEvent.bind(this)();
		this.isrunning = true;
		this._pause = false;
	};
	/**
	 * 暂停功能
	 */
	VideoFusionEX.prototype.stop = function () {
		this.removeEvent();
	};
	/**@private */
	VideoFusionEX.prototype.removeEvent = function () {
		unbindEvent.bind(this)();
		this.pause = true;
	};

	function bindEvent() {
		this._handle.setInputAction(mouseMove.bind(this), SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
		this._handle.setInputAction(leftClick.bind(this), SceneGIS.ScreenSpaceEventType.LEFT_CLICK);
		this._handle.setInputAction(rightClick.bind(this), SceneGIS.ScreenSpaceEventType.RIGHT_CLICK);
		let that = this;
		this._tempPoint = this._viewer.entities.add({
			position: new SceneGIS.CallbackProperty(function () {
				return that._tempPosition;
			}, false),
			point: {
				show: new SceneGIS.CallbackProperty(function () {
					return !that._pause;
				}, false),
				pixelSize: 10,
				outlineColor: SceneGIS.Color.YELLOW,
				outlineWidth: 3
			}
		});
	}

	function mouseMove(movement) {
		if (this._pause) {
			return;
		}
		let position = this._viewer.scene.pickPosition(movement.endPosition);
		if (SceneGIS.defined(position)) {
			const planeView = this._viewer.scene.planeView;
			this._tempPosition = position;
			if (this._readyTempEntity) {
				this._readyTempEntity = false;
				let that = this;
				this._tempEntity = this._viewer.entities.add({
					position: this._depthCameraPosition,
					orientation: new SceneGIS.CallbackProperty(function () {
						let direction = new SceneGIS.Cartesian3(
							that._tempPosition.x - that._depthCameraPosition.x,
							that._tempPosition.y - that._depthCameraPosition.y,
							that._tempPosition.z - that._depthCameraPosition.z);
						SceneGIS.Cartesian3.normalize(direction, direction);
						let up;
						if (planeView === true) {
							up = new SceneGIS.Cartesian3(0, 0, 1);
						} else {
							up = SceneGIS.Cartesian3.normalize(that._depthCameraPosition, new SceneGIS.Cartesian3);
						}
						let right = SceneGIS.Cartesian3.cross(direction, up, new SceneGIS.Cartesian3);
						SceneGIS.Cartesian3.normalize(right, right);
						SceneGIS.Cartesian3.cross(right, direction, up);
						SceneGIS.Cartesian3.normalize(up, up);
						let viewMatrix = SceneGIS.Matrix4.computeView(that._depthCameraPosition, direction, up, right, new SceneGIS.Matrix4);
						let inverseViewMatrix = SceneGIS.Matrix4.inverse(viewMatrix, new SceneGIS.Matrix4);
						const mat3 = SceneGIS.Matrix4.getMatrix3(inverseViewMatrix, new SceneGIS.Matrix3()); //获取旋转矩阵，也是以深度相机为原点，以视线负方向为z轴、以上方向为y轴的坐标系
						const rotate = SceneGIS.Matrix3.fromRotationX(-SceneGIS.Math.PI_OVER_TWO); //绕x轴顺时针旋转90度的旋转矩阵
						const rotated = SceneGIS.Matrix3.multiply(mat3, rotate, new SceneGIS.Matrix3()); //得到以视线方向为y轴，上方向为z轴的坐标系
						return SceneGIS.Quaternion.fromRotationMatrix(rotated, new SceneGIS.Quaternion())
					}, false),
					ellipsoid: {
						radii: new SceneGIS.Cartesian3(this._far, this._far, this._far), //外径
						innerRadii: new SceneGIS.Cartesian3(this._near, this._near, this._near), //内径
						minimumClock: SceneGIS.Math.PI_OVER_TWO - this._fovx * SceneGIS.Math.RADIANS_PER_DEGREE * 0.5, //水平方向，以x轴方向为起点，绕z轴顺时针方向
						maximumClock: SceneGIS.Math.PI_OVER_TWO + this._fovx * SceneGIS.Math.RADIANS_PER_DEGREE * 0.5,
						minimumCone: SceneGIS.Math.PI_OVER_TWO - this._fovy * SceneGIS.Math.RADIANS_PER_DEGREE * 0.5, //垂直方向，以z轴方向为起点，绕x轴顺时针方向
						maximumCone: SceneGIS.Math.PI_OVER_TWO + this._fovy * SceneGIS.Math.RADIANS_PER_DEGREE * 0.5,
						fill: false, //不填充
						outline: true, //绘制边线
						outlineColor: SceneGIS.Color.YELLOW,
						stackPartitions: 4,
						slicePartitions: 4,
					},
				});
			}
		}
	}

	function leftClick(mouse) {
		if (this._pause) {
			return;
		}
		let position = this._viewer.scene.pickPosition(mouse.position);
		if (!this._tempEntity) {
			this._readyTempEntity = true;
			this._depthCameraPosition = position;
		} else {
			const planeView = this._viewer.scene.planeView;
			//有两个点就完成
			this._viewer.entities.remove(this._tempEntity);
			this._tempEntity = null;
			//重置条件
			this._pause = true;
			//调用视域分析功能
			let direction = new SceneGIS.Cartesian3(
				this._tempPosition.x - this._depthCameraPosition.x,
				this._tempPosition.y - this._depthCameraPosition.y,
				this._tempPosition.z - this._depthCameraPosition.z);
			SceneGIS.Cartesian3.normalize(direction, direction);
			let up;
			if (planeView === true) {
				up = new SceneGIS.Cartesian3(0, 0, 1);
			} else {
				up = SceneGIS.Cartesian3.normalize(this._depthCameraPosition, new SceneGIS.Cartesian3);
			}
			let right = SceneGIS.Cartesian3.cross(direction, up, new SceneGIS.Cartesian3);
			SceneGIS.Cartesian3.normalize(right, right);
			SceneGIS.Cartesian3.cross(right, direction, up);
			SceneGIS.Cartesian3.normalize(up, up);
			let videoElement = document.createElement("video");
			videoElement.setAttribute('crossorigin', 'anonymous');
			let player = videojs(videoElement, {
				controls: false, // 是否显示控制条
				preload: 'auto',
				autoplay: true,
				loop: true,
				fluid: false, // 自适应宽高
				language: 'zh-CN', // 设置语言
				muted: true, // 是否静音
				sources: [ // 视频源
					{
						src: this.videoUrl,
						type: this.videoTpye
					}
				]
			});
			player.play();
			let project = new SceneGIS.Project(this._viewer, {
				position: this._depthCameraPosition,
				diretion: direction,
				up: up,
				verticalFov: this._fovy,
				horizontalFov: this._fovx,
				near: this.near,
				far: this.far,
				source: videoElement,
				hasLine: this.hasLine
			});
			project.apply();
			this._projects.push(project);
			this._players.push(player);
			if (this.hasCameraEntity) {
				this.addCameraEntity(project);
			}

			if (this._callback) {
				this._callback(project);
			}
		}
	}

	function rightClick() {
		if (this._pause) {
			return;
		}

		if (this._tempEntity) {
			this._viewer.entities.remove(this._tempEntity);
			this._tempEntity = null;
		}
	}

	function unbindEvent() {
		this._handle.removeInputAction(SceneGIS.ScreenSpaceEventType.MOUSE_MOVE);
		this._handle.removeInputAction(SceneGIS.ScreenSpaceEventType.LEFT_CLICK);
		this._handle.removeInputAction(SceneGIS.ScreenSpaceEventType.RIGHT_CLICK);
	}
	/**@private */
	VideoFusionEX.prototype.addCameraEntity = function (project) {
		let depthCamera = project.depthCamera;
		let cameraEntity = new SceneGIS.Entity({
			position: new SceneGIS.CallbackProperty(function () {
				return depthCamera.position;
			}, false),
			orientation: new SceneGIS.CallbackProperty(function () {
				let hpr = new SceneGIS.HeadingPitchRoll(depthCamera.heading - Math.PI / 2, depthCamera.pitch, depthCamera.roll);
				return SceneGIS.Transforms.headingPitchRollQuaternion(depthCamera.position, hpr);
			}, false),
			model: {
				uri: CoreEX.getAssetUrl('glb/UE4Camera.glb'),
				scale: 10
			}
		});
		this.cameraEntities.entities.add(cameraEntity);
		this._entities.push(cameraEntity);
	};

	/**
	 * @private
	 * 从场景相机创建投射
	 */
	VideoFusionEX.prototype.fromScene = function () {
		const camera = this._viewer.camera;
		let videoElement = document.createElement("video");
		videoElement.setAttribute('crossorigin', 'anonymous');
		let player = videojs(videoElement, {
			controls: false, // 是否显示控制条
			preload: 'auto',
			autoplay: true,
			loop: true,
			fluid: false, // 自适应宽高
			language: 'zh-CN', // 设置语言
			muted: true, // 是否静音
			sources: [ // 视频源
				{
					src: this.videoUrl,
					type: this.videoTpye
				}
			]
		});
		player.play();
		let project = new SceneGIS.Project(this._viewer, {
			position: camera.position.clone(),
			diretion: camera.direction.clone(),
			up: camera.up.clone(),
			verticalFov: this._fovy,
			horizontalFov: this._fovx,
			near: this.near,
			far: this.far,
			source: videoElement,
			hasLine: this.hasLine
		});
		project.apply();
		this._projects.push(project);
		this._players.push(player);
		if (this.hasCameraEntity) {
			this.addCameraEntity(project);
		}
		if (this._callback) {
			this._callback(project);
		}
	};

	/**
	 * 清除
	 */
	VideoFusionEX.prototype.clear = function () {
		rightClick.bind(this)();
		for (let project of this._projects) {
			project.destroy();
		}
		this._projects = [];
		for (let player of this._players) {
			player.dispose();
		}
		this._players = [];
		this.cameraEntities.entities.removeAll();
		this._entities = [];
	};

	/**
	 * 移除分析案例
	 * @param {number} index 序号
	 */
	VideoFusionEX.prototype.removeCase = function (index) {
		if (index < this._projects.length) {
			let project = this._projects[index];
			project.destroy();
			this._projects.splice(index, 1);
			let player = this._players[index];
			player.dispose();
			this._players.splice(index, 1);
			if (this.addCameraEntity) {
				let entity = this._entities[index];
				this.cameraEntities.entities.remove(entity);
				this._entities.splice(index, 1);
			}
			return true;
		}
		return false;
	};

	/**
	 * 销毁
	 */
	VideoFusionEX.prototype.destroy = function () {
		if (this._destroyed) {
			return;
		}
		this.clear();
		unbindEvent.bind(this)();
		if (this._tempPoint) {
			this._viewer.entities.remove(this._tempPoint);
		}
		this._viewer.dataSources.remove(this.cameraEntities, true);
		this._viewer.scene.globe.depthTestAgainstTerrain = this._depthTestAgainstTerrain;
		this._destroyed = true;
		this.isrunning = false;
	};

	/**
	 * 该类仅用于更新Vue组件的位置信息，把Vue组件的位置信息更新到cesium的场景中，不具备其他功能。
	 * @alias VueEX
	 * @constructor
	 * @param {Viewer} viewer viewer对象
	 * @param {Vue} vuedom  Vue组件对象
	 * @param {Object} option  内部对象参数，不同的对象不一样
	 * @param {Object} option.id 对象id
	 * @param {Object} option.positions 对象位置
	 */
	function VueEX(viewer, vuedom, option) {
		this.vuedom = vuedom;
		this.viewer = viewer;
		this._id = option.id ? option.id : CoreEX.MathEX.createUID();
		let scene = this.viewer.scene;
		if (scene.planeView) {
			new SceneGIS.Cartesian3(option.positions[0], option.positions[1], option.positions[2]);
		} else {
			SceneGIS.Cartesian3.fromDegrees(option.positions[0], option.positions[1], option.positions[2]);
		}
		var scratch = new SceneGIS.Cartesian2(); //cesium二维笛卡尔 笛卡尔二维坐标系就是我们熟知的而二维坐标系；三维也如此

		var self = this;
		this.vueupdate = function () {
			try {
				var canvasPosition = scene.cartesianToCanvasCoordinates(self.position, scratch); //cartesianToCanvasCoordinates 笛卡尔坐标（3维度）到画布坐标
				if (SceneGIS.defined(canvasPosition)) {
					self.vuedom.$el.style.left = (canvasPosition.x + (option.offsetx ? option.offsetx : 0)) + 'px';
					self.vuedom.$el.style.top = (canvasPosition.y - (option.height ? option.height : self.vuedom.$el.style.height)) + 'px';
				}
				else {

				}
			}
			catch (e) {
				console.log(e);
			}
		};
		this.viewer.scene.preRender.addEventListener(this.vueupdate);
	}


	VueEX.prototype.getObj = function () {
		return [];//这个对象不需要返回具体值用于建立事件字典
	};

	/*
	* 销毁,去掉位置更新
	*/
	VueEX.prototype.destroy = function () {
		this.viewer.scene.preRender.removeEventListener(this.vueupdate);
	};

	Object.defineProperties(VueEX.prototype, {
		/**
		 * 显隐控制
		 *
		 * @memberof VueEX.prototype
		 * @type {Boolean}
		*/
		show: {
			get: function () {
				if (this.vuedom.$el.style.display == "none") {
					return false;
				}
				else {
					return true;
				}
			},
			set: function (value) {
				if (value) {
					this.vuedom.$el.style.display = "inline";
				}
				else {
					this.vuedom.$el.style.display = "none";
				}
			}
		},
		/**
		* id
		*
		* @memberof VueEX.prototype
		* @type {String}
	   */
		id: {
			get: function () {
				return this._id;
			}
		}

	});

	const VERSION = '1.0';

	exports.AAEX = AAEX;
	exports.AAType = AAType$1;
	exports.AOEX = AOEX;
	exports.AOType = AOType$1;
	exports.AttributeEditorEX = AttributeEditorEX;
	exports.BufferAnalysisEX = BufferAnalysisEX;
	exports.BuildingClipEX = BuildingClipEX;
	exports.CameraEX = CameraEX;
	exports.Cartesian3EX = Cartesian3EX;
	exports.ChartsLayerEX = ChartsLayerEX;
	exports.CheckEX = CheckEX;
	exports.CommanDrawEX = CommanDrawEX;
	exports.CommanDrawModeEX = CommanDrawModeEX$1;
	exports.CoordTransform = CoordTransform;
	exports.CurveArrowEX = CurveArrowEX;
	exports.CustomEntity = CustomEntity;
	exports.CustomEntityCollection = CustomEntityCollection;
	exports.CustomLayerEX = CustomLayerEX;
	exports.CustomShadersEX = CustomShadersEX;
	exports.CzmlEntityEX = CzmlEntityEX;
	exports.CzmlLayerEX = CzmlLayerEX;
	exports.DataTransform = DataTransform;
	exports.DefaultValueEX = DefaultValueEX;
	exports.DepthTestEX = DepthTestEX;
	exports.DialogLocationType = DialogLocationType$1;
	exports.DialogWithOutLineEX = DialogWithOutLineEX;
	exports.DivEX = DivEX;
	exports.DomFactory = DomFactory;
	exports.DynamicGridEX = DynamicGridEX;
	exports.DynamicWallEX = DynamicWallEX;
	exports.EchartsEntityEX = EchartsEntityEX;
	exports.EchartsLayerEX = EchartsLayerEX;
	exports.EditorEX = EditorEX;
	exports.EntityPropEX = SceneGisEntityProp;
	exports.EntityTypeEX = EntityTypeEX$1;
	exports.EnvironmentMapsEX = EnvironmentMapsEX;
	exports.FeatureType = FeatureType$1;
	exports.FenceEX = FenceEX;
	exports.FireworkEX = FireworkEX;
	exports.FlatTilesetEX = FlatTilesetEX;
	exports.FlowPolylineEX = FlowPolylineEX;
	exports.FlyEX = FlyEX;
	exports.FogEX = FogEX;
	exports.FountainEX = FountainEX;
	exports.GeojsonLayerEX = GeojsonLayerEX;
	exports.GlbEX = GlbEX;
	exports.GlbLayerEX = GlbLayerEX;
	exports.GlbsLayerEX = GlbsLayerEX;
	exports.GraphicLayerEX = GraphicLayerEX;
	exports.GroundLineEX = GroundLineEX;
	exports.HeatMap2DEX = HeatMap2DEX;
	exports.HeatMap3DEX = HeatMap3DEX;
	exports.HeatMapRenderEX = HeatMapRenderEX;
	exports.I3SLayerEX = I3SLayerEX;
	exports.IEntityEX = IEntityEX;
	exports.IconPlotEX = IconPlotEX;
	exports.ImageryLayerEX = ImageryLayerEX;
	exports.ImagerySplitEX = ImagerySplitEX;
	exports.InteractiveEX = InteractiveEX;
	exports.InteractiveType = InteractiveType$1;
	exports.KeyboardCameraControlEX = KeyboardCameraControlEX;
	exports.LayerFactoryEX = GisLayerFactoryEX;
	exports.LayerType = LayerType$1;
	exports.LidarEX = LidarEX;
	exports.LimitHeightEX = LimitHeightEX;
	exports.LineEX = LineEX;
	exports.LineMaterialType = LineMaterialType$1;
	exports.LinePlotEX = LinePlotEX;
	exports.MDialogWithOutLineEX = MDialogWithOutLineEX;
	exports.Map23DEX = Map23DEX;
	exports.MapEchartsEX = MapEchartsEX;
	exports.MapHelperEX = MapHelperEX;
	exports.MeasureAreaEX = MeasureAreaEX;
	exports.MeasureDistanceEX = MeasureDistanceEX;
	exports.MeasureHDistanceEX = MeasureHDistanceEX;
	exports.MeasureVDistanceEX = MeasureVDistanceEX;
	exports.MilitaryPlotEX = MilitaryPlotEX;
	exports.ParticleEffectEX = ParticleEffectEX;
	exports.PieChartEX = PieChartEX;
	exports.PipeLayerEX = PipeLayerEX;
	exports.PointEX = PointEX;
	exports.PointMaterialType = PointMaterialType$1;
	exports.PointPlotEX = PointPlotEX;
	exports.PolyGonPlotEX = PolyGonPlotEX;
	exports.PolygonDrawEX = PolygonDrawEX;
	exports.PolygonEX = PolygonEX;
	exports.PolygonEditorEX = PolygonEditorEX;
	exports.PolygonMaterialType = PolygonMaterialType$1;
	exports.PolygonType = PolygonType$1;
	exports.PolylineFlowImgMaterialProperty = PolylineFlowImgMaterialProperty;
	exports.PolylineFlowTailMaterialProperty = PolylineFlowTailMaterialProperty;
	exports.PolylineTrailEX = PolylineTrailEX;
	exports.PolylineTrailLinkMaterialPropertyEX = PolylineTrailLinkMaterialPropertyEX;
	exports.RoadExcavationEX = RoadExcavationEX;
	exports.S3MLayerEX = S3MLayerEX;
	exports.SceneColorEX = SceneColorEX;
	exports.SceneEX = SceneEX;
	exports.SetEX = SetEX;
	exports.SetFactoryEX = SetFactoryEX;
	exports.SetType = SetType$1;
	exports.ShadowEX = ShadowEX;
	exports.ShpLayerEX = ShpLayerEX;
	exports.SkyBoxEX = SkyBoxEX;
	exports.SkyBoxType = SkyBoxType$1;
	exports.SkylineEX = SkylineEX;
	exports.SlopeAspectEX = SlopeAspectEX;
	exports.StaticObservationEX = StaticObservationEX;
	exports.SwEntityEX = SwEntityEX;
	exports.TableLayerEX = TableLayerEX;
	exports.TerrainClipPlan = TerrainClipPlan;
	exports.TerrainLayerEX = TerrainLayerEX;
	exports.TileSetEffectType = TileSetEffectType$1;
	exports.TileSetLayerEX = TileSetLayerEX;
	exports.TilesetRibbonEX = TilesetRibbonEX;
	exports.TilesetScanningEX = TilesetScanningEX;
	exports.TilesetVerticalGradientEX = TilesetVerticalGradientEX;
	exports.TimeEX = TimeEX;
	exports.TipEX = TipEX;
	exports.ToolFactoryEX = ToolFactoryEX;
	exports.ToolTipEX = ToolTipEX;
	exports.ToolsEX = ToolsEX;
	exports.ToolsType = ToolsType$1;
	exports.TransformEX = TransformEX;
	exports.UndergroundModeEX = UndergroundModeEX;
	exports.VERSION = VERSION;
	exports.VideoFusionEX = VideoFusionEX;
	exports.ViewManageEX = ViewManageEX;
	exports.VisibilityAnalysisEX = VisibilityAnalysisEX;
	exports.VisibleAreaAnalysisEX = VisibleAreaAnalysisEX;
	exports.VolumeAnalysisEX = VolumeAnalysisEX;
	exports.VueDialogEX = VueDialogEX;
	exports.VueEX = VueEX;
	exports.WallTrailEX = PolylineTrail;
	exports.WallTrailLinkMaterialPropertyEX = WallTrailLinkMaterialPropertyEX;
	exports.WaterEX = WaterEX;
	exports.WaterFilterEX = WaterFilterEX;
	exports.WaterLevelWellEX = WaterLevelWellEX;
	exports.WaterPolygonEX = WaterPolygonEX;
	exports.WeatherEX = WeatherEX;
	exports.WeatherType = WeatherType$1;
	exports.WordPlotEX = WordPlot;
	exports.YmAnalysisEX = YmAnalysisEX;
	exports.createPropertyDescriptorEX = createPropertyDescriptor$1;
	exports.createSgPropertyTypeDescriptor = createPropertyTypeDescriptor;
	exports.shp = shp;
	exports.skyAtmosphereEX = skyAtmosphereEX;

	Object.defineProperty(exports, '__esModule', { value: true });

	return exports;

})({});
//# sourceMappingURL=SceneGISEX.js.map

if (window.SceneGIS) {
	window.SceneGIS = Object.assign({}, window.SceneGIS, SceneGISEX);
} else {
	window.SceneGIS = SceneGISEX;
}
