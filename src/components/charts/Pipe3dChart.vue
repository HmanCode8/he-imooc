<template>
    <div ref="target" v-resize-ob="handleResize" class="w-full h-full"></div>
</template>

<script setup>
import { h, onMounted, ref, watch } from 'vue'
import * as echarts from 'echarts'
import 'echarts-gl'
import { Label } from 'cesium';

const props = defineProps({
    data: {
        type: Object,
        required: true
    },
    legend: {
        type: Array,
        default: () => [
            { name: '亭湖区', percentage: 24, distance: '25km', color: '#FF6384' },
            { name: '盐都区', percentage: 24, distance: '25km', color: '#FFCE56' },
            { name: '大丰区', percentage: 24, distance: '15km', color: '#36A2EB' },
            { name: '建湖县', percentage: 24, distance: '25km', color: '#FFA07A' },
            { name: '阜宁县', percentage: 24, distance: '25km', color: '#4BC0C0' },
            { name: '滨海县', percentage: 24, distance: '25km', color: '#FF6384' },
            { name: '响水县', percentage: 24, distance: '25km', color: '#FFCE56' },
            { name: '东台市', percentage: 24, distance: '45km', color: '#36A2EB' },
            { name: '射阳县', percentage: 24, distance: '25km', color: '#FFA07A' },
        ]
    }
})

const target = ref(null)
let mChart = null
onMounted(() => {
    mChart = echarts.init(target.value)
    renderChart()
})

const handleResize = (size) => {
    console.log('resize', size)
    mChart.resize()
}

const renderChart = () => {
    const optionsData = [
        {
            name: "已完成",
            value: 110,
            itemStyle: {
                color: "#e1eb53",
            },
        },
        {
            name: "处置中",
            value: 200,
            itemStyle: {
                color: "#ddbd51",
            },
        },
        {
            name: "待处理",
            value: 190,
            itemStyle: {
                color: "#55acf8",
            },
        },
    ];

    // 生成扇形的曲面参数方程，用于 series-surface.parametricEquation
    function getParametricEquation(
        startRatio,
        endRatio,
        isSelected,
        isHovered,
        k,
        h
    ) {
        // 计算
        let midRatio = (startRatio + endRatio) / 2;

        let startRadian = startRatio * Math.PI * 2;
        let endRadian = endRatio * Math.PI * 2;
        let midRadian = midRatio * Math.PI * 2;

        // 如果只有一个扇形，则不实现选中效果。
        // if (startRatio === 0 && endRatio === 1) {
        //     isSelected = false;
        // }
        isSelected = false;
        // 通过扇形内径/外径的值，换算出辅助参数 k（默认值 1/3）
        k = typeof k !== "undefined" ? k : 1 / 3;

        // 计算选中效果分别在 x 轴、y 轴方向上的位移（未选中，则位移均为 0）
        let offsetX = isSelected ? Math.sin(midRadian) * 0.1 : 0;
        let offsetY = isSelected ? Math.cos(midRadian) * 0.1 : 0;

        // 计算高亮效果的放大比例（未高亮，则比例为 1）
        let hoverRate = isHovered ? 1.05 : 1;

        // 返回曲面参数方程
        return {
            u: {
                min: -Math.PI,
                max: Math.PI * 3,
                step: Math.PI / 32,
            },

            v: {
                min: 0,
                max: Math.PI * 2,
                step: Math.PI / 20,
            },

            x: function (u, v) {
                if (u < startRadian) {
                    return (
                        offsetX +
                        Math.cos(startRadian) * (1 + Math.cos(v) * k) * hoverRate
                    );
                }
                if (u > endRadian) {
                    return (
                        offsetX +
                        Math.cos(endRadian) * (1 + Math.cos(v) * k) * hoverRate
                    );
                }
                return offsetX + Math.cos(u) * (1 + Math.cos(v) * k) * hoverRate;
            },

            y: function (u, v) {
                if (u < startRadian) {
                    return (
                        offsetY +
                        Math.sin(startRadian) * (1 + Math.cos(v) * k) * hoverRate
                    );
                }
                if (u > endRadian) {
                    return (
                        offsetY +
                        Math.sin(endRadian) * (1 + Math.cos(v) * k) * hoverRate
                    );
                }
                return offsetY + Math.sin(u) * (1 + Math.cos(v) * k) * hoverRate;
            },

            z: function (u, v) {
                if (u < -Math.PI * 0.5) {
                    return Math.sin(u);
                }
                if (u > Math.PI * 2.5) {
                    return Math.sin(u) * h * 0.1;
                }
                return Math.sin(v) > 0 ? 1 * h * 0.1 : -1;
            },
        };
    }

    // 生成模拟 3D 饼图的配置项
    function getPie3D(pieData, internalDiameterRatio) {
        let series = [];
        let sumValue = 0;
        let startValue = 0;
        let endValue = 0;
        let legendData = [];
        let k =
            typeof internalDiameterRatio !== "undefined"
                ? (1 - internalDiameterRatio) / (1 + internalDiameterRatio)
                : 1 / 3;

        // 为每一个饼图数据，生成一个 series-surface 配置
        for (let i = 0; i < pieData.length; i++) {
            sumValue += pieData[i].value;

            let seriesItem = {
                name:
                    typeof pieData[i].name === "undefined"
                        ? `series${i}`
                        : pieData[i].name,
                type: "surface",
                parametric: true,
                wireframe: {
                    show: false,
                },
                pieData: pieData[i],
                pieStatus: {
                    selected: false,
                    hovered: false,
                    k: 1 / 10,
                },
            };

            if (typeof pieData[i].itemStyle != "undefined") {
                let itemStyle = {};

                typeof pieData[i].itemStyle.color != "undefined"
                    ? (itemStyle.color = pieData[i].itemStyle.color)
                    : null;
                typeof pieData[i].itemStyle.opacity != "undefined"
                    ? (itemStyle.opacity = pieData[i].itemStyle.opacity)
                    : null;

                seriesItem.itemStyle = itemStyle;
            }
            series.push(seriesItem);
        }

        // 使用上一次遍历时，计算出的数据和 sumValue，调用 getParametricEquation 函数，
        // 向每个 series-surface 传入不同的参数方程 series-surface.parametricEquation，也就是实现每一个扇形。
        for (let i = 0; i < series.length; i++) {
            endValue = startValue + series[i].pieData.value;

            series[i].pieData.startRatio = startValue / sumValue;
            series[i].pieData.endRatio = endValue / sumValue;
            series[i].parametricEquation = getParametricEquation(
                series[i].pieData.startRatio,
                series[i].pieData.endRatio,
                false,
                false,
                k,
                series[i].pieData.value
            );

            startValue = endValue;

            legendData.push(series[i].name);
        }

        // // 补充一个透明的圆环，用于支撑高亮功能的近似实现。
        // series.push({
        //     name: "mouseoutSeries",
        //     type: "surface",
        //     parametric: true,
        //     wireframe: {
        //         show: false,
        //     },
        //     itemStyle: {
        //         opacity: 0.1,
        //         color: "#E1E8EC",
        //     },
        //     parametricEquation: {
        //         u: {
        //             min: 0,
        //             max: Math.PI * 2,
        //             step: Math.PI / 20,
        //         },
        //         v: {
        //             min: 0,
        //             max: Math.PI,
        //             step: Math.PI / 20,
        //         },
        //         x: function (u, v) {
        //             return ((Math.sin(v) * Math.sin(u) + Math.sin(u)) / Math.PI) * 2;
        //         },
        //         y: function (u, v) {
        //             return ((Math.sin(v) * Math.cos(u) + Math.cos(u)) / Math.PI) * 2;
        //         },
        //         z: function (u, v) {
        //             return Math.cos(v) > 0 ? -0.5 : -5;
        //         },
        //     },
        // });
        // // // 补充一个透明的圆环，用于支撑高亮功能的近似实现。
        // series.push({
        //     name: "mouseoutSeries",
        //     type: "surface",
        //     parametric: true,
        //     wireframe: {
        //         show: false,
        //     },
        //     itemStyle: {
        //         opacity: 0.1,
        //         color: "#E1E8EC",
        //     },
        //     parametricEquation: {
        //         u: {
        //             min: 0,
        //             max: Math.PI * 2,
        //             step: Math.PI / 20,
        //         },
        //         v: {
        //             min: 0,
        //             max: Math.PI,
        //             step: Math.PI / 20,
        //         },
        //         x: function (u, v) {
        //             return ((Math.sin(v) * Math.sin(u) + Math.sin(u)) / Math.PI) * 2;
        //         },
        //         y: function (u, v) {
        //             return ((Math.sin(v) * Math.cos(u) + Math.cos(u)) / Math.PI) * 2;
        //         },
        //         z: function (u, v) {
        //             return Math.cos(v) > 0 ? -5 : -7;
        //         },
        //     },
        // });
        // series.push({
        //     name: "mouseoutSeries",
        //     type: "surface",

        //     parametric: true,
        //     wireframe: {
        //         show: false,
        //     },
        //     itemStyle: {
        //         opacity: 0.1,
        //         color: "#E1E8EC",
        //     },
        //     parametricEquation: {
        //         u: {
        //             min: 0,
        //             max: Math.PI * 2,
        //             step: Math.PI / 20,
        //         },
        //         v: {
        //             min: 0,
        //             max: Math.PI,
        //             step: Math.PI / 20,
        //         },
        //         x: function (u, v) {
        //             return (
        //                 ((Math.sin(v) * Math.sin(u) + Math.sin(u)) / Math.PI) * 2.2
        //             );
        //         },
        //         y: function (u, v) {
        //             return (
        //                 ((Math.sin(v) * Math.cos(u) + Math.cos(u)) / Math.PI) * 2.2
        //             );
        //         },
        //         z: function (u, v) {
        //             return Math.cos(v) > 0 ? -7 : -7;
        //         },
        //     },
        // });
        // // return series;
        return series;
    }

    const series = getPie3D(optionsData, 0.6);
    series.push({
        name: "pie2d",
        type: "pie",
        label: {
            opacity: 1,
            fontSize: 14,
            lineHeight: 20,
            textStyle: {
                fontSize: 14,
                color: "#fff",
            },
        },
        labelLine: {
            length: 10,
            length2: 10,
        },
        startAngle: 2, //起始角度，支持范围[0, 360]。
        clockwise: false, //饼图的扇区是否是顺时针排布。上述这两项配置主要是为了对齐3d的样式
        radius: ["50%", "60%"],
        center: ["62%", "50%"],
        data: optionsData,
        itemStyle: {
            opacity: 0,
        },
        labelLine: {
            show: false,
        },
        label: {
            show: false,
            position: "center",
        },
    });
    // 准备待返回的配置项，把准备好的 legendData、series 传入。
    const option = {
        animation: true,
        tooltip: {
            backgroundColor: "rgba(64, 180, 176, 0.6)",
            borderColor: "rgba(64, 180, 176, 0.6)",
            textStyle: {
                color: "#fff",
                fontSize: 10,
            },
            formatter: (params) => {
                if (
                    params.seriesName !== "mouseoutSeries" &&
                    params.seriesName !== "pie2d"
                ) {
                    return `${params.seriesName
                        }<br/><span style="display:inline-block;margin-right:5px;border-radius:10px;width:10px;height:10px;background-color:${params.color
                        };"></span>${option.series[params.seriesIndex].pieData.value + "个"
                        }`;
                }
            },
        },
        // backgroundColor: "#092B35",
        labelLine: {
            show: true,
            lineStyle: {
                color: "#7BC0CB",
            },
            normal: {
                show: true,
                length: 10,
                length2: 10,
            },
        },
        label: {
            show: true,
            position: "outside",
            formatter: "{b} \n{c}\n{d}%",
            textStyle: {
                color: "rgba(176, 216, 223, 1)",
                fontSize: 10,
            },
        },
        xAxis3D: {
            min: -1,
            max: 1,
        },
        yAxis3D: {
            min: -1,
            max: 1,
        },
        zAxis3D: {
            min: -1,
            max: 1,
        },
        grid3D: {
            show: false,
            boxHeight: 1,
            //top: '30%',
            left: "6%",
            top: -10,
            width: "50%",
            // environment: "rgba(255,255,255,0)",
            viewControl: {
                distance: 280,
                alpha: 20,
                beta: 15,
                autoRotate: true, // 自动旋转
                rotateSensitivity: 1,
                zoomSensitivity: 0,
                panSensitivity: 0,
            },
        },
        series: series,
    };
    mChart.setOption(option)
}
</script>
